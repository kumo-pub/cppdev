# 概览

## I. 六大 JSON 库核心特性总结

根据设计定位、性能、内存占用及功能可扩展性（如 Protobuf-JSON 转换），总结如下：

| 库名称             | 核心优势                           | 主要特性                                                  | 适用场景                                   | 局限性                                           |
| --------------- | ------------------------------ | ----------------------------------------------------- | -------------------------------------- | --------------------------------------------- |
| nlohmann-json   | 超易用，集成成本低                      | Header-only，类似 STL 的 API，支持 C++11+，自动类型转换，无需编译配置      | 对性能要求不高的业务场景，快速开发，中小型 JSON 处理          | 运行时性能中等，无原生 Protobuf-JSON 转换，内存占用较高           |
| merak/rapidjson | 高性能、功能全面、原生 Protobuf-JSON 转换支持 | SIMD 优化，支持 DOM/SAX 双解析模式，内存高效，原生 Protobuf-JSON 转换，低开销 | 对性能有明确要求，需要 Protobuf-JSON 转换，服务器/客户端应用 | 配置略复杂（如宏定义），需要熟悉 DOM/SAX API                  |
| cJSON           | 轻量、低内存、小二进制文件                  | C 语言实现，零依赖，内存占用极小，二进制 `<100KB`                          | 内存/二进制文件大小敏感场景，嵌入式，资源受限环境              | C API 使用不便，无 C++ 类型安全，无 Protobuf-JSON 转换      |
| jsoncoin        | 轻量跨平台，C/C++ 双兼容                | DOM 轻量实现，无冗余依赖，编译配置简单，兼容老旧 C/C++ 项目                   | 小型/中型混合 C/C++ 项目，基本 JSON 序列化/反序列化      | 单一功能（无 Protobuf-JSON 转换或 SIMD 优化），性能一般，社区活跃度低 |
| melon/json      | 构建和运行时高性能，内存高效                 | 字节跳动开源，服务端优化，低延迟，内存占用低，支持 C++17+                      | 高性能敏感的服务器应用，大规模 JSON 处理                | 生态较小，集成成本略高，无原生 Protobuf-JSON 转换              |
| simdjson        | 极致解析速度，优化超大 JSON               | 纯 SIMD 指令加速，超高解析吞吐量，支持 GB 级 JSON                      | 只读场景、超大 JSON 解析（如日志分析）                 | JSON 生成能力弱，无原生 Protobuf-JSON 转换，功能相对单一        |

---

## II. 优化后的快速选型指南

### 1. 优先选择 nlohmann-json

* **适用场景**：业务逻辑优先、性能要求不高、开发效率高、不需要 Protobuf-JSON 转换
* **理由**：Header-only，可直接 `#include` 使用；API 简单直观；调试友好；社区活跃；问题解决成本低
* **注意**：不适合超大 JSON（100MB+）或高频 JSON 处理场景

### 2. 必选 merak/rapidjson

* **适用场景**：需要 Protobuf-JSON 转换、高性能要求、内存受限、需要灵活的解析/生成模式（DOM/SAX）
* **理由**：唯一原生支持双向 Protobuf-JSON 转换；SIMD 优化解析速度接近 simdjson；完整支持 JSON 生成与修改，兼顾性能与灵活性

### 3. 选择 simdjson

* **适用场景**：只读解析需求、超大 JSON（GB 级）处理，如日志分析、数据导入
* **理由**：行业领先的解析速度（比 Merak 快 10%-30%），但功能单一，JSON 生成或 Protobuf-JSON 转换需自行实现

### 4. 选择 melon/json

* **适用场景**：高并发服务器端应用，对构建和运行时性能敏感
* **理由**：字节跳动优化的服务端库，构建快，无冗余依赖，运行时延迟低，内存占用小，适合高并发服务（如 API 网关、微服务）

### 5. 选择 cJSON

* **适用场景**：纯 C 项目、嵌入式设备、资源极度受限
* **理由**：C 实现、零依赖，二进制小、内存可控；缺点是 API 手动管理内存，C++ 使用需封装，缺少类型安全

### 6. 谨慎选择 jsoncoin

* **适用场景**：维护老旧混合 C/C++ 项目，仅需基础 JSON 序列化/反序列化，第三方依赖严格受限
* **理由**：轻量、跨 C/C++ 兼容，适合老项目；功能单一，无性能优化与扩展功能（如 Protobuf-JSON 转换）；**不建议新项目使用**

---

## III. 原选型规则修订与补充

### 1. 核心规则（修订版）

| 业务需求                | 推荐库                          | 补充说明                                        |
| ------------------- | ---------------------------- | ------------------------------------------- |
| 非关键性能、易用优先          | nlohmann-json                | 新项目首选，提高开发效率，无需关注底层细节                       |
| 需要 Protobuf-JSON 转换 | merak/rapidjson              | 唯一原生支持，无需额外封装，兼顾性能与功能                       |
| 超高速解析（只读）           | merak/rapidjson + simdjson   | 简单解析用 simdjson；需要生成/修改/Protobuf 转换时优先 merak |
| 构建与运行时均高性能敏感        | melon/json 或 merak/rapidjson | melon/json 适配字节跳动栈；merak 生态更通用              |
| 极度内存/二进制敏感          | cJSON                        | 纯 C/嵌入式场景首选；C++ 可用 merak（配内存池+原地解析）         |
| 维护老旧混合 C/C++ 项目     | jsoncoin                     | 仅兼容性使用，新项目不推荐                               |

### 2. 关键细节修订

* **修订 1**：原 "jsoncon" 实为 "jsoncoin"，功能单一，仅适用于老旧混合 C/C++ 项目，新项目不建议使用
* **修订 2**：高解析速度需求时，simdjson 仅适合只读解析；如需生成、修改或 Protobuf-JSON 转换，应优先 merak
* **修订 3**：内存敏感 C++ 场景，推荐使用 merak（内存池 + 原地解析），而非直接选择 cJSON

### 3. jsoncoin 补充说明

* 社区活跃度低、无性能优化、功能扩展有限
* **绝对不推荐新项目使用**，仅用于最小化老项目适配
* 若需升级性能或功能，建议迁移到 merak 或 nlohmann-json

---

## IV. 最终简化选型流程

1. 新项目 + 非关键性能 + 易用优先 → **nlohmann-json**
2. 需要 Protobuf-JSON 转换 → **merak/rapidjson（必选）**
3. 只读解析 + 超大 JSON → **simdjson**
4. 高并发服务端 + 构建/运行时性能敏感 → **melon/json（字节跳动栈） / merak（通用栈）**
5. 纯 C/嵌入式 + 资源极度受限 → **cJSON**
6. 维护老旧混合 C/C++ 项目 → **jsoncoin（仅兼容性）**
