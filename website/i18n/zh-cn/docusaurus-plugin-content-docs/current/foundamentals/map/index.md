# 高性能 Map 容器选型指南

## I. 容器及底层技术特性

有序容器的核心价值在于支持 **区间查询** 和 **有序遍历**。两类主流容器的技术差异源于底层存储结构，这直接决定了性能边界和适用场景。

* **turbo::btree_map/set**
  基于 **B+ 树变体** 实现。与 `std::map` 的红黑树相比，节点结构经过优化：非叶子节点仅存储键值索引，叶子节点通过双向链表连接，数据集中在叶子层。这使得范围查询可批量加载连续叶子节点，显著减少 CPU 内存访问次数，缓存命中率比红黑树高 30% 以上。扩容采用 **批量渐进迁移** 策略，避免大量节点旋转导致业务阻塞，写入性能在百万级 Key 插入场景下更稳定。原生支持 `std::string_view` 作为 Key，并兼容结构化绑定语法，遍历无需手动调用 `first/second`。迭代器永久稳定的原因是插入和删除仅调整节点指针，不移动已有数据地址。但非叶节点索引结构带来约 10% 内存开销，对小数据集（`<10,000` Key）优势不明显。

* **tsl::ordered_map/set**
  采用 **哈希表 + 双向链表混合架构**。哈希表提供 O(1) 级快速查找，链表保持插入顺序，实现“无序插入，有序遍历”。哈希桶使用 **链地址法**，链表节点做了缓存行填充（每节点对齐 64 字节）以避免伪共享，查找性能比传统链表提升约 20%。缺点是扩容时需要重建哈希桶与链表节点的映射，高频插入场景下会产生短时性能抖动，更适合插入频率适中且需要遍历顺序的混合场景。

* **turbo::flat_hash_map/set**
  基于 **开放寻址 + 二次探测**，所有键值对连续存储，消除链表指针开销。二次探测步长为 `i²`，避免线性探测聚集效应。严格遵循 **64 字节缓存行对齐**，数据块大小适配 CPU 缓存粒度，小对象缓存命中率接近 100%。`emplace` 支持 **完美转发**，避免临时对象构造。迭代器失效源于扩容重分配地址，批量插入前需调用 `reserve` 预分配空间。哈希种子存储在 **TLS**，跨进程不可直接序列化。

* **F14 算法容器（folly::F14Map/Set, melon::F14Map/Set）**
  核心为 **混合寻址机制**：低负载时采用开放寻址，高负载时切换到链地址法。支持高负载因子至 0.9，分段哈希桶设计避免全局冲突。固定哈希种子保证跨进程序列化稳定。Folly 版本修复多线程死锁问题，melon 版本精简元数据，节省约 20% 内存，适合资源受限场景。

* **tsl::robin_map/set**
  核心为 **Robin Hood 哈希** 优化开放寻址：插入时根据元素距离理想桶的距离进行“公平竞争”，使元素尽可能接近理想桶，查找步数显著减少。长字符串 Key 冲突优化明显，查找步数可减少 40%，冲突解决效率提高 30%。采用固定 FarmHash，支持跨进程序列化，原生兼容 `std::string_view`。

* **turbo::node_hash_map/set**
  采用 **链表 + 独立节点存储**，节点包含 key-value 及 prev/next 指针，插入删除仅调整指针，迭代器永久稳定。缺点是散列存储导致缓存命中率下降，小对象性能比 flat 算法低约 30%，适合对迭代器稳定性要求高的场景。

* **原子无锁容器（folly::AtomicHashMap/Set, melon::AtomicHashMap/Set）**
  核心技术为 **细粒度原子操作 + 双字 CAS**，高并发读场景下性能出色。使用双字 CAS 解决 ABA 问题，melon 版本采用压缩存储，元数据减半，单线程性能损耗仅 3%。仅适合 **读多写少（读写比 >20:1）** 场景，高并发写入时性能会急剧下降。

---

## II. 场景选型与技术依据

* **小数据集（函数参数、临时数据）**：`turbo::flat_hash_map` 优先，连续内存布局 + 高缓存命中。小于 10,000 Key 时可直接使用 `std::unordered_map`。
* **大数据集存储小对象**：仍首选 `turbo::flat_hash_map`，提前 `reserve(1.2 * size)` 避免扩容。内存紧张且负载 >0.7，可选 `folly::F14Map`。
* **高并发读、低并发写（配置缓存、字典查询）**：单机可选 `turbo::flat_hash_map`；并发独立 Map 可选原子无锁容器；Map 与业务强绑定时需使用 slot hash 分片。
* **低并发读、高并发写（日志采集、数据收集）**：单机可选 `folly::F14Map`；遍历中动态增删数据需选 `turbo::node_hash_map`；并发独立 Map 可选 pmap（内置 shard 锁）；绑定业务数据时采用 slot hash 分片，分片数建议 = CPU 核心数。

**特殊需求**：

* 非复制 Key（`std::string_view`）：`tsl::robin_map` 原生支持
* 遍历/修改时迭代器稳定：单机选 `turbo::node_hash_map`，并发独立 Map 选 `pmap::flat_node_map`
* 序列化/跨进程：F14、Robin 或原子容器（固定哈希种子）
* 内存敏感/嵌入式：`turbo::flat_hash_map`
* 高负载：`melon::F14Map`（精简元数据）

---

## III. 编码与集成要点

* **迭代器**：flat/F14/Robin 系列扩容会失效，遍历时禁止直接插入删除；Node 系列稳定，但并发需加锁。
* **并发编码**：业务绑定 Map 使用 slot hash 分片，分片数 = CPU 核心数，锁与数据对齐 64 字节缓存行，锁顺序固定 `业务锁 → 分片锁`。独立 Map 使用原子无锁或 pmap 内置 shard 锁，禁止用 `std::mutex` 封装单机容器。
* **序列化**：优先支持固定哈希种子的容器，Turbo/Abseil 容器需自定义无状态哈希函数，保证跨进程一致性。
* **集成**：Turbo 容器需启用 C++17，Folly 容器需修复锁顺序问题，melon 容器需确认 ABA 问题已修复，Robin 需验证哈希种子稳定性，pmap 仅支持独立 Map，绑定 Map 必须使用 slot hash 分片。

---

## IV. 快速选型参考表

| 场景               | 推荐容器                                     | 核心技术依据                    |
| ---------------- | ---------------------------------------- | ------------------------- |
| 单机小/大数据集，性能+内存敏感 | turbo::flat_hash_map                     | 连续内存 + 缓存行对齐，高内存利用率与缓存命中率 |
| 遍历中增删（单机）        | turbo::node_hash_map                     | 链表独立节点，迭代器永久稳定            |
| 遍历中增删（并发独立 Map）  | pmap::flat_node_map                      | 内置分片锁 + 迭代器稳定，兼顾并发与动态操作   |
| 数据序列化/跨进程传输      | folly::F14Map / tsl::robin_map           | 固定哈希种子，跨进程哈希一致性           |
| 高并发读（独立 Map）     | melon::AtomicHashMap                     | 无锁读 + 压缩存储，高并发性能与低内存占用    |
| 高并发写（独立 Map）     | pmap::flat_hash_map（并发版）                 | 内置分片锁，锁粒度细、争用低            |
| Map 绑定外部数据（并发）   | slot hash 分片（turbo::flat_hash_map + 分片锁） | 可控锁顺序，避免死锁与数据不一致          |
