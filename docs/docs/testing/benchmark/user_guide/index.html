<!doctype html>
<html lang="en-GB" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-testing/benchmark/user_guide" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.9.2">
<title data-rh="true">User Guide | Kumo Foundamental</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://your-docusaurus-site.example.com/cppdev/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://your-docusaurus-site.example.com/cppdev/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://your-docusaurus-site.example.com/cppdev/docs/testing/benchmark/user_guide"><meta data-rh="true" property="og:locale" content="en_GB"><meta data-rh="true" property="og:locale:alternate" content="zh_cn"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="User Guide | Kumo Foundamental"><meta data-rh="true" name="description" content="Command Line"><meta data-rh="true" property="og:description" content="Command Line"><link data-rh="true" rel="icon" href="/cppdev/img/favicon.svg"><link data-rh="true" rel="canonical" href="https://your-docusaurus-site.example.com/cppdev/docs/testing/benchmark/user_guide"><link data-rh="true" rel="alternate" href="https://your-docusaurus-site.example.com/cppdev/docs/testing/benchmark/user_guide" hreflang="en-GB"><link data-rh="true" rel="alternate" href="https://your-docusaurus-site.example.com/cppdev/zh-cn/docs/testing/benchmark/user_guide" hreflang="zh-cn"><link data-rh="true" rel="alternate" href="https://your-docusaurus-site.example.com/cppdev/docs/testing/benchmark/user_guide" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Foundamentals","item":"https://your-docusaurus-site.example.com/cppdev/docs/category/foundamentals"},{"@type":"ListItem","position":2,"name":"Performance Testing and Unit Testing","item":"https://your-docusaurus-site.example.com/cppdev/docs/testing/"},{"@type":"ListItem","position":3,"name":"benchmark","item":"https://your-docusaurus-site.example.com/cppdev/docs/testing/benchmark/"},{"@type":"ListItem","position":4,"name":"User Guide","item":"https://your-docusaurus-site.example.com/cppdev/docs/testing/benchmark/user_guide"}]}</script><link rel="alternate" type="application/rss+xml" href="/cppdev/blog/rss.xml" title="Kumo Foundamental RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/cppdev/blog/atom.xml" title="Kumo Foundamental Atom Feed"><link rel="stylesheet" href="/cppdev/assets/css/styles.a7490ef4.css">
<script src="/cppdev/assets/js/runtime~main.fd8f228b.js" defer="defer"></script>
<script src="/cppdev/assets/js/main.0e500fd9.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",t||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light")),document.documentElement.setAttribute("data-theme-choice",t||"system")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/cppdev/img/kumo-logo.svg"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/cppdev/"><div class="navbar__logo"><img src="/cppdev/img/kumo-logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/cppdev/img/kumo-logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Foundamental</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/cppdev/docs/intro">Tutorial</a><a class="navbar__item navbar__link" href="/cppdev/docs/integration/overview">Integration</a><a class="navbar__item navbar__link" href="/cppdev/blog">Blog</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_nlXk"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>English</a><ul class="dropdown__menu"><li><a href="/cppdev/docs/testing/benchmark/user_guide" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="en-GB">English</a></li><li><a href="/cppdev/zh-cn/docs/testing/benchmark/user_guide" target="_self" rel="noopener noreferrer" class="dropdown__link" lang="zh-cn">中文（中国）</a></li></ul></div><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="Switch between dark and light mode (currently system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/cppdev/docs/intro"><span title="Overview" class="linkLabel_WmDU">Overview</span></a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--active" href="/cppdev/docs/category/foundamentals"><span title="Foundamentals" class="categoryLinkLabel_W154">Foundamentals</span></a><button aria-label="Collapse sidebar category &#x27;Foundamentals&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--active" tabindex="0" href="/cppdev/docs/testing/"><span title="Performance Testing and Unit Testing" class="categoryLinkLabel_W154">Performance Testing and Unit Testing</span></a><button aria-label="Collapse sidebar category &#x27;Performance Testing and Unit Testing&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist" tabindex="0" href="/cppdev/docs/category/doctest-unit-testing"><span title="doctest Unit Testing" class="categoryLinkLabel_W154">doctest Unit Testing</span></a><button aria-label="Expand sidebar category &#x27;doctest Unit Testing&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist" tabindex="0" href="/cppdev/docs/category/google-test"><span title="Google Test" class="categoryLinkLabel_W154">Google Test</span></a><button aria-label="Expand sidebar category &#x27;Google Test&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--active" tabindex="0" href="/cppdev/docs/testing/benchmark/"><span title="benchmark" class="categoryLinkLabel_W154">benchmark</span></a><button aria-label="Collapse sidebar category &#x27;benchmark&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/cppdev/docs/testing/benchmark/AssemblyTests"><span title="Assembly Tests" class="linkLabel_WmDU">Assembly Tests</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/cppdev/docs/testing/benchmark/dependencies"><span title="Build tool dependency policy" class="linkLabel_WmDU">Build tool dependency policy</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/cppdev/docs/testing/benchmark/perf_counters"><span title="perf_counters" class="linkLabel_WmDU">perf_counters</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/cppdev/docs/testing/benchmark/platform_specific_build_instructions"><span title="Platform Specific Build Instructions" class="linkLabel_WmDU">Platform Specific Build Instructions</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/cppdev/docs/testing/benchmark/python_bindings"><span title="Building and installing Python bindings" class="linkLabel_WmDU">Building and installing Python bindings</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/cppdev/docs/testing/benchmark/random_interleaving"><span title="random_interleaving" class="linkLabel_WmDU">random_interleaving</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/cppdev/docs/testing/benchmark/reducing_variance"><span title="Reducing Variance" class="linkLabel_WmDU">Reducing Variance</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/cppdev/docs/testing/benchmark/releasing"><span title="How to release" class="linkLabel_WmDU">How to release</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/cppdev/docs/testing/benchmark/tools"><span title="Benchmark Tools" class="linkLabel_WmDU">Benchmark Tools</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/cppdev/docs/testing/benchmark/user_guide"><span title="User Guide" class="linkLabel_WmDU">User Guide</span></a></li></ul></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist" tabindex="0" href="/cppdev/docs/log/"><span title="Log Section" class="categoryLinkLabel_W154">Log Section</span></a><button aria-label="Expand sidebar category &#x27;Log Section&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cppdev/docs/time/"><span title="Time and Calendar" class="linkLabel_WmDU">Time and Calendar</span></a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist" tabindex="0" href="/cppdev/docs/category/standardized-errors-and-error-return-values"><span title="Standardized Errors and Error Return Values" class="categoryLinkLabel_W154">Standardized Errors and Error Return Values</span></a><button aria-label="Expand sidebar category &#x27;Standardized Errors and Error Return Values&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist" tabindex="0" href="/cppdev/docs/strings/"><span title="strings operations" class="categoryLinkLabel_W154">strings operations</span></a><button aria-label="Expand sidebar category &#x27;strings operations&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/cppdev/docs/flags/"><span title="Turbo Command-Line Flags (Turbo Flags)" class="linkLabel_WmDU">Turbo Command-Line Flags (Turbo Flags)</span></a></li></ul></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/cppdev/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><a class="breadcrumbs__link" href="/cppdev/docs/category/foundamentals"><span>Foundamentals</span></a></li><li class="breadcrumbs__item"><a class="breadcrumbs__link" href="/cppdev/docs/testing/"><span>Performance Testing and Unit Testing</span></a></li><li class="breadcrumbs__item"><a class="breadcrumbs__link" href="/cppdev/docs/testing/benchmark/"><span>benchmark</span></a></li><li class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link">User Guide</span></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>User Guide</h1></header>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="command-line">Command Line<a href="#command-line" class="hash-link" aria-label="Direct link to Command Line" title="Direct link to Command Line" translate="no">​</a></h2>
<p><a href="#output-formats" class="">Output Formats</a></p>
<p><a href="#output-files" class="">Output Files</a></p>
<p><a href="#running-benchmarks" class="">Running Benchmarks</a></p>
<p><a href="#running-a-subset-of-benchmarks" class="">Running a Subset of Benchmarks</a></p>
<p><a href="#result-comparison" class="">Result Comparison</a></p>
<p><a href="#extra-context" class="">Extra Context</a></p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="library">Library<a href="#library" class="hash-link" aria-label="Direct link to Library" title="Direct link to Library" translate="no">​</a></h2>
<p><a href="#runtime-and-reporting-considerations" class="">Runtime and Reporting Considerations</a></p>
<p><a href="#setupteardown" class="">Setup/Teardown</a></p>
<p><a href="#passing-arguments" class="">Passing Arguments</a></p>
<p><a href="#custom-benchmark-name" class="">Custom Benchmark Name</a></p>
<p><a href="#asymptotic-complexity" class="">Calculating Asymptotic Complexity</a></p>
<p><a href="#templated-benchmarks" class="">Templated Benchmarks</a></p>
<p><a href="#templated-benchmarks-with-arguments" class="">Templated Benchmarks that take arguments</a></p>
<p><a href="#fixtures" class="">Fixtures</a></p>
<p><a href="#custom-counters" class="">Custom Counters</a></p>
<p><a href="#multithreaded-benchmarks" class="">Multithreaded Benchmarks</a></p>
<p><a href="#cpu-timers" class="">CPU Timers</a></p>
<p><a href="#manual-timing" class="">Manual Timing</a></p>
<p><a href="#setting-the-time-unit" class="">Setting the Time Unit</a></p>
<p><a class="" href="/cppdev/docs/testing/benchmark/random_interleaving">Random Interleaving</a></p>
<p><a class="" href="/cppdev/docs/testing/benchmark/perf_counters">User-Requested Performance Counters</a></p>
<p><a href="#preventing-optimization" class="">Preventing Optimization</a></p>
<p><a href="#reporting-statistics" class="">Reporting Statistics</a></p>
<p><a href="#custom-statistics" class="">Custom Statistics</a></p>
<p><a href="#memory-usage" class="">Memory Usage</a></p>
<p><a href="#using-register-benchmark" class="">Using RegisterBenchmark</a></p>
<p><a href="#exiting-with-an-error" class="">Exiting with an Error</a></p>
<p><a href="#a-faster-keep-running-loop" class="">A Faster <code>KeepRunning</code> Loop</a></p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="benchmarking-tips">Benchmarking Tips<a href="#benchmarking-tips" class="hash-link" aria-label="Direct link to Benchmarking Tips" title="Direct link to Benchmarking Tips" translate="no">​</a></h2>
<p><a href="#disabling-cpu-frequency-scaling" class="">Disabling CPU Frequency Scaling</a></p>
<p><a class="" href="/cppdev/docs/testing/benchmark/reducing_variance">Reducing Variance in Benchmarks</a></p>
<a name="output-formats"></a>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="output-formats">Output Formats<a href="#output-formats" class="hash-link" aria-label="Direct link to Output Formats" title="Direct link to Output Formats" translate="no">​</a></h2>
<p>The library supports multiple output formats. Use the
<code>--benchmark_format=&lt;console|json|csv&gt;</code> flag (or set the
<code>BENCHMARK_FORMAT=&lt;console|json|csv&gt;</code> environment variable) to set
the format type. <code>console</code> is the default format.</p>
<p>The Console format is intended to be a human readable format. By default
the format generates color output. Context is output on stderr and the
tabular data on stdout. Example tabular output looks like:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Benchmark                               Time(ns)    CPU(ns) Iterations</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">----------------------------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_SetInsert/1024/1                        28928      29349      23853  133.097kiB/s   33.2742k items/s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_SetInsert/1024/8                        32065      32913      21375  949.487kiB/s   237.372k items/s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_SetInsert/1024/10                       33157      33648      21431  1.13369MiB/s   290.225k items/s</span><br></span></code></pre></div></div>
<p>The JSON format outputs human readable json split into two top level attributes.
The <code>context</code> attribute contains information about the run in general, including
information about the CPU and the date.
The <code>benchmarks</code> attribute contains a list of every benchmark run. Example json
output looks like:</p>
<div class="language-json codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-json codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token property" style="color:#36acaa">&quot;context&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token property" style="color:#36acaa">&quot;date&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;2015/03/17-18:40:25&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token property" style="color:#36acaa">&quot;num_cpus&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">40</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token property" style="color:#36acaa">&quot;mhz_per_cpu&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">2801</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token property" style="color:#36acaa">&quot;cpu_scaling_enabled&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token boolean" style="color:#36acaa">false</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token property" style="color:#36acaa">&quot;build_type&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;debug&quot;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token property" style="color:#36acaa">&quot;benchmarks&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token property" style="color:#36acaa">&quot;name&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;BM_SetInsert/1024/1&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token property" style="color:#36acaa">&quot;iterations&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">94877</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token property" style="color:#36acaa">&quot;real_time&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">29275</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token property" style="color:#36acaa">&quot;cpu_time&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">29836</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token property" style="color:#36acaa">&quot;bytes_per_second&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">134066</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token property" style="color:#36acaa">&quot;items_per_second&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">33516</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token property" style="color:#36acaa">&quot;name&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;BM_SetInsert/1024/8&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token property" style="color:#36acaa">&quot;iterations&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">21609</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token property" style="color:#36acaa">&quot;real_time&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">32317</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token property" style="color:#36acaa">&quot;cpu_time&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">32429</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token property" style="color:#36acaa">&quot;bytes_per_second&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">986770</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token property" style="color:#36acaa">&quot;items_per_second&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">246693</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token property" style="color:#36acaa">&quot;name&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;BM_SetInsert/1024/10&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token property" style="color:#36acaa">&quot;iterations&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">21393</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token property" style="color:#36acaa">&quot;real_time&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">32724</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token property" style="color:#36acaa">&quot;cpu_time&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">33355</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token property" style="color:#36acaa">&quot;bytes_per_second&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1199226</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token property" style="color:#36acaa">&quot;items_per_second&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">299807</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre></div></div>
<p>The CSV format outputs comma-separated values. The <code>context</code> is output on stderr
and the CSV itself on stdout. Example CSV output looks like:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">name,iterations,real_time,cpu_time,bytes_per_second,items_per_second,label</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&quot;BM_SetInsert/1024/1&quot;,65465,17890.7,8407.45,475768,118942,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&quot;BM_SetInsert/1024/8&quot;,116606,18810.1,9766.64,3.27646e+06,819115,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&quot;BM_SetInsert/1024/10&quot;,106365,17238.4,8421.53,4.74973e+06,1.18743e+06,</span><br></span></code></pre></div></div>
<a name="output-files"></a>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="output-files">Output Files<a href="#output-files" class="hash-link" aria-label="Direct link to Output Files" title="Direct link to Output Files" translate="no">​</a></h2>
<p>Write benchmark results to a file with the <code>--benchmark_out=&lt;filename&gt;</code> option
(or set <code>BENCHMARK_OUT</code>). Specify the output format with
<code>--benchmark_out_format={json|console|csv}</code> (or set
<code>BENCHMARK_OUT_FORMAT={json|console|csv}</code>). Note that the &#x27;csv&#x27; reporter is
deprecated and the saved <code>.csv</code> file
<a href="https://github.com/google/benchmark/issues/794" target="_blank" rel="noopener noreferrer" class="">is not parsable</a> by csv
parsers.</p>
<p>Specifying <code>--benchmark_out</code> does not suppress the console output.</p>
<a name="running-benchmarks"></a>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="running-benchmarks">Running Benchmarks<a href="#running-benchmarks" class="hash-link" aria-label="Direct link to Running Benchmarks" title="Direct link to Running Benchmarks" translate="no">​</a></h2>
<p>Benchmarks are executed by running the produced binaries. Benchmarks binaries,
by default, accept options that may be specified either through their command
line interface or by setting environment variables before execution. For every
<code>--option_flag=&lt;value&gt;</code> CLI switch, a corresponding environment variable
<code>OPTION_FLAG=&lt;value&gt;</code> exist and is used as default if set (CLI switches always
prevails). A complete list of CLI options is available running benchmarks
with the <code>--help</code> switch.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="dry-runs">Dry runs<a href="#dry-runs" class="hash-link" aria-label="Direct link to Dry runs" title="Direct link to Dry runs" translate="no">​</a></h3>
<p>To confirm that benchmarks can run successfully without needing to wait for
multiple repetitions and iterations, the <code>--benchmark_dry_run</code> flag can be
used.  This will run the benchmarks as normal, but for 1 iteration and 1
repetition only.</p>
<a name="running-a-subset-of-benchmarks"></a>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="running-a-subset-of-benchmarks">Running a Subset of Benchmarks<a href="#running-a-subset-of-benchmarks" class="hash-link" aria-label="Direct link to Running a Subset of Benchmarks" title="Direct link to Running a Subset of Benchmarks" translate="no">​</a></h2>
<p>The <code>--benchmark_filter=&lt;regex&gt;</code> option (or <code>BENCHMARK_FILTER=&lt;regex&gt;</code>
environment variable) can be used to only run the benchmarks that match
the specified <code>&lt;regex&gt;</code>. For example:</p>
<div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ ./run_benchmarks.x --benchmark_filter=BM_memcpy/32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Run on (1 X 2300 MHz CPU )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2016-06-25 19:34:24</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Benchmark              Time           CPU Iterations</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">----------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_memcpy/32          11 ns         11 ns   79545455</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_memcpy/32k       2181 ns       2185 ns     324074</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_memcpy/32          12 ns         12 ns   54687500</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_memcpy/32k       1834 ns       1837 ns     357143</span><br></span></code></pre></div></div>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="disabling-benchmarks">Disabling Benchmarks<a href="#disabling-benchmarks" class="hash-link" aria-label="Direct link to Disabling Benchmarks" title="Direct link to Disabling Benchmarks" translate="no">​</a></h2>
<p>It is possible to temporarily disable benchmarks by renaming the benchmark
function to have the prefix &quot;DISABLED_&quot;. This will cause the benchmark to
be skipped at runtime.</p>
<a name="result-comparison"></a>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="result-comparison">Result comparison<a href="#result-comparison" class="hash-link" aria-label="Direct link to Result comparison" title="Direct link to Result comparison" translate="no">​</a></h2>
<p>It is possible to compare the benchmarking results.
See <a class="" href="/cppdev/docs/testing/benchmark/tools">Additional Tooling Documentation</a></p>
<a name="extra-context"></a>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="extra-context">Extra Context<a href="#extra-context" class="hash-link" aria-label="Direct link to Extra Context" title="Direct link to Extra Context" translate="no">​</a></h2>
<p>Sometimes it&#x27;s useful to add extra context to the content printed before the
results. By default this section includes information about the CPU on which
the benchmarks are running. If you do want to add more context, you can use
the <code>benchmark_context</code> command line flag:</p>
<div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ ./run_benchmarks --benchmark_context=pwd=`pwd`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Run on (1 x 2300 MHz CPU)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pwd: /home/user/benchmark/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Benchmark              Time           CPU Iterations</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">----------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_memcpy/32          11 ns         11 ns   79545455</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_memcpy/32k       2181 ns       2185 ns     324074</span><br></span></code></pre></div></div>
<p>You can get the same effect with the API:</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">  benchmark::AddCustomContext(&quot;foo&quot;, &quot;bar&quot;);</span><br></span></code></pre></div></div>
<p>Note that attempts to add a second value with the same key will fail with an
error message.</p>
<a name="runtime-and-reporting-considerations"></a>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="runtime-and-reporting-considerations">Runtime and Reporting Considerations<a href="#runtime-and-reporting-considerations" class="hash-link" aria-label="Direct link to Runtime and Reporting Considerations" title="Direct link to Runtime and Reporting Considerations" translate="no">​</a></h2>
<p>When the benchmark binary is executed, each benchmark function is run serially.
The number of iterations to run is determined dynamically by running the
benchmark a few times and measuring the time taken and ensuring that the
ultimate result will be statistically stable. As such, faster benchmark
functions will be run for more iterations than slower benchmark functions, and
the number of iterations is thus reported.</p>
<p>In all cases, the number of iterations for which the benchmark is run is
governed by the amount of time the benchmark takes. Concretely, the number of
iterations is at least one, not more than 1e9, until CPU time is greater than
the minimum time, or the wallclock time is 5x minimum time. The minimum time is
set per benchmark by calling <code>MinTime</code> on the registered benchmark object.</p>
<p>Furthermore warming up a benchmark might be necessary in order to get
stable results because of e.g caching effects of the code under benchmark.
Warming up means running the benchmark a given amount of time, before
results are actually taken into account. The amount of time for which
the warmup should be run can be set per benchmark by calling
<code>MinWarmUpTime</code> on the registered benchmark object or for all benchmarks
using the <code>--benchmark_min_warmup_time</code> command-line option. Note that
<code>MinWarmUpTime</code> will overwrite the value of <code>--benchmark_min_warmup_time</code>
for the single benchmark. How many iterations the warmup run of each
benchmark takes is determined the same way as described in the paragraph
above. Per default the warmup phase is set to 0 seconds and is therefore
disabled.</p>
<p>Average timings are then reported over the iterations run. If multiple
repetitions are requested using the <code>--benchmark_repetitions</code> command-line
option, or at registration time, the benchmark function will be run several
times and statistical results across these repetitions will also be reported.</p>
<p>As well as the per-benchmark entries, a preamble in the report will include
information about the machine on which the benchmarks are run.</p>
<a name="setup-teardown"></a>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="setupteardown">Setup/Teardown<a href="#setupteardown" class="hash-link" aria-label="Direct link to Setup/Teardown" title="Direct link to Setup/Teardown" translate="no">​</a></h2>
<p>Global setup/teardown specific to each benchmark can be done by
passing a callback to Setup/Teardown:</p>
<p>The setup/teardown callbacks will be invoked once for each benchmark. If the
benchmark is multi-threaded (will run in k threads), they will be invoked
exactly once before each run with k threads.</p>
<p>If the benchmark uses different size groups of threads, the above will be true
for each size group.</p>
<p>Eg.,</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static void DoSetup(const benchmark::State&amp; state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void DoTeardown(const benchmark::State&amp; state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void BM_func(benchmark::State&amp; state) {...}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK(BM_func)-&gt;Arg(1)-&gt;Arg(3)-&gt;Threads(16)-&gt;Threads(32)-&gt;Setup(DoSetup)-&gt;Teardown(DoTeardown);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre></div></div>
<p>In this example, <code>DoSetup</code> and <code>DoTearDown</code> will be invoked 4 times each,
specifically, once for each of this family:</p>
<ul>
<li class="">BM_func_Arg_1_Threads_16, BM_func_Arg_1_Threads_32</li>
<li class="">BM_func_Arg_3_Threads_16, BM_func_Arg_3_Threads_32</li>
</ul>
<a name="passing-arguments"></a>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="passing-arguments">Passing Arguments<a href="#passing-arguments" class="hash-link" aria-label="Direct link to Passing Arguments" title="Direct link to Passing Arguments" translate="no">​</a></h2>
<p>Sometimes a family of benchmarks can be implemented with just one routine that
takes an extra argument to specify which one of the family of benchmarks to
run. For example, the following code defines a family of benchmarks for
measuring the speed of <code>memcpy()</code> calls of different lengths:</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static void BM_memcpy(benchmark::State&amp; state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  char* src = new char[state.range(0)];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  char* dst = new char[state.range(0)];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  memset(src, &#x27;x&#x27;, state.range(0));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (auto _ : state)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memcpy(dst, src, state.range(0));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  state.SetBytesProcessed(int64_t(state.iterations()) *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          int64_t(state.range(0)));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  delete[] src;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  delete[] dst;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK(BM_memcpy)-&gt;Arg(8)-&gt;Arg(64)-&gt;Arg(512)-&gt;Arg(4&lt;&lt;10)-&gt;Arg(8&lt;&lt;10);</span><br></span></code></pre></div></div>
<p>The preceding code is quite repetitive, and can be replaced with the following
short-hand. The following invocation will pick a few appropriate arguments in
the specified range and will generate a benchmark for each such argument.</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK(BM_memcpy)-&gt;Range(8, 8&lt;&lt;10);</span><br></span></code></pre></div></div>
<p>By default the arguments in the range are generated in multiples of eight and
the command above selects [ 8, 64, 512, 4k, 8k ]. In the following code the
range multiplier is changed to multiples of two.</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK(BM_memcpy)-&gt;RangeMultiplier(2)-&gt;Range(8, 8&lt;&lt;10);</span><br></span></code></pre></div></div>
<p>Now arguments generated are [ 8, 16, 32, 64, 128, 256, 512, 1024, 2k, 4k, 8k ].</p>
<p>The preceding code shows a method of defining a sparse range.  The following
example shows a method of defining a dense range. It is then used to benchmark
the performance of <code>std::vector</code> initialization for uniformly increasing sizes.</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static void BM_DenseRange(benchmark::State&amp; state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for(auto _ : state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    std::vector&lt;int&gt; v(state.range(0), state.range(0));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    auto data = v.data();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    benchmark::DoNotOptimize(data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    benchmark::ClobberMemory();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK(BM_DenseRange)-&gt;DenseRange(0, 1024, 128);</span><br></span></code></pre></div></div>
<p>Now arguments generated are [ 0, 128, 256, 384, 512, 640, 768, 896, 1024 ].</p>
<p>You might have a benchmark that depends on two or more inputs. For example, the
following code defines a family of benchmarks for measuring the speed of set
insertion.</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static void BM_SetInsert(benchmark::State&amp; state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  std::set&lt;int&gt; data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (auto _ : state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    state.PauseTiming();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    data = ConstructRandomSet(state.range(0));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    state.ResumeTiming();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int j = 0; j &lt; state.range(1); ++j)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      data.insert(RandomNumber());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK(BM_SetInsert)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt;Args({1&lt;&lt;10, 128})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt;Args({2&lt;&lt;10, 128})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt;Args({4&lt;&lt;10, 128})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt;Args({8&lt;&lt;10, 128})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt;Args({1&lt;&lt;10, 512})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt;Args({2&lt;&lt;10, 512})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt;Args({4&lt;&lt;10, 512})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt;Args({8&lt;&lt;10, 512});</span><br></span></code></pre></div></div>
<p>The preceding code is quite repetitive, and can be replaced with the following
short-hand. The following macro will pick a few appropriate arguments in the
product of the two specified ranges and will generate a benchmark for each such
pair.</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK(BM_SetInsert)-&gt;Ranges({{1&lt;&lt;10, 8&lt;&lt;10}, {128, 512}});</span><br></span></code></pre></div></div>
<p>Some benchmarks may require specific argument values that cannot be expressed
with <code>Ranges</code>. In this case, <code>ArgsProduct</code> offers the ability to generate a
benchmark input for each combination in the product of the supplied vectors.</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK(BM_SetInsert)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt;ArgsProduct({{1&lt;&lt;10, 3&lt;&lt;10, 8&lt;&lt;10}, {20, 40, 60, 80}})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// would generate the same benchmark arguments as</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK(BM_SetInsert)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt;Args({1&lt;&lt;10, 20})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt;Args({3&lt;&lt;10, 20})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt;Args({8&lt;&lt;10, 20})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt;Args({3&lt;&lt;10, 40})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt;Args({8&lt;&lt;10, 40})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt;Args({1&lt;&lt;10, 40})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt;Args({1&lt;&lt;10, 60})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt;Args({3&lt;&lt;10, 60})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt;Args({8&lt;&lt;10, 60})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt;Args({1&lt;&lt;10, 80})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt;Args({3&lt;&lt;10, 80})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt;Args({8&lt;&lt;10, 80});</span><br></span></code></pre></div></div>
<p>For the most common scenarios, helper methods for creating a list of
integers for a given sparse or dense range are provided.</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK(BM_SetInsert)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt;ArgsProduct({</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      benchmark::CreateRange(8, 128, /*multi=*/2),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      benchmark::CreateDenseRange(1, 4, /*step=*/1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// would generate the same benchmark arguments as</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK(BM_SetInsert)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt;ArgsProduct({</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      {8, 16, 32, 64, 128},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      {1, 2, 3, 4}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span><br></span></code></pre></div></div>
<p>For more complex patterns of inputs, passing a custom function to <code>Apply</code> allows
programmatic specification of an arbitrary set of arguments on which to run the
benchmark. The following example enumerates a dense range on one parameter,
and a sparse range on the second.</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static void CustomArguments(benchmark::internal::Benchmark* b) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (int i = 0; i &lt;= 10; ++i)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int j = 32; j &lt;= 1024*1024; j *= 8)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      b-&gt;Args({i, j});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK(BM_SetInsert)-&gt;Apply(CustomArguments);</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="passing-arbitrary-arguments-to-a-benchmark">Passing Arbitrary Arguments to a Benchmark<a href="#passing-arbitrary-arguments-to-a-benchmark" class="hash-link" aria-label="Direct link to Passing Arbitrary Arguments to a Benchmark" title="Direct link to Passing Arbitrary Arguments to a Benchmark" translate="no">​</a></h3>
<p>It is possible to define a benchmark that takes an arbitrary number
of extra arguments. The <code>BENCHMARK_CAPTURE(func, test_case_name, ...args)</code>
macro creates a benchmark that invokes <code>func</code>  with the <code>benchmark::State</code> as
the first argument followed by the specified <code>args...</code>.
The <code>test_case_name</code> is appended to the name of the benchmark and
should describe the values passed.</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">template &lt;class ...Args&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void BM_takes_args(benchmark::State&amp; state, Args&amp;&amp;... args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  auto args_tuple = std::make_tuple(std::move(args)...);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (auto _ : state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    std::cout &lt;&lt; std::get&lt;0&gt;(args_tuple) &lt;&lt; &quot;: &quot; &lt;&lt; std::get&lt;1&gt;(args_tuple)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              &lt;&lt; &#x27;\n&#x27;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [...]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Registers a benchmark named &quot;BM_takes_args/int_string_test&quot; that passes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// the specified values to `args`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK_CAPTURE(BM_takes_args, int_string_test, 42, std::string(&quot;abc&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Registers the same benchmark &quot;BM_takes_args/int_test&quot; that passes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// the specified values to `args`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK_CAPTURE(BM_takes_args, int_test, 42, 43);</span><br></span></code></pre></div></div>
<p>Note that elements of <code>...args</code> may refer to global variables. Users should
avoid modifying global state inside of a benchmark.</p>
<a name="asymptotic-complexity"></a>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="calculating-asymptotic-complexity-big-o">Calculating Asymptotic Complexity (Big O)<a href="#calculating-asymptotic-complexity-big-o" class="hash-link" aria-label="Direct link to Calculating Asymptotic Complexity (Big O)" title="Direct link to Calculating Asymptotic Complexity (Big O)" translate="no">​</a></h2>
<p>Asymptotic complexity might be calculated for a family of benchmarks. The
following code will calculate the coefficient for the high-order term in the
running time and the normalized root-mean square error of string comparison.</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static void BM_StringCompare(benchmark::State&amp; state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  std::string s1(state.range(0), &#x27;-&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  std::string s2(state.range(0), &#x27;-&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (auto _ : state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    auto comparison_result = s1.compare(s2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    benchmark::DoNotOptimize(comparison_result);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  state.SetComplexityN(state.range(0));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK(BM_StringCompare)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt;RangeMultiplier(2)-&gt;Range(1&lt;&lt;10, 1&lt;&lt;18)-&gt;Complexity(benchmark::oN);</span><br></span></code></pre></div></div>
<p>As shown in the following invocation, asymptotic complexity might also be
calculated automatically.</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK(BM_StringCompare)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt;RangeMultiplier(2)-&gt;Range(1&lt;&lt;10, 1&lt;&lt;18)-&gt;Complexity();</span><br></span></code></pre></div></div>
<p>The following code will specify asymptotic complexity with a lambda function,
that might be used to customize high-order term calculation.</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK(BM_StringCompare)-&gt;RangeMultiplier(2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt;Range(1&lt;&lt;10, 1&lt;&lt;18)-&gt;Complexity([](benchmark::IterationCount n)-&gt;double{return n; });</span><br></span></code></pre></div></div>
<a name="custom-benchmark-name"></a>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="custom-benchmark-name">Custom Benchmark Name<a href="#custom-benchmark-name" class="hash-link" aria-label="Direct link to Custom Benchmark Name" title="Direct link to Custom Benchmark Name" translate="no">​</a></h2>
<p>You can change the benchmark&#x27;s name as follows:</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK(BM_memcpy)-&gt;Name(&quot;memcpy&quot;)-&gt;RangeMultiplier(2)-&gt;Range(8, 8&lt;&lt;10);</span><br></span></code></pre></div></div>
<p>The invocation will execute the benchmark as before using <code>BM_memcpy</code> but changes
the prefix in the report to <code>memcpy</code>.</p>
<a name="templated-benchmarks"></a>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="templated-benchmarks">Templated Benchmarks<a href="#templated-benchmarks" class="hash-link" aria-label="Direct link to Templated Benchmarks" title="Direct link to Templated Benchmarks" translate="no">​</a></h2>
<p>This example produces and consumes messages of size <code>sizeof(v)</code> <code>range_x</code>
times. It also outputs throughput in the absence of multiprogramming.</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">template &lt;class Q&gt; void BM_Sequential(benchmark::State&amp; state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Q q;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  typename Q::value_type v;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (auto _ : state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = state.range(0); i--; )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      q.push(v);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int e = state.range(0); e--; )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      q.Wait(&amp;v);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // actually messages, not bytes:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  state.SetBytesProcessed(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      static_cast&lt;int64_t&gt;(state.iterations())*state.range(0));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// You can use the BENCHMARK macro with template parameters:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK(BM_Sequential&lt;WaitQueue&lt;int&gt;&gt;)-&gt;Range(1&lt;&lt;0, 1&lt;&lt;10);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Old, legacy verbose C++03 syntax:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK_TEMPLATE(BM_Sequential, WaitQueue&lt;int&gt;)-&gt;Range(1&lt;&lt;0, 1&lt;&lt;10);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre></div></div>
<p>Three macros are provided for adding benchmark templates.</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define BENCHMARK(func&lt;...&gt;) // Takes any number of parameters.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define BENCHMARK_TEMPLATE1(func, arg1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define BENCHMARK_TEMPLATE2(func, arg1, arg2)</span><br></span></code></pre></div></div>
<a name="templated-benchmarks-with-arguments"></a>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="templated-benchmarks-that-take-arguments">Templated Benchmarks that take arguments<a href="#templated-benchmarks-that-take-arguments" class="hash-link" aria-label="Direct link to Templated Benchmarks that take arguments" title="Direct link to Templated Benchmarks that take arguments" translate="no">​</a></h2>
<p>Sometimes there is a need to template benchmarks, and provide arguments to them.</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">template &lt;class Q&gt; void BM_Sequential_With_Step(benchmark::State&amp; state, int step) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Q q;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  typename Q::value_type v;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (auto _ : state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = state.range(0); i-=step; )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      q.push(v);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int e = state.range(0); e-=step; )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      q.Wait(&amp;v);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // actually messages, not bytes:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  state.SetBytesProcessed(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      static_cast&lt;int64_t&gt;(state.iterations())*state.range(0));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK_TEMPLATE1_CAPTURE(BM_Sequential, WaitQueue&lt;int&gt;, Step1, 1)-&gt;Range(1&lt;&lt;0, 1&lt;&lt;10);</span><br></span></code></pre></div></div>
<a name="fixtures"></a>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="fixtures">Fixtures<a href="#fixtures" class="hash-link" aria-label="Direct link to Fixtures" title="Direct link to Fixtures" translate="no">​</a></h2>
<p>Fixture tests are created by first defining a type that derives from
<code>::benchmark::Fixture</code> and then creating/registering the tests using the
following macros:</p>
<ul>
<li class=""><code>BENCHMARK_F(ClassName, Method)</code></li>
<li class=""><code>BENCHMARK_DEFINE_F(ClassName, Method)</code></li>
<li class=""><code>BENCHMARK_REGISTER_F(ClassName, Method)</code></li>
</ul>
<p>For Example:</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class MyFixture : public benchmark::Fixture {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  void SetUp(::benchmark::State&amp; state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  void TearDown(::benchmark::State&amp; state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Defines and registers `FooTest` using the class `MyFixture`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK_F(MyFixture, FooTest)(benchmark::State&amp; st) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   for (auto _ : st) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Only defines `BarTest` using the class `MyFixture`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK_DEFINE_F(MyFixture, BarTest)(benchmark::State&amp; st) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   for (auto _ : st) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// `BarTest` is NOT registered.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK_REGISTER_F(MyFixture, BarTest)-&gt;Threads(2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// `BarTest` is now registered.</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="templated-fixtures">Templated Fixtures<a href="#templated-fixtures" class="hash-link" aria-label="Direct link to Templated Fixtures" title="Direct link to Templated Fixtures" translate="no">​</a></h3>
<p>Also you can create templated fixture by using the following macros:</p>
<ul>
<li class=""><code>BENCHMARK_TEMPLATE_F(ClassName, Method, ...)</code></li>
<li class=""><code>BENCHMARK_TEMPLATE_DEFINE_F(ClassName, Method, ...)</code></li>
</ul>
<p>For example:</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">template&lt;typename T&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class MyFixture : public benchmark::Fixture {};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Defines and registers `IntTest` using the class template `MyFixture&lt;int&gt;`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK_TEMPLATE_F(MyFixture, IntTest, int)(benchmark::State&amp; st) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   for (auto _ : st) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Only defines `DoubleTest` using the class template `MyFixture&lt;double&gt;`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK_TEMPLATE_DEFINE_F(MyFixture, DoubleTest, double)(benchmark::State&amp; st) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   for (auto _ : st) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// `DoubleTest` is NOT registered.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK_REGISTER_F(MyFixture, DoubleTest)-&gt;Threads(2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// `DoubleTest` is now registered.</span><br></span></code></pre></div></div>
<p>If you want to use a method template for your fixtures,
which you instantiate afterward, use the following macros:</p>
<ul>
<li class=""><code>BENCHMARK_TEMPLATE_METHOD_F(ClassName, Method)</code></li>
<li class=""><code>BENCHMARK_TEMPLATE_INSTANTIATE_F(ClassName, Method, ...)</code></li>
</ul>
<p>With these macros you can define one method for several instantiations.
Example (using <code>MyFixture</code> from above):</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Defines `Test` using the class template `MyFixture`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK_TEMPLATE_METHOD_F(MyFixture, Test)(benchmark::State&amp; st) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   for (auto _ : st) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Instantiates and registers the benchmark `MyFixture&lt;int&gt;::Test`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK_TEMPLATE_INSTANTIATE_F(MyFixture, Test, int)-&gt;Threads(2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Instantiates and registers the benchmark `MyFixture&lt;double&gt;::Test`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK_TEMPLATE_INSTANTIATE_F(MyFixture, Test, double)-&gt;Threads(4);</span><br></span></code></pre></div></div>
<p>Inside the method definition of <code>BENCHMARK_TEMPLATE_METHOD_F</code> the type <code>Base</code> refers
to the type of the instantiated fixture.
Accesses to members of the fixture must be prefixed by <code>this-&gt;</code>.</p>
<p><code>BENCHMARK_TEMPLATE_METHOD_F</code>and <code>BENCHMARK_TEMPLATE_INSTANTIATE_F</code> can only be used,
if the fixture does not use non-type template parameters.
If you want to pass values as template parameters, use e.g. <code>std::integral_constant</code>.
For example:</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">template&lt;typename Sz&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class SizedFixture : public benchmark::Fixture {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  static constexpr auto Size = Sz::value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  int myValue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK_TEMPLATE_METHOD_F(SizedFixture, Test)(benchmark::State&amp; st) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   for (auto _ : st) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     this-&gt;myValue = Base::Size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK_TEMPLATE_INSTANTIATE_F(SizedFixture, Test, std::integral_constant&lt;5&gt;)-&gt;Threads(2);</span><br></span></code></pre></div></div>
<a name="custom-counters"></a>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="custom-counters">Custom Counters<a href="#custom-counters" class="hash-link" aria-label="Direct link to Custom Counters" title="Direct link to Custom Counters" translate="no">​</a></h2>
<p>You can add your own counters with user-defined names. The example below
will add columns &quot;Foo&quot;, &quot;Bar&quot; and &quot;Baz&quot; in its output:</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static void UserCountersExample1(benchmark::State&amp; state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  double numFoos = 0, numBars = 0, numBazs = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (auto _ : state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ... count Foo,Bar,Baz events</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  state.counters[&quot;Foo&quot;] = numFoos;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  state.counters[&quot;Bar&quot;] = numBars;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  state.counters[&quot;Baz&quot;] = numBazs;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>The <code>state.counters</code> object is a <code>std::map</code> with <code>std::string</code> keys
and <code>Counter</code> values. The latter is a <code>double</code>-like class, via an implicit
conversion to <code>double&amp;</code>. Thus you can use all of the standard arithmetic
assignment operators (<code>=,+=,-=,*=,/=</code>) to change the value of each counter.</p>
<p>The <code>Counter</code> constructor accepts three parameters: the value as a <code>double</code>
; a bit flag which allows you to show counters as rates, and/or as per-thread
iteration, and/or as per-thread averages, and/or iteration invariants,
and/or finally inverting the result; and a flag specifying the &#x27;unit&#x27; - i.e.
is 1k a 1000 (default, <code>benchmark::Counter::OneK::kIs1000</code>), or 1024
(<code>benchmark::Counter::OneK::kIs1024</code>)?</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">  // sets a simple counter</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  state.counters[&quot;Foo&quot;] = numFoos;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Set the counter as a rate. It will be presented divided</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // by the duration of the benchmark.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Meaning: per one second, how many &#x27;foo&#x27;s are processed?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  state.counters[&quot;FooRate&quot;] = Counter(numFoos, benchmark::Counter::kIsRate);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Set the counter as a rate. It will be presented divided</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // by the duration of the benchmark, and the result inverted.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Meaning: how many seconds it takes to process one &#x27;foo&#x27;?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  state.counters[&quot;FooInvRate&quot;] = Counter(numFoos, benchmark::Counter::kIsRate | benchmark::Counter::kInvert);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Set the counter as a thread-average quantity. It will</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // be presented divided by the number of threads.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  state.counters[&quot;FooAvg&quot;] = Counter(numFoos, benchmark::Counter::kAvgThreads);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // There&#x27;s also a combined flag:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  state.counters[&quot;FooAvgRate&quot;] = Counter(numFoos,benchmark::Counter::kAvgThreadsRate);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // This says that we process with the rate of state.range(0) bytes every iteration:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  state.counters[&quot;BytesProcessed&quot;] = Counter(state.range(0), benchmark::Counter::kIsIterationInvariantRate, benchmark::Counter::OneK::kIs1024);</span><br></span></code></pre></div></div>
<p>You can use <code>insert()</code> with <code>std::initializer_list</code>:</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">  state.counters.insert({{&quot;Foo&quot;, numFoos}, {&quot;Bar&quot;, numBars}, {&quot;Baz&quot;, numBazs}});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ... instead of:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  state.counters[&quot;Foo&quot;] = numFoos;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  state.counters[&quot;Bar&quot;] = numBars;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  state.counters[&quot;Baz&quot;] = numBazs;</span><br></span></code></pre></div></div>
<p>In multithreaded benchmarks, each counter is set on the calling thread only.
When the benchmark finishes, the counters from each thread will be summed.
Counters that are configured with <code>kIsRate</code>, will report the average rate across all threads, while <code>kAvgThreadsRate</code> counters will report the average rate per thread.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="counter-reporting">Counter Reporting<a href="#counter-reporting" class="hash-link" aria-label="Direct link to Counter Reporting" title="Direct link to Counter Reporting" translate="no">​</a></h3>
<p>When using the console reporter, by default, user counters are printed at
the end after the table, the same way as <code>bytes_processed</code> and
<code>items_processed</code>. This is best for cases in which there are few counters,
or where there are only a couple of lines per benchmark. Here&#x27;s an example of
the default output:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">------------------------------------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Benchmark                        Time           CPU Iterations UserCounters...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">------------------------------------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_UserCounter/threads:8      2248 ns      10277 ns      68808 Bar=16 Bat=40 Baz=24 Foo=8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_UserCounter/threads:1      9797 ns       9788 ns      71523 Bar=2 Bat=5 Baz=3 Foo=1024m</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_UserCounter/threads:2      4924 ns       9842 ns      71036 Bar=4 Bat=10 Baz=6 Foo=2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_UserCounter/threads:4      2589 ns      10284 ns      68012 Bar=8 Bat=20 Baz=12 Foo=4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_UserCounter/threads:8      2212 ns      10287 ns      68040 Bar=16 Bat=40 Baz=24 Foo=8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_UserCounter/threads:16     1782 ns      10278 ns      68144 Bar=32 Bat=80 Baz=48 Foo=16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_UserCounter/threads:32     1291 ns      10296 ns      68256 Bar=64 Bat=160 Baz=96 Foo=32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_UserCounter/threads:4      2615 ns      10307 ns      68040 Bar=8 Bat=20 Baz=12 Foo=4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_Factorial                    26 ns         26 ns   26608979 40320</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_Factorial/real_time          26 ns         26 ns   26587936 40320</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_CalculatePiRange/1           16 ns         16 ns   45704255 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_CalculatePiRange/8           73 ns         73 ns    9520927 3.28374</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_CalculatePiRange/64         609 ns        609 ns    1140647 3.15746</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_CalculatePiRange/512       4900 ns       4901 ns     142696 3.14355</span><br></span></code></pre></div></div>
<p>If this doesn&#x27;t suit you, you can print each counter as a table column by
passing the flag <code>--benchmark_counters_tabular=true</code> to the benchmark
application. This is best for cases in which there are a lot of counters, or
a lot of lines per individual benchmark. Note that this will trigger a
reprinting of the table header any time the counter set changes between
individual benchmarks. Here&#x27;s an example of corresponding output when
<code>--benchmark_counters_tabular=true</code> is passed:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">---------------------------------------------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Benchmark                        Time           CPU Iterations    Bar   Bat   Baz   Foo</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">---------------------------------------------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_UserCounter/threads:8      2198 ns       9953 ns      70688     16    40    24     8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_UserCounter/threads:1      9504 ns       9504 ns      73787      2     5     3     1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_UserCounter/threads:2      4775 ns       9550 ns      72606      4    10     6     2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_UserCounter/threads:4      2508 ns       9951 ns      70332      8    20    12     4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_UserCounter/threads:8      2055 ns       9933 ns      70344     16    40    24     8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_UserCounter/threads:16     1610 ns       9946 ns      70720     32    80    48    16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_UserCounter/threads:32     1192 ns       9948 ns      70496     64   160    96    32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_UserCounter/threads:4      2506 ns       9949 ns      70332      8    20    12     4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--------------------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Benchmark                        Time           CPU Iterations</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--------------------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_Factorial                    26 ns         26 ns   26392245 40320</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_Factorial/real_time          26 ns         26 ns   26494107 40320</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_CalculatePiRange/1           15 ns         15 ns   45571597 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_CalculatePiRange/8           74 ns         74 ns    9450212 3.28374</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_CalculatePiRange/64         595 ns        595 ns    1173901 3.15746</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_CalculatePiRange/512       4752 ns       4752 ns     147380 3.14355</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_CalculatePiRange/4k       37970 ns      37972 ns      18453 3.14184</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_CalculatePiRange/32k     303733 ns     303744 ns       2305 3.14162</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_CalculatePiRange/256k   2434095 ns    2434186 ns        288 3.1416</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_CalculatePiRange/1024k  9721140 ns    9721413 ns         71 3.14159</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BM_CalculatePi/threads:8      2255 ns       9943 ns      70936</span><br></span></code></pre></div></div>
<p>Note above the additional header printed when the benchmark changes from
<code>BM_UserCounter</code> to <code>BM_Factorial</code>. This is because <code>BM_Factorial</code> does
not have the same counter set as <code>BM_UserCounter</code>.</p>
<a name="multithreaded-benchmarks"></a>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="multithreaded-benchmarks">Multithreaded Benchmarks<a href="#multithreaded-benchmarks" class="hash-link" aria-label="Direct link to Multithreaded Benchmarks" title="Direct link to Multithreaded Benchmarks" translate="no">​</a></h2>
<p>In a multithreaded test (benchmark invoked by multiple threads simultaneously),
it is guaranteed that none of the threads will start until all have reached
the start of the benchmark loop, and all will have finished before any thread
exits the benchmark loop. (This behavior is also provided by the <code>KeepRunning()</code>
API) As such, any global setup or teardown can be wrapped in a check against the thread
index:</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static void BM_MultiThreaded(benchmark::State&amp; state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (state.thread_index() == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Setup code here.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (auto _ : state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Run the test as normal.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (state.thread_index() == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Teardown code here.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK(BM_MultiThreaded)-&gt;Threads(2);</span><br></span></code></pre></div></div>
<p>To run the benchmark across a range of thread counts, instead of <code>Threads</code>, use
<code>ThreadRange</code>. This takes two parameters (<code>min_threads</code> and <code>max_threads</code>) and
runs the benchmark once for values in the inclusive range. For example:</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK(BM_MultiThreaded)-&gt;ThreadRange(1, 8);</span><br></span></code></pre></div></div>
<p>will run <code>BM_MultiThreaded</code> with thread counts 1, 2, 4, and 8.</p>
<p>If the benchmarked code itself uses threads and you want to compare it to
single-threaded code, you may want to use real-time (&quot;wallclock&quot;) measurements
for latency comparisons:</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK(BM_test)-&gt;Range(8, 8&lt;&lt;10)-&gt;UseRealTime();</span><br></span></code></pre></div></div>
<p>Without <code>UseRealTime</code>, CPU time is used by default.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="manual-multithreaded-benchmarks">Manual Multithreaded Benchmarks<a href="#manual-multithreaded-benchmarks" class="hash-link" aria-label="Direct link to Manual Multithreaded Benchmarks" title="Direct link to Manual Multithreaded Benchmarks" translate="no">​</a></h3>
<p>Google/benchmark uses <code>std::thread</code> as multithreading environment per default.
If you want to use another multithreading environment (e.g. OpenMP), you can provide
a factory function to your benchmark using the <code>ThreadRunner</code> function.
The factory function takes the number of threads as argument and creates a custom class
derived from <code>benchmark::ThreadRunnerBase</code>.
This custom class must override the function
<code>void RunThreads(const std::function&lt;void(int)&gt;&amp; fn)</code>.
<code>RunThreads</code> is called by the main thread and spawns the requested number of threads.
Each spawned thread must call <code>fn(thread_index)</code>, where <code>thread_index</code> is its own
thread index. Before <code>RunThreads</code> returns, all spawned threads must be joined.</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class OpenMPThreadRunner : public benchmark::ThreadRunnerBase</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  OpenMPThreadRunner(int num_threads)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  : num_threads_(num_threads)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  void RunThreads(const std::function&lt;void(int)&gt;&amp; fn) final</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#pragma omp parallel num_threads(num_threads_)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn(omp_get_thread_num());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  int num_threads_;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK(BM_MultiThreaded)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  -&gt;ThreadRunner([](int num_threads) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return std::make_unique&lt;OpenMPThreadRunner&gt;(num_threads);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  -&gt;Threads(1)-&gt;Threads(2)-&gt;Threads(4);</span><br></span></code></pre></div></div>
<p>The above example creates a parallel OpenMP region before it enters <code>BM_MultiThreaded</code>.
The actual benchmark code can remain the same and is therefore not tied to a specific
thread runner. The measurement does not include the time for creating and joining the
threads.</p>
<a name="cpu-timers"></a>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="cpu-timers">CPU Timers<a href="#cpu-timers" class="hash-link" aria-label="Direct link to CPU Timers" title="Direct link to CPU Timers" translate="no">​</a></h2>
<p>By default, the CPU timer only measures the time spent by the main thread.
If the benchmark itself uses threads internally, this measurement may not
be what you are looking for. Instead, there is a way to measure the total
CPU usage of the process, by all the threads.</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void callee(int i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void MyMain(int size) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#pragma omp parallel for</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for(int i = 0; i &lt; size; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    callee(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void BM_OpenMP(benchmark::State&amp; state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (auto _ : state)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MyMain(state.range(0));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Measure the time spent by the main thread, use it to decide for how long to</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// run the benchmark loop. Depending on the internal implementation detail may</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// measure to anywhere from near-zero (the overhead spent before/after work</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// handoff to worker thread[s]) to the whole single-thread time.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK(BM_OpenMP)-&gt;Range(8, 8&lt;&lt;10);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Measure the user-visible time, the wall clock (literally, the time that</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// has passed on the clock on the wall), use it to decide for how long to</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// run the benchmark loop. This will always be meaningful, and will match the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// time spent by the main thread in single-threaded case, in general decreasing</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// with the number of internal threads doing the work.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK(BM_OpenMP)-&gt;Range(8, 8&lt;&lt;10)-&gt;UseRealTime();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Measure the total CPU consumption, use it to decide for how long to</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// run the benchmark loop. This will always measure to no less than the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// time spent by the main thread in single-threaded case.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK(BM_OpenMP)-&gt;Range(8, 8&lt;&lt;10)-&gt;MeasureProcessCPUTime();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// A mixture of the last two. Measure the total CPU consumption, but use the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// wall clock to decide for how long to run the benchmark loop.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK(BM_OpenMP)-&gt;Range(8, 8&lt;&lt;10)-&gt;MeasureProcessCPUTime()-&gt;UseRealTime();</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="controlling-timers">Controlling Timers<a href="#controlling-timers" class="hash-link" aria-label="Direct link to Controlling Timers" title="Direct link to Controlling Timers" translate="no">​</a></h3>
<p>Normally, the entire duration of the work loop (<code>for (auto _ : state) {}</code>)
is measured. But sometimes, it is necessary to do some work inside of
that loop, every iteration, but without counting that time to the benchmark time.
That is possible, although it is not recommended, since it has high overhead.</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static void BM_SetInsert_With_Timer_Control(benchmark::State&amp; state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  std::set&lt;int&gt; data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (auto _ : state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    state.PauseTiming(); // Stop timers. They will not count until they are resumed.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    data = ConstructRandomSet(state.range(0)); // Do something that should not be measured</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    state.ResumeTiming(); // And resume timers. They are now counting again.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // The rest will be measured.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int j = 0; j &lt; state.range(1); ++j)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      data.insert(RandomNumber());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK(BM_SetInsert_With_Timer_Control)-&gt;Ranges({{1&lt;&lt;10, 8&lt;&lt;10}, {128, 512}});</span><br></span></code></pre></div></div>
<a name="manual-timing"></a>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="manual-timing">Manual Timing<a href="#manual-timing" class="hash-link" aria-label="Direct link to Manual Timing" title="Direct link to Manual Timing" translate="no">​</a></h2>
<p>For benchmarking something for which neither CPU time nor real-time are
correct or accurate enough, completely manual timing is supported using
the <code>UseManualTime</code> function.</p>
<p>When <code>UseManualTime</code> is used, the benchmarked code must call
<code>SetIterationTime</code> once per iteration of the benchmark loop to
report the manually measured time.</p>
<p>An example use case for this is benchmarking GPU execution (e.g. OpenCL
or CUDA kernels, OpenGL or Vulkan or Direct3D draw calls), which cannot
be accurately measured using CPU time or real-time. Instead, they can be
measured accurately using a dedicated API, and these measurement results
can be reported back with <code>SetIterationTime</code>.</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static void BM_ManualTiming(benchmark::State&amp; state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  int microseconds = state.range(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  std::chrono::duration&lt;double, std::micro&gt; sleep_duration {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static_cast&lt;double&gt;(microseconds)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (auto _ : state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    auto start = std::chrono::high_resolution_clock::now();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Simulate some useful workload with a sleep</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    std::this_thread::sleep_for(sleep_duration);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    auto end = std::chrono::high_resolution_clock::now();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    auto elapsed_seconds =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      std::chrono::duration_cast&lt;std::chrono::duration&lt;double&gt;&gt;(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        end - start);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    state.SetIterationTime(elapsed_seconds.count());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK(BM_ManualTiming)-&gt;Range(1, 1&lt;&lt;17)-&gt;UseManualTime();</span><br></span></code></pre></div></div>
<a name="setting-the-time-unit"></a>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="setting-the-time-unit">Setting the Time Unit<a href="#setting-the-time-unit" class="hash-link" aria-label="Direct link to Setting the Time Unit" title="Direct link to Setting the Time Unit" translate="no">​</a></h2>
<p>If a benchmark runs a few milliseconds it may be hard to visually compare the
measured times, since the output data is given in nanoseconds per default. In
order to manually set the time unit, you can specify it manually:</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK(BM_test)-&gt;Unit(benchmark::kMillisecond);</span><br></span></code></pre></div></div>
<p>Additionally the default time unit can be set globally with the
<code>--benchmark_time_unit={ns|us|ms|s}</code> command line argument. The argument only
affects benchmarks where the time unit is not set explicitly.</p>
<a name="preventing-optimization"></a>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="preventing-optimization">Preventing Optimization<a href="#preventing-optimization" class="hash-link" aria-label="Direct link to Preventing Optimization" title="Direct link to Preventing Optimization" translate="no">​</a></h2>
<p>To prevent a value or expression from being optimized away by the compiler
the <code>benchmark::DoNotOptimize(...)</code> and <code>benchmark::ClobberMemory()</code>
functions can be used.</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static void BM_test(benchmark::State&amp; state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (auto _ : state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      int x = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      for (int i=0; i &lt; 64; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        benchmark::DoNotOptimize(x += i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p><code>DoNotOptimize(&lt;expr&gt;)</code> forces the  <em>result</em> of <code>&lt;expr&gt;</code> to be stored in either
memory or a register. For GNU based compilers it acts as read/write barrier
for global memory. More specifically it forces the compiler to flush pending
writes to memory and reload any other values as necessary.</p>
<p>Note that <code>DoNotOptimize(&lt;expr&gt;)</code> does not prevent optimizations on <code>&lt;expr&gt;</code>
in any way. <code>&lt;expr&gt;</code> may even be removed entirely when the result is already
known. For example:</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">  // Example 1: `&lt;expr&gt;` is removed entirely.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  int foo(int x) { return x + 42; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  while (...) DoNotOptimize(foo(0)); // Optimized to DoNotOptimize(42);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Example 2: Result of &#x27;&lt;expr&gt;&#x27; is only reused.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  int bar(int) __attribute__((const));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  while (...) DoNotOptimize(bar(0)); // Optimized to:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // int __result__ = bar(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // while (...) DoNotOptimize(__result__);</span><br></span></code></pre></div></div>
<p>The second tool for preventing optimizations is <code>ClobberMemory()</code>. In essence
<code>ClobberMemory()</code> forces the compiler to perform all pending writes to global
memory. Memory managed by block scope objects must be &quot;escaped&quot; using
<code>DoNotOptimize(...)</code> before it can be clobbered. In the below example
<code>ClobberMemory()</code> prevents the call to <code>v.push_back(42)</code> from being optimized
away.</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static void BM_vector_push_back(benchmark::State&amp; state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (auto _ : state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    std::vector&lt;int&gt; v;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v.reserve(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    auto data = v.data();           // Allow v.data() to be clobbered. Pass as non-const</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    benchmark::DoNotOptimize(data); // lvalue to avoid undesired compiler optimizations</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v.push_back(42);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    benchmark::ClobberMemory(); // Force 42 to be written to memory.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>Note that <code>ClobberMemory()</code> is only available for GNU or MSVC based compilers.</p>
<a name="reporting-statistics"></a>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="statistics-reporting-the-mean-median-and-standard-deviation--coefficient-of-variation-of-repeated-benchmarks">Statistics: Reporting the Mean, Median and Standard Deviation / Coefficient of variation of Repeated Benchmarks<a href="#statistics-reporting-the-mean-median-and-standard-deviation--coefficient-of-variation-of-repeated-benchmarks" class="hash-link" aria-label="Direct link to Statistics: Reporting the Mean, Median and Standard Deviation / Coefficient of variation of Repeated Benchmarks" title="Direct link to Statistics: Reporting the Mean, Median and Standard Deviation / Coefficient of variation of Repeated Benchmarks" translate="no">​</a></h2>
<p>By default each benchmark is run once and that single result is reported.
However benchmarks are often noisy and a single result may not be representative
of the overall behavior. For this reason it&#x27;s possible to repeatedly rerun the
benchmark.</p>
<p>The number of runs of each benchmark is specified globally by the
<code>--benchmark_repetitions</code> flag or on a per benchmark basis by calling
<code>Repetitions</code> on the registered benchmark object. When a benchmark is run more
than once the mean, median, standard deviation and coefficient of variation
of the runs will be reported.</p>
<p>Additionally the <code>--benchmark_report_aggregates_only={true|false}</code>,
<code>--benchmark_display_aggregates_only={true|false}</code> flags or
<code>ReportAggregatesOnly(bool)</code>, <code>DisplayAggregatesOnly(bool)</code> functions can be
used to change how repeated tests are reported. By default the result of each
repeated run is reported. When <code>report aggregates only</code> option is <code>true</code>,
only the aggregates (i.e. mean, median, standard deviation and coefficient
of variation, maybe complexity measurements if they were requested) of the runs
is reported, to both the reporters - standard output (console), and the file.
However when only the <code>display aggregates only</code> option is <code>true</code>,
only the aggregates are displayed in the standard output, while the file
output still contains everything.
Calling <code>ReportAggregatesOnly(bool)</code> / <code>DisplayAggregatesOnly(bool)</code> on a
registered benchmark object overrides the value of the appropriate flag for that
benchmark.</p>
<a name="custom-statistics"></a>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="custom-statistics">Custom Statistics<a href="#custom-statistics" class="hash-link" aria-label="Direct link to Custom Statistics" title="Direct link to Custom Statistics" translate="no">​</a></h2>
<p>While having these aggregates is nice, this may not be enough for everyone.
For example you may want to know what the largest observation is, e.g. because
you have some real-time constraints. This is easy. The following code will
specify a custom statistic to be calculated, defined by a lambda function.</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void BM_spin_empty(benchmark::State&amp; state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (auto _ : state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int x = 0; x &lt; state.range(0); ++x) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      benchmark::DoNotOptimize(x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK(BM_spin_empty)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  -&gt;Repetitions(3) // or add option --benchmark_repetitions=3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  -&gt;ComputeStatistics(&quot;max&quot;, [](const std::vector&lt;double&gt;&amp; v) -&gt; double {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return *(std::max_element(std::begin(v), std::end(v)));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  -&gt;Arg(512);</span><br></span></code></pre></div></div>
<p>While usually the statistics produce values in time units,
you can also produce percentages:</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void BM_spin_empty(benchmark::State&amp; state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (auto _ : state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int x = 0; x &lt; state.range(0); ++x) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      benchmark::DoNotOptimize(x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK(BM_spin_empty)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  -&gt;Repetitions(3) // or add option --benchmark_repetitions=3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  -&gt;ComputeStatistics(&quot;ratio&quot;, [](const std::vector&lt;double&gt;&amp; v) -&gt; double {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return v.front() / v.back();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }, benchmark::StatisticUnit::kPercentage)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  -&gt;Arg(512);</span><br></span></code></pre></div></div>
<a name="memory-usage"></a>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="memory-usage">Memory Usage<a href="#memory-usage" class="hash-link" aria-label="Direct link to Memory Usage" title="Direct link to Memory Usage" translate="no">​</a></h2>
<p>It&#x27;s often useful to also track memory usage for benchmarks, alongside CPU
performance. For this reason, benchmark offers the <code>RegisterMemoryManager</code>
method that allows a custom <code>MemoryManager</code> to be injected.</p>
<p>If set, the <code>MemoryManager::Start</code> and <code>MemoryManager::Stop</code> methods will be
called at the start and end of benchmark runs to allow user code to fill out
a report on the number of allocations, bytes used, etc.</p>
<p>This data will then be reported alongside other performance data, currently
only when using JSON output.</p>
<a name="profiling"></a>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="profiling">Profiling<a href="#profiling" class="hash-link" aria-label="Direct link to Profiling" title="Direct link to Profiling" translate="no">​</a></h2>
<p>It&#x27;s often useful to also profile benchmarks in particular ways, in addition to
CPU performance. For this reason, benchmark offers the <code>RegisterProfilerManager</code>
method that allows a custom <code>ProfilerManager</code> to be injected.</p>
<p>If set, the <code>ProfilerManager::AfterSetupStart</code> and
<code>ProfilerManager::BeforeTeardownStop</code> methods will be called at the start and
end of a separate benchmark run to allow user code to collect and report
user-provided profile metrics.</p>
<p>Output collected from this profiling run must be reported separately.</p>
<a name="using-register-benchmark"></a>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="using-registerbenchmarkname-fn-args">Using RegisterBenchmark(name, fn, args...)<a href="#using-registerbenchmarkname-fn-args" class="hash-link" aria-label="Direct link to Using RegisterBenchmark(name, fn, args...)" title="Direct link to Using RegisterBenchmark(name, fn, args...)" translate="no">​</a></h2>
<p>The <code>RegisterBenchmark(name, func, args...)</code> function provides an alternative
way to create and register benchmarks.
<code>RegisterBenchmark(name, func, args...)</code> creates, registers, and returns a
pointer to a new benchmark with the specified <code>name</code> that invokes
<code>func(st, args...)</code> where <code>st</code> is a <code>benchmark::State</code> object.</p>
<p>Unlike the <code>BENCHMARK</code> registration macros, which can only be used at the global
scope, the <code>RegisterBenchmark</code> can be called anywhere. This allows for
benchmark tests to be registered programmatically.</p>
<p>Additionally <code>RegisterBenchmark</code> allows any callable object to be registered
as a benchmark. Including capturing lambdas and function objects.</p>
<p>For Example:</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">auto BM_test = [](benchmark::State&amp; st, auto Inputs) { /* ... */ };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(int argc, char** argv) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  benchmark::MaybeReenterWithoutASLR(argc, argv);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (auto&amp; test_input : { /* ... */ })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      benchmark::RegisterBenchmark(test_input.name(), BM_test, test_input);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  benchmark::Initialize(&amp;argc, argv);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  benchmark::RunSpecifiedBenchmarks();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  benchmark::Shutdown();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<a name="exiting-with-an-error"></a>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="exiting-with-an-error">Exiting with an Error<a href="#exiting-with-an-error" class="hash-link" aria-label="Direct link to Exiting with an Error" title="Direct link to Exiting with an Error" translate="no">​</a></h2>
<p>When errors caused by external influences, such as file I/O and network
communication, occur within a benchmark the
<code>State::SkipWithError(const std::string&amp; msg)</code> function can be used to skip that run
of benchmark and report the error. Note that only future iterations of the
<code>KeepRunning()</code> are skipped. For the ranged-for version of the benchmark loop
Users must explicitly exit the loop, otherwise all iterations will be performed.
Users may explicitly return to exit the benchmark immediately.</p>
<p>The <code>SkipWithError(...)</code> function may be used at any point within the benchmark,
including before and after the benchmark loop. Moreover, if <code>SkipWithError(...)</code>
has been used, it is not required to reach the benchmark loop and one may return
from the benchmark function early.</p>
<p>For example:</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static void BM_test(benchmark::State&amp; state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  auto resource = GetResource();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (!resource.good()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    state.SkipWithError(&quot;Resource is not good!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // KeepRunning() loop will not be entered.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  while (state.KeepRunning()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    auto data = resource.read_data();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!resource.good()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      state.SkipWithError(&quot;Failed to read data!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      break; // Needed to skip the rest of the iteration.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    do_stuff(data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void BM_test_ranged_fo(benchmark::State &amp; state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  auto resource = GetResource();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (!resource.good()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    state.SkipWithError(&quot;Resource is not good!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return; // Early return is allowed when SkipWithError() has been used.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (auto _ : state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    auto data = resource.read_data();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!resource.good()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      state.SkipWithError(&quot;Failed to read data!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      break; // REQUIRED to prevent all further iterations.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    do_stuff(data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<a name="a-faster-keep-running-loop"></a>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="a-faster-keeprunning-loop">A Faster KeepRunning Loop<a href="#a-faster-keeprunning-loop" class="hash-link" aria-label="Direct link to A Faster KeepRunning Loop" title="Direct link to A Faster KeepRunning Loop" translate="no">​</a></h2>
<p>A ranged-based for loop should be used in preference to
the <code>KeepRunning</code> loop for running the benchmarks. For example:</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static void BM_Fast(benchmark::State &amp;state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (auto _ : state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    FastOperation();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BENCHMARK(BM_Fast);</span><br></span></code></pre></div></div>
<p>The reason the ranged-for loop is faster than using <code>KeepRunning</code>, is
because <code>KeepRunning</code> requires a memory load and store of the iteration count
ever iteration, whereas the ranged-for variant is able to keep the iteration count
in a register.</p>
<p>For example, an empty inner loop of using the ranged-based for method looks like:</p>
<div class="language-asm codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-asm codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># Loop Init</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  mov rbx, qword ptr [r14 + 104]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  call benchmark::State::StartKeepRunning()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  test rbx, rbx</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  je .LoopEnd</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">.LoopHeader: # =&gt;This Inner Loop Header: Depth=1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  add rbx, -1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  jne .LoopHeader</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">.LoopEnd:</span><br></span></code></pre></div></div>
<p>Compared to an empty <code>KeepRunning</code> loop, which looks like:</p>
<div class="language-asm codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-asm codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">.LoopHeader: # in Loop: Header=BB0_3 Depth=1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  cmp byte ptr [rbx], 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  jne .LoopInit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">.LoopBody: # =&gt;This Inner Loop Header: Depth=1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  mov rax, qword ptr [rbx + 8]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  lea rcx, [rax + 1]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  mov qword ptr [rbx + 8], rcx</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  cmp rax, qword ptr [rbx + 104]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  jb .LoopHeader</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  jmp .LoopEnd</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">.LoopInit:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  mov rdi, rbx</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  call benchmark::State::StartKeepRunning()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  jmp .LoopBody</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">.LoopEnd:</span><br></span></code></pre></div></div>
<p>Unless C++03 compatibility is required, the ranged-for variant of writing
the benchmark loop should be preferred.</p>
<a name="disabling-cpu-frequency-scaling"></a>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="disabling-cpu-frequency-scaling">Disabling CPU Frequency Scaling<a href="#disabling-cpu-frequency-scaling" class="hash-link" aria-label="Direct link to Disabling CPU Frequency Scaling" title="Direct link to Disabling CPU Frequency Scaling" translate="no">​</a></h2>
<p>If you see this error:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">***WARNING*** CPU scaling is enabled, the benchmark real time measurements may</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">be noisy and will incur extra overhead.</span><br></span></code></pre></div></div>
<p>you might want to disable the CPU frequency scaling while running the
benchmark, as well as consider other ways to stabilize the performance of
your system while benchmarking.</p>
<p>See <a class="" href="/cppdev/docs/testing/benchmark/reducing_variance">Reducing Variance</a> for more information.</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col noPrint_WFHX"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/testing/benchmark/user_guide.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/cppdev/docs/testing/benchmark/tools"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Benchmark Tools</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/cppdev/docs/log/"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">index</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#command-line" class="table-of-contents__link toc-highlight">Command Line</a></li><li><a href="#library" class="table-of-contents__link toc-highlight">Library</a></li><li><a href="#benchmarking-tips" class="table-of-contents__link toc-highlight">Benchmarking Tips</a></li><li><a href="#output-formats" class="table-of-contents__link toc-highlight">Output Formats</a></li><li><a href="#output-files" class="table-of-contents__link toc-highlight">Output Files</a></li><li><a href="#running-benchmarks" class="table-of-contents__link toc-highlight">Running Benchmarks</a><ul><li><a href="#dry-runs" class="table-of-contents__link toc-highlight">Dry runs</a></li></ul></li><li><a href="#running-a-subset-of-benchmarks" class="table-of-contents__link toc-highlight">Running a Subset of Benchmarks</a></li><li><a href="#disabling-benchmarks" class="table-of-contents__link toc-highlight">Disabling Benchmarks</a></li><li><a href="#result-comparison" class="table-of-contents__link toc-highlight">Result comparison</a></li><li><a href="#extra-context" class="table-of-contents__link toc-highlight">Extra Context</a></li><li><a href="#runtime-and-reporting-considerations" class="table-of-contents__link toc-highlight">Runtime and Reporting Considerations</a></li><li><a href="#setupteardown" class="table-of-contents__link toc-highlight">Setup/Teardown</a></li><li><a href="#passing-arguments" class="table-of-contents__link toc-highlight">Passing Arguments</a><ul><li><a href="#passing-arbitrary-arguments-to-a-benchmark" class="table-of-contents__link toc-highlight">Passing Arbitrary Arguments to a Benchmark</a></li></ul></li><li><a href="#calculating-asymptotic-complexity-big-o" class="table-of-contents__link toc-highlight">Calculating Asymptotic Complexity (Big O)</a></li><li><a href="#custom-benchmark-name" class="table-of-contents__link toc-highlight">Custom Benchmark Name</a></li><li><a href="#templated-benchmarks" class="table-of-contents__link toc-highlight">Templated Benchmarks</a></li><li><a href="#templated-benchmarks-that-take-arguments" class="table-of-contents__link toc-highlight">Templated Benchmarks that take arguments</a></li><li><a href="#fixtures" class="table-of-contents__link toc-highlight">Fixtures</a><ul><li><a href="#templated-fixtures" class="table-of-contents__link toc-highlight">Templated Fixtures</a></li></ul></li><li><a href="#custom-counters" class="table-of-contents__link toc-highlight">Custom Counters</a><ul><li><a href="#counter-reporting" class="table-of-contents__link toc-highlight">Counter Reporting</a></li></ul></li><li><a href="#multithreaded-benchmarks" class="table-of-contents__link toc-highlight">Multithreaded Benchmarks</a><ul><li><a href="#manual-multithreaded-benchmarks" class="table-of-contents__link toc-highlight">Manual Multithreaded Benchmarks</a></li></ul></li><li><a href="#cpu-timers" class="table-of-contents__link toc-highlight">CPU Timers</a><ul><li><a href="#controlling-timers" class="table-of-contents__link toc-highlight">Controlling Timers</a></li></ul></li><li><a href="#manual-timing" class="table-of-contents__link toc-highlight">Manual Timing</a></li><li><a href="#setting-the-time-unit" class="table-of-contents__link toc-highlight">Setting the Time Unit</a></li><li><a href="#preventing-optimization" class="table-of-contents__link toc-highlight">Preventing Optimization</a></li><li><a href="#statistics-reporting-the-mean-median-and-standard-deviation--coefficient-of-variation-of-repeated-benchmarks" class="table-of-contents__link toc-highlight">Statistics: Reporting the Mean, Median and Standard Deviation / Coefficient of variation of Repeated Benchmarks</a></li><li><a href="#custom-statistics" class="table-of-contents__link toc-highlight">Custom Statistics</a></li><li><a href="#memory-usage" class="table-of-contents__link toc-highlight">Memory Usage</a></li><li><a href="#profiling" class="table-of-contents__link toc-highlight">Profiling</a></li><li><a href="#using-registerbenchmarkname-fn-args" class="table-of-contents__link toc-highlight">Using RegisterBenchmark(name, fn, args...)</a></li><li><a href="#exiting-with-an-error" class="table-of-contents__link toc-highlight">Exiting with an Error</a></li><li><a href="#a-faster-keeprunning-loop" class="table-of-contents__link toc-highlight">A Faster KeepRunning Loop</a></li><li><a href="#disabling-cpu-frequency-scaling" class="table-of-contents__link toc-highlight">Disabling CPU Frequency Scaling</a></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/cppdev/docs/intro">Tutorial</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://x.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">X<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/cppdev/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/kumo-pub" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 Kumo, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>