"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[507],{8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>l});var r=i(6540);const t={},s=r.createContext(t);function a(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(s.Provider,{value:n},e.children)}},9245:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"retrieve/trie/cedar","title":"cedar","description":"Cedar Trie","source":"@site/docs/retrieve/trie/cedar.mdx","sourceDirName":"retrieve/trie","slug":"/retrieve/trie/cedar","permalink":"/cppdev/docs/retrieve/trie/cedar","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"marisa","permalink":"/cppdev/docs/retrieve/trie/marisa"},"next":{"title":"NLP Modules for Text Preprocessing","permalink":"/cppdev/docs/retrieve/nlp/"}}');var t=i(4848),s=i(8453);const a={},l=void 0,d={},c=[{value:"Cedar Trie",id:"cedar-trie",level:2},{value:"Overview",id:"overview",level:3},{value:"Key Features",id:"key-features",level:3},{value:"Typical Use Cases",id:"typical-use-cases",level:3},{value:"Not Suitable For",id:"not-suitable-for",level:3},{value:"Industrial Fit",id:"industrial-fit",level:3},{value:"C++ Example",id:"c-example",level:3},{value:"Build",id:"build",level:4},{value:"Construct, Insert, and Delete Keys",id:"construct-insert-and-delete-keys",level:4},{value:"Load and Query Trie",id:"load-and-query-trie",level:4},{value:"Notes",id:"notes",level:3}];function o(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"cedar-trie",children:"Cedar Trie"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Project:"})," Cedar \u2014 ",(0,t.jsx)(n.em,{children:"Updatable Double-Array Trie in C++"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Official Website:"})," ",(0,t.jsx)(n.a,{href:"http://www.tkl.iis.u-tokyo.ac.jp/~ynaga/cedar/",children:"http://www.tkl.iis.u-tokyo.ac.jp/~ynaga/cedar/"})]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"overview",children:"Overview"}),"\n",(0,t.jsxs)(n.p,{children:["Cedar is a ",(0,t.jsx)(n.strong,{children:"C++ implementation of an updatable double-array trie"})," designed for ",(0,t.jsx)(n.strong,{children:"fast incremental insertions, deletions, and lookups"})," of English string dictionaries."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Supports ",(0,t.jsx)(n.strong,{children:"dynamic insertion and deletion"})," at any time, not only during build."]}),"\n",(0,t.jsxs)(n.li,{children:["Provides ",(0,t.jsx)(n.strong,{children:"exact match and prefix search"})," with high cache efficiency."]}),"\n",(0,t.jsxs)(n.li,{children:["Supports ",(0,t.jsx)(n.strong,{children:"serialization and deserialization"})," for persistent storage."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["This makes Cedar suitable for applications where the dictionary evolves over time and requires ",(0,t.jsx)(n.strong,{children:"both dynamic updates and high-performance queries"}),"."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"key-features",children:"Key Features"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Fully dynamic:"})," online insertions and deletions supported."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Exact match and prefix search:"})," high-performance lookup for queries."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Memory efficient:"})," compact double-array structure for large English vocabularies."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Persistent storage:"})," serialization and deserialization supported for production use."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Incremental updates:"})," can handle skewed and growing datasets efficiently."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"typical-use-cases",children:"Typical Use Cases"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["English ",(0,t.jsx)(n.strong,{children:"keyword lookup"})," with frequent updates"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Autocomplete / prefix search"})," on evolving query sets"]}),"\n",(0,t.jsx)(n.li,{children:"Dynamic dictionary access in text processing pipelines"}),"\n",(0,t.jsx)(n.li,{children:"Real-time search engines or indexing systems requiring insert/delete support"}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"not-suitable-for",children:"Not Suitable For"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Very large-scale static dictionaries where a purely static double-array trie may be slightly more memory efficient"}),"\n",(0,t.jsx)(n.li,{children:"Non-English or Unicode-heavy workloads (requires proper encoding handling)"}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"industrial-fit",children:"Industrial Fit"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Requirement"}),(0,t.jsx)(n.th,{children:"Cedar Support"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Online insert/delete"}),(0,t.jsx)(n.td,{children:"\u2714\ufe0f"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Fast prefix & exact search"}),(0,t.jsx)(n.td,{children:"\u2714\ufe0f"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"mmap-able & serializable dictionary"}),(0,t.jsx)(n.td,{children:"\u2714\ufe0f"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Attaching payload (bitmap / counts)"}),(0,t.jsx)(n.td,{children:"\u274c"})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Conclusion:"}),"\nCedar Trie is suitable for ",(0,t.jsx)(n.strong,{children:"dynamic English dictionary workloads"}),", where ",(0,t.jsx)(n.strong,{children:"online insertions and deletions"})," coexist with high-performance exact match and prefix queries. It supports persistent storage and incremental updates, making it a fully dynamic trie for production systems."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"c-example",children:"C++ Example"}),"\n",(0,t.jsx)(n.h4,{id:"build",children:"Build"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"git clone http://www.tkl.iis.u-tokyo.ac.jp/~ynaga/cedar/\ncd cedar\nmake\n"})}),"\n",(0,t.jsx)(n.h4,{id:"construct-insert-and-delete-keys",children:"Construct, Insert, and Delete Keys"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'#include <cedar.h>\n#include <iostream>\n#include <vector>\n\nint main() {\n    cedar::da<int> trie;\n\n    // Initial insertions\n    std::vector<std::string> keys = {"apple", "application", "banana", "band"};\n    for (size_t i = 0; i < keys.size(); ++i) {\n        trie.update(keys[i].c_str(), static_cast<int>(i));\n    }\n\n    // Dynamic insertion\n    trie.update("applet", 4);\n\n    // Dynamic deletion\n    trie.remove("banana");\n\n    // Save for persistent use\n    trie.save("cedar.dict");\n\n    return 0;\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h4,{id:"load-and-query-trie",children:"Load and Query Trie"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'#include <cedar.h>\n#include <iostream>\n\nint main() {\n    cedar::da<int> trie;\n    trie.load("cedar.dict");\n\n    std::string query = "app";\n    int value;\n\n    // Exact match\n    if (trie.exactMatchSearch(query.c_str(), &value)) {\n        std::cout << "Exact match found: " << query\n                  << " -> " << value << "\\n";\n    }\n\n    // Prefix search\n    cedar::da<int>::prefix_iterator it = trie.prefixBegin(query.c_str());\n    cedar::da<int>::prefix_iterator end = trie.prefixEnd();\n    for (; it != end; ++it) {\n        std::cout << "Prefix match: " << it->key()\n                  << " -> " << it->value() << "\\n";\n    }\n\n    return 0;\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"notes",children:"Notes"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Cedar ",(0,t.jsx)(n.strong,{children:"fully supports online insertions and deletions"}),", not limited to build-time."]}),"\n",(0,t.jsx)(n.li,{children:"Exact match, prefix search, and serialization are fully supported."}),"\n",(0,t.jsxs)(n.li,{children:["Suitable for production systems with ",(0,t.jsx)(n.strong,{children:"dynamic English dictionaries"})," requiring frequent updates."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}}}]);