"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[1273],{268:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"foundamentals/fibers/futures","title":"Futures","description":"Futures is a framework for expressing asynchronous code in C++ using the Promise/Future pattern.","source":"@site/docs/foundamentals/fibers/futures.md","sourceDirName":"foundamentals/fibers","slug":"/foundamentals/fibers/futures","permalink":"/cppdev/docs/foundamentals/fibers/futures","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/foundamentals/fibers/futures.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Fiber Pattern Selection: A Multi-threaded Contention Perspective (Supplemented with Memory Contention Management Costs)","permalink":"/cppdev/docs/foundamentals/fibers/"},"next":{"title":"std-future","permalink":"/cppdev/docs/foundamentals/fibers/std-future"}}');var a=n(4848),s=n(8453);const i={},o="Futures",c={},l=[{value:"Futures is a framework for expressing asynchronous code in C++ using the Promise/Future pattern.",id:"futures-is-a-framework-for-expressing-asynchronous-code-in-c-using-the-promisefuture-pattern",level:3},{value:"Blog Post",id:"blog-post",level:2}];function u(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"futures",children:"Futures"})}),"\n",(0,a.jsx)(t.h3,{id:"futures-is-a-framework-for-expressing-asynchronous-code-in-c-using-the-promisefuture-pattern",children:"Futures is a framework for expressing asynchronous code in C++ using the Promise/Future pattern."}),"\n",(0,a.jsx)(t.h1,{id:"overview",children:"Overview"}),"\n",(0,a.jsxs)(t.p,{children:["Melon Futures is an async C++ framework inspired by ",(0,a.jsx)(t.a,{href:"https://twitter.github.io/finagle/guide/Futures.html",children:"Twitter's Futures"})," implementation in Scala (see also ",(0,a.jsx)(t.a,{href:"https://github.com/twitter/util/blob/master/util-core/src/main/scala/com/twitter/util/Future.scala",children:"Future.scala"}),", ",(0,a.jsx)(t.a,{href:"https://github.com/twitter/util/blob/master/util-core/src/main/scala/com/twitter/util/Promise.scala",children:"Promise.scala"}),", and friends), and loosely builds upon the existing but anemic Futures code found in the C++11 standard (",(0,a.jsx)(t.a,{href:"https://en.cppreference.com/w/cpp/thread/future",children:"std::future"}),") and ",(0,a.jsx)(t.a,{href:"https://www.boost.org/doc/libs/1_53_0/doc/html/thread/synchronization.html#thread.synchronization.futures",children:"boost::future"})," (especially >= 1.53.0). Although inspired by the C++11 std::future interface, it is not a drop-in replacement because some ideas don't translate well enough to maintain API compatibility."]}),"\n",(0,a.jsxs)(t.p,{children:["The primary difference from std::future is that you can attach callbacks to Futures (with ",(0,a.jsx)(t.code,{children:"thenValue"})," or ",(0,a.jsx)(t.code,{children:"thenTry"}),"), under the control of an executor to manage where work runs, which enables sequential and parallel composition of Futures for cleaner asynchronous code."]}),"\n",(0,a.jsx)(t.h1,{id:"brief-synopsis",children:"Brief Synopsis"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cpp",children:'#include <melon/futures/future.h>\n#include <melon/executors/threaded_executor.h>\nusing namespace melon;\nusing namespace std;\n\nvoid foo(int x) {\n  // do something with x\n  cout << "foo(" << x << ")" << endl;\n}\n\n// ...\n  melon::ThreadedExecutor executor;\n  cout << "making Promise" << endl;\n  Promise<int> p;\n  Future<int> f = p.getSemiFuture().via(&executor);\n  auto f2 = move(f).thenValue(foo);\n  cout << "Future chain made" << endl;\n\n// ... now perhaps in another event callback\n\n  cout << "fulfilling Promise" << endl;\n  p.setValue(42);\n  move(f2).get();\n  cout << "Promise fulfilled" << endl;\n'})}),"\n",(0,a.jsx)(t.p,{children:"This would print:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"making Promise\nFuture chain made\nfulfilling Promise\nfoo(42)\nPromise fulfilled\n"})}),"\n",(0,a.jsx)(t.h2,{id:"blog-post",children:"Blog Post"}),"\n",(0,a.jsxs)(t.p,{children:["In addition to this document, there is ",(0,a.jsx)(t.a,{href:"https://code.facebook.com/posts/1661982097368498/futures-for-c-11-at-facebook/",children:"a blog post on code.facebook.com (June\n2015)"}),"."]}),"\n",(0,a.jsx)(t.h1,{id:"brief-guide",children:"Brief guide"}),"\n",(0,a.jsx)(t.p,{children:"This brief guide covers the basics. For a more in-depth coverage skip to the appropriate section."}),"\n",(0,a.jsx)(t.p,{children:"Let's begin with an example using an imaginary simplified Memcache client interface:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cpp",children:"using std::string;\nclass MemcacheClient {\n public:\n  struct GetReply {\n    enum class Result {\n      FOUND,\n      NOT_FOUND,\n      SERVER_ERROR,\n    };\n\n    Result result;\n    // The value when result is FOUND,\n    // The error message when result is SERVER_ERROR or CLIENT_ERROR\n    // undefined otherwise\n    string value;\n  };\n\n  GetReply get(string key);\n};\n"})}),"\n",(0,a.jsxs)(t.p,{children:["This API is synchronous, i.e. when you call ",(0,a.jsx)(t.code,{children:"get()"})," you have to wait for the result. This is very simple, but unfortunately it is also very easy to write very slow code using synchronous APIs."]}),"\n",(0,a.jsx)(t.p,{children:"Now, consider this traditional asynchronous signature for the same operation:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cpp",children:"int async_get(string key, std::function<void(GetReply)> callback);\n"})}),"\n",(0,a.jsxs)(t.p,{children:["When you call ",(0,a.jsx)(t.code,{children:"async_get()"}),', your asynchronous operation begins and when it finishes your callback will be called with the result. Very performant code can be written with an API like this, but for nontrivial applications the code devolves into a special kind of spaghetti code affectionately referred to as "callback hell".']}),"\n",(0,a.jsx)(t.p,{children:"The Future-based API looks like this:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cpp",children:"SemiFuture<GetReply> future_get(string key);\n"})}),"\n",(0,a.jsxs)(t.p,{children:["A ",(0,a.jsx)(t.code,{children:"SemiFuture<GetReply>"})," or ",(0,a.jsx)(t.code,{children:"Future<GetReply>"})," is a placeholder for the ",(0,a.jsx)(t.code,{children:"GetReply"})," that we will eventually get. For most of the descriptive text below, Future can refer to either ",(0,a.jsx)(t.code,{children:"melon::SemiFuture"})," or ",(0,a.jsx)(t.code,{children:"melon::Future"}),' as the former is a safe subset of the latter. A Future usually starts life out "unfulfilled", or incomplete, i.e.:']}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cpp",children:"fut.isReady() == false\nfut.value()  // will throw an exception because the Future is not ready\n"})}),"\n",(0,a.jsxs)(t.p,{children:["At some point in the future, the ",(0,a.jsx)(t.code,{children:"Future"})," will have been fulfilled, and we can access its value."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cpp",children:"fut.isReady() == true\nGetReply& reply = fut.value();\n"})}),"\n",(0,a.jsx)(t.p,{children:"Futures support exceptions. If the asynchronous producer fails with an exception, your Future may represent an exception instead of a value. In that case:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cpp",children:"fut.isReady() == true\nfut.value() // will rethrow the exception\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Just what is exceptional depends on the API. In our example we have chosen not to raise exceptions for ",(0,a.jsx)(t.code,{children:"SERVER_ERROR"}),", but represent this explicitly in the ",(0,a.jsx)(t.code,{children:"GetReply"})," object. On the other hand, an astute Memcache veteran would notice that we left ",(0,a.jsx)(t.code,{children:"CLIENT_ERROR"})," out of ",(0,a.jsx)(t.code,{children:"GetReply::Result"}),", and perhaps a ",(0,a.jsx)(t.code,{children:"CLIENT_ERROR"})," would have been raised as an exception, because ",(0,a.jsx)(t.code,{children:"CLIENT_ERROR"}),' means there\'s a bug in the library and this would be truly exceptional. These decisions are judgement calls by the API designer. The important thing is that exceptional conditions (including and especially spurious exceptions that nobody expects) get captured and can be handled higher up the "stack".']}),"\n",(0,a.jsx)(t.p,{children:"So far we have described a way to initiate an asynchronous operation via an API that returns a Future, and then sometime later after it is fulfilled, we get its value. This is slightly more useful than a synchronous API, but it's not yet ideal. There are two more very important pieces to the puzzle."}),"\n",(0,a.jsx)(t.p,{children:"First, we can aggregate Futures, to define a new Future that completes after some or all of the aggregated Futures complete. Consider two examples: fetching a batch of requests and waiting for all of them, and fetching a group of requests and waiting for only one of them."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cpp",children:"MemcacheClient mc;\n\nvector<SemiFuture<GetReply>> futs;\nfor (auto& key : keys) {\n  futs.push_back(mc.future_get(key));\n}\nauto all = collectAll(futs.begin(), futs.end());\n\nvector<SemiFuture<GetReply>> futs;\nfor (auto& key : keys) {\n  futs.push_back(mc.future_get(key));\n}\nauto any = collectAny(futs.begin(), futs.end());\n\nvector<SemiFuture<GetReply>> futs;\nfor (auto& key : keys) {\n  futs.push_back(mc.future_get(key));\n}\nauto anyv = collectAnyWithoutException(futs.begin(), futs.end());\n"})}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"all"})," and ",(0,a.jsx)(t.code,{children:"any"})," are Futures (for the exact type and usage see the header files). They will be complete when all/one of futs are complete, respectively. (There is also ",(0,a.jsx)(t.code,{children:"collectN()"})," for when you need some, and ",(0,a.jsx)(t.code,{children:"collectAnyWithoutException"})," when you need one value if some value would be available.)"]}),"\n",(0,a.jsxs)(t.p,{children:["Second, we can associate a Future with an executor. An executor specifies where work will run, and we detail this more later. In summary, given an executor we can convert a ",(0,a.jsx)(t.code,{children:"SemiFuture"})," to a ",(0,a.jsx)(t.code,{children:"Future"})," with an executor, or a ",(0,a.jsx)(t.code,{children:"Future"})," on one executor to a ",(0,a.jsx)(t.code,{children:"Future"})," on another executor."]}),"\n",(0,a.jsx)(t.p,{children:"For example:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cpp",children:'melon::ThreadedExecutor executor;\nSemiFuture<GetReply> semiFut = mc.future_get("foo");\nFuture<GetReply> fut1 = std::move(semiFut).via(&executor);\n'})}),"\n",(0,a.jsxs)(t.p,{children:["Once an executor is attached, a ",(0,a.jsx)(t.code,{children:"Future"})," allows continuations to be attached and chained together monadically. An example will clarify:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cpp",children:'SemiFuture<GetReply> semiFut = mc.future_get("foo");\nFuture<GetReply> fut1 = std::move(semiFut).via(&executor);\n\nFuture<string> fut2 = std::move(fut1).thenValue(\n  [](GetReply reply) {\n    if (reply.result == MemcacheClient::GetReply::Result::FOUND)\n      return reply.value;\n    throw SomeException("No value");\n  });\n\nFuture<Unit> fut3 = std::move(fut2)\n  .thenValue([](string str) {\n    cout << str << endl;\n  })\n  .thenTry([](melon::Try<string> strTry) {\n    cout << strTry.value() << endl;\n  })\n  .thenError(melon::tag_t<std::exception>{}, [](std::exception const& e) {\n    cerr << e.what() << endl;\n  });\n'})}),"\n",(0,a.jsx)(t.p,{children:"That example is a little contrived but the idea is that you can transform a result from one type to another, potentially in a chain, and unhandled errors propagate. Of course, the intermediate variables are optional."}),"\n",(0,a.jsxs)(t.p,{children:["Using ",(0,a.jsx)(t.code,{children:".thenValue"})," or ",(0,a.jsx)(t.code,{children:".thenTry"})," to add callbacks is idiomatic. It brings all the code into one place, which avoids callback hell. ",(0,a.jsx)(t.code,{children:".thenValue"})," appends a continuation that takes ",(0,a.jsx)(t.code,{children:"T&&"})," for some ",(0,a.jsx)(t.code,{children:"Future<T>"})," and an error bypasses the callback and is passed to the next, ",(0,a.jsx)(t.code,{children:"thenTry"})," takes a callback taking ",(0,a.jsx)(t.code,{children:"melon::Try<T>"})," which encapsulates both value and exception. ",(0,a.jsx)(t.code,{children:"thenError(tag_t<ExceptionType>{},..."})," will bypass a value and only run if there is an exception, the ",(0,a.jsx)(t.code,{children:"ExceptionType"})," template parameter to the tag type allows filtering by exception type; ",(0,a.jsx)(t.code,{children:"tag_t<ExceptionType>{}"})," is optional and if no tag is passed passed the function will be parameterized with a ",(0,a.jsx)(t.code,{children:"melon::exception_wrapper"}),". For C++17 there is a global inline variable and ",(0,a.jsx)(t.code,{children:"melon::tag<ExceptionType>"})," may be passed directly without explicit construction."]}),"\n",(0,a.jsxs)(t.p,{children:["Up to this point we have skirted around the matter of waiting for Futures. You may never need to wait for a Future, because your code is event-driven and all follow-up action happens in a then-block. But if want to have a batch workflow, where you initiate a batch of asynchronous operations and then wait for them all to finish at a synchronization point, then you will want to wait for a Future. Futures have a blocking method called ",(0,a.jsx)(t.code,{children:"wait()"})," that does exactly that and optionally takes a timeout."]}),"\n",(0,a.jsxs)(t.p,{children:["Futures are partially threadsafe. A Promise or Future can migrate between threads as long as there's a full memory barrier of some sort. ",(0,a.jsx)(t.code,{children:"Future::thenValue"})," and ",(0,a.jsx)(t.code,{children:"Promise::setValue"})," (and all variants that boil down to those two calls) can be called from different threads. ",(0,a.jsx)(t.strong,{children:"But"}),", be warned that you might be surprised about which thread your callback executes on. Let's consider an example, where we take a future straight from a promise, without going via the safer SemiFuture, and where we therefore have a ",(0,a.jsx)(t.code,{children:"Future"})," that does not carry an executor. This is in general something to avoid."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cpp",children:"// Thread A\nPromise<Unit> p;\nauto f = p.getFuture();\n\n// Thread B\nstd::move(f).thenValue(x).thenValue(y).thenTry(z);\n\n// Thread A\np.setValue();\n"})}),"\n",(0,a.jsxs)(t.p,{children:["This is legal and technically threadsafe. However, it is important to realize that you do not know in which thread ",(0,a.jsx)(t.code,{children:"x"}),", ",(0,a.jsx)(t.code,{children:"y"}),", and/or ",(0,a.jsx)(t.code,{children:"z"})," will execute. Maybe they will execute in Thread A when ",(0,a.jsx)(t.code,{children:"p.setValue()"})," is called. Or, maybe they will execute in Thread B when ",(0,a.jsx)(t.code,{children:"f.thenValue"})," is called. Or, maybe ",(0,a.jsx)(t.code,{children:"x"})," will execute in Thread A, but ",(0,a.jsx)(t.code,{children:"y"})," and/or ",(0,a.jsx)(t.code,{children:"z"})," will execute in Thread B. There's a race between ",(0,a.jsx)(t.code,{children:"setValue"})," and ",(0,a.jsx)(t.code,{children:"then"}),"\u2014whichever runs last will execute the callback. The only guarantee is that one of them will run the callback."]}),"\n",(0,a.jsxs)(t.p,{children:["For safety, ",(0,a.jsx)(t.code,{children:".via"})," should be preferred. We can chain ",(0,a.jsx)(t.code,{children:".via"})," operations to give very strong control over where callbacks run:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cpp",children:"std::move(aFuture)\n  .thenValue(x)\n  .via(e1).thenValue(y1).thenValue(y2)\n  .via(e2).thenValue(z);\n"})}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"x"})," will execute in the context of the executor associated with ",(0,a.jsx)(t.code,{children:"aFuture"}),". ",(0,a.jsx)(t.code,{children:"y1"})," and ",(0,a.jsx)(t.code,{children:"y2"})," will execute in the context of ",(0,a.jsx)(t.code,{children:"e1"}),", and ",(0,a.jsx)(t.code,{children:"z"})," will execute in the context of ",(0,a.jsx)(t.code,{children:"e2"}),". If after ",(0,a.jsx)(t.code,{children:"z"})," you want to get back to the original context, you need to get there with a call to ",(0,a.jsx)(t.code,{children:"via"})," passing the original executor."]}),"\n",(0,a.jsx)(t.h1,{id:"you-make-me-promises-promises",children:"You make me Promises, Promises"}),"\n",(0,a.jsxs)(t.p,{children:["If you are wrapping an asynchronous operation, or providing an asynchronous API to users, then you will want to make ",(0,a.jsx)(t.code,{children:"Promise"}),"s. Every Future has a corresponding Promise (except Futures that spring into existence already completed, with ",(0,a.jsx)(t.code,{children:"makeFuture()"}),"). Promises are simple: you make one, you extract the Future, and you fulfill it with a value or an exception. Example:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cpp",children:"Promise<int> p;\nSemiFuture<int> f = p.getSemiFuture();\n\nf.isReady() == false\n\np.setValue(42);\n\nf.isReady() == true\nf.value() == 42\n"})}),"\n",(0,a.jsx)(t.p,{children:"and an exception example:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cpp",children:'Promise<int> p;\nSemiFuture<int> f = p.getSemiFuture();\n\nf.isReady() == false\n\np.setException(std::runtime_error("Fail"));\n\nf.isReady() == true\nf.value() // throws the exception\n'})}),"\n",(0,a.jsx)(t.p,{children:"It's good practice to use setWith which takes a function and automatically captures exceptions, e.g."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cpp",children:"Promise<int> p;\np.setWith([]{\n  try {\n    // do stuff that may throw\n    return 42;\n  } catch (MySpecialException const& e) {\n    // handle it\n    return 7;\n  }\n  // Any exceptions that we didn't catch, will be caught for us\n});\n"})})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>o});var r=n(6540);const a={},s=r.createContext(a);function i(e){const t=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);