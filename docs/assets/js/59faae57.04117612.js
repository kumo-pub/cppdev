"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[3764],{2732:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"foundamentals/testing/gt/gmock_cook_book","title":"gMock Cookbook","description":"You can find recipes for using gMock here. If you haven\'t yet, please read","source":"@site/docs/foundamentals/testing/gt/gmock_cook_book.md","sourceDirName":"foundamentals/testing/gt","slug":"/foundamentals/testing/gt/gmock_cook_book","permalink":"/cppdev/docs/foundamentals/testing/gt/gmock_cook_book","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"gMock for Dummies","permalink":"/cppdev/docs/foundamentals/testing/gt/gmock_for_dummies"},"next":{"title":"gMock Cheat Sheet","permalink":"/cppdev/docs/foundamentals/testing/gt/gmock_cheat_sheet"}}');var s=t(4848),i=t(8453);const a={},c="gMock Cookbook",r={},l=[{value:"Creating Mock Classes",id:"creating-mock-classes",level:2},{value:"Dealing with unprotected commas",id:"dealing-with-unprotected-commas",level:3},{value:"Mocking Private or Protected Methods",id:"mocking-private-or-protected-methods",level:3},{value:"Mocking Overloaded Methods",id:"mocking-overloaded-methods",level:3},{value:"Mocking Class Templates",id:"mocking-class-templates",level:3},{value:"Mocking Non-virtual Methods",id:"MockingNonVirtualMethods",level:3},{value:"Mocking Free Functions",id:"mocking-free-functions",level:3},{value:"Old-Style <code>MOCK_METHODn</code> Macros",id:"old-style-mock_methodn-macros",level:3},{value:"The Nice, the Strict, and the Naggy",id:"NiceStrictNaggy",level:3},{value:"Simplifying the Interface without Breaking Existing Code",id:"SimplerInterfaces",level:3},{value:"Alternative to Mocking Concrete Classes",id:"alternative-to-mocking-concrete-classes",level:3},{value:"Delegating Calls to a Fake",id:"DelegatingToFake",level:3},{value:"Delegating Calls to a Real Object",id:"delegating-calls-to-a-real-object",level:3},{value:"Delegating Calls to a Parent Class",id:"delegating-calls-to-a-parent-class",level:3},{value:"Using Matchers",id:"using-matchers",level:2},{value:"Matching Argument Values Exactly",id:"matching-argument-values-exactly",level:3},{value:"Using Simple Matchers",id:"using-simple-matchers",level:3},{value:"Combining Matchers",id:"CombiningMatchers",level:3},{value:"Casting Matchers",id:"SafeMatcherCast",level:3},{value:"Selecting Between Overloaded Functions",id:"SelectOverload",level:3},{value:"Performing Different Actions Based on the Arguments",id:"performing-different-actions-based-on-the-arguments",level:3},{value:"Matching Multiple Arguments as a Whole",id:"matching-multiple-arguments-as-a-whole",level:3},{value:"Using Matchers as Predicates",id:"using-matchers-as-predicates",level:3},{value:"Using Matchers in googletest Assertions",id:"using-matchers-in-googletest-assertions",level:3},{value:"Using Predicates as Matchers",id:"using-predicates-as-matchers",level:3},{value:"Matching Arguments that Are Not Copyable",id:"matching-arguments-that-are-not-copyable",level:3},{value:"Validating a Member of an Object",id:"validating-a-member-of-an-object",level:3},{value:"Validating the Value Pointed to by a Pointer Argument",id:"validating-the-value-pointed-to-by-a-pointer-argument",level:3},{value:"Defining a Custom Matcher Class",id:"CustomMatcherClass",level:3},{value:"Matching Containers",id:"matching-containers",level:3},{value:"Sharing Matchers",id:"sharing-matchers",level:3},{value:"Matchers must have no side-effects",id:"PureMatchers",level:3},{value:"Setting Expectations",id:"setting-expectations",level:2},{value:"Knowing When to Expect",id:"UseOnCall",level:3},{value:"Ignoring Uninteresting Calls",id:"ignoring-uninteresting-calls",level:3},{value:"Disallowing Unexpected Calls",id:"disallowing-unexpected-calls",level:3},{value:"Understanding Uninteresting vs Unexpected Calls",id:"uninteresting-vs-unexpected",level:3},{value:"Ignoring Uninteresting Arguments",id:"ParameterlessExpectations",level:3},{value:"Expecting Ordered Calls",id:"OrderedCalls",level:3},{value:"Expecting Partially Ordered Calls",id:"PartialOrder",level:3},{value:"Controlling When an Expectation Retires",id:"controlling-when-an-expectation-retires",level:3},{value:"Using Actions",id:"using-actions",level:2},{value:"Returning References from Mock Methods",id:"returning-references-from-mock-methods",level:3},{value:"Returning Live Values from Mock Methods",id:"returning-live-values-from-mock-methods",level:3},{value:"Combining Actions",id:"combining-actions",level:3},{value:"Verifying Complex Arguments",id:"SaveArgVerify",level:3},{value:"Mocking Side Effects",id:"mocking-side-effects",level:3},{value:"Changing a Mock Object&#39;s Behavior Based on the State",id:"changing-a-mock-objects-behavior-based-on-the-state",level:3},{value:"Setting the Default Value for a Return Type",id:"DefaultValue",level:3},{value:"Setting the Default Actions for a Mock Method",id:"setting-the-default-actions-for-a-mock-method",level:3},{value:"Using Functions/Methods/Functors/Lambdas as Actions",id:"FunctionsAsActions",level:3},{value:"Using Functions with Extra Info as Actions",id:"using-functions-with-extra-info-as-actions",level:3},{value:"Invoking a Function/Method/Functor/Lambda/Callback Without Arguments",id:"invoking-a-functionmethodfunctorlambdacallback-without-arguments",level:3},{value:"Invoking an Argument of the Mock Function",id:"invoking-an-argument-of-the-mock-function",level:3},{value:"Ignoring an Action&#39;s Result",id:"ignoring-an-actions-result",level:3},{value:"Selecting an Action&#39;s Arguments",id:"SelectingArgs",level:3},{value:"Ignoring Arguments in Action Functions",id:"ignoring-arguments-in-action-functions",level:3},{value:"Sharing Actions",id:"sharing-actions",level:3},{value:"Testing Asynchronous Behavior",id:"testing-asynchronous-behavior",level:3},{value:"Misc Recipes on Using gMock",id:"misc-recipes-on-using-gmock",level:2},{value:"Mocking Methods That Use Move-Only Types",id:"mocking-methods-that-use-move-only-types",level:3},{value:"Legacy workarounds for move-only types",id:"LegacyMoveOnly",level:4},{value:"Making the Compilation Faster",id:"making-the-compilation-faster",level:3},{value:"Forcing a Verification",id:"forcing-a-verification",level:3},{value:"Using Checkpoints",id:"UsingCheckPoints",level:3},{value:"Mocking Destructors",id:"mocking-destructors",level:3},{value:"Using gMock and Threads",id:"UsingThreads",level:3},{value:"Controlling How Much Information gMock Prints",id:"controlling-how-much-information-gmock-prints",level:3},{value:"Gaining Super Vision into Mock Calls",id:"gaining-super-vision-into-mock-calls",level:3},{value:"Running Tests in Emacs",id:"running-tests-in-emacs",level:3},{value:"Extending gMock",id:"extending-gmock",level:2},{value:"Writing New Matchers Quickly",id:"NewMatchers",level:3},{value:"Basic Example",id:"basic-example",level:4},{value:"Adding Custom Failure Messages",id:"adding-custom-failure-messages",level:4},{value:"Using EXPECT_ Statements in Matchers",id:"using-expect_-statements-in-matchers",level:4},{value:"<code>MatchAndExplain</code>",id:"matchandexplain",level:4},{value:"Argument Types",id:"argument-types",level:4},{value:"Writing New Parameterized Matchers Quickly",id:"writing-new-parameterized-matchers-quickly",level:3},{value:"Writing New Monomorphic Matchers",id:"writing-new-monomorphic-matchers",level:3},{value:"Writing New Polymorphic Matchers",id:"writing-new-polymorphic-matchers",level:3},{value:"Legacy Matcher Implementation",id:"legacy-matcher-implementation",level:3},{value:"Implementing Composite Matchers",id:"CompositeMatchers",level:3},{value:"Writing New Cardinalities",id:"writing-new-cardinalities",level:3},{value:"Writing New Actions",id:"QuickNewActions",level:3},{value:"Legacy macro-based Actions",id:"legacy-macro-based-actions",level:4},{value:"Legacy macro-based parameterized Actions",id:"legacy-macro-based-parameterized-actions",level:4},{value:"Restricting the Type of an Argument or Parameter in an ACTION",id:"restricting-the-type-of-an-argument-or-parameter-in-an-action",level:3},{value:"Writing New Action Templates Quickly",id:"writing-new-action-templates-quickly",level:3},{value:"Using the ACTION Object&#39;s Type",id:"using-the-action-objects-type",level:3},{value:"Writing New Monomorphic Actions",id:"new-mono-actions",level:3},{value:"Writing New Polymorphic Actions",id:"NewPolyActions",level:3},{value:"Teaching gMock How to Print Your Values",id:"teaching-gmock-how-to-print-your-values",level:3},{value:"Useful Mocks Created Using gMock",id:"useful-mocks-created-using-gmock",level:2},{value:"Mock std::function",id:"MockFunction",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"gmock-cookbook",children:"gMock Cookbook"})}),"\n",(0,s.jsxs)(n.p,{children:["You can find recipes for using gMock here. If you haven't yet, please read\n",(0,s.jsx)(n.a,{href:"/cppdev/docs/foundamentals/testing/gt/gmock_for_dummies",children:"the dummy guide"})," first to make sure you understand the\nbasics."]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"})," gMock lives in the ",(0,s.jsx)(n.code,{children:"testing"})," name space. For readability, it is\nrecommended to write ",(0,s.jsx)(n.code,{children:"using ::testing::Foo;"})," once in your file before using the\nname ",(0,s.jsx)(n.code,{children:"Foo"})," defined by gMock. We omit such ",(0,s.jsx)(n.code,{children:"using"})," statements in this section for\nbrevity, but you should do it in your own code."]})}),"\n",(0,s.jsx)(n.h2,{id:"creating-mock-classes",children:"Creating Mock Classes"}),"\n",(0,s.jsxs)(n.p,{children:["Mock classes are defined as normal classes, using the ",(0,s.jsx)(n.code,{children:"MOCK_METHOD"})," macro to\ngenerate mocked methods. The macro gets 3 or 4 parameters:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class MyMock {\n public:\n  MOCK_METHOD(ReturnType, MethodName, (Args...));\n  MOCK_METHOD(ReturnType, MethodName, (Args...), (Specs...));\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"The first 3 parameters are simply the method declaration, split into 3 parts.\nThe 4th parameter accepts a closed list of qualifiers, which affect the\ngenerated method:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"const"})})," - Makes the mocked method a ",(0,s.jsx)(n.code,{children:"const"})," method. Required if\noverriding a ",(0,s.jsx)(n.code,{children:"const"})," method."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"override"})})," - Marks the method with ",(0,s.jsx)(n.code,{children:"override"}),". Recommended if overriding\na ",(0,s.jsx)(n.code,{children:"virtual"})," method."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"noexcept"})})," - Marks the method with ",(0,s.jsx)(n.code,{children:"noexcept"}),". Required if overriding a\n",(0,s.jsx)(n.code,{children:"noexcept"})," method."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"Calltype(...)"})})," - Sets the call type for the method (e.g. to\n",(0,s.jsx)(n.code,{children:"STDMETHODCALLTYPE"}),"), useful in Windows."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"ref(...)"})})," - Marks the method with the reference qualification\nspecified. Required if overriding a method that has reference\nqualifications. Eg ",(0,s.jsx)(n.code,{children:"ref(&)"})," or ",(0,s.jsx)(n.code,{children:"ref(&&)"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"dealing-with-unprotected-commas",children:"Dealing with unprotected commas"}),"\n",(0,s.jsxs)(n.p,{children:["Unprotected commas, i.e. commas which are not surrounded by parentheses, prevent\n",(0,s.jsx)(n.code,{children:"MOCK_METHOD"})," from parsing its arguments correctly:"]}),"\n",(0,s.jsx)(n.admonition,{type:"danger",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class MockFoo {\n public:\n  MOCK_METHOD(std::pair<bool, int>, GetPair, ());  // Won't compile!\n  MOCK_METHOD(bool, CheckMap, (std::map<int, double>, bool));  // Won't compile!\n};\n"})})}),"\n",(0,s.jsx)(n.p,{children:"Solution 1 - wrap with parentheses:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class MockFoo {\n public:\n  MOCK_METHOD((std::pair<bool, int>), GetPair, ());\n  MOCK_METHOD(bool, CheckMap, ((std::map<int, double>), bool));\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Note that wrapping a return or argument type with parentheses is, in general,\ninvalid C++. ",(0,s.jsx)(n.code,{children:"MOCK_METHOD"})," removes the parentheses."]}),"\n",(0,s.jsx)(n.p,{children:"Solution 2 - define an alias:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class MockFoo {\n public:\n  using BoolAndInt = std::pair<bool, int>;\n  MOCK_METHOD(BoolAndInt, GetPair, ());\n  using MapIntDouble = std::map<int, double>;\n  MOCK_METHOD(bool, CheckMap, (MapIntDouble, bool));\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"mocking-private-or-protected-methods",children:"Mocking Private or Protected Methods"}),"\n",(0,s.jsxs)(n.p,{children:["You must always put a mock method definition (",(0,s.jsx)(n.code,{children:"MOCK_METHOD"}),") in a ",(0,s.jsx)(n.code,{children:"public:"}),"\nsection of the mock class, regardless of the method being mocked being ",(0,s.jsx)(n.code,{children:"public"}),",\n",(0,s.jsx)(n.code,{children:"protected"}),", or ",(0,s.jsx)(n.code,{children:"private"})," in the base class. This allows ",(0,s.jsx)(n.code,{children:"ON_CALL"})," and\n",(0,s.jsx)(n.code,{children:"EXPECT_CALL"})," to reference the mock function from outside of the mock class.\n(Yes, C++ allows a subclass to change the access level of a virtual function in\nthe base class.) Example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class Foo {\n public:\n  ...\n  virtual bool Transform(Gadget* g) = 0;\n\n protected:\n  virtual void Resume();\n\n private:\n  virtual int GetTimeOut();\n};\n\nclass MockFoo : public Foo {\n public:\n  ...\n  MOCK_METHOD(bool, Transform, (Gadget* g), (override));\n\n  // The following must be in the public section, even though the\n  // methods are protected or private in the base class.\n  MOCK_METHOD(void, Resume, (), (override));\n  MOCK_METHOD(int, GetTimeOut, (), (override));\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"mocking-overloaded-methods",children:"Mocking Overloaded Methods"}),"\n",(0,s.jsx)(n.p,{children:"You can mock overloaded functions as usual. No special attention is required:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class Foo {\n  ...\n\n  // Must be virtual as we'll inherit from Foo.\n  virtual ~Foo();\n\n  // Overloaded on the types and/or numbers of arguments.\n  virtual int Add(Element x);\n  virtual int Add(int times, Element x);\n\n  // Overloaded on the const-ness of this object.\n  virtual Bar& GetBar();\n  virtual const Bar& GetBar() const;\n};\n\nclass MockFoo : public Foo {\n  ...\n  MOCK_METHOD(int, Add, (Element x), (override));\n  MOCK_METHOD(int, Add, (int times, Element x), (override));\n\n  MOCK_METHOD(Bar&, GetBar, (), (override));\n  MOCK_METHOD(const Bar&, GetBar, (), (const, override));\n};\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"})," if you don't mock all versions of the overloaded method, the compiler\nwill give you a warning about some methods in the base class being hidden. To\nfix that, use ",(0,s.jsx)(n.code,{children:"using"})," to bring them in scope:"]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class MockFoo : public Foo {\n  ...\n  using Foo::Add;\n  MOCK_METHOD(int, Add, (Element x), (override));\n  // We don't want to mock int Add(int times, Element x);\n  ...\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"mocking-class-templates",children:"Mocking Class Templates"}),"\n",(0,s.jsx)(n.p,{children:"You can mock class templates just like any class."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"template <typename Elem>\nclass StackInterface {\n  ...\n  // Must be virtual as we'll inherit from StackInterface.\n  virtual ~StackInterface();\n\n  virtual int GetSize() const = 0;\n  virtual void Push(const Elem& x) = 0;\n};\n\ntemplate <typename Elem>\nclass MockStack : public StackInterface<Elem> {\n  ...\n  MOCK_METHOD(int, GetSize, (), (const, override));\n  MOCK_METHOD(void, Push, (const Elem& x), (override));\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"MockingNonVirtualMethods",children:"Mocking Non-virtual Methods"}),"\n",(0,s.jsx)(n.p,{children:"gMock can mock non-virtual functions to be used in Hi-perf dependency injection."}),"\n",(0,s.jsxs)(n.p,{children:["In this case, instead of sharing a common base class with the real class, your\nmock class will be ",(0,s.jsx)(n.em,{children:"unrelated"})," to the real class, but contain methods with the\nsame signatures. The syntax for mocking non-virtual methods is the ",(0,s.jsx)(n.em,{children:"same"})," as\nmocking virtual methods (just don't add ",(0,s.jsx)(n.code,{children:"override"}),"):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// A simple packet stream class.  None of its members is virtual.\nclass ConcretePacketStream {\n public:\n  void AppendPacket(Packet* new_packet);\n  const Packet* GetPacket(size_t packet_number) const;\n  size_t NumberOfPackets() const;\n  ...\n};\n\n// A mock packet stream class.  It inherits from no other, but defines\n// GetPacket() and NumberOfPackets().\nclass MockPacketStream {\n public:\n  MOCK_METHOD(const Packet*, GetPacket, (size_t packet_number), (const));\n  MOCK_METHOD(size_t, NumberOfPackets, (), (const));\n  ...\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Note that the mock class doesn't define ",(0,s.jsx)(n.code,{children:"AppendPacket()"}),", unlike the real class.\nThat's fine as long as the test doesn't need to call it."]}),"\n",(0,s.jsxs)(n.p,{children:["Next, you need a way to say that you want to use ",(0,s.jsx)(n.code,{children:"ConcretePacketStream"})," in\nproduction code, and use ",(0,s.jsx)(n.code,{children:"MockPacketStream"})," in tests. Since the functions are\nnot virtual and the two classes are unrelated, you must specify your choice at\n",(0,s.jsx)(n.em,{children:"compile time"})," (as opposed to run time)."]}),"\n",(0,s.jsxs)(n.p,{children:["One way to do it is to templatize your code that needs to use a packet stream.\nMore specifically, you will give your code a template type argument for the type\nof the packet stream. In production, you will instantiate your template with\n",(0,s.jsx)(n.code,{children:"ConcretePacketStream"})," as the type argument. In tests, you will instantiate the\nsame template with ",(0,s.jsx)(n.code,{children:"MockPacketStream"}),". For example, you may write:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"template <class PacketStream>\nvoid CreateConnection(PacketStream* stream) { ... }\n\ntemplate <class PacketStream>\nclass PacketReader {\n public:\n  void ReadPackets(PacketStream* stream, size_t packet_num);\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Then you can use ",(0,s.jsx)(n.code,{children:"CreateConnection<ConcretePacketStream>()"})," and\n",(0,s.jsx)(n.code,{children:"PacketReader<ConcretePacketStream>"})," in production code, and use\n",(0,s.jsx)(n.code,{children:"CreateConnection<MockPacketStream>()"})," and ",(0,s.jsx)(n.code,{children:"PacketReader<MockPacketStream>"})," in\ntests."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"  MockPacketStream mock_stream;\n  EXPECT_CALL(mock_stream, ...)...;\n  .. set more expectations on mock_stream ...\n  PacketReader<MockPacketStream> reader(&mock_stream);\n  ... exercise reader ...\n"})}),"\n",(0,s.jsx)(n.h3,{id:"mocking-free-functions",children:"Mocking Free Functions"}),"\n",(0,s.jsx)(n.p,{children:"It is not possible to directly mock a free function (i.e. a C-style function or\na static method). If you need to, you can rewrite your code to use an interface\n(abstract class)."}),"\n",(0,s.jsxs)(n.p,{children:["Instead of calling a free function (say, ",(0,s.jsx)(n.code,{children:"OpenFile"}),") directly, introduce an\ninterface for it and have a concrete subclass that calls the free function:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class FileInterface {\n public:\n  ...\n  virtual bool Open(const char* path, const char* mode) = 0;\n};\n\nclass File : public FileInterface {\n public:\n  ...\n  bool Open(const char* path, const char* mode) override {\n     return OpenFile(path, mode);\n  }\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Your code should talk to ",(0,s.jsx)(n.code,{children:"FileInterface"})," to open a file. Now it's easy to mock\nout the function."]}),"\n",(0,s.jsx)(n.p,{children:"This may seem like a lot of hassle, but in practice you often have multiple\nrelated functions that you can put in the same interface, so the per-function\nsyntactic overhead will be much lower."}),"\n",(0,s.jsxs)(n.p,{children:["If you are concerned about the performance overhead incurred by virtual\nfunctions, and profiling confirms your concern, you can combine this with the\nrecipe for ",(0,s.jsx)(n.a,{href:"#MockingNonVirtualMethods",children:"mocking non-virtual methods"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Alternatively, instead of introducing a new interface, you can rewrite your code\nto accept a std::function instead of the free function, and then use\n",(0,s.jsx)(n.a,{href:"#MockFunction",children:"MockFunction"})," to mock the std::function."]}),"\n",(0,s.jsxs)(n.h3,{id:"old-style-mock_methodn-macros",children:["Old-Style ",(0,s.jsx)(n.code,{children:"MOCK_METHODn"})," Macros"]}),"\n",(0,s.jsxs)(n.p,{children:["Before the generic ",(0,s.jsx)(n.code,{children:"MOCK_METHOD"})," macro\n",(0,s.jsx)(n.a,{href:"https://github.com/google/googletest/commit/c5f08bf91944ce1b19bcf414fa1760e69d20afc2",children:"was introduced in 2018"}),",\nmocks where created using a family of macros collectively called ",(0,s.jsx)(n.code,{children:"MOCK_METHODn"}),".\nThese macros are still supported, though migration to the new ",(0,s.jsx)(n.code,{children:"MOCK_METHOD"})," is\nrecommended."]}),"\n",(0,s.jsxs)(n.p,{children:["The macros in the ",(0,s.jsx)(n.code,{children:"MOCK_METHODn"})," family differ from ",(0,s.jsx)(n.code,{children:"MOCK_METHOD"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The general structure is ",(0,s.jsx)(n.code,{children:"MOCK_METHODn(MethodName, ReturnType(Args))"}),",\ninstead of ",(0,s.jsx)(n.code,{children:"MOCK_METHOD(ReturnType, MethodName, (Args))"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["The number ",(0,s.jsx)(n.code,{children:"n"})," must equal the number of arguments."]}),"\n",(0,s.jsxs)(n.li,{children:["When mocking a const method, one must use ",(0,s.jsx)(n.code,{children:"MOCK_CONST_METHODn"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["When mocking a class template, the macro name must be suffixed with ",(0,s.jsx)(n.code,{children:"_T"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["In order to specify the call type, the macro name must be suffixed with\n",(0,s.jsx)(n.code,{children:"_WITH_CALLTYPE"}),", and the call type is the first macro argument."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Old macros and their new equivalents:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"\u5206\u7c7b"}),(0,s.jsx)(n.th,{children:"Old \u8bed\u6cd5"}),(0,s.jsx)(n.th,{children:"New \u8bed\u6cd5"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Simple"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"MOCK_METHOD1(Foo, bool(int))"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"MOCK_METHOD(bool, Foo, (int))"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Const Method"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"MOCK_CONST_METHOD1(Foo, bool(int))"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"MOCK_METHOD(bool, Foo, (int), (const))"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Method in a Class Template"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"MOCK_METHOD1_T(Foo, bool(int))"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"MOCK_METHOD(bool, Foo, (int))"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Const Method in a Class Template"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"MOCK_CONST_METHOD1_T(Foo, bool(int))"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"MOCK_METHOD(bool, Foo, (int), (const))"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Method with Call Type"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"MOCK_METHOD1_WITH_CALLTYPE(STDMETHODCALLTYPE, Foo, bool(int))"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"MOCK_METHOD(bool, Foo, (int), (Calltype(STDMETHODCALLTYPE)))"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Const Method with Call Type"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"MOCK_CONST_METHOD1_WITH_CALLTYPE(STDMETHODCALLTYPE, Foo, bool(int))"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"MOCK_METHOD(bool, Foo, (int), (const, Calltype(STDMETHODCALLTYPE)))"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Method with Call Type in a Class Template"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"MOCK_METHOD1_T_WITH_CALLTYPE(STDMETHODCALLTYPE, Foo, bool(int))"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"MOCK_METHOD(bool, Foo, (int), (Calltype(STDMETHODCALLTYPE)))"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Const Method with Call Type in a Class Template"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"MOCK_CONST_METHOD1_T_WITH_CALLTYPE(STDMETHODCALLTYPE, Foo, bool(int))"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"MOCK_METHOD(bool, Foo, (int), (const, Calltype(STDMETHODCALLTYPE)))"})})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"NiceStrictNaggy",children:"The Nice, the Strict, and the Naggy"}),"\n",(0,s.jsxs)(n.p,{children:["If a mock method has no ",(0,s.jsx)(n.code,{children:"EXPECT_CALL"}),' spec but is called, we say that it\'s an\n"uninteresting call", and the default action (which can be specified using\n',(0,s.jsx)(n.code,{children:"ON_CALL()"}),") of the method will be taken. Currently, an uninteresting call will\nalso by default cause gMock to print a warning."]}),"\n",(0,s.jsx)(n.p,{children:"However, sometimes you may want to ignore these uninteresting calls, and\nsometimes you may want to treat them as errors. gMock lets you make the decision\non a per-mock-object basis."}),"\n",(0,s.jsxs)(n.p,{children:["Suppose your test uses a mock class ",(0,s.jsx)(n.code,{children:"MockFoo"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"TEST(...) {\n  MockFoo mock_foo;\n  EXPECT_CALL(mock_foo, DoThis());\n  ... code that uses mock_foo ...\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If a method of ",(0,s.jsx)(n.code,{children:"mock_foo"})," other than ",(0,s.jsx)(n.code,{children:"DoThis()"})," is called, you will get a\nwarning. However, if you rewrite your test to use ",(0,s.jsx)(n.code,{children:"NiceMock<MockFoo>"})," instead,\nyou can suppress the warning:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::NiceMock;\n\nTEST(...) {\n  NiceMock<MockFoo> mock_foo;\n  EXPECT_CALL(mock_foo, DoThis());\n  ... code that uses mock_foo ...\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"NiceMock<MockFoo>"})," is a subclass of ",(0,s.jsx)(n.code,{children:"MockFoo"}),", so it can be used wherever\n",(0,s.jsx)(n.code,{children:"MockFoo"})," is accepted."]}),"\n",(0,s.jsxs)(n.p,{children:["It also works if ",(0,s.jsx)(n.code,{children:"MockFoo"}),"'s constructor takes some arguments, as\n",(0,s.jsx)(n.code,{children:"NiceMock<MockFoo>"}),' "inherits" ',(0,s.jsx)(n.code,{children:"MockFoo"}),"'s constructors:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'using ::testing::NiceMock;\n\nTEST(...) {\n  NiceMock<MockFoo> mock_foo(5, "hi");  // Calls MockFoo(5, "hi").\n  EXPECT_CALL(mock_foo, DoThis());\n  ... code that uses mock_foo ...\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The usage of ",(0,s.jsx)(n.code,{children:"StrictMock"})," is similar, except that it makes all uninteresting\ncalls failures:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::StrictMock;\n\nTEST(...) {\n  StrictMock<MockFoo> mock_foo;\n  EXPECT_CALL(mock_foo, DoThis());\n  ... code that uses mock_foo ...\n\n  // The test will fail if a method of mock_foo other than DoThis()\n  // is called.\n}\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["NOTE: ",(0,s.jsx)(n.code,{children:"NiceMock"})," and ",(0,s.jsx)(n.code,{children:"StrictMock"})," only affects ",(0,s.jsx)(n.em,{children:"uninteresting"})," calls (calls of\n",(0,s.jsx)(n.em,{children:"methods"})," with no expectations); they do not affect ",(0,s.jsx)(n.em,{children:"unexpected"})," calls (calls of\nmethods with expectations, but they don't match). See\n",(0,s.jsx)(n.a,{href:"#uninteresting-vs-unexpected",children:"Understanding Uninteresting vs Unexpected Calls"}),"."]})}),"\n",(0,s.jsx)(n.p,{children:"There are some caveats though (sadly they are side effects of C++'s\nlimitations):"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"NiceMock<MockFoo>"})," and ",(0,s.jsx)(n.code,{children:"StrictMock<MockFoo>"})," only work for mock methods\ndefined using the ",(0,s.jsx)(n.code,{children:"MOCK_METHOD"})," macro ",(0,s.jsx)(n.strong,{children:"directly"})," in the ",(0,s.jsx)(n.code,{children:"MockFoo"})," class.\nIf a mock method is defined in a ",(0,s.jsx)(n.strong,{children:"base class"})," of ",(0,s.jsx)(n.code,{children:"MockFoo"}),', the "nice" or\n"strict" modifier may not affect it, depending on the compiler. In\nparticular, nesting ',(0,s.jsx)(n.code,{children:"NiceMock"})," and ",(0,s.jsx)(n.code,{children:"StrictMock"})," (e.g.\n",(0,s.jsx)(n.code,{children:"NiceMock<StrictMock<MockFoo> >"}),") is ",(0,s.jsx)(n.strong,{children:"not"})," supported."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"NiceMock<MockFoo>"})," and ",(0,s.jsx)(n.code,{children:"StrictMock<MockFoo>"})," may not work correctly if the\ndestructor of ",(0,s.jsx)(n.code,{children:"MockFoo"})," is not virtual. We would like to fix this, but it\nrequires cleaning up existing tests."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Finally, you should be ",(0,s.jsx)(n.strong,{children:"very cautious"})," about when to use naggy or strict\nmocks, as they tend to make tests more brittle and harder to maintain. When you\nrefactor your code without changing its externally visible behavior, ideally you\nshouldn't need to update any tests. If your code interacts with a naggy mock,\nhowever, you may start to get spammed with warnings as the result of your\nchange. Worse, if your code interacts with a strict mock, your tests may start\nto fail and you'll be forced to fix them. Our general recommendation is to use\nnice mocks (not yet the default) most of the time, use naggy mocks (the current\ndefault) when developing or debugging tests, and use strict mocks only as the\nlast resort."]}),"\n",(0,s.jsx)(n.h3,{id:"SimplerInterfaces",children:"Simplifying the Interface without Breaking Existing Code"}),"\n",(0,s.jsx)(n.p,{children:"Sometimes a method has a long list of arguments that is mostly uninteresting.\nFor example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class LogSink {\n public:\n  ...\n  virtual void send(LogSeverity severity, const char* full_filename,\n                    const char* base_filename, int line,\n                    const struct tm* tm_time,\n                    const char* message, size_t message_len) = 0;\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This method's argument list is lengthy and hard to work with (the ",(0,s.jsx)(n.code,{children:"message"}),"\nargument is not even 0-terminated). If we mock it as is, using the mock will be\nawkward. If, however, we try to simplify this interface, we'll need to fix all\nclients depending on it, which is often infeasible."]}),"\n",(0,s.jsx)(n.p,{children:"The trick is to redispatch the method in the mock class:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class ScopedMockLog : public LogSink {\n public:\n  ...\n  void send(LogSeverity severity, const char* full_filename,\n                    const char* base_filename, int line, const tm* tm_time,\n                    const char* message, size_t message_len) override {\n    // We are only interested in the log severity, full file name, and\n    // log message.\n    Log(severity, full_filename, std::string(message, message_len));\n  }\n\n  // Implements the mock method:\n  //\n  //   void Log(LogSeverity severity,\n  //            const string& file_path,\n  //            const string& message);\n  MOCK_METHOD(void, Log,\n              (LogSeverity severity, const string& file_path,\n               const string& message));\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"By defining a new mock method with a trimmed argument list, we make the mock\nclass more user-friendly."}),"\n",(0,s.jsx)(n.p,{children:"This technique may also be applied to make overloaded methods more amenable to\nmocking. For example, when overloads have been used to implement default\narguments:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class MockTurtleFactory : public TurtleFactory {\n public:\n  Turtle* MakeTurtle(int length, int weight) override { ... }\n  Turtle* MakeTurtle(int length, int weight, int speed) override { ... }\n\n  // the above methods delegate to this one:\n  MOCK_METHOD(Turtle*, DoMakeTurtle, ());\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"This allows tests that don't care which overload was invoked to avoid specifying\nargument matchers:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"ON_CALL(factory, DoMakeTurtle)\n    .WillByDefault(Return(MakeMockTurtle()));\n"})}),"\n",(0,s.jsx)(n.h3,{id:"alternative-to-mocking-concrete-classes",children:"Alternative to Mocking Concrete Classes"}),"\n",(0,s.jsxs)(n.p,{children:["Often you may find yourself using classes that don't implement interfaces. In\norder to test your code that uses such a class (let's call it ",(0,s.jsx)(n.code,{children:"Concrete"}),"), you\nmay be tempted to make the methods of ",(0,s.jsx)(n.code,{children:"Concrete"})," virtual and then mock it."]}),"\n",(0,s.jsx)(n.p,{children:"Try not to do that."}),"\n",(0,s.jsx)(n.p,{children:"Making a non-virtual function virtual is a big decision. It creates an extension\npoint where subclasses can tweak your class' behavior. This weakens your control\non the class because now it's harder to maintain the class invariants. You\nshould make a function virtual only when there is a valid reason for a subclass\nto override it."}),"\n",(0,s.jsx)(n.p,{children:"Mocking concrete classes directly is problematic as it creates a tight coupling\nbetween the class and the tests - any small change in the class may invalidate\nyour tests and make test maintenance a pain."}),"\n",(0,s.jsxs)(n.p,{children:['To avoid such problems, many programmers have been practicing "coding to\ninterfaces": instead of talking to the ',(0,s.jsx)(n.code,{children:"Concrete"})," class, your code would define\nan interface and talk to it. Then you implement that interface as an adaptor on\ntop of ",(0,s.jsx)(n.code,{children:"Concrete"}),". In tests, you can easily mock that interface to observe how\nyour code is doing."]}),"\n",(0,s.jsx)(n.p,{children:"This technique incurs some overhead:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"You pay the cost of virtual function calls (usually not a problem)."}),"\n",(0,s.jsx)(n.li,{children:"There is more abstraction for the programmers to learn."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"However, it can also bring significant benefits in addition to better\ntestability:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Concrete"}),"'s API may not fit your problem domain very well, as you may not\nbe the only client it tries to serve. By designing your own interface, you\nhave a chance to tailor it to your need - you may add higher-level\nfunctionalities, rename stuff, etc instead of just trimming the class. This\nallows you to write your code (user of the interface) in a more natural way,\nwhich means it will be more readable, more maintainable, and you'll be more\nproductive."]}),"\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"Concrete"}),"'s implementation ever has to change, you don't have to rewrite\neverywhere it is used. Instead, you can absorb the change in your\nimplementation of the interface, and your other code and tests will be\ninsulated from this change."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Some people worry that if everyone is practicing this technique, they will end\nup writing lots of redundant code. This concern is totally understandable.\nHowever, there are two reasons why it may not be the case:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Different projects may need to use ",(0,s.jsx)(n.code,{children:"Concrete"})," in different ways, so the best\ninterfaces for them will be different. Therefore, each of them will have its\nown domain-specific interface on top of ",(0,s.jsx)(n.code,{children:"Concrete"}),", and they will not be the\nsame code."]}),"\n",(0,s.jsxs)(n.li,{children:["If enough projects want to use the same interface, they can always share it,\njust like they have been sharing ",(0,s.jsx)(n.code,{children:"Concrete"}),". You can check in the interface\nand the adaptor somewhere near ",(0,s.jsx)(n.code,{children:"Concrete"})," (perhaps in a ",(0,s.jsx)(n.code,{children:"contrib"}),"\nsub-directory) and let many projects use it."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"You need to weigh the pros and cons carefully for your particular problem, but\nI'd like to assure you that the Java community has been practicing this for a\nlong time and it's a proven effective technique applicable in a wide variety of\nsituations. :-)"}),"\n",(0,s.jsx)(n.h3,{id:"DelegatingToFake",children:"Delegating Calls to a Fake"}),"\n",(0,s.jsx)(n.p,{children:"Some times you have a non-trivial fake implementation of an interface. For\nexample:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class Foo {\n public:\n  virtual ~Foo() {}\n  virtual char DoThis(int n) = 0;\n  virtual void DoThat(const char* s, int* p) = 0;\n};\n\nclass FakeFoo : public Foo {\n public:\n  char DoThis(int n) override {\n    return (n > 0) ? '+' :\n           (n < 0) ? '-' : '0';\n  }\n\n  void DoThat(const char* s, int* p) override {\n    *p = strlen(s);\n  }\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Now you want to mock this interface such that you can set expectations on it.\nHowever, you also want to use ",(0,s.jsx)(n.code,{children:"FakeFoo"})," for the default behavior, as duplicating\nit in the mock object is, well, a lot of work."]}),"\n",(0,s.jsx)(n.p,{children:"When you define the mock class using gMock, you can have it delegate its default\naction to a fake class you already have, using this pattern:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class MockFoo : public Foo {\n public:\n  // Normal mock method definitions using gMock.\n  MOCK_METHOD(char, DoThis, (int n), (override));\n  MOCK_METHOD(void, DoThat, (const char* s, int* p), (override));\n\n  // Delegates the default actions of the methods to a FakeFoo object.\n  // This must be called *before* the custom ON_CALL() statements.\n  void DelegateToFake() {\n    ON_CALL(*this, DoThis).WillByDefault([this](int n) {\n      return fake_.DoThis(n);\n    });\n    ON_CALL(*this, DoThat).WillByDefault([this](const char* s, int* p) {\n      fake_.DoThat(s, p);\n    });\n  }\n\n private:\n  FakeFoo fake_;  // Keeps an instance of the fake in the mock.\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["With that, you can use ",(0,s.jsx)(n.code,{children:"MockFoo"})," in your tests as usual. Just remember that if\nyou don't explicitly set an action in an ",(0,s.jsx)(n.code,{children:"ON_CALL()"})," or ",(0,s.jsx)(n.code,{children:"EXPECT_CALL()"}),", the\nfake will be called upon to do it.:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::_;\n\nTEST(AbcTest, Xyz) {\n  MockFoo foo;\n\n  foo.DelegateToFake();  // Enables the fake for delegation.\n\n  // Put your ON_CALL(foo, ...)s here, if any.\n\n  // No action specified, meaning to use the default action.\n  EXPECT_CALL(foo, DoThis(5));\n  EXPECT_CALL(foo, DoThat(_, _));\n\n  int n = 0;\n  EXPECT_EQ(foo.DoThis(5), '+');  // FakeFoo::DoThis() is invoked.\n  foo.DoThat(\"Hi\", &n);  // FakeFoo::DoThat() is invoked.\n  EXPECT_EQ(n, 2);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Some tips:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["If you want, you can still override the default action by providing your own\n",(0,s.jsx)(n.code,{children:"ON_CALL()"})," or using ",(0,s.jsx)(n.code,{children:".WillOnce()"})," / ",(0,s.jsx)(n.code,{children:".WillRepeatedly()"})," in ",(0,s.jsx)(n.code,{children:"EXPECT_CALL()"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["In ",(0,s.jsx)(n.code,{children:"DelegateToFake()"}),", you only need to delegate the methods whose fake\nimplementation you intend to use."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The general technique discussed here works for overloaded methods, but\nyou'll need to tell the compiler which version you mean. To disambiguate a\nmock function (the one you specify inside the parentheses of ",(0,s.jsx)(n.code,{children:"ON_CALL()"}),"),\nuse ",(0,s.jsx)(n.a,{href:"#SelectOverload",children:"this technique"}),"; to disambiguate a fake function (the\none you place inside ",(0,s.jsx)(n.code,{children:"Invoke()"}),"), use a ",(0,s.jsx)(n.code,{children:"static_cast"})," to specify the\nfunction's type. For instance, if class ",(0,s.jsx)(n.code,{children:"Foo"})," has methods ",(0,s.jsx)(n.code,{children:"char DoThis(int n)"})," and ",(0,s.jsx)(n.code,{children:"bool DoThis(double x) const"}),", and you want to invoke the latter,\nyou need to write ",(0,s.jsx)(n.code,{children:"Invoke(&fake_, static_cast<bool (FakeFoo::*)(double) const>(&FakeFoo::DoThis))"})," instead of ",(0,s.jsx)(n.code,{children:"Invoke(&fake_, &FakeFoo::DoThis)"}),"\n(The strange-looking thing inside the angled brackets of ",(0,s.jsx)(n.code,{children:"static_cast"})," is\nthe type of a function pointer to the second ",(0,s.jsx)(n.code,{children:"DoThis()"})," method.)."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Having to mix a mock and a fake is often a sign of something gone wrong.\nPerhaps you haven't got used to the interaction-based way of testing yet. Or\nperhaps your interface is taking on too many roles and should be split up.\nTherefore, ",(0,s.jsx)(n.strong,{children:"don't abuse this"}),". We would only recommend to do it as an\nintermediate step when you are refactoring your code."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Regarding the tip on mixing a mock and a fake, here's an example on why it may\nbe a bad sign: Suppose you have a class ",(0,s.jsx)(n.code,{children:"System"})," for low-level system\noperations. In particular, it does file and I/O operations. And suppose you want\nto test how your code uses ",(0,s.jsx)(n.code,{children:"System"})," to do I/O, and you just want the file\noperations to work normally. If you mock out the entire ",(0,s.jsx)(n.code,{children:"System"})," class, you'll\nhave to provide a fake implementation for the file operation part, which\nsuggests that ",(0,s.jsx)(n.code,{children:"System"})," is taking on too many roles."]}),"\n",(0,s.jsxs)(n.p,{children:["Instead, you can define a ",(0,s.jsx)(n.code,{children:"FileOps"})," interface and an ",(0,s.jsx)(n.code,{children:"IOOps"})," interface and split\n",(0,s.jsx)(n.code,{children:"System"}),"'s functionalities into the two. Then you can mock ",(0,s.jsx)(n.code,{children:"IOOps"})," without\nmocking ",(0,s.jsx)(n.code,{children:"FileOps"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"delegating-calls-to-a-real-object",children:"Delegating Calls to a Real Object"}),"\n",(0,s.jsx)(n.p,{children:"When using testing doubles (mocks, fakes, stubs, and etc), sometimes their\nbehaviors will differ from those of the real objects. This difference could be\neither intentional (as in simulating an error such that you can test the error\nhandling code) or unintentional. If your mocks have different behaviors than the\nreal objects by mistake, you could end up with code that passes the tests but\nfails in production."}),"\n",(0,s.jsxs)(n.p,{children:["You can use the ",(0,s.jsx)(n.em,{children:"delegating-to-real"})," technique to ensure that your mock has the\nsame behavior as the real object while retaining the ability to validate calls.\nThis technique is very similar to the ",(0,s.jsx)(n.a,{href:"#DelegatingToFake",children:"delegating-to-fake"}),"\ntechnique, the difference being that we use a real object instead of a fake.\nHere's an example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'using ::testing::AtLeast;\n\nclass MockFoo : public Foo {\n public:\n  MockFoo() {\n    // By default, all calls are delegated to the real object.\n    ON_CALL(*this, DoThis).WillByDefault([this](int n) {\n      return real_.DoThis(n);\n    });\n    ON_CALL(*this, DoThat).WillByDefault([this](const char* s, int* p) {\n      real_.DoThat(s, p);\n    });\n    ...\n  }\n  MOCK_METHOD(char, DoThis, ...);\n  MOCK_METHOD(void, DoThat, ...);\n  ...\n private:\n  Foo real_;\n};\n\n...\n  MockFoo mock;\n  EXPECT_CALL(mock, DoThis())\n      .Times(3);\n  EXPECT_CALL(mock, DoThat("Hi"))\n      .Times(AtLeast(1));\n  ... use mock in test ...\n'})}),"\n",(0,s.jsx)(n.p,{children:"With this, gMock will verify that your code made the right calls (with the right\narguments, in the right order, called the right number of times, etc), and a\nreal object will answer the calls (so the behavior will be the same as in\nproduction). This gives you the best of both worlds."}),"\n",(0,s.jsx)(n.h3,{id:"delegating-calls-to-a-parent-class",children:"Delegating Calls to a Parent Class"}),"\n",(0,s.jsx)(n.p,{children:"Ideally, you should code to interfaces, whose methods are all pure virtual. In\nreality, sometimes you do need to mock a virtual method that is not pure (i.e,\nit already has an implementation). For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class Foo {\n public:\n  virtual ~Foo();\n\n  virtual void Pure(int n) = 0;\n  virtual int Concrete(const char* str) { ... }\n};\n\nclass MockFoo : public Foo {\n public:\n  // Mocking a pure method.\n  MOCK_METHOD(void, Pure, (int n), (override));\n  // Mocking a concrete method.  Foo::Concrete() is shadowed.\n  MOCK_METHOD(int, Concrete, (const char* str), (override));\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Sometimes you may want to call ",(0,s.jsx)(n.code,{children:"Foo::Concrete()"})," instead of\n",(0,s.jsx)(n.code,{children:"MockFoo::Concrete()"}),". Perhaps you want to do it as part of a stub action, or\nperhaps your test doesn't need to mock ",(0,s.jsx)(n.code,{children:"Concrete()"})," at all (but it would be\noh-so painful to have to define a new mock class whenever you don't need to mock\none of its methods)."]}),"\n",(0,s.jsxs)(n.p,{children:["You can call ",(0,s.jsx)(n.code,{children:"Foo::Concrete()"})," inside an action by:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"...\n  EXPECT_CALL(foo, Concrete).WillOnce([&foo](const char* str) {\n    return foo.Foo::Concrete(str);\n  });\n"})}),"\n",(0,s.jsxs)(n.p,{children:["or tell the mock object that you don't want to mock ",(0,s.jsx)(n.code,{children:"Concrete()"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"...\n  ON_CALL(foo, Concrete).WillByDefault([&foo](const char* str) {\n    return foo.Foo::Concrete(str);\n  });\n"})}),"\n",(0,s.jsxs)(n.p,{children:["(Why don't we just write ",(0,s.jsx)(n.code,{children:"{ return foo.Concrete(str); }"}),"? If you do that,\n",(0,s.jsx)(n.code,{children:"MockFoo::Concrete()"})," will be called (and cause an infinite recursion) since\n",(0,s.jsx)(n.code,{children:"Foo::Concrete()"})," is virtual. That's just how C++ works.)"]}),"\n",(0,s.jsx)(n.h2,{id:"using-matchers",children:"Using Matchers"}),"\n",(0,s.jsx)(n.h3,{id:"matching-argument-values-exactly",children:"Matching Argument Values Exactly"}),"\n",(0,s.jsx)(n.p,{children:"You can specify exactly which arguments a mock method is expecting:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::Return;\n...\n  EXPECT_CALL(foo, DoThis(5))\n      .WillOnce(Return('a'));\n  EXPECT_CALL(foo, DoThat(\"Hello\", bar));\n"})}),"\n",(0,s.jsx)(n.h3,{id:"using-simple-matchers",children:"Using Simple Matchers"}),"\n",(0,s.jsx)(n.p,{children:"You can use matchers to match arguments that have a certain property:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::NotNull;\nusing ::testing::Return;\n...\n  EXPECT_CALL(foo, DoThis(Ge(5)))  // The argument must be >= 5.\n      .WillOnce(Return('a'));\n  EXPECT_CALL(foo, DoThat(\"Hello\", NotNull()));\n      // The second argument must not be NULL.\n"})}),"\n",(0,s.jsxs)(n.p,{children:["A frequently used matcher is ",(0,s.jsx)(n.code,{children:"_"}),", which matches anything:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"  EXPECT_CALL(foo, DoThat(_, NotNull()));\n"})}),"\n",(0,s.jsx)(n.h3,{id:"CombiningMatchers",children:"Combining Matchers"}),"\n",(0,s.jsxs)(n.p,{children:["You can build complex matchers from existing ones using ",(0,s.jsx)(n.code,{children:"AllOf()"}),",\n",(0,s.jsx)(n.code,{children:"AllOfArray()"}),", ",(0,s.jsx)(n.code,{children:"AnyOf()"}),", ",(0,s.jsx)(n.code,{children:"AnyOfArray()"})," and ",(0,s.jsx)(n.code,{children:"Not()"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'using ::testing::AllOf;\nusing ::testing::Gt;\nusing ::testing::HasSubstr;\nusing ::testing::Ne;\nusing ::testing::Not;\n...\n  // The argument must be > 5 and != 10.\n  EXPECT_CALL(foo, DoThis(AllOf(Gt(5),\n                                Ne(10))));\n\n  // The first argument must not contain sub-string "blah".\n  EXPECT_CALL(foo, DoThat(Not(HasSubstr("blah")),\n                          NULL));\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Matchers are function objects, and parametrized matchers can be composed just\nlike any other function. However because their types can be long and rarely\nprovide meaningful information, it can be easier to express them with template\nparameters and ",(0,s.jsx)(n.code,{children:"auto"}),". For example,"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'using ::testing::Contains;\nusing ::testing::Property;\n\ntemplate <typename SubMatcher>\ninline constexpr auto HasFoo(const SubMatcher& sub_matcher) {\n  return Property("foo", &MyClass::foo, Contains(sub_matcher));\n};\n...\n  EXPECT_THAT(x, HasFoo("blah"));\n'})}),"\n",(0,s.jsx)(n.h3,{id:"SafeMatcherCast",children:"Casting Matchers"}),"\n",(0,s.jsxs)(n.p,{children:["gMock matchers are statically typed, meaning that the compiler can catch your\nmistake if you use a matcher of the wrong type (for example, if you use ",(0,s.jsx)(n.code,{children:"Eq(5)"}),"\nto match a ",(0,s.jsx)(n.code,{children:"string"})," argument). Good for you!"]}),"\n",(0,s.jsxs)(n.p,{children:["Sometimes, however, you know what you're doing and want the compiler to give you\nsome slack. One example is that you have a matcher for ",(0,s.jsx)(n.code,{children:"long"})," and the argument\nyou want to match is ",(0,s.jsx)(n.code,{children:"int"}),". While the two types aren't exactly the same, there\nis nothing really wrong with using a ",(0,s.jsx)(n.code,{children:"Matcher<long>"})," to match an ",(0,s.jsx)(n.code,{children:"int"})," - after\nall, we can first convert the ",(0,s.jsx)(n.code,{children:"int"})," argument to a ",(0,s.jsx)(n.code,{children:"long"})," losslessly before\ngiving it to the matcher."]}),"\n",(0,s.jsxs)(n.p,{children:["To support this need, gMock gives you the ",(0,s.jsx)(n.code,{children:"SafeMatcherCast<T>(m)"})," function. It\ncasts a matcher ",(0,s.jsx)(n.code,{children:"m"})," to type ",(0,s.jsx)(n.code,{children:"Matcher<T>"}),". To ensure safety, gMock checks that\n(let ",(0,s.jsx)(n.code,{children:"U"})," be the type ",(0,s.jsx)(n.code,{children:"m"})," accepts :"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Type ",(0,s.jsx)(n.code,{children:"T"})," can be ",(0,s.jsx)(n.em,{children:"implicitly"})," cast to type ",(0,s.jsx)(n.code,{children:"U"}),";"]}),"\n",(0,s.jsxs)(n.li,{children:["When both ",(0,s.jsx)(n.code,{children:"T"})," and ",(0,s.jsx)(n.code,{children:"U"})," are built-in arithmetic types (",(0,s.jsx)(n.code,{children:"bool"}),", integers, and\nfloating-point numbers), the conversion from ",(0,s.jsx)(n.code,{children:"T"})," to ",(0,s.jsx)(n.code,{children:"U"})," is not lossy (in\nother words, any value representable by ",(0,s.jsx)(n.code,{children:"T"})," can also be represented by ",(0,s.jsx)(n.code,{children:"U"}),");\nand"]}),"\n",(0,s.jsxs)(n.li,{children:["When ",(0,s.jsx)(n.code,{children:"U"})," is a non-const reference, ",(0,s.jsx)(n.code,{children:"T"})," must also be a reference (as the\nunderlying matcher may be interested in the address of the ",(0,s.jsx)(n.code,{children:"U"})," value)."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The code won't compile if any of these conditions isn't met."}),"\n",(0,s.jsx)(n.p,{children:"Here's one example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::SafeMatcherCast;\n\n// A base class and a child class.\nclass Base { ... };\nclass Derived : public Base { ... };\n\nclass MockFoo : public Foo {\n public:\n  MOCK_METHOD(void, DoThis, (Derived* derived), (override));\n};\n\n...\n  MockFoo foo;\n  // m is a Matcher<Base*> we got from somewhere.\n  EXPECT_CALL(foo, DoThis(SafeMatcherCast<Derived*>(m)));\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If you find ",(0,s.jsx)(n.code,{children:"SafeMatcherCast<T>(m)"})," too limiting, you can use a similar function\n",(0,s.jsx)(n.code,{children:"MatcherCast<T>(m)"}),". The difference is that ",(0,s.jsx)(n.code,{children:"MatcherCast"})," works as long as you\ncan ",(0,s.jsx)(n.code,{children:"static_cast"})," type ",(0,s.jsx)(n.code,{children:"T"})," to type ",(0,s.jsx)(n.code,{children:"U"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"MatcherCast"})," essentially lets you bypass C++'s type system (",(0,s.jsx)(n.code,{children:"static_cast"})," isn't\nalways safe as it could throw away information, for example), so be careful not\nto misuse/abuse it."]}),"\n",(0,s.jsx)(n.h3,{id:"SelectOverload",children:"Selecting Between Overloaded Functions"}),"\n",(0,s.jsx)(n.p,{children:"If you expect an overloaded function to be called, the compiler may need some\nhelp on which overloaded version it is."}),"\n",(0,s.jsxs)(n.p,{children:["To disambiguate functions overloaded on the const-ness of this object, use the\n",(0,s.jsx)(n.code,{children:"Const()"})," argument wrapper."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::ReturnRef;\n\nclass MockFoo : public Foo {\n  ...\n  MOCK_METHOD(Bar&, GetBar, (), (override));\n  MOCK_METHOD(const Bar&, GetBar, (), (const, override));\n};\n\n...\n  MockFoo foo;\n  Bar bar1, bar2;\n  EXPECT_CALL(foo, GetBar())         // The non-const GetBar().\n      .WillOnce(ReturnRef(bar1));\n  EXPECT_CALL(Const(foo), GetBar())  // The const GetBar().\n      .WillOnce(ReturnRef(bar2));\n"})}),"\n",(0,s.jsxs)(n.p,{children:["(",(0,s.jsx)(n.code,{children:"Const()"})," is defined by gMock and returns a ",(0,s.jsx)(n.code,{children:"const"})," reference to its argument.)"]}),"\n",(0,s.jsxs)(n.p,{children:["To disambiguate overloaded functions with the same number of arguments but\ndifferent argument types, you may need to specify the exact type of a matcher,\neither by wrapping your matcher in ",(0,s.jsx)(n.code,{children:"Matcher<type>()"}),", or using a matcher whose\ntype is fixed (",(0,s.jsx)(n.code,{children:"TypedEq<type>"}),", ",(0,s.jsx)(n.code,{children:"An<type>()"}),", etc):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::An;\nusing ::testing::Matcher;\nusing ::testing::TypedEq;\n\nclass MockPrinter : public Printer {\n public:\n  MOCK_METHOD(void, Print, (int n), (override));\n  MOCK_METHOD(void, Print, (char c), (override));\n};\n\nTEST(PrinterTest, Print) {\n  MockPrinter printer;\n\n  EXPECT_CALL(printer, Print(An<int>()));            // void Print(int);\n  EXPECT_CALL(printer, Print(Matcher<int>(Lt(5))));  // void Print(int);\n  EXPECT_CALL(printer, Print(TypedEq<char>('a')));   // void Print(char);\n\n  printer.Print(3);\n  printer.Print(6);\n  printer.Print('a');\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"performing-different-actions-based-on-the-arguments",children:"Performing Different Actions Based on the Arguments"}),"\n",(0,s.jsxs)(n.p,{children:["When a mock method is called, the ",(0,s.jsx)(n.em,{children:"last"}),' matching expectation that\'s still\nactive will be selected (think "newer overrides older"). So, you can make a\nmethod do different things depending on its argument values like this:']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::_;\nusing ::testing::Lt;\nusing ::testing::Return;\n...\n  // The default case.\n  EXPECT_CALL(foo, DoThis(_))\n      .WillRepeatedly(Return('b'));\n  // The more specific case.\n  EXPECT_CALL(foo, DoThis(Lt(5)))\n      .WillRepeatedly(Return('a'));\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Now, if ",(0,s.jsx)(n.code,{children:"foo.DoThis()"})," is called with a value less than 5, ",(0,s.jsx)(n.code,{children:"'a'"})," will be\nreturned; otherwise ",(0,s.jsx)(n.code,{children:"'b'"})," will be returned."]}),"\n",(0,s.jsx)(n.h3,{id:"matching-multiple-arguments-as-a-whole",children:"Matching Multiple Arguments as a Whole"}),"\n",(0,s.jsxs)(n.p,{children:["Sometimes it's not enough to match the arguments individually. For example, we\nmay want to say that the first argument must be less than the second argument.\nThe ",(0,s.jsx)(n.code,{children:"With()"})," clause allows us to match all arguments of a mock function as a\nwhole. For example,"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::_;\nusing ::testing::Ne;\nusing ::testing::Lt;\n...\n  EXPECT_CALL(foo, InRange(Ne(0), _))\n      .With(Lt());\n"})}),"\n",(0,s.jsxs)(n.p,{children:["says that the first argument of ",(0,s.jsx)(n.code,{children:"InRange()"})," must not be 0, and must be less than\nthe second argument."]}),"\n",(0,s.jsxs)(n.p,{children:["The expression inside ",(0,s.jsx)(n.code,{children:"With()"})," must be a matcher of type ",(0,s.jsx)(n.code,{children:"Matcher<std::tuple<A1, ..., An>>"}),", where ",(0,s.jsx)(n.code,{children:"A1"}),", ..., ",(0,s.jsx)(n.code,{children:"An"})," are the types of the function arguments."]}),"\n",(0,s.jsxs)(n.p,{children:["You can also write ",(0,s.jsx)(n.code,{children:"AllArgs(m)"})," instead of ",(0,s.jsx)(n.code,{children:"m"})," inside ",(0,s.jsx)(n.code,{children:".With()"}),". The two forms\nare equivalent, but ",(0,s.jsx)(n.code,{children:".With(AllArgs(Lt()))"})," is more readable than ",(0,s.jsx)(n.code,{children:".With(Lt())"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["You can use ",(0,s.jsx)(n.code,{children:"Args<k1, ..., kn>(m)"})," to match the ",(0,s.jsx)(n.code,{children:"n"})," selected arguments (as a\ntuple) against ",(0,s.jsx)(n.code,{children:"m"}),". For example,"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::_;\nusing ::testing::AllOf;\nusing ::testing::Args;\nusing ::testing::Lt;\n...\n  EXPECT_CALL(foo, Blah)\n      .With(AllOf(Args<0, 1>(Lt()), Args<1, 2>(Lt())));\n"})}),"\n",(0,s.jsxs)(n.p,{children:["says that ",(0,s.jsx)(n.code,{children:"Blah"})," will be called with arguments ",(0,s.jsx)(n.code,{children:"x"}),", ",(0,s.jsx)(n.code,{children:"y"}),", and ",(0,s.jsx)(n.code,{children:"z"})," where ",(0,s.jsx)(n.code,{children:"x < y < z"}),". Note that in this example, it wasn't necessary to specify the positional\nmatchers."]}),"\n",(0,s.jsxs)(n.p,{children:["As a convenience and example, gMock provides some matchers for 2-tuples,\nincluding the ",(0,s.jsx)(n.code,{children:"Lt()"})," matcher above. See\n",(0,s.jsx)(n.a,{href:"/cppdev/docs/foundamentals/testing/gt/reference/matchers#MultiArgMatchers",children:"Multi-argument Matchers"})," for the\ncomplete list."]}),"\n",(0,s.jsxs)(n.p,{children:["Note that if you want to pass the arguments to a predicate of your own (e.g.\n",(0,s.jsx)(n.code,{children:".With(Args<0, 1>(Truly(&MyPredicate)))"}),"), that predicate MUST be written to\ntake a ",(0,s.jsx)(n.code,{children:"std::tuple"})," as its argument; gMock will pass the ",(0,s.jsx)(n.code,{children:"n"})," selected arguments\nas ",(0,s.jsx)(n.em,{children:"one"})," single tuple to the predicate."]}),"\n",(0,s.jsx)(n.h3,{id:"using-matchers-as-predicates",children:"Using Matchers as Predicates"}),"\n",(0,s.jsxs)(n.p,{children:["Have you noticed that a matcher is just a fancy predicate that also knows how to\ndescribe itself? Many existing algorithms take predicates as arguments (e.g.\nthose defined in STL's ",(0,s.jsx)(n.code,{children:"<algorithm>"})," header), and it would be a shame if gMock\nmatchers were not allowed to participate."]}),"\n",(0,s.jsxs)(n.p,{children:["Luckily, you can use a matcher where a unary predicate functor is expected by\nwrapping it inside the ",(0,s.jsx)(n.code,{children:"Matches()"})," function. For example,"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"#include <algorithm>\n#include <vector>\n\nusing ::testing::Matches;\nusing ::testing::Ge;\n\nvector<int> v;\n...\n// How many elements in v are >= 10?\nconst int count = count_if(v.begin(), v.end(), Matches(Ge(10)));\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Since you can build complex matchers from simpler ones easily using gMock, this\ngives you a way to conveniently construct composite predicates (doing the same\nusing STL's ",(0,s.jsx)(n.code,{children:"<functional>"})," header is just painful). For example, here's a\npredicate that's satisfied by any number that is ",(0,s.jsx)(n.code,{children:">="})," 0, ",(0,s.jsx)(n.code,{children:"<="})," 100, and ",(0,s.jsx)(n.code,{children:"!="})," 50:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::AllOf;\nusing ::testing::Ge;\nusing ::testing::Le;\nusing ::testing::Matches;\nusing ::testing::Ne;\n...\nMatches(AllOf(Ge(0), Le(100), Ne(50)))\n"})}),"\n",(0,s.jsx)(n.h3,{id:"using-matchers-in-googletest-assertions",children:"Using Matchers in googletest Assertions"}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"/cppdev/docs/foundamentals/testing/gt/reference/assertions#EXPECT_THAT",children:(0,s.jsx)(n.code,{children:"EXPECT_THAT"})})," in the Assertions\nReference."]}),"\n",(0,s.jsx)(n.h3,{id:"using-predicates-as-matchers",children:"Using Predicates as Matchers"}),"\n",(0,s.jsxs)(n.p,{children:["gMock provides a set of built-in matchers for matching arguments with expected\nvalues\u2014see the ",(0,s.jsx)(n.a,{href:"/cppdev/docs/foundamentals/testing/gt/reference/matchers",children:"Matchers Reference"})," for more information.\nIn case you find the built-in set lacking, you can use an arbitrary unary\npredicate function or functor as a matcher - as long as the predicate accepts a\nvalue of the type you want. You do this by wrapping the predicate inside the\n",(0,s.jsx)(n.code,{children:"Truly()"})," function, for example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::Truly;\n\nint IsEven(int n) { return (n % 2) == 0 ? 1 : 0; }\n...\n  // Bar() must be called with an even number.\n  EXPECT_CALL(foo, Bar(Truly(IsEven)));\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Note that the predicate function / functor doesn't have to return ",(0,s.jsx)(n.code,{children:"bool"}),". It\nworks as long as the return value can be used as the condition in the statement\n",(0,s.jsx)(n.code,{children:"if (condition) ..."}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"matching-arguments-that-are-not-copyable",children:"Matching Arguments that Are Not Copyable"}),"\n",(0,s.jsxs)(n.p,{children:["When you do an ",(0,s.jsx)(n.code,{children:"EXPECT_CALL(mock_obj, Foo(bar))"}),", gMock saves away a copy of\n",(0,s.jsx)(n.code,{children:"bar"}),". When ",(0,s.jsx)(n.code,{children:"Foo()"})," is called later, gMock compares the argument to ",(0,s.jsx)(n.code,{children:"Foo()"})," with\nthe saved copy of ",(0,s.jsx)(n.code,{children:"bar"}),". This way, you don't need to worry about ",(0,s.jsx)(n.code,{children:"bar"})," being\nmodified or destroyed after the ",(0,s.jsx)(n.code,{children:"EXPECT_CALL()"})," is executed. The same is true\nwhen you use matchers like ",(0,s.jsx)(n.code,{children:"Eq(bar)"}),", ",(0,s.jsx)(n.code,{children:"Le(bar)"}),", and so on."]}),"\n",(0,s.jsxs)(n.p,{children:["But what if ",(0,s.jsx)(n.code,{children:"bar"})," cannot be copied (i.e. has no copy constructor)? You could\ndefine your own matcher function or callback and use it with ",(0,s.jsx)(n.code,{children:"Truly()"}),", as the\nprevious couple of recipes have shown. Or, you may be able to get away from it\nif you can guarantee that ",(0,s.jsx)(n.code,{children:"bar"})," won't be changed after the ",(0,s.jsx)(n.code,{children:"EXPECT_CALL()"})," is\nexecuted. Just tell gMock that it should save a reference to ",(0,s.jsx)(n.code,{children:"bar"}),", instead of a\ncopy of it. Here's how:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::Eq;\nusing ::testing::Lt;\n...\n  // Expects that Foo()'s argument == bar.\n  EXPECT_CALL(mock_obj, Foo(Eq(std::ref(bar))));\n\n  // Expects that Foo()'s argument < bar.\n  EXPECT_CALL(mock_obj, Foo(Lt(std::ref(bar))));\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Remember: if you do this, don't change ",(0,s.jsx)(n.code,{children:"bar"})," after the ",(0,s.jsx)(n.code,{children:"EXPECT_CALL()"}),", or the\nresult is undefined."]}),"\n",(0,s.jsx)(n.h3,{id:"validating-a-member-of-an-object",children:"Validating a Member of an Object"}),"\n",(0,s.jsxs)(n.p,{children:["Often a mock function takes a reference to object as an argument. When matching\nthe argument, you may not want to compare the entire object against a fixed\nobject, as that may be over-specification. Instead, you may need to validate a\ncertain member variable or the result of a certain getter method of the object.\nYou can do this with ",(0,s.jsx)(n.code,{children:"Field()"})," and ",(0,s.jsx)(n.code,{children:"Property()"}),". More specifically,"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"Field(&Foo::bar, m)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["is a matcher that matches a ",(0,s.jsx)(n.code,{children:"Foo"})," object whose ",(0,s.jsx)(n.code,{children:"bar"})," member variable satisfies\nmatcher ",(0,s.jsx)(n.code,{children:"m"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"Property(&Foo::baz, m)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["is a matcher that matches a ",(0,s.jsx)(n.code,{children:"Foo"})," object whose ",(0,s.jsx)(n.code,{children:"baz()"})," method returns a value\nthat satisfies matcher ",(0,s.jsx)(n.code,{children:"m"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"For example:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"Expression"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"Field(&Foo::number, Ge(3))"})}),(0,s.jsxs)(n.td,{style:{textAlign:"left"},children:["Matches ",(0,s.jsx)(n.code,{children:"x"})," where ",(0,s.jsx)(n.code,{children:"x.number >= 3"}),"."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:'Property(&Foo::name,  StartsWith("John "))'})}),(0,s.jsxs)(n.td,{style:{textAlign:"left"},children:["Matches ",(0,s.jsx)(n.code,{children:"x"})," where ",(0,s.jsx)(n.code,{children:"x.name()"})," starts with  ",(0,s.jsx)(n.code,{children:'"John "'}),"."]})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["Note that in ",(0,s.jsx)(n.code,{children:"Property(&Foo::baz, ...)"}),", method ",(0,s.jsx)(n.code,{children:"baz()"})," must take no argument\nand be declared as ",(0,s.jsx)(n.code,{children:"const"}),". Don't use ",(0,s.jsx)(n.code,{children:"Property()"})," against member functions that\nyou do not own, because taking addresses of functions is fragile and generally\nnot part of the contract of the function."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Field()"})," and ",(0,s.jsx)(n.code,{children:"Property()"})," can also match plain pointers to objects. For\ninstance,"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::Field;\nusing ::testing::Ge;\n...\nField(&Foo::number, Ge(3))\n"})}),"\n",(0,s.jsxs)(n.p,{children:["matches a plain pointer ",(0,s.jsx)(n.code,{children:"p"})," where ",(0,s.jsx)(n.code,{children:"p->number >= 3"}),". If ",(0,s.jsx)(n.code,{children:"p"})," is ",(0,s.jsx)(n.code,{children:"NULL"}),", the match\nwill always fail regardless of the inner matcher."]}),"\n",(0,s.jsxs)(n.p,{children:["What if you want to validate more than one members at the same time? Remember\nthat there are ",(0,s.jsxs)(n.a,{href:"#CombiningMatchers",children:[(0,s.jsx)(n.code,{children:"AllOf()"})," and ",(0,s.jsx)(n.code,{children:"AllOfArray()"})]}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Finally ",(0,s.jsx)(n.code,{children:"Field()"})," and ",(0,s.jsx)(n.code,{children:"Property()"})," provide overloads that take the field or\nproperty names as the first argument to include it in the error message. This\ncan be useful when creating combined matchers."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'using ::testing::AllOf;\nusing ::testing::Field;\nusing ::testing::Matcher;\nusing ::testing::SafeMatcherCast;\n\nMatcher<Foo> IsFoo(const Foo& foo) {\n  return AllOf(Field("some_field", &Foo::some_field, foo.some_field),\n               Field("other_field", &Foo::other_field, foo.other_field),\n               Field("last_field", &Foo::last_field, foo.last_field));\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"validating-the-value-pointed-to-by-a-pointer-argument",children:"Validating the Value Pointed to by a Pointer Argument"}),"\n",(0,s.jsxs)(n.p,{children:["C++ functions often take pointers as arguments. You can use matchers like\n",(0,s.jsx)(n.code,{children:"IsNull()"}),", ",(0,s.jsx)(n.code,{children:"NotNull()"}),", and other comparison matchers to match a pointer, but\nwhat if you want to make sure the value ",(0,s.jsx)(n.em,{children:"pointed to"})," by the pointer, instead of\nthe pointer itself, has a certain property? Well, you can use the ",(0,s.jsx)(n.code,{children:"Pointee(m)"}),"\nmatcher."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Pointee(m)"})," matches a pointer if and only if ",(0,s.jsx)(n.code,{children:"m"})," matches the value the pointer\npoints to. For example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::Ge;\nusing ::testing::Pointee;\n...\n  EXPECT_CALL(foo, Bar(Pointee(Ge(3))));\n"})}),"\n",(0,s.jsxs)(n.p,{children:["expects ",(0,s.jsx)(n.code,{children:"foo.Bar()"})," to be called with a pointer that points to a value greater\nthan or equal to 3."]}),"\n",(0,s.jsxs)(n.p,{children:["One nice thing about ",(0,s.jsx)(n.code,{children:"Pointee()"})," is that it treats a ",(0,s.jsx)(n.code,{children:"NULL"})," pointer as a match\nfailure, so you can write ",(0,s.jsx)(n.code,{children:"Pointee(m)"})," instead of"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::AllOf;\nusing ::testing::NotNull;\nusing ::testing::Pointee;\n...\n  AllOf(NotNull(), Pointee(m))\n"})}),"\n",(0,s.jsxs)(n.p,{children:["without worrying that a ",(0,s.jsx)(n.code,{children:"NULL"})," pointer will crash your test."]}),"\n",(0,s.jsxs)(n.p,{children:["Also, did we tell you that ",(0,s.jsx)(n.code,{children:"Pointee()"})," works with both raw pointers ",(0,s.jsx)(n.strong,{children:"and"}),"\nsmart pointers (",(0,s.jsx)(n.code,{children:"std::unique_ptr"}),", ",(0,s.jsx)(n.code,{children:"std::shared_ptr"}),", etc)?"]}),"\n",(0,s.jsxs)(n.p,{children:["What if you have a pointer to pointer? You guessed it - you can use nested\n",(0,s.jsx)(n.code,{children:"Pointee()"})," to probe deeper inside the value. For example,\n",(0,s.jsx)(n.code,{children:"Pointee(Pointee(Lt(3)))"})," matches a pointer that points to a pointer that points\nto a number less than 3 (what a mouthful...)."]}),"\n",(0,s.jsx)(n.h3,{id:"CustomMatcherClass",children:"Defining a Custom Matcher Class"}),"\n",(0,s.jsxs)(n.p,{children:["Most matchers can be simply defined using ",(0,s.jsx)(n.a,{href:"#NewMatchers",children:"the MATCHER* macros"}),",\nwhich are terse and flexible, and produce good error messages. However, these\nmacros are not very explicit about the interfaces they create and are not always\nsuitable, especially for matchers that will be widely reused."]}),"\n",(0,s.jsx)(n.p,{children:"For more advanced cases, you may need to define your own matcher class. A custom\nmatcher allows you to test a specific invariant property of that object. Let's\ntake a look at how to do so."}),"\n",(0,s.jsxs)(n.p,{children:["Imagine you have a mock function that takes an object of type ",(0,s.jsx)(n.code,{children:"Foo"}),", which has\nan ",(0,s.jsx)(n.code,{children:"int bar()"})," method and an ",(0,s.jsx)(n.code,{children:"int baz()"})," method. You want to constrain that the\nargument's ",(0,s.jsx)(n.code,{children:"bar()"})," value plus its ",(0,s.jsx)(n.code,{children:"baz()"})," value is a given number. (This is an\ninvariant.) Here's how we can write and use a matcher class to do so:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'class BarPlusBazEqMatcher {\n public:\n  using is_gtest_matcher = void;\n\n  explicit BarPlusBazEqMatcher(int expected_sum)\n      : expected_sum_(expected_sum) {}\n\n  bool MatchAndExplain(const Foo& foo,\n                       std::ostream* /* listener */) const {\n    return (foo.bar() + foo.baz()) == expected_sum_;\n  }\n\n  void DescribeTo(std::ostream* os) const {\n    *os << "bar() + baz() equals " << expected_sum_;\n  }\n\n  void DescribeNegationTo(std::ostream* os) const {\n    *os << "bar() + baz() does not equal " << expected_sum_;\n  }\n private:\n  const int expected_sum_;\n};\n\n::testing::Matcher<const Foo&> BarPlusBazEq(int expected_sum) {\n  return BarPlusBazEqMatcher(expected_sum);\n}\n\n...\n  Foo foo;\n  EXPECT_THAT(foo, BarPlusBazEq(5))...;\n'})}),"\n",(0,s.jsx)(n.h3,{id:"matching-containers",children:"Matching Containers"}),"\n",(0,s.jsxs)(n.p,{children:["Sometimes an STL container (e.g. list, vector, map, ...) is passed to a mock\nfunction and you may want to validate it. Since most STL containers support the\n",(0,s.jsx)(n.code,{children:"=="})," operator, you can write ",(0,s.jsx)(n.code,{children:"Eq(expected_container)"})," or simply\n",(0,s.jsx)(n.code,{children:"expected_container"})," to match a container exactly."]}),"\n",(0,s.jsx)(n.p,{children:"Sometimes, though, you may want to be more flexible (for example, the first\nelement must be an exact match, but the second element can be any positive\nnumber, and so on). Also, containers used in tests often have a small number of\nelements, and having to define the expected container out-of-line is a bit of a\nhassle."}),"\n",(0,s.jsxs)(n.p,{children:["You can use the ",(0,s.jsx)(n.code,{children:"ElementsAre()"})," or ",(0,s.jsx)(n.code,{children:"UnorderedElementsAre()"})," matcher in such\ncases:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::_;\nusing ::testing::ElementsAre;\nusing ::testing::Gt;\n...\n  MOCK_METHOD(void, Foo, (const vector<int>& numbers), (override));\n...\n  EXPECT_CALL(mock, Foo(ElementsAre(1, Gt(0), _, 5)));\n"})}),"\n",(0,s.jsx)(n.p,{children:"The above matcher says that the container must have 4 elements, which must be 1,\ngreater than 0, anything, and 5 respectively."}),"\n",(0,s.jsx)(n.p,{children:"If you instead write:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::_;\nusing ::testing::Gt;\nusing ::testing::UnorderedElementsAre;\n...\n  MOCK_METHOD(void, Foo, (const vector<int>& numbers), (override));\n...\n  EXPECT_CALL(mock, Foo(UnorderedElementsAre(1, Gt(0), _, 5)));\n"})}),"\n",(0,s.jsx)(n.p,{children:"It means that the container must have 4 elements, which (under some permutation)\nmust be 1, greater than 0, anything, and 5 respectively."}),"\n",(0,s.jsxs)(n.p,{children:["As an alternative you can place the arguments in a C-style array and use\n",(0,s.jsx)(n.code,{children:"ElementsAreArray()"})," or ",(0,s.jsx)(n.code,{children:"UnorderedElementsAreArray()"})," instead:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::ElementsAreArray;\n...\n  // ElementsAreArray accepts an array of element values.\n  const int expected_vector1[] = {1, 5, 2, 4, ...};\n  EXPECT_CALL(mock, Foo(ElementsAreArray(expected_vector1)));\n\n  // Or, an array of element matchers.\n  Matcher<int> expected_vector2[] = {1, Gt(2), _, 3, ...};\n  EXPECT_CALL(mock, Foo(ElementsAreArray(expected_vector2)));\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In case the array needs to be dynamically created (and therefore the array size\ncannot be inferred by the compiler), you can give ",(0,s.jsx)(n.code,{children:"ElementsAreArray()"})," an\nadditional argument to specify the array size:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::ElementsAreArray;\n...\n  int* const expected_vector3 = new int[count];\n  ... fill expected_vector3 with values ...\n  EXPECT_CALL(mock, Foo(ElementsAreArray(expected_vector3, count)));\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"Pair"})," when comparing maps or other associative containers."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'using ::testing::UnorderedElementsAre;\nusing ::testing::Pair;\n...\n  absl::flat_hash_map<string, int> m = {{"a", 1}, {"b", 2}, {"c", 3}};\n  EXPECT_THAT(m, UnorderedElementsAre(\n      Pair("a", 1), Pair("b", 2), Pair("c", 3)));\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Tips:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ElementsAre*()"})," can be used to match ",(0,s.jsx)(n.em,{children:"any"})," container that implements the\nSTL iterator pattern (i.e. it has a ",(0,s.jsx)(n.code,{children:"const_iterator"})," type and supports\n",(0,s.jsx)(n.code,{children:"begin()/end()"}),"), not just the ones defined in STL. It will even work with\ncontainer types yet to be written - as long as they follows the above\npattern."]}),"\n",(0,s.jsxs)(n.li,{children:["You can use nested ",(0,s.jsx)(n.code,{children:"ElementsAre*()"})," to match nested (multi-dimensional)\ncontainers."]}),"\n",(0,s.jsxs)(n.li,{children:["If the container is passed by pointer instead of by reference, just write\n",(0,s.jsx)(n.code,{children:"Pointee(ElementsAre*(...))"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["The order of elements ",(0,s.jsx)(n.em,{children:"matters"})," for ",(0,s.jsx)(n.code,{children:"ElementsAre*()"}),". If you are using it\nwith containers whose element order are undefined (such as a\n",(0,s.jsx)(n.code,{children:"std::unordered_map"}),") you should use ",(0,s.jsx)(n.code,{children:"UnorderedElementsAre"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"sharing-matchers",children:"Sharing Matchers"}),"\n",(0,s.jsx)(n.p,{children:"Under the hood, a gMock matcher object consists of a pointer to a ref-counted\nimplementation object. Copying matchers is allowed and very efficient, as only\nthe pointer is copied. When the last matcher that references the implementation\nobject dies, the implementation object will be deleted."}),"\n",(0,s.jsx)(n.p,{children:"Therefore, if you have some complex matcher that you want to use again and\nagain, there is no need to build it every time. Just assign it to a matcher\nvariable and use that variable repeatedly! For example,"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::AllOf;\nusing ::testing::Gt;\nusing ::testing::Le;\nusing ::testing::Matcher;\n...\n  Matcher<int> in_range = AllOf(Gt(5), Le(10));\n  ... use in_range as a matcher in multiple EXPECT_CALLs ...\n"})}),"\n",(0,s.jsx)(n.h3,{id:"PureMatchers",children:"Matchers must have no side-effects"}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsxs)(n.p,{children:["WARNING: gMock does not guarantee when or how many times a matcher will be\ninvoked. Therefore, all matchers must be ",(0,s.jsx)(n.em,{children:"purely functional"}),": they cannot have\nany side effects, and the match result must not depend on anything other than\nthe matcher's parameters and the value being matched."]})}),"\n",(0,s.jsx)(n.p,{children:"This requirement must be satisfied no matter how a matcher is defined (e.g., if\nit is one of the standard matchers, or a custom matcher). In particular, a\nmatcher can never call a mock function, as that will affect the state of the\nmock object and gMock."}),"\n",(0,s.jsx)(n.h2,{id:"setting-expectations",children:"Setting Expectations"}),"\n",(0,s.jsx)(n.h3,{id:"UseOnCall",children:"Knowing When to Expect"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"ON_CALL"})})," is likely the ",(0,s.jsx)(n.em,{children:"single most under-utilized construct"})," in gMock."]}),"\n",(0,s.jsxs)(n.p,{children:["There are basically two constructs for defining the behavior of a mock object:\n",(0,s.jsx)(n.code,{children:"ON_CALL"})," and ",(0,s.jsx)(n.code,{children:"EXPECT_CALL"}),". The difference? ",(0,s.jsx)(n.code,{children:"ON_CALL"})," defines what happens when\na mock method is called, but doesn't imply any expectation on the method\nbeing called. ",(0,s.jsx)(n.code,{children:"EXPECT_CALL"})," not only defines the behavior, but also sets an\nexpectation that the method will be called with the given arguments, for the\ngiven number of times (and ",(0,s.jsx)(n.em,{children:"in the given order"})," when you specify the order\ntoo)."]}),"\n",(0,s.jsxs)(n.p,{children:["Since ",(0,s.jsx)(n.code,{children:"EXPECT_CALL"})," does more, isn't it better than ",(0,s.jsx)(n.code,{children:"ON_CALL"}),"? Not really. Every\n",(0,s.jsx)(n.code,{children:"EXPECT_CALL"})," adds a constraint on the behavior of the code under test. Having\nmore constraints than necessary is ",(0,s.jsx)(n.em,{children:"baaad"})," - even worse than not having enough\nconstraints."]}),"\n",(0,s.jsx)(n.p,{children:"This may be counter-intuitive. How could tests that verify more be worse than\ntests that verify less? Isn't verification the whole point of tests?"}),"\n",(0,s.jsxs)(n.p,{children:["The answer lies in ",(0,s.jsx)(n.em,{children:"what"})," a test should verify. ",(0,s.jsx)(n.strong,{children:"A good test verifies the\ncontract of the code."})," If a test over-specifies, it doesn't leave enough\nfreedom to the implementation. As a result, changing the implementation without\nbreaking the contract (e.g. refactoring and optimization), which should be\nperfectly fine to do, can break such tests. Then you have to spend time fixing\nthem, only to see them broken again the next time the implementation is changed."]}),"\n",(0,s.jsxs)(n.p,{children:["Keep in mind that one doesn't have to verify more than one property in one test.\nIn fact, ",(0,s.jsx)(n.strong,{children:"it's a good style to verify only one thing in one test."})," If you do\nthat, a bug will likely break only one or two tests instead of dozens (which\ncase would you rather debug?). If you are also in the habit of giving tests\ndescriptive names that tell what they verify, you can often easily guess what's\nwrong just from the test log itself."]}),"\n",(0,s.jsxs)(n.p,{children:["So use ",(0,s.jsx)(n.code,{children:"ON_CALL"})," by default, and only use ",(0,s.jsx)(n.code,{children:"EXPECT_CALL"})," when you actually intend\nto verify that the call is made. For example, you may have a bunch of ",(0,s.jsx)(n.code,{children:"ON_CALL"}),"s\nin your test fixture to set the common mock behavior shared by all tests in the\nsame group, and write (scarcely) different ",(0,s.jsx)(n.code,{children:"EXPECT_CALL"}),"s in different ",(0,s.jsx)(n.code,{children:"TEST_F"}),"s\nto verify different aspects of the code's behavior. Compared with the style\nwhere each ",(0,s.jsx)(n.code,{children:"TEST"})," has many ",(0,s.jsx)(n.code,{children:"EXPECT_CALL"}),"s, this leads to tests that are more\nresilient to implementational changes (and thus less likely to require\nmaintenance) and makes the intent of the tests more obvious (so they are easier\nto maintain when you do need to maintain them)."]}),"\n",(0,s.jsxs)(n.p,{children:['If you are bothered by the "Uninteresting mock function call" message printed\nwhen a mock method without an ',(0,s.jsx)(n.code,{children:"EXPECT_CALL"})," is called, you may use a ",(0,s.jsx)(n.code,{children:"NiceMock"}),"\ninstead to suppress all such messages for the mock object, or suppress the\nmessage for specific methods by adding ",(0,s.jsx)(n.code,{children:"EXPECT_CALL(...).Times(AnyNumber())"}),". DO\nNOT suppress it by blindly adding an ",(0,s.jsx)(n.code,{children:"EXPECT_CALL(...)"}),", or you'll have a test\nthat's a pain to maintain."]}),"\n",(0,s.jsx)(n.h3,{id:"ignoring-uninteresting-calls",children:"Ignoring Uninteresting Calls"}),"\n",(0,s.jsxs)(n.p,{children:["If you are not interested in how a mock method is called, just don't say\nanything about it. In this case, if the method is ever called, gMock will\nperform its default action to allow the test program to continue. If you are not\nhappy with the default action taken by gMock, you can override it using\n",(0,s.jsx)(n.code,{children:"DefaultValue<T>::Set()"})," (described ",(0,s.jsx)(n.a,{href:"#DefaultValue",children:"here"}),") or ",(0,s.jsx)(n.code,{children:"ON_CALL()"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Please note that once you expressed interest in a particular mock method (via\n",(0,s.jsx)(n.code,{children:"EXPECT_CALL()"}),"), all invocations to it must match some expectation. If this\nfunction is called but the arguments don't match any ",(0,s.jsx)(n.code,{children:"EXPECT_CALL()"})," statement,\nit will be an error."]}),"\n",(0,s.jsx)(n.h3,{id:"disallowing-unexpected-calls",children:"Disallowing Unexpected Calls"}),"\n",(0,s.jsx)(n.p,{children:"If a mock method shouldn't be called at all, explicitly say so:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::_;\n...\n  EXPECT_CALL(foo, Bar(_))\n      .Times(0);\n"})}),"\n",(0,s.jsx)(n.p,{children:"If some calls to the method are allowed, but the rest are not, just list all the\nexpected calls:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::AnyNumber;\nusing ::testing::Gt;\n...\n  EXPECT_CALL(foo, Bar(5));\n  EXPECT_CALL(foo, Bar(Gt(10)))\n      .Times(AnyNumber());\n"})}),"\n",(0,s.jsxs)(n.p,{children:["A call to ",(0,s.jsx)(n.code,{children:"foo.Bar()"})," that doesn't match any of the ",(0,s.jsx)(n.code,{children:"EXPECT_CALL()"})," statements\nwill be an error."]}),"\n",(0,s.jsx)(n.h3,{id:"uninteresting-vs-unexpected",children:"Understanding Uninteresting vs Unexpected Calls"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Uninteresting"})," calls and ",(0,s.jsx)(n.em,{children:"unexpected"})," calls are different concepts in gMock.\n",(0,s.jsx)(n.em,{children:"Very"})," different."]}),"\n",(0,s.jsxs)(n.p,{children:["A call ",(0,s.jsx)(n.code,{children:"x.Y(...)"})," is ",(0,s.jsx)(n.strong,{children:"uninteresting"})," if there's ",(0,s.jsx)(n.em,{children:"not even a single"}),"\n",(0,s.jsx)(n.code,{children:"EXPECT_CALL(x, Y(...))"})," set. In other words, the test isn't interested in the\n",(0,s.jsx)(n.code,{children:"x.Y()"})," method at all, as evident in that the test doesn't care to say anything\nabout it."]}),"\n",(0,s.jsxs)(n.p,{children:["A call ",(0,s.jsx)(n.code,{children:"x.Y(...)"})," is ",(0,s.jsx)(n.strong,{children:"unexpected"})," if there are ",(0,s.jsx)(n.em,{children:"some"})," ",(0,s.jsx)(n.code,{children:"EXPECT_CALL(x, Y(...))"}),"s set, but none of them matches the call. Put another way, the test is\ninterested in the ",(0,s.jsx)(n.code,{children:"x.Y()"})," method (therefore it explicitly sets some\n",(0,s.jsx)(n.code,{children:"EXPECT_CALL"})," to verify how it's called); however, the verification fails as the\ntest doesn't expect this particular call to happen."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"An unexpected call is always an error,"})," as the code under test doesn't behave\nthe way the test expects it to behave."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"By default, an uninteresting call is not an error,"})," as it violates no\nconstraint specified by the test. (gMock's philosophy is that saying nothing\nmeans there is no constraint.) However, it leads to a warning, as it ",(0,s.jsx)(n.em,{children:"might"}),"\nindicate a problem (e.g. the test author might have forgotten to specify a\nconstraint)."]}),"\n",(0,s.jsxs)(n.p,{children:["In gMock, ",(0,s.jsx)(n.code,{children:"NiceMock"})," and ",(0,s.jsx)(n.code,{children:"StrictMock"}),' can be used to make a mock class "nice" or\n"strict". How does this affect uninteresting calls and unexpected calls?']}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.strong,{children:"nice mock"})," suppresses uninteresting call ",(0,s.jsx)(n.em,{children:"warnings"}),". It is less chatty than\nthe default mock, but otherwise is the same. If a test fails with a default\nmock, it will also fail using a nice mock instead. And vice versa. Don't expect\nmaking a mock nice to change the test's result."]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.strong,{children:"strict mock"})," turns uninteresting call warnings into errors. So making a\nmock strict may change the test's result."]}),"\n",(0,s.jsx)(n.p,{children:"Let's look at an example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'TEST(...) {\n  NiceMock<MockDomainRegistry> mock_registry;\n  EXPECT_CALL(mock_registry, GetDomainOwner("google.com"))\n          .WillRepeatedly(Return("Larry Page"));\n\n  // Use mock_registry in code under test.\n  ... &mock_registry ...\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The sole ",(0,s.jsx)(n.code,{children:"EXPECT_CALL"})," here says that all calls to ",(0,s.jsx)(n.code,{children:"GetDomainOwner()"})," must have\n",(0,s.jsx)(n.code,{children:'"google.com"'})," as the argument. If ",(0,s.jsx)(n.code,{children:'GetDomainOwner("yahoo.com")'})," is called, it\nwill be an unexpected call, and thus an error. ",(0,s.jsx)(n.em,{children:"Having a nice mock doesn't\nchange the severity of an unexpected call."})]}),"\n",(0,s.jsxs)(n.p,{children:["So how do we tell gMock that ",(0,s.jsx)(n.code,{children:"GetDomainOwner()"}),' can be called with some other\narguments as well? The standard technique is to add a "catch all" ',(0,s.jsx)(n.code,{children:"EXPECT_CALL"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'  EXPECT_CALL(mock_registry, GetDomainOwner(_))\n        .Times(AnyNumber());  // catches all other calls to this method.\n  EXPECT_CALL(mock_registry, GetDomainOwner("google.com"))\n        .WillRepeatedly(Return("Larry Page"));\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Remember that ",(0,s.jsx)(n.code,{children:"_"})," is the wildcard matcher that matches anything. With this, if\n",(0,s.jsx)(n.code,{children:'GetDomainOwner("google.com")'})," is called, it will do what the second\n",(0,s.jsx)(n.code,{children:"EXPECT_CALL"})," says; if it is called with a different argument, it will do what\nthe first ",(0,s.jsx)(n.code,{children:"EXPECT_CALL"})," says."]}),"\n",(0,s.jsxs)(n.p,{children:["Note that the order of the two ",(0,s.jsx)(n.code,{children:"EXPECT_CALL"}),"s is important, as a newer\n",(0,s.jsx)(n.code,{children:"EXPECT_CALL"})," takes precedence over an older one."]}),"\n",(0,s.jsxs)(n.p,{children:["For more on uninteresting calls, nice mocks, and strict mocks, read\n",(0,s.jsx)(n.a,{href:"#NiceStrictNaggy",children:'"The Nice, the Strict, and the Naggy"'}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"ParameterlessExpectations",children:"Ignoring Uninteresting Arguments"}),"\n",(0,s.jsx)(n.p,{children:"If your test doesn't care about the parameters (it only cares about the number\nor order of calls), you can often simply omit the parameter list:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"  // Expect foo.Bar( ... ) twice with any arguments.\n  EXPECT_CALL(foo, Bar).Times(2);\n\n  // Delegate to the given method whenever the factory is invoked.\n  ON_CALL(foo_factory, MakeFoo)\n      .WillByDefault(&BuildFooForTest);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This functionality is only available when a method is not overloaded; to prevent\nunexpected behavior it is a compilation error to try to set an expectation on a\nmethod where the specific overload is ambiguous. You can work around this by\nsupplying a ",(0,s.jsx)(n.a,{href:"#SimplerInterfaces",children:"simpler mock interface"})," than the mocked class\nprovides."]}),"\n",(0,s.jsxs)(n.p,{children:["This pattern is also useful when the arguments are interesting, but match logic\nis substantially complex. You can leave the argument list unspecified and use\nSaveArg actions to ",(0,s.jsx)(n.a,{href:"#SaveArgVerify",children:"save the values for later verification"}),". If\nyou do that, you can easily differentiate calling the method the wrong number of\ntimes from calling it with the wrong arguments."]}),"\n",(0,s.jsx)(n.h3,{id:"OrderedCalls",children:"Expecting Ordered Calls"}),"\n",(0,s.jsxs)(n.p,{children:["Although an ",(0,s.jsx)(n.code,{children:"EXPECT_CALL()"})," statement defined later takes precedence when gMock\ntries to match a function call with an expectation, by default calls don't have\nto happen in the order ",(0,s.jsx)(n.code,{children:"EXPECT_CALL()"})," statements are written. For example, if\nthe arguments match the matchers in the second ",(0,s.jsx)(n.code,{children:"EXPECT_CALL()"}),", but not those in\nthe first and third, then the second expectation will be used."]}),"\n",(0,s.jsxs)(n.p,{children:["If you would rather have all calls occur in the order of the expectations, put\nthe ",(0,s.jsx)(n.code,{children:"EXPECT_CALL()"})," statements in a block where you define a variable of type\n",(0,s.jsx)(n.code,{children:"InSequence"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::_;\nusing ::testing::InSequence;\n\n  {\n    InSequence s;\n\n    EXPECT_CALL(foo, DoThis(5));\n    EXPECT_CALL(bar, DoThat(_))\n        .Times(2);\n    EXPECT_CALL(foo, DoThis(6));\n  }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In this example, we expect a call to ",(0,s.jsx)(n.code,{children:"foo.DoThis(5)"}),", followed by two calls to\n",(0,s.jsx)(n.code,{children:"bar.DoThat()"})," where the argument can be anything, which are in turn followed by\na call to ",(0,s.jsx)(n.code,{children:"foo.DoThis(6)"}),". If a call occurred out-of-order, gMock will report an\nerror."]}),"\n",(0,s.jsx)(n.h3,{id:"PartialOrder",children:"Expecting Partially Ordered Calls"}),"\n",(0,s.jsxs)(n.p,{children:["Sometimes requiring everything to occur in a predetermined order can lead to\nbrittle tests. For example, we may care about ",(0,s.jsx)(n.code,{children:"A"})," occurring before both ",(0,s.jsx)(n.code,{children:"B"})," and\n",(0,s.jsx)(n.code,{children:"C"}),", but aren't interested in the relative order of ",(0,s.jsx)(n.code,{children:"B"})," and ",(0,s.jsx)(n.code,{children:"C"}),". In this case,\nthe test should reflect our real intent, instead of being overly constraining."]}),"\n",(0,s.jsxs)(n.p,{children:["gMock allows you to impose an arbitrary DAG (directed acyclic graph) on the\ncalls. One way to express the DAG is to use the\n",(0,s.jsxs)(n.a,{href:"/cppdev/docs/foundamentals/testing/gt/reference/mocking#EXPECT_CALL.After",children:[(0,s.jsx)(n.code,{children:"After"})," clause"]})," of ",(0,s.jsx)(n.code,{children:"EXPECT_CALL"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Another way is via the ",(0,s.jsx)(n.code,{children:"InSequence()"})," clause (not the same as the ",(0,s.jsx)(n.code,{children:"InSequence"}),"\nclass), which we borrowed from jMock 2. It's less flexible than ",(0,s.jsx)(n.code,{children:"After()"}),", but\nmore convenient when you have long chains of sequential calls, as it doesn't\nrequire you to come up with different names for the expectations in the chains.\nHere's how it works:"]}),"\n",(0,s.jsxs)(n.p,{children:["If we view ",(0,s.jsx)(n.code,{children:"EXPECT_CALL()"}),' statements as nodes in a graph, and add an edge from\nnode A to node B wherever A must occur before B, we can get a DAG. We use the\nterm "sequence" to mean a directed path in this DAG. Now, if we decompose the\nDAG into sequences, we just need to know which sequences each ',(0,s.jsx)(n.code,{children:"EXPECT_CALL()"}),"\nbelongs to in order to be able to reconstruct the original DAG."]}),"\n",(0,s.jsxs)(n.p,{children:["So, to specify the partial order on the expectations we need to do two things:\nfirst to define some ",(0,s.jsx)(n.code,{children:"Sequence"})," objects, and then for each ",(0,s.jsx)(n.code,{children:"EXPECT_CALL()"})," say\nwhich ",(0,s.jsx)(n.code,{children:"Sequence"})," objects it is part of."]}),"\n",(0,s.jsx)(n.p,{children:"Expectations in the same sequence must occur in the order they are written. For\nexample,"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::Sequence;\n...\n  Sequence s1, s2;\n\n  EXPECT_CALL(foo, A())\n      .InSequence(s1, s2);\n  EXPECT_CALL(bar, B())\n      .InSequence(s1);\n  EXPECT_CALL(bar, C())\n      .InSequence(s2);\n  EXPECT_CALL(foo, D())\n      .InSequence(s2);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["specifies the following DAG (where ",(0,s.jsx)(n.code,{children:"s1"})," is ",(0,s.jsx)(n.code,{children:"A -> B"}),", and ",(0,s.jsx)(n.code,{children:"s2"})," is ",(0,s.jsx)(n.code,{children:"A -> C -> D"}),"):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"       +---\x3e B\n       |\n  A ---|\n       |\n       +---\x3e C ---\x3e D\n"})}),"\n",(0,s.jsx)(n.p,{children:"This means that A must occur before B and C, and C must occur before D. There's\nno restriction about the order other than these."}),"\n",(0,s.jsx)(n.h3,{id:"controlling-when-an-expectation-retires",children:"Controlling When an Expectation Retires"}),"\n",(0,s.jsxs)(n.p,{children:["When a mock method is called, gMock only considers expectations that are still\nactive. An expectation is active when created, and becomes inactive (aka\n",(0,s.jsx)(n.em,{children:"retires"}),") when a call that has to occur later has occurred. For example, in"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'using ::testing::_;\nusing ::testing::Sequence;\n...\n  Sequence s1, s2;\n\n  EXPECT_CALL(log, Log(WARNING, _, "File too large."))      // #1\n      .Times(AnyNumber())\n      .InSequence(s1, s2);\n  EXPECT_CALL(log, Log(WARNING, _, "Data set is empty."))   // #2\n      .InSequence(s1);\n  EXPECT_CALL(log, Log(WARNING, _, "User not found."))      // #3\n      .InSequence(s2);\n'})}),"\n",(0,s.jsxs)(n.p,{children:["as soon as either #2 or #3 is matched, #1 will retire. If a warning ",(0,s.jsx)(n.code,{children:'"File too large."'})," is logged after this, it will be an error."]}),"\n",(0,s.jsx)(n.p,{children:"Note that an expectation doesn't retire automatically when it's saturated. For\nexample,"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'using ::testing::_;\n...\n  EXPECT_CALL(log, Log(WARNING, _, _));                     // #1\n  EXPECT_CALL(log, Log(WARNING, _, "File too large."));     // #2\n'})}),"\n",(0,s.jsxs)(n.p,{children:["says that there will be exactly one warning with the message ",(0,s.jsx)(n.code,{children:'"File too large."'}),". If the second warning contains this message too, #2 will match again\nand result in an upper-bound-violated error."]}),"\n",(0,s.jsx)(n.p,{children:"If this is not what you want, you can ask an expectation to retire as soon as it\nbecomes saturated:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'using ::testing::_;\n...\n  EXPECT_CALL(log, Log(WARNING, _, _));                     // #1\n  EXPECT_CALL(log, Log(WARNING, _, "File too large."))      // #2\n      .RetiresOnSaturation();\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Here #2 can be used only once, so if you have two warnings with the message\n",(0,s.jsx)(n.code,{children:'"File too large."'}),", the first will match #2 and the second will match #1 -\nthere will be no error."]}),"\n",(0,s.jsx)(n.h2,{id:"using-actions",children:"Using Actions"}),"\n",(0,s.jsx)(n.h3,{id:"returning-references-from-mock-methods",children:"Returning References from Mock Methods"}),"\n",(0,s.jsxs)(n.p,{children:["If a mock function's return type is a reference, you need to use ",(0,s.jsx)(n.code,{children:"ReturnRef()"}),"\ninstead of ",(0,s.jsx)(n.code,{children:"Return()"})," to return a result:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::ReturnRef;\n\nclass MockFoo : public Foo {\n public:\n  MOCK_METHOD(Bar&, GetBar, (), (override));\n};\n...\n  MockFoo foo;\n  Bar bar;\n  EXPECT_CALL(foo, GetBar())\n      .WillOnce(ReturnRef(bar));\n...\n"})}),"\n",(0,s.jsx)(n.h3,{id:"returning-live-values-from-mock-methods",children:"Returning Live Values from Mock Methods"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Return(x)"})," action saves a copy of ",(0,s.jsx)(n.code,{children:"x"})," when the action is created, and\nalways returns the same value whenever it's executed. Sometimes you may want to\ninstead return the ",(0,s.jsx)(n.em,{children:"live"})," value of ",(0,s.jsx)(n.code,{children:"x"})," (i.e. its value at the time when the\naction is ",(0,s.jsx)(n.em,{children:"executed"}),".). Use either ",(0,s.jsx)(n.code,{children:"ReturnRef()"})," or ",(0,s.jsx)(n.code,{children:"ReturnPointee()"})," for this\npurpose."]}),"\n",(0,s.jsxs)(n.p,{children:["If the mock function's return type is a reference, you can do it using\n",(0,s.jsx)(n.code,{children:"ReturnRef(x)"}),', as shown in the previous recipe ("Returning References from Mock\nMethods"). However, gMock doesn\'t let you use ',(0,s.jsx)(n.code,{children:"ReturnRef()"})," in a mock function\nwhose return type is not a reference, as doing that usually indicates a user\nerror. So, what shall you do?"]}),"\n",(0,s.jsxs)(n.p,{children:["Though you may be tempted, DO NOT use ",(0,s.jsx)(n.code,{children:"std::ref()"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::Return;\n\nclass MockFoo : public Foo {\n public:\n  MOCK_METHOD(int, GetValue, (), (override));\n};\n...\n  int x = 0;\n  MockFoo foo;\n  EXPECT_CALL(foo, GetValue())\n      .WillRepeatedly(Return(std::ref(x)));  // Wrong!\n  x = 42;\n  EXPECT_EQ(foo.GetValue(), 42);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Unfortunately, it doesn't work here. The above code will fail with error:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"Value of: foo.GetValue()\n  Actual: 0\nExpected: 42\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The reason is that ",(0,s.jsx)(n.code,{children:"Return(*value*)"})," converts ",(0,s.jsx)(n.code,{children:"value"})," to the actual return type\nof the mock function at the time when the action is ",(0,s.jsx)(n.em,{children:"created"}),", not when it is\n",(0,s.jsx)(n.em,{children:"executed"}),". (This behavior was chosen for the action to be safe when ",(0,s.jsx)(n.code,{children:"value"})," is\na proxy object that references some temporary objects.) As a result,\n",(0,s.jsx)(n.code,{children:"std::ref(x)"})," is converted to an ",(0,s.jsx)(n.code,{children:"int"})," value (instead of a ",(0,s.jsx)(n.code,{children:"const int&"}),") when\nthe expectation is set, and ",(0,s.jsx)(n.code,{children:"Return(std::ref(x))"})," will always return 0."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ReturnPointee(pointer)"})," was provided to solve this problem specifically. It\nreturns the value pointed to by ",(0,s.jsx)(n.code,{children:"pointer"})," at the time the action is ",(0,s.jsx)(n.em,{children:"executed"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::ReturnPointee;\n...\n  int x = 0;\n  MockFoo foo;\n  EXPECT_CALL(foo, GetValue())\n      .WillRepeatedly(ReturnPointee(&x));  // Note the & here.\n  x = 42;\n  EXPECT_EQ(foo.GetValue(), 42);  // This will succeed now.\n"})}),"\n",(0,s.jsx)(n.h3,{id:"combining-actions",children:"Combining Actions"}),"\n",(0,s.jsxs)(n.p,{children:["Want to do more than one thing when a function is called? That's fine. ",(0,s.jsx)(n.code,{children:"DoAll()"}),"\nallows you to do a sequence of actions every time. Only the return value of the\nlast action in the sequence will be used."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::_;\nusing ::testing::DoAll;\n\nclass MockFoo : public Foo {\n public:\n  MOCK_METHOD(bool, Bar, (int n), (override));\n};\n...\n  EXPECT_CALL(foo, Bar(_))\n      .WillOnce(DoAll(action_1,\n                      action_2,\n                      ...\n                      action_n));\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The return value of the last action ",(0,s.jsx)(n.strong,{children:"must"})," match the return type of the mocked\nmethod. In the example above, ",(0,s.jsx)(n.code,{children:"action_n"})," could be ",(0,s.jsx)(n.code,{children:"Return(true)"}),", or a lambda\nthat returns a ",(0,s.jsx)(n.code,{children:"bool"}),", but not ",(0,s.jsx)(n.code,{children:"SaveArg"}),", which returns ",(0,s.jsx)(n.code,{children:"void"}),". Otherwise the\nsignature of ",(0,s.jsx)(n.code,{children:"DoAll"})," would not match the signature expected by ",(0,s.jsx)(n.code,{children:"WillOnce"}),", which\nis the signature of the mocked method, and it wouldn't compile."]}),"\n",(0,s.jsx)(n.h3,{id:"SaveArgVerify",children:"Verifying Complex Arguments"}),"\n",(0,s.jsx)(n.p,{children:"If you want to verify that a method is called with a particular argument but the\nmatch criteria is complex, it can be difficult to distinguish between\ncardinality failures (calling the method the wrong number of times) and argument\nmatch failures. Similarly, if you are matching multiple parameters, it may not\nbe easy to distinguishing which argument failed to match. For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"  // Not ideal: this could fail because of a problem with arg1 or arg2, or maybe\n  // just the method wasn't called.\n  EXPECT_CALL(foo, SendValues(_, ElementsAre(1, 4, 4, 7), EqualsProto( ... )));\n"})}),"\n",(0,s.jsx)(n.p,{children:"You can instead save the arguments and test them individually:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"  EXPECT_CALL(foo, SendValues)\n      .WillOnce(DoAll(SaveArg<1>(&actual_array), SaveArg<2>(&actual_proto)));\n  ... run the test\n  EXPECT_THAT(actual_array, ElementsAre(1, 4, 4, 7));\n  EXPECT_THAT(actual_proto, EqualsProto( ... ));\n"})}),"\n",(0,s.jsx)(n.h3,{id:"mocking-side-effects",children:"Mocking Side Effects"}),"\n",(0,s.jsxs)(n.p,{children:["Sometimes a method exhibits its effect not via returning a value but via side\neffects. For example, it may change some global state or modify an output\nargument. To mock side effects, in general you can define your own action by\nimplementing ",(0,s.jsx)(n.code,{children:"::testing::ActionInterface"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["If all you need to do is to change an output argument, the built-in\n",(0,s.jsx)(n.code,{children:"SetArgPointee()"})," action is convenient:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::_;\nusing ::testing::SetArgPointee;\n\nclass MockMutator : public Mutator {\n public:\n  MOCK_METHOD(void, Mutate, (bool mutate, int* value), (override));\n  ...\n}\n...\n  MockMutator mutator;\n  EXPECT_CALL(mutator, Mutate(true, _))\n      .WillOnce(SetArgPointee<1>(5));\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In this example, when ",(0,s.jsx)(n.code,{children:"mutator.Mutate()"})," is called, we will assign 5 to the\n",(0,s.jsx)(n.code,{children:"int"})," variable pointed to by argument #1 (0-based)."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"SetArgPointee()"})," conveniently makes an internal copy of the value you pass to\nit, removing the need to keep the value in scope and alive. The implication\nhowever is that the value must have a copy constructor and assignment operator."]}),"\n",(0,s.jsxs)(n.p,{children:["If the mock method also needs to return a value as well, you can chain\n",(0,s.jsx)(n.code,{children:"SetArgPointee()"})," with ",(0,s.jsx)(n.code,{children:"Return()"})," using ",(0,s.jsx)(n.code,{children:"DoAll()"}),", remembering to put the\n",(0,s.jsx)(n.code,{children:"Return()"})," statement last:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::_;\nusing ::testing::DoAll;\nusing ::testing::Return;\nusing ::testing::SetArgPointee;\n\nclass MockMutator : public Mutator {\n public:\n  ...\n  MOCK_METHOD(bool, MutateInt, (int* value), (override));\n}\n...\n  MockMutator mutator;\n  EXPECT_CALL(mutator, MutateInt(_))\n      .WillOnce(DoAll(SetArgPointee<0>(5),\n                      Return(true)));\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Note, however, that if you use the ",(0,s.jsx)(n.code,{children:"ReturnOKWith()"})," method, it will override the\nvalues provided by ",(0,s.jsx)(n.code,{children:"SetArgPointee()"})," in the response parameters of your function\ncall."]}),"\n",(0,s.jsxs)(n.p,{children:["If the output argument is an array, use the ",(0,s.jsx)(n.code,{children:"SetArrayArgument<N>(first, last)"}),"\naction instead. It copies the elements in source range ",(0,s.jsx)(n.code,{children:"[first, last)"})," to the\narray pointed to by the ",(0,s.jsx)(n.code,{children:"N"}),"-th (0-based) argument:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::NotNull;\nusing ::testing::SetArrayArgument;\n\nclass MockArrayMutator : public ArrayMutator {\n public:\n  MOCK_METHOD(void, Mutate, (int* values, int num_values), (override));\n  ...\n}\n...\n  MockArrayMutator mutator;\n  int values[5] = {1, 2, 3, 4, 5};\n  EXPECT_CALL(mutator, Mutate(NotNull(), 5))\n      .WillOnce(SetArrayArgument<0>(values, values + 5));\n"})}),"\n",(0,s.jsx)(n.p,{children:"This also works when the argument is an output iterator:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'using ::testing::_;\nusing ::testing::SetArrayArgument;\n\nclass MockRolodex : public Rolodex {\n public:\n  MOCK_METHOD(void, GetNames, (std::back_insert_iterator<vector<string>>),\n              (override));\n  ...\n}\n...\n  MockRolodex rolodex;\n  vector<string> names = {"George", "John", "Thomas"};\n  EXPECT_CALL(rolodex, GetNames(_))\n      .WillOnce(SetArrayArgument<0>(names.begin(), names.end()));\n'})}),"\n",(0,s.jsx)(n.h3,{id:"changing-a-mock-objects-behavior-based-on-the-state",children:"Changing a Mock Object's Behavior Based on the State"}),"\n",(0,s.jsxs)(n.p,{children:["If you expect a call to change the behavior of a mock object, you can use\n",(0,s.jsx)(n.code,{children:"::testing::InSequence"})," to specify different behaviors before and after the\ncall:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::InSequence;\nusing ::testing::Return;\n\n...\n  {\n     InSequence seq;\n     EXPECT_CALL(my_mock, IsDirty())\n         .WillRepeatedly(Return(true));\n     EXPECT_CALL(my_mock, Flush());\n     EXPECT_CALL(my_mock, IsDirty())\n         .WillRepeatedly(Return(false));\n  }\n  my_mock.FlushIfDirty();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This makes ",(0,s.jsx)(n.code,{children:"my_mock.IsDirty()"})," return ",(0,s.jsx)(n.code,{children:"true"})," before ",(0,s.jsx)(n.code,{children:"my_mock.Flush()"})," is called\nand return ",(0,s.jsx)(n.code,{children:"false"})," afterwards."]}),"\n",(0,s.jsx)(n.p,{children:"If the behavior change is more complex, you can store the effects in a variable\nand make a mock method get its return value from that variable:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::_;\nusing ::testing::SaveArg;\nusing ::testing::Return;\n\nACTION_P(ReturnPointee, p) { return *p; }\n...\n  int previous_value = 0;\n  EXPECT_CALL(my_mock, GetPrevValue)\n      .WillRepeatedly(ReturnPointee(&previous_value));\n  EXPECT_CALL(my_mock, UpdateValue)\n      .WillRepeatedly(SaveArg<0>(&previous_value));\n  my_mock.DoSomethingToUpdateValue();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Here ",(0,s.jsx)(n.code,{children:"my_mock.GetPrevValue()"})," will always return the argument of the last\n",(0,s.jsx)(n.code,{children:"UpdateValue()"})," call."]}),"\n",(0,s.jsx)(n.h3,{id:"DefaultValue",children:"Setting the Default Value for a Return Type"}),"\n",(0,s.jsx)(n.p,{children:"If a mock method's return type is a built-in C++ type or pointer, by default it\nwill return 0 when invoked. Also, in C++ 11 and above, a mock method whose\nreturn type has a default constructor will return a default-constructed value by\ndefault. You only need to specify an action if this default value doesn't work\nfor you."}),"\n",(0,s.jsxs)(n.p,{children:["Sometimes, you may want to change this default value, or you may want to specify\na default value for types gMock doesn't know about. You can do this using the\n",(0,s.jsx)(n.code,{children:"::testing::DefaultValue"})," class template:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::DefaultValue;\n\nclass MockFoo : public Foo {\n public:\n  MOCK_METHOD(Bar, CalculateBar, (), (override));\n};\n\n\n...\n  Bar default_bar;\n  // Sets the default return value for type Bar.\n  DefaultValue<Bar>::Set(default_bar);\n\n  MockFoo foo;\n\n  // We don't need to specify an action here, as the default\n  // return value works for us.\n  EXPECT_CALL(foo, CalculateBar());\n\n  foo.CalculateBar();  // This should return default_bar.\n\n  // Unsets the default return value.\n  DefaultValue<Bar>::Clear();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Please note that changing the default value for a type can make your tests hard\nto understand. We recommend you to use this feature judiciously. For example,\nyou may want to make sure the ",(0,s.jsx)(n.code,{children:"Set()"})," and ",(0,s.jsx)(n.code,{children:"Clear()"})," calls are right next to the\ncode that uses your mock."]}),"\n",(0,s.jsx)(n.h3,{id:"setting-the-default-actions-for-a-mock-method",children:"Setting the Default Actions for a Mock Method"}),"\n",(0,s.jsxs)(n.p,{children:["You've learned how to change the default value of a given type. However, this\nmay be too coarse for your purpose: perhaps you have two mock methods with the\nsame return type and you want them to have different behaviors. The ",(0,s.jsx)(n.code,{children:"ON_CALL()"}),"\nmacro allows you to customize your mock's behavior at the method level:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::_;\nusing ::testing::AnyNumber;\nusing ::testing::Gt;\nusing ::testing::Return;\n...\n  ON_CALL(foo, Sign(_))\n      .WillByDefault(Return(-1));\n  ON_CALL(foo, Sign(0))\n      .WillByDefault(Return(0));\n  ON_CALL(foo, Sign(Gt(0)))\n      .WillByDefault(Return(1));\n\n  EXPECT_CALL(foo, Sign(_))\n      .Times(AnyNumber());\n\n  foo.Sign(5);   // This should return 1.\n  foo.Sign(-9);  // This should return -1.\n  foo.Sign(0);   // This should return 0.\n"})}),"\n",(0,s.jsxs)(n.p,{children:["As you may have guessed, when there are more than one ",(0,s.jsx)(n.code,{children:"ON_CALL()"})," statements,\nthe newer ones in the order take precedence over the older ones. In other words,\nthe ",(0,s.jsx)(n.strong,{children:"last"})," one that matches the function arguments will be used. This matching\norder allows you to set up the common behavior in a mock object's constructor or\nthe test fixture's set-up phase and specialize the mock's behavior later."]}),"\n",(0,s.jsxs)(n.p,{children:["Note that both ",(0,s.jsx)(n.code,{children:"ON_CALL"})," and ",(0,s.jsx)(n.code,{children:"EXPECT_CALL"}),' have the same "later statements take\nprecedence" rule, but they don\'t interact. That is, ',(0,s.jsx)(n.code,{children:"EXPECT_CALL"}),"s have their\nown precedence order distinct from the ",(0,s.jsx)(n.code,{children:"ON_CALL"})," precedence order."]}),"\n",(0,s.jsx)(n.h3,{id:"FunctionsAsActions",children:"Using Functions/Methods/Functors/Lambdas as Actions"}),"\n",(0,s.jsxs)(n.p,{children:["If the built-in actions don't suit you, you can use an existing callable\n(function, ",(0,s.jsx)(n.code,{children:"std::function"}),", method, functor, lambda) as an action."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::_; using ::testing::Invoke;\n\nclass MockFoo : public Foo {\n public:\n  MOCK_METHOD(int, Sum, (int x, int y), (override));\n  MOCK_METHOD(bool, ComplexJob, (int x), (override));\n};\n\nint CalculateSum(int x, int y) { return x + y; }\nint Sum3(int x, int y, int z) { return x + y + z; }\n\nclass Helper {\n public:\n  bool ComplexJob(int x);\n};\n\n...\n  MockFoo foo;\n  Helper helper;\n  EXPECT_CALL(foo, Sum(_, _))\n      .WillOnce(&CalculateSum)\n      .WillRepeatedly(Invoke(NewPermanentCallback(Sum3, 1)));\n  EXPECT_CALL(foo, ComplexJob(_))\n      .WillOnce(Invoke(&helper, &Helper::ComplexJob))\n      .WillOnce([] { return true; })\n      .WillRepeatedly([](int x) { return x > 0; });\n\n  foo.Sum(5, 6);         // Invokes CalculateSum(5, 6).\n  foo.Sum(2, 3);         // Invokes Sum3(1, 2, 3).\n  foo.ComplexJob(10);    // Invokes helper.ComplexJob(10).\n  foo.ComplexJob(-1);    // Invokes the inline lambda.\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The only requirement is that the type of the function, etc must be ",(0,s.jsx)(n.em,{children:"compatible"}),"\nwith the signature of the mock function, meaning that the latter's arguments (if\nit takes any) can be implicitly converted to the corresponding arguments of the\nformer, and the former's return type can be implicitly converted to that of the\nlatter. So, you can invoke something whose type is ",(0,s.jsx)(n.em,{children:"not"})," exactly the same as the\nmock function, as long as it's safe to do so - nice, huh?"]}),"\n",(0,s.jsx)(n.p,{children:"Note that:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The action takes ownership of the callback and will delete it when the\naction itself is destructed."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["If the type of a callback is derived from a base callback type ",(0,s.jsx)(n.code,{children:"C"}),", you need\nto implicitly cast it to ",(0,s.jsx)(n.code,{children:"C"})," to resolve the overloading, e.g."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::Invoke;\n...\n  ResultCallback<bool>* is_ok = ...;\n  ... Invoke(is_ok) ...;  // This works.\n\n  BlockingClosure* done = new BlockingClosure;\n  ... Invoke(implicit_cast<Closure*>(done)) ...;  // The cast is necessary.\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"using-functions-with-extra-info-as-actions",children:"Using Functions with Extra Info as Actions"}),"\n",(0,s.jsxs)(n.p,{children:["The function or functor you call using ",(0,s.jsx)(n.code,{children:"Invoke()"})," must have the same number of\narguments as the mock function you use it for. Sometimes you may have a function\nthat takes more arguments, and you are willing to pass in the extra arguments\nyourself to fill the gap. You can do this in gMock using callbacks with\npre-bound arguments. Here's an example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::Invoke;\n\nclass MockFoo : public Foo {\n public:\n  MOCK_METHOD(char, DoThis, (int n), (override));\n};\n\nchar SignOfSum(int x, int y) {\n  const int sum = x + y;\n  return (sum > 0) ? '+' : (sum < 0) ? '-' : '0';\n}\n\nTEST_F(FooTest, Test) {\n  MockFoo foo;\n\n  EXPECT_CALL(foo, DoThis(2))\n      .WillOnce(Invoke(NewPermanentCallback(SignOfSum, 5)));\n  EXPECT_EQ(foo.DoThis(2), '+');  // Invokes SignOfSum(5, 2).\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"invoking-a-functionmethodfunctorlambdacallback-without-arguments",children:"Invoking a Function/Method/Functor/Lambda/Callback Without Arguments"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Invoke()"})," passes the mock function's arguments to the function, etc being\ninvoked such that the callee has the full context of the call to work with. If\nthe invoked function is not interested in some or all of the arguments, it can\nsimply ignore them."]}),"\n",(0,s.jsx)(n.p,{children:"Yet, a common pattern is that a test author wants to invoke a function without\nthe arguments of the mock function. She could do that using a wrapper function\nthat throws away the arguments before invoking an underlining nullary function.\nNeedless to say, this can be tedious and obscures the intent of the test."}),"\n",(0,s.jsxs)(n.p,{children:["There are two solutions to this problem. First, you can pass any callable of\nzero args as an action. Alternatively, use ",(0,s.jsx)(n.code,{children:"InvokeWithoutArgs()"}),", which is like\n",(0,s.jsx)(n.code,{children:"Invoke()"})," except that it doesn't pass the mock function's arguments to the\ncallee. Here's an example of each:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::_;\nusing ::testing::InvokeWithoutArgs;\n\nclass MockFoo : public Foo {\n public:\n  MOCK_METHOD(bool, ComplexJob, (int n), (override));\n};\n\nbool Job1() { ... }\nbool Job2(int n, char c) { ... }\n\n...\n  MockFoo foo;\n  EXPECT_CALL(foo, ComplexJob(_))\n      .WillOnce([] { Job1(); });\n      .WillOnce(InvokeWithoutArgs(NewPermanentCallback(Job2, 5, 'a')));\n\n  foo.ComplexJob(10);  // Invokes Job1().\n  foo.ComplexJob(20);  // Invokes Job2(5, 'a').\n"})}),"\n",(0,s.jsx)(n.p,{children:"Note that:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The action takes ownership of the callback and will delete it when the\naction itself is destructed."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["If the type of a callback is derived from a base callback type ",(0,s.jsx)(n.code,{children:"C"}),", you need\nto implicitly cast it to ",(0,s.jsx)(n.code,{children:"C"})," to resolve the overloading, e.g."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::InvokeWithoutArgs;\n...\n  ResultCallback<bool>* is_ok = ...;\n  ... InvokeWithoutArgs(is_ok) ...;  // This works.\n\n  BlockingClosure* done = ...;\n  ... InvokeWithoutArgs(implicit_cast<Closure*>(done)) ...;\n  // The cast is necessary.\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"invoking-an-argument-of-the-mock-function",children:"Invoking an Argument of the Mock Function"}),"\n",(0,s.jsx)(n.p,{children:'Sometimes a mock function will receive a function pointer, a functor (in other\nwords, a "callable") as an argument, e.g.'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class MockFoo : public Foo {\n public:\n  MOCK_METHOD(bool, DoThis, (int n, (ResultCallback1<bool, int>* callback)),\n              (override));\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"and you may want to invoke this callable argument:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::_;\n...\n  MockFoo foo;\n  EXPECT_CALL(foo, DoThis(_, _))\n      .WillOnce(...);\n      // Will execute callback->Run(5), where callback is the\n      // second argument DoThis() receives.\n"})}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsx)(n.p,{children:"NOTE: The section below is legacy documentation from before C++ had lambdas:"}),(0,s.jsx)(n.p,{children:"Arghh, you need to refer to a mock function argument but C++ has no lambda\n(yet), so you have to define your own action. :-( Or do you really?"}),(0,s.jsxs)(n.p,{children:["Well, gMock has an action to solve ",(0,s.jsx)(n.em,{children:"exactly"})," this problem:"]})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"InvokeArgument<N>(arg_1, arg_2, ..., arg_m)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["will invoke the ",(0,s.jsx)(n.code,{children:"N"}),"-th (0-based) argument the mock function receives, with\n",(0,s.jsx)(n.code,{children:"arg_1"}),", ",(0,s.jsx)(n.code,{children:"arg_2"}),", ..., and ",(0,s.jsx)(n.code,{children:"arg_m"}),". No matter if the argument is a function\npointer, a functor, or a callback. gMock handles them all."]}),"\n",(0,s.jsx)(n.p,{children:"With that, you could write:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::_;\nusing ::testing::InvokeArgument;\n...\n  EXPECT_CALL(foo, DoThis(_, _))\n      .WillOnce(InvokeArgument<1>(5));\n      // Will execute callback->Run(5), where callback is the\n      // second argument DoThis() receives.\n"})}),"\n",(0,s.jsxs)(n.p,{children:["What if the callable takes an argument by reference? No problem - just wrap it\ninside ",(0,s.jsx)(n.code,{children:"std::ref()"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"  ...\n  MOCK_METHOD(bool, Bar,\n              ((ResultCallback2<bool, int, const Helper&>* callback)),\n              (override));\n  ...\n  using ::testing::_;\n  using ::testing::InvokeArgument;\n  ...\n  MockFoo foo;\n  Helper helper;\n  ...\n  EXPECT_CALL(foo, Bar(_))\n      .WillOnce(InvokeArgument<0>(5, std::ref(helper)));\n      // std::ref(helper) guarantees that a reference to helper, not a copy of\n      // it, will be passed to the callback.\n"})}),"\n",(0,s.jsxs)(n.p,{children:["What if the callable takes an argument by reference and we do ",(0,s.jsx)(n.strong,{children:"not"})," wrap the\nargument in ",(0,s.jsx)(n.code,{children:"std::ref()"}),"? Then ",(0,s.jsx)(n.code,{children:"InvokeArgument()"})," will ",(0,s.jsx)(n.em,{children:"make a copy"})," of the\nargument, and pass a ",(0,s.jsx)(n.em,{children:"reference to the copy"}),", instead of a reference to the\noriginal value, to the callable. This is especially handy when the argument is a\ntemporary value:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'  ...\n  MOCK_METHOD(bool, DoThat, (bool (*f)(const double& x, const string& s)),\n              (override));\n  ...\n  using ::testing::_;\n  using ::testing::InvokeArgument;\n  ...\n  MockFoo foo;\n  ...\n  EXPECT_CALL(foo, DoThat(_))\n      .WillOnce(InvokeArgument<0>(5.0, string("Hi")));\n      // Will execute (*f)(5.0, string("Hi")), where f is the function pointer\n      // DoThat() receives.  Note that the values 5.0 and string("Hi") are\n      // temporary and dead once the EXPECT_CALL() statement finishes.  Yet\n      // it\'s fine to perform this action later, since a copy of the values\n      // are kept inside the InvokeArgument action.\n'})}),"\n",(0,s.jsx)(n.h3,{id:"ignoring-an-actions-result",children:"Ignoring an Action's Result"}),"\n",(0,s.jsxs)(n.p,{children:["Sometimes you have an action that returns ",(0,s.jsx)(n.em,{children:"something"}),", but you need an action\nthat returns ",(0,s.jsx)(n.code,{children:"void"})," (perhaps you want to use it in a mock function that returns\n",(0,s.jsx)(n.code,{children:"void"}),", or perhaps it needs to be used in ",(0,s.jsx)(n.code,{children:"DoAll()"})," and it's not the last in the\nlist). ",(0,s.jsx)(n.code,{children:"IgnoreResult()"})," lets you do that. For example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::_;\nusing ::testing::DoAll;\nusing ::testing::IgnoreResult;\nusing ::testing::Return;\n\nint Process(const MyData& data);\nstring DoSomething();\n\nclass MockFoo : public Foo {\n public:\n  MOCK_METHOD(void, Abc, (const MyData& data), (override));\n  MOCK_METHOD(bool, Xyz, (), (override));\n};\n\n  ...\n  MockFoo foo;\n  EXPECT_CALL(foo, Abc(_))\n      // .WillOnce(Invoke(Process));\n      // The above line won't compile as Process() returns int but Abc() needs\n      // to return void.\n      .WillOnce(IgnoreResult(Process));\n  EXPECT_CALL(foo, Xyz())\n      .WillOnce(DoAll(IgnoreResult(DoSomething),\n                      // Ignores the string DoSomething() returns.\n                      Return(true)));\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Note that you ",(0,s.jsx)(n.strong,{children:"cannot"})," use ",(0,s.jsx)(n.code,{children:"IgnoreResult()"})," on an action that already returns\n",(0,s.jsx)(n.code,{children:"void"}),". Doing so will lead to ugly compiler errors."]}),"\n",(0,s.jsx)(n.h3,{id:"SelectingArgs",children:"Selecting an Action's Arguments"}),"\n",(0,s.jsxs)(n.p,{children:["Say you have a mock function ",(0,s.jsx)(n.code,{children:"Foo()"})," that takes seven arguments, and you have a\ncustom action that you want to invoke when ",(0,s.jsx)(n.code,{children:"Foo()"})," is called. Trouble is, the\ncustom action only wants three arguments:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::_;\nusing ::testing::Invoke;\n...\n  MOCK_METHOD(bool, Foo,\n              (bool visible, const string& name, int x, int y,\n               (const map<pair<int, int>>), double& weight, double min_weight,\n               double max_wight));\n...\nbool IsVisibleInQuadrant1(bool visible, int x, int y) {\n  return visible && x >= 0 && y >= 0;\n}\n...\n  EXPECT_CALL(mock, Foo)\n      .WillOnce(Invoke(IsVisibleInQuadrant1));  // Uh, won't compile. :-(\n"})}),"\n",(0,s.jsxs)(n.p,{children:['To please the compiler God, you need to define an "adaptor" that has the same\nsignature as ',(0,s.jsx)(n.code,{children:"Foo()"})," and calls the custom action with the right arguments:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::_;\nusing ::testing::Invoke;\n...\nbool MyIsVisibleInQuadrant1(bool visible, const string& name, int x, int y,\n                            const map<pair<int, int>, double>& weight,\n                            double min_weight, double max_wight) {\n  return IsVisibleInQuadrant1(visible, x, y);\n}\n...\n  EXPECT_CALL(mock, Foo)\n      .WillOnce(Invoke(MyIsVisibleInQuadrant1));  // Now it works.\n"})}),"\n",(0,s.jsx)(n.p,{children:"But isn't this awkward?"}),"\n",(0,s.jsxs)(n.p,{children:["gMock provides a generic ",(0,s.jsx)(n.em,{children:"action adaptor"}),", so you can spend your time minding\nmore important business than writing your own adaptors. Here's the syntax:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"WithArgs<N1, N2, ..., Nk>(action)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["creates an action that passes the arguments of the mock function at the given\nindices (0-based) to the inner ",(0,s.jsx)(n.code,{children:"action"})," and performs it. Using ",(0,s.jsx)(n.code,{children:"WithArgs"}),", our\noriginal example can be written as:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::_;\nusing ::testing::Invoke;\nusing ::testing::WithArgs;\n...\n  EXPECT_CALL(mock, Foo)\n      .WillOnce(WithArgs<0, 2, 3>(Invoke(IsVisibleInQuadrant1)));  // No need to define your own adaptor.\n"})}),"\n",(0,s.jsx)(n.p,{children:"For better readability, gMock also gives you:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"WithoutArgs(action)"})," when the inner ",(0,s.jsx)(n.code,{children:"action"})," takes ",(0,s.jsx)(n.em,{children:"no"})," argument, and"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"WithArg<N>(action)"})," (no ",(0,s.jsx)(n.code,{children:"s"})," after ",(0,s.jsx)(n.code,{children:"Arg"}),") when the inner ",(0,s.jsx)(n.code,{children:"action"})," takes\n",(0,s.jsx)(n.em,{children:"one"})," argument."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["As you may have realized, ",(0,s.jsx)(n.code,{children:"InvokeWithoutArgs(...)"})," is just syntactic sugar for\n",(0,s.jsx)(n.code,{children:"WithoutArgs(Invoke(...))"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Here are more tips:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The inner action used in ",(0,s.jsx)(n.code,{children:"WithArgs"})," and friends does not have to be\n",(0,s.jsx)(n.code,{children:"Invoke()"})," -- it can be anything."]}),"\n",(0,s.jsxs)(n.li,{children:["You can repeat an argument in the argument list if necessary, e.g.\n",(0,s.jsx)(n.code,{children:"WithArgs<2, 3, 3, 5>(...)"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["You can change the order of the arguments, e.g. ",(0,s.jsx)(n.code,{children:"WithArgs<3, 2, 1>(...)"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["The types of the selected arguments do ",(0,s.jsx)(n.em,{children:"not"})," have to match the signature of\nthe inner action exactly. It works as long as they can be implicitly\nconverted to the corresponding arguments of the inner action. For example,\nif the 4-th argument of the mock function is an ",(0,s.jsx)(n.code,{children:"int"})," and ",(0,s.jsx)(n.code,{children:"my_action"})," takes\na ",(0,s.jsx)(n.code,{children:"double"}),", ",(0,s.jsx)(n.code,{children:"WithArg<4>(my_action)"})," will work."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"ignoring-arguments-in-action-functions",children:"Ignoring Arguments in Action Functions"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.a,{href:"#SelectingArgs",children:"selecting-an-action's-arguments"})," recipe showed us one way\nto make a mock function and an action with incompatible argument lists fit\ntogether. The downside is that wrapping the action in ",(0,s.jsx)(n.code,{children:"WithArgs<...>()"})," can get\ntedious for people writing the tests."]}),"\n",(0,s.jsxs)(n.p,{children:["If you are defining a function (or method, functor, lambda, callback) to be used\nwith ",(0,s.jsx)(n.code,{children:"Invoke*()"}),", and you are not interested in some of its arguments, an\nalternative to ",(0,s.jsx)(n.code,{children:"WithArgs"})," is to declare the uninteresting arguments as ",(0,s.jsx)(n.code,{children:"Unused"}),".\nThis makes the definition less cluttered and less fragile in case the types of\nthe uninteresting arguments change. It could also increase the chance the action\nfunction can be reused. For example, given"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:" public:\n  MOCK_METHOD(double, Foo, double(const string& label, double x, double y),\n              (override));\n  MOCK_METHOD(double, Bar, (int index, double x, double y), (override));\n"})}),"\n",(0,s.jsx)(n.p,{children:"instead of"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'using ::testing::_;\nusing ::testing::Invoke;\n\ndouble DistanceToOriginWithLabel(const string& label, double x, double y) {\n  return sqrt(x*x + y*y);\n}\ndouble DistanceToOriginWithIndex(int index, double x, double y) {\n  return sqrt(x*x + y*y);\n}\n...\n  EXPECT_CALL(mock, Foo("abc", _, _))\n      .WillOnce(Invoke(DistanceToOriginWithLabel));\n  EXPECT_CALL(mock, Bar(5, _, _))\n      .WillOnce(Invoke(DistanceToOriginWithIndex));\n'})}),"\n",(0,s.jsx)(n.p,{children:"you could write"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'using ::testing::_;\nusing ::testing::Invoke;\nusing ::testing::Unused;\n\ndouble DistanceToOrigin(Unused, double x, double y) {\n  return sqrt(x*x + y*y);\n}\n...\n  EXPECT_CALL(mock, Foo("abc", _, _))\n      .WillOnce(Invoke(DistanceToOrigin));\n  EXPECT_CALL(mock, Bar(5, _, _))\n      .WillOnce(Invoke(DistanceToOrigin));\n'})}),"\n",(0,s.jsx)(n.h3,{id:"sharing-actions",children:"Sharing Actions"}),"\n",(0,s.jsx)(n.p,{children:"Just like matchers, a gMock action object consists of a pointer to a ref-counted\nimplementation object. Therefore copying actions is also allowed and very\nefficient. When the last action that references the implementation object dies,\nthe implementation object will be deleted."}),"\n",(0,s.jsx)(n.p,{children:"If you have some complex action that you want to use again and again, you may\nnot have to build it from scratch every time. If the action doesn't have an\ninternal state (i.e. if it always does the same thing no matter how many times\nit has been called), you can assign it to an action variable and use that\nvariable repeatedly. For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::Action;\nusing ::testing::DoAll;\nusing ::testing::Return;\nusing ::testing::SetArgPointee;\n...\n  Action<bool(int*)> set_flag = DoAll(SetArgPointee<0>(5),\n                                      Return(true));\n  ... use set_flag in .WillOnce() and .WillRepeatedly() ...\n"})}),"\n",(0,s.jsxs)(n.p,{children:["However, if the action has its own state, you may be surprised if you share the\naction object. Suppose you have an action factory ",(0,s.jsx)(n.code,{children:"IncrementCounter(init)"})," which\ncreates an action that increments and returns a counter whose initial value is\n",(0,s.jsx)(n.code,{children:"init"}),", using two actions created from the same expression and using a shared\naction will exhibit different behaviors. Example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"  EXPECT_CALL(foo, DoThis())\n      .WillRepeatedly(IncrementCounter(0));\n  EXPECT_CALL(foo, DoThat())\n      .WillRepeatedly(IncrementCounter(0));\n  foo.DoThis();  // Returns 1.\n  foo.DoThis();  // Returns 2.\n  foo.DoThat();  // Returns 1 - DoThat() uses a different\n                 // counter than DoThis()'s.\n"})}),"\n",(0,s.jsx)(n.p,{children:"versus"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::Action;\n...\n  Action<int()> increment = IncrementCounter(0);\n  EXPECT_CALL(foo, DoThis())\n      .WillRepeatedly(increment);\n  EXPECT_CALL(foo, DoThat())\n      .WillRepeatedly(increment);\n  foo.DoThis();  // Returns 1.\n  foo.DoThis();  // Returns 2.\n  foo.DoThat();  // Returns 3 - the counter is shared.\n"})}),"\n",(0,s.jsx)(n.h3,{id:"testing-asynchronous-behavior",children:"Testing Asynchronous Behavior"}),"\n",(0,s.jsxs)(n.p,{children:["One oft-encountered problem with gMock is that it can be hard to test\nasynchronous behavior. Suppose you had a ",(0,s.jsx)(n.code,{children:"EventQueue"})," class that you wanted to\ntest, and you created a separate ",(0,s.jsx)(n.code,{children:"EventDispatcher"})," interface so that you could\neasily mock it out. However, the implementation of the class fired all the\nevents on a background thread, which made test timings difficult. You could just\ninsert ",(0,s.jsx)(n.code,{children:"sleep()"})," statements and hope for the best, but that makes your test\nbehavior nondeterministic. A better way is to use gMock actions and\n",(0,s.jsx)(n.code,{children:"Notification"})," objects to force your asynchronous test to behave synchronously."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class MockEventDispatcher : public EventDispatcher {\n  MOCK_METHOD(bool, DispatchEvent, (int32), (override));\n};\n\nTEST(EventQueueTest, EnqueueEventTest) {\n  MockEventDispatcher mock_event_dispatcher;\n  EventQueue event_queue(&mock_event_dispatcher);\n\n  const int32 kEventId = 321;\n  absl::Notification done;\n  EXPECT_CALL(mock_event_dispatcher, DispatchEvent(kEventId))\n      .WillOnce([&done] { done.Notify(); });\n\n  event_queue.EnqueueEvent(kEventId);\n  done.WaitForNotification();\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In the example above, we set our normal gMock expectations, but then add an\nadditional action to notify the ",(0,s.jsx)(n.code,{children:"Notification"})," object. Now we can just call\n",(0,s.jsx)(n.code,{children:"Notification::WaitForNotification()"})," in the main thread to wait for the\nasynchronous call to finish. After that, our test suite is complete and we can\nsafely exit."]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["Note: this example has a downside: namely, if the expectation is not satisfied,\nour test will run forever. It will eventually time-out and fail, but it will\ntake longer and be slightly harder to debug. To alleviate this problem, you can\nuse ",(0,s.jsx)(n.code,{children:"WaitForNotificationWithTimeout(ms)"})," instead of ",(0,s.jsx)(n.code,{children:"WaitForNotification()"}),"."]})}),"\n",(0,s.jsx)(n.h2,{id:"misc-recipes-on-using-gmock",children:"Misc Recipes on Using gMock"}),"\n",(0,s.jsx)(n.h3,{id:"mocking-methods-that-use-move-only-types",children:"Mocking Methods That Use Move-Only Types"}),"\n",(0,s.jsxs)(n.p,{children:["C++11 introduced ",(0,s.jsx)(n.em,{children:"move-only types"}),". A move-only-typed value can be moved from\none object to another, but cannot be copied. ",(0,s.jsx)(n.code,{children:"std::unique_ptr<T>"})," is probably\nthe most commonly used move-only type."]}),"\n",(0,s.jsxs)(n.p,{children:["Mocking a method that takes and/or returns move-only types presents some\nchallenges, but nothing insurmountable. This recipe shows you how you can do it.\nNote that the support for move-only method arguments was only introduced to\ngMock in April 2017; in older code, you may find more complex\n",(0,s.jsx)(n.a,{href:"#LegacyMoveOnly",children:"workarounds"})," for lack of this feature."]}),"\n",(0,s.jsx)(n.p,{children:"Let\u2019s say we are working on a fictional project that lets one post and share\nsnippets called \u201cbuzzes\u201d. Your code uses these types:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"enum class AccessLevel { kInternal, kPublic };\n\nclass Buzz {\n public:\n  explicit Buzz(AccessLevel access) { ... }\n  ...\n};\n\nclass Buzzer {\n public:\n  virtual ~Buzzer() {}\n  virtual std::unique_ptr<Buzz> MakeBuzz(StringPiece text) = 0;\n  virtual bool ShareBuzz(std::unique_ptr<Buzz> buzz, int64_t timestamp) = 0;\n  ...\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.code,{children:"Buzz"})," object represents a snippet being posted. A class that implements the\n",(0,s.jsx)(n.code,{children:"Buzzer"})," interface is capable of creating and sharing ",(0,s.jsx)(n.code,{children:"Buzz"}),"es. Methods in\n",(0,s.jsx)(n.code,{children:"Buzzer"})," may return a ",(0,s.jsx)(n.code,{children:"unique_ptr<Buzz>"})," or take a ",(0,s.jsx)(n.code,{children:"unique_ptr<Buzz>"}),". Now we\nneed to mock ",(0,s.jsx)(n.code,{children:"Buzzer"})," in our tests."]}),"\n",(0,s.jsxs)(n.p,{children:["To mock a method that accepts or returns move-only types, you just use the\nfamiliar ",(0,s.jsx)(n.code,{children:"MOCK_METHOD"})," syntax as usual:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class MockBuzzer : public Buzzer {\n public:\n  MOCK_METHOD(std::unique_ptr<Buzz>, MakeBuzz, (StringPiece text), (override));\n  MOCK_METHOD(bool, ShareBuzz, (std::unique_ptr<Buzz> buzz, int64_t timestamp),\n              (override));\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Now that we have the mock class defined, we can use it in tests. In the\nfollowing code examples, we assume that we have defined a ",(0,s.jsx)(n.code,{children:"MockBuzzer"})," object\nnamed ",(0,s.jsx)(n.code,{children:"mock_buzzer_"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"  MockBuzzer mock_buzzer_;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["First let\u2019s see how we can set expectations on the ",(0,s.jsx)(n.code,{children:"MakeBuzz()"})," method, which\nreturns a ",(0,s.jsx)(n.code,{children:"unique_ptr<Buzz>"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["As usual, if you set an expectation without an action (i.e. the ",(0,s.jsx)(n.code,{children:".WillOnce()"})," or\n",(0,s.jsx)(n.code,{children:".WillRepeatedly()"})," clause), when that expectation fires, the default action for\nthat method will be taken. Since ",(0,s.jsx)(n.code,{children:"unique_ptr<>"})," has a default constructor that\nreturns a null ",(0,s.jsx)(n.code,{children:"unique_ptr"}),", that\u2019s what you\u2019ll get if you don\u2019t specify an\naction:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'using ::testing::IsNull;\n...\n  // Use the default action.\n  EXPECT_CALL(mock_buzzer_, MakeBuzz("hello"));\n\n  // Triggers the previous EXPECT_CALL.\n  EXPECT_THAT(mock_buzzer_.MakeBuzz("hello"), IsNull());\n'})}),"\n",(0,s.jsx)(n.p,{children:"If you are not happy with the default action, you can tweak it as usual; see\nSetting Default Actions."}),"\n",(0,s.jsxs)(n.p,{children:["If you just need to return a move-only value, you can use it in combination with\n",(0,s.jsx)(n.code,{children:"WillOnce"}),". For example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'  EXPECT_CALL(mock_buzzer_, MakeBuzz("hello"))\n      .WillOnce(Return(std::make_unique<Buzz>(AccessLevel::kInternal)));\n  EXPECT_NE(nullptr, mock_buzzer_.MakeBuzz("hello"));\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Quiz time! What do you think will happen if a ",(0,s.jsx)(n.code,{children:"Return"})," action is performed more\nthan once (e.g. you write ",(0,s.jsx)(n.code,{children:"... .WillRepeatedly(Return(std::move(...)));"}),")? Come\nthink of it, after the first time the action runs, the source value will be\nconsumed (since it\u2019s a move-only value), so the next time around, there\u2019s no\nvalue to move from -- you\u2019ll get a run-time error that ",(0,s.jsx)(n.code,{children:"Return(std::move(...))"}),"\ncan only be run once."]}),"\n",(0,s.jsx)(n.p,{children:"If you need your mock method to do more than just moving a pre-defined value,\nremember that you can always use a lambda or a callable object, which can do\npretty much anything you want:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'  EXPECT_CALL(mock_buzzer_, MakeBuzz("x"))\n      .WillRepeatedly([](StringPiece text) {\n        return std::make_unique<Buzz>(AccessLevel::kInternal);\n      });\n\n  EXPECT_NE(nullptr, mock_buzzer_.MakeBuzz("x"));\n  EXPECT_NE(nullptr, mock_buzzer_.MakeBuzz("x"));\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Every time this ",(0,s.jsx)(n.code,{children:"EXPECT_CALL"})," fires, a new ",(0,s.jsx)(n.code,{children:"unique_ptr<Buzz>"})," will be created\nand returned. You cannot do this with ",(0,s.jsx)(n.code,{children:"Return(std::make_unique<...>(...))"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["That covers returning move-only values; but how do we work with methods\naccepting move-only arguments? The answer is that they work normally, although\nsome actions will not compile when any of method's arguments are move-only. You\ncan always use ",(0,s.jsx)(n.code,{children:"Return"}),", or a ",(0,s.jsx)(n.a,{href:"#FunctionsAsActions",children:"lambda or functor"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"  using ::testing::Unused;\n\n  EXPECT_CALL(mock_buzzer_, ShareBuzz(NotNull(), _)).WillOnce(Return(true));\n  EXPECT_TRUE(mock_buzzer_.ShareBuzz(std::make_unique<Buzz>(AccessLevel::kInternal)),\n              0);\n\n  EXPECT_CALL(mock_buzzer_, ShareBuzz(_, _)).WillOnce(\n      [](std::unique_ptr<Buzz> buzz, Unused) { return buzz != nullptr; });\n  EXPECT_FALSE(mock_buzzer_.ShareBuzz(nullptr, 0));\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Many built-in actions (",(0,s.jsx)(n.code,{children:"WithArgs"}),", ",(0,s.jsx)(n.code,{children:"WithoutArgs"}),",",(0,s.jsx)(n.code,{children:"DeleteArg"}),", ",(0,s.jsx)(n.code,{children:"SaveArg"}),", ...)\ncould in principle support move-only arguments, but the support for this is not\nimplemented yet. If this is blocking you, please file a bug."]}),"\n",(0,s.jsxs)(n.p,{children:["A few actions (e.g. ",(0,s.jsx)(n.code,{children:"DoAll"}),") copy their arguments internally, so they can never\nwork with non-copyable objects; you'll have to use functors instead."]}),"\n",(0,s.jsx)(n.h4,{id:"LegacyMoveOnly",children:"Legacy workarounds for move-only types"}),"\n",(0,s.jsx)(n.p,{children:"Support for move-only function arguments was only introduced to gMock in April\nof 2017. In older code, you may encounter the following workaround for the lack\nof this feature (it is no longer necessary - we're including it just for\nreference):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class MockBuzzer : public Buzzer {\n public:\n  MOCK_METHOD(bool, DoShareBuzz, (Buzz* buzz, Time timestamp));\n  bool ShareBuzz(std::unique_ptr<Buzz> buzz, Time timestamp) override {\n    return DoShareBuzz(buzz.get(), timestamp);\n  }\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The trick is to delegate the ",(0,s.jsx)(n.code,{children:"ShareBuzz()"})," method to a mock method (let\u2019s call\nit ",(0,s.jsx)(n.code,{children:"DoShareBuzz()"}),") that does not take move-only parameters. Then, instead of\nsetting expectations on ",(0,s.jsx)(n.code,{children:"ShareBuzz()"}),", you set them on the ",(0,s.jsx)(n.code,{children:"DoShareBuzz()"})," mock\nmethod:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"  MockBuzzer mock_buzzer_;\n  EXPECT_CALL(mock_buzzer_, DoShareBuzz(NotNull(), _));\n\n  // When one calls ShareBuzz() on the MockBuzzer like this, the call is\n  // forwarded to DoShareBuzz(), which is mocked.  Therefore this statement\n  // will trigger the above EXPECT_CALL.\n  mock_buzzer_.ShareBuzz(std::make_unique<Buzz>(AccessLevel::kInternal), 0);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"making-the-compilation-faster",children:"Making the Compilation Faster"}),"\n",(0,s.jsxs)(n.p,{children:["Believe it or not, the ",(0,s.jsx)(n.em,{children:"vast majority"})," of the time spent on compiling a mock\nclass is in generating its constructor and destructor, as they perform\nnon-trivial tasks (e.g. verification of the expectations). What's more, mock\nmethods with different signatures have different types and thus their\nconstructors/destructors need to be generated by the compiler separately. As a\nresult, if you mock many different types of methods, compiling your mock class\ncan get really slow."]}),"\n",(0,s.jsxs)(n.p,{children:["If you are experiencing slow compilation, you can move the definition of your\nmock class' constructor and destructor out of the class body and into a ",(0,s.jsx)(n.code,{children:".cc"}),"\nfile. This way, even if you ",(0,s.jsx)(n.code,{children:"#include"})," your mock class in N files, the compiler\nonly needs to generate its constructor and destructor once, resulting in a much\nfaster compilation."]}),"\n",(0,s.jsx)(n.p,{children:"Let's illustrate the idea using an example. Here's the definition of a mock\nclass before applying this recipe:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// File mock_foo.h.\n...\nclass MockFoo : public Foo {\n public:\n  // Since we don't declare the constructor or the destructor,\n  // the compiler will generate them in every translation unit\n  // where this mock class is used.\n\n  MOCK_METHOD(int, DoThis, (), (override));\n  MOCK_METHOD(bool, DoThat, (const char* str), (override));\n  ... more mock methods ...\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"After the change, it would look like:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// File mock_foo.h.\n...\nclass MockFoo : public Foo {\n public:\n  // The constructor and destructor are declared, but not defined, here.\n  MockFoo();\n  virtual ~MockFoo();\n\n  MOCK_METHOD(int, DoThis, (), (override));\n  MOCK_METHOD(bool, DoThat, (const char* str), (override));\n  ... more mock methods ...\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"and"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'// File mock_foo.cc.\n#include "path/to/mock_foo.h"\n\n// The definitions may appear trivial, but the functions actually do a\n// lot of things through the constructors/destructors of the member\n// variables used to implement the mock methods.\nMockFoo::MockFoo() {}\nMockFoo::~MockFoo() {}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"forcing-a-verification",children:"Forcing a Verification"}),"\n",(0,s.jsx)(n.p,{children:"When it's being destroyed, your friendly mock object will automatically verify\nthat all expectations on it have been satisfied, and will generate googletest\nfailures if not. This is convenient as it leaves you with one less thing to\nworry about. That is, unless you are not sure if your mock object will be\ndestroyed."}),"\n",(0,s.jsx)(n.p,{children:"How could it be that your mock object won't eventually be destroyed? Well, it\nmight be created on the heap and owned by the code you are testing. Suppose\nthere's a bug in that code and it doesn't delete the mock object properly - you\ncould end up with a passing test when there's actually a bug."}),"\n",(0,s.jsxs)(n.p,{children:["Using a heap checker is a good idea and can alleviate the concern, but its\nimplementation is not 100% reliable. So, sometimes you do want to ",(0,s.jsx)(n.em,{children:"force"})," gMock\nto verify a mock object before it is (hopefully) destructed. You can do this\nwith ",(0,s.jsx)(n.code,{children:"Mock::VerifyAndClearExpectations(&mock_object)"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"TEST(MyServerTest, ProcessesRequest) {\n  using ::testing::Mock;\n\n  MockFoo* const foo = new MockFoo;\n  EXPECT_CALL(*foo, ...)...;\n  // ... other expectations ...\n\n  // server now owns foo.\n  MyServer server(foo);\n  server.ProcessRequest(...);\n\n  // In case that server's destructor will forget to delete foo,\n  // this will verify the expectations anyway.\n  Mock::VerifyAndClearExpectations(foo);\n}  // server is destroyed when it goes out of scope here.\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Tip:"})," The ",(0,s.jsx)(n.code,{children:"Mock::VerifyAndClearExpectations()"})," function returns a ",(0,s.jsx)(n.code,{children:"bool"})," to\nindicate whether the verification was successful (",(0,s.jsx)(n.code,{children:"true"})," for yes), so you can\nwrap that function call inside a ",(0,s.jsx)(n.code,{children:"ASSERT_TRUE()"})," if there is no point going\nfurther when the verification has failed."]})}),"\n",(0,s.jsxs)(n.p,{children:["Do not set new expectations after verifying and clearing a mock after its use.\nSetting expectations after code that exercises the mock has undefined behavior.\nSee ",(0,s.jsx)(n.a,{href:"/cppdev/docs/foundamentals/testing/gt/gmock_for_dummies#using-mocks-in-tests",children:"Using Mocks in Tests"})," for more\ninformation."]}),"\n",(0,s.jsx)(n.h3,{id:"UsingCheckPoints",children:"Using Checkpoints"}),"\n",(0,s.jsx)(n.p,{children:"Sometimes you might want to test a mock object's behavior in phases whose sizes\nare each manageable, or you might want to set more detailed expectations about\nwhich API calls invoke which mock functions."}),"\n",(0,s.jsx)(n.p,{children:'A technique you can use is to put the expectations in a sequence and insert\ncalls to a dummy "checkpoint" function at specific places. Then you can verify\nthat the mock function calls do happen at the right time. For example, if you\nare exercising the code:'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"  Foo(1);\n  Foo(2);\n  Foo(3);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["and want to verify that ",(0,s.jsx)(n.code,{children:"Foo(1)"})," and ",(0,s.jsx)(n.code,{children:"Foo(3)"})," both invoke ",(0,s.jsx)(n.code,{children:'mock.Bar("a")'}),", but\n",(0,s.jsx)(n.code,{children:"Foo(2)"})," doesn't invoke anything, you can write:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'using ::testing::MockFunction;\n\nTEST(FooTest, InvokesBarCorrectly) {\n  MyMock mock;\n  // Class MockFunction<F> has exactly one mock method.  It is named\n  // Call() and has type F.\n  MockFunction<void(string check_point_name)> check;\n  {\n    InSequence s;\n\n    EXPECT_CALL(mock, Bar("a"));\n    EXPECT_CALL(check, Call("1"));\n    EXPECT_CALL(check, Call("2"));\n    EXPECT_CALL(mock, Bar("a"));\n  }\n  Foo(1);\n  check.Call("1");\n  Foo(2);\n  check.Call("2");\n  Foo(3);\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The expectation spec says that the first ",(0,s.jsx)(n.code,{children:'Bar("a")'}),' call must happen before\ncheckpoint "1", the second ',(0,s.jsx)(n.code,{children:'Bar("a")'}),' call must happen after checkpoint "2", and\nnothing should happen between the two checkpoints. The explicit checkpoints make\nit clear which ',(0,s.jsx)(n.code,{children:'Bar("a")'})," is called by which call to ",(0,s.jsx)(n.code,{children:"Foo()"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"mocking-destructors",children:"Mocking Destructors"}),"\n",(0,s.jsxs)(n.p,{children:["Sometimes you want to make sure a mock object is destructed at the right time,\ne.g. after ",(0,s.jsx)(n.code,{children:"bar->A()"})," is called but before ",(0,s.jsx)(n.code,{children:"bar->B()"})," is called. We already know\nthat you can specify constraints on the ",(0,s.jsx)(n.a,{href:"#OrderedCalls",children:"order"})," of mock function\ncalls, so all we need to do is to mock the destructor of the mock function."]}),"\n",(0,s.jsxs)(n.p,{children:["This sounds simple, except for one problem: a destructor is a special function\nwith special syntax and special semantics, and the ",(0,s.jsx)(n.code,{children:"MOCK_METHOD"})," macro doesn't\nwork for it:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"MOCK_METHOD(void, ~MockFoo, ());  // Won't compile!\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The good news is that you can use a simple pattern to achieve the same effect.\nFirst, add a mock function ",(0,s.jsx)(n.code,{children:"Die()"})," to your mock class and call it in the\ndestructor, like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class MockFoo : public Foo {\n  ...\n  // Add the following two lines to the mock class.\n  MOCK_METHOD(void, Die, ());\n  ~MockFoo() override { Die(); }\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["(If the name ",(0,s.jsx)(n.code,{children:"Die()"})," clashes with an existing symbol, choose another name.) Now,\nwe have translated the problem of testing when a ",(0,s.jsx)(n.code,{children:"MockFoo"})," object dies to\ntesting when its ",(0,s.jsx)(n.code,{children:"Die()"})," method is called:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"  MockFoo* foo = new MockFoo;\n  MockBar* bar = new MockBar;\n  ...\n  {\n    InSequence s;\n\n    // Expects *foo to die after bar->A() and before bar->B().\n    EXPECT_CALL(*bar, A());\n    EXPECT_CALL(*foo, Die());\n    EXPECT_CALL(*bar, B());\n  }\n"})}),"\n",(0,s.jsx)(n.p,{children:"And that's that."}),"\n",(0,s.jsx)(n.h3,{id:"UsingThreads",children:"Using gMock and Threads"}),"\n",(0,s.jsxs)(n.p,{children:["In a ",(0,s.jsx)(n.strong,{children:"unit"})," test, it's best if you could isolate and test a piece of code in a\nsingle-threaded context. That avoids race conditions and dead locks, and makes\ndebugging your test much easier."]}),"\n",(0,s.jsx)(n.p,{children:"Yet most programs are multi-threaded, and sometimes to test something we need to\npound on it from more than one thread. gMock works for this purpose too."}),"\n",(0,s.jsx)(n.p,{children:"Remember the steps for using a mock:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Create a mock object ",(0,s.jsx)(n.code,{children:"foo"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Set its default actions and expectations using ",(0,s.jsx)(n.code,{children:"ON_CALL()"})," and\n",(0,s.jsx)(n.code,{children:"EXPECT_CALL()"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["The code under test calls methods of ",(0,s.jsx)(n.code,{children:"foo"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"Optionally, verify and reset the mock."}),"\n",(0,s.jsx)(n.li,{children:"Destroy the mock yourself, or let the code under test destroy it. The\ndestructor will automatically verify it."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"If you follow the following simple rules, your mocks and threads can live\nhappily together:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Execute your ",(0,s.jsx)(n.em,{children:"test code"})," (as opposed to the code being tested) in ",(0,s.jsx)(n.em,{children:"one"}),"\nthread. This makes your test easy to follow."]}),"\n",(0,s.jsx)(n.li,{children:"Obviously, you can do step #1 without locking."}),"\n",(0,s.jsxs)(n.li,{children:["When doing step #2 and #5, make sure no other thread is accessing ",(0,s.jsx)(n.code,{children:"foo"}),".\nObvious too, huh?"]}),"\n",(0,s.jsx)(n.li,{children:"#3 and #4 can be done either in one thread or in multiple threads - anyway\nyou want. gMock takes care of the locking, so you don't have to do any -\nunless required by your test logic."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"If you violate the rules (for example, if you set expectations on a mock while\nanother thread is calling its methods), you get undefined behavior. That's not\nfun, so don't do it."}),"\n",(0,s.jsx)(n.p,{children:"gMock guarantees that the action for a mock function is done in the same thread\nthat called the mock function. For example, in"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"  EXPECT_CALL(mock, Foo(1))\n      .WillOnce(action1);\n  EXPECT_CALL(mock, Foo(2))\n      .WillOnce(action2);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["if ",(0,s.jsx)(n.code,{children:"Foo(1)"})," is called in thread 1 and ",(0,s.jsx)(n.code,{children:"Foo(2)"})," is called in thread 2, gMock will\nexecute ",(0,s.jsx)(n.code,{children:"action1"})," in thread 1 and ",(0,s.jsx)(n.code,{children:"action2"})," in thread 2."]}),"\n",(0,s.jsxs)(n.p,{children:["gMock does ",(0,s.jsx)(n.em,{children:"not"})," impose a sequence on actions performed in different threads\n(doing so may create deadlocks as the actions may need to cooperate). This means\nthat the execution of ",(0,s.jsx)(n.code,{children:"action1"})," and ",(0,s.jsx)(n.code,{children:"action2"})," in the above example ",(0,s.jsx)(n.em,{children:"may"}),"\ninterleave. If this is a problem, you should add proper synchronization logic to\n",(0,s.jsx)(n.code,{children:"action1"})," and ",(0,s.jsx)(n.code,{children:"action2"})," to make the test thread-safe."]}),"\n",(0,s.jsxs)(n.p,{children:["Also, remember that ",(0,s.jsx)(n.code,{children:"DefaultValue<T>"})," is a global resource that potentially\naffects ",(0,s.jsx)(n.em,{children:"all"})," living mock objects in your program. Naturally, you won't want to\nmess with it from multiple threads or when there still are mocks in action."]}),"\n",(0,s.jsx)(n.h3,{id:"controlling-how-much-information-gmock-prints",children:"Controlling How Much Information gMock Prints"}),"\n",(0,s.jsx)(n.p,{children:"When gMock sees something that has the potential of being an error (e.g. a mock\nfunction with no expectation is called, a.k.a. an uninteresting call, which is\nallowed but perhaps you forgot to explicitly ban the call), it prints some\nwarning messages, including the arguments of the function, the return value, and\nthe stack trace. Hopefully this will remind you to take a look and see if there\nis indeed a problem."}),"\n",(0,s.jsx)(n.p,{children:"Sometimes you are confident that your tests are correct and may not appreciate\nsuch friendly messages. Some other times, you are debugging your tests or\nlearning about the behavior of the code you are testing, and wish you could\nobserve every mock call that happens (including argument values, the return\nvalue, and the stack trace). Clearly, one size doesn't fit all."}),"\n",(0,s.jsxs)(n.p,{children:["You can control how much gMock tells you using the ",(0,s.jsx)(n.code,{children:"--gmock_verbose=LEVEL"}),"\ncommand-line flag, where ",(0,s.jsx)(n.code,{children:"LEVEL"})," is a string with three possible values:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"info"}),": gMock will print all informational messages, warnings, and errors\n(most verbose). At this setting, gMock will also log any calls to the\n",(0,s.jsx)(n.code,{children:"ON_CALL/EXPECT_CALL"}),' macros. It will include a stack trace in\n"uninteresting call" warnings.']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"warning"}),': gMock will print both warnings and errors (less verbose); it will\nomit the stack traces in "uninteresting call" warnings. This is the default.']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"error"}),": gMock will print errors only (least verbose)."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Alternatively, you can adjust the value of that flag from within your tests like\nso:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'  ::testing::FLAGS_gmock_verbose = "error";\n'})}),"\n",(0,s.jsxs)(n.p,{children:["If you find gMock printing too many stack frames with its informational or\nwarning messages, remember that you can control their amount with the\n",(0,s.jsx)(n.code,{children:"--gtest_stack_trace_depth=max_depth"})," flag."]}),"\n",(0,s.jsx)(n.p,{children:"Now, judiciously use the right flag to enable gMock serve you better!"}),"\n",(0,s.jsx)(n.h3,{id:"gaining-super-vision-into-mock-calls",children:"Gaining Super Vision into Mock Calls"}),"\n",(0,s.jsxs)(n.p,{children:["You have a test using gMock. It fails: gMock tells you some expectations aren't\nsatisfied. However, you aren't sure why: Is there a typo somewhere in the\nmatchers? Did you mess up the order of the ",(0,s.jsx)(n.code,{children:"EXPECT_CALL"}),"s? Or is the code under\ntest doing something wrong? How can you find out the cause?"]}),"\n",(0,s.jsxs)(n.p,{children:["Won't it be nice if you have X-ray vision and can actually see the trace of all\n",(0,s.jsx)(n.code,{children:"EXPECT_CALL"}),"s and mock method calls as they are made? For each call, would you\nlike to see its actual argument values and which ",(0,s.jsx)(n.code,{children:"EXPECT_CALL"})," gMock thinks it\nmatches? If you still need some help to figure out who made these calls, how\nabout being able to see the complete stack trace at each mock call?"]}),"\n",(0,s.jsxs)(n.p,{children:["You can unlock this power by running your test with the ",(0,s.jsx)(n.code,{children:"--gmock_verbose=info"}),"\nflag. For example, given the test program:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include <gmock/gmock.h>\n\nusing ::testing::_;\nusing ::testing::HasSubstr;\nusing ::testing::Return;\n\nclass MockFoo {\n public:\n  MOCK_METHOD(void, F, (const string& x, const string& y));\n};\n\nTEST(Foo, Bar) {\n  MockFoo mock;\n  EXPECT_CALL(mock, F(_, _)).WillRepeatedly(Return());\n  EXPECT_CALL(mock, F("a", "b"));\n  EXPECT_CALL(mock, F("c", HasSubstr("d")));\n\n  mock.F("a", "good");\n  mock.F("a", "b");\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["if you run it with ",(0,s.jsx)(n.code,{children:"--gmock_verbose=info"}),", you will see this output:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:'[ RUN       ] Foo.Bar\n\nfoo_test.cc:14: EXPECT_CALL(mock, F(_, _)) invoked\nStack trace: ...\n\nfoo_test.cc:15: EXPECT_CALL(mock, F("a", "b")) invoked\nStack trace: ...\n\nfoo_test.cc:16: EXPECT_CALL(mock, F("c", HasSubstr("d"))) invoked\nStack trace: ...\n\nfoo_test.cc:14: Mock function call matches EXPECT_CALL(mock, F(_, _))...\n    Function call: F(@0x7fff7c8dad40"a",@0x7fff7c8dad10"good")\nStack trace: ...\n\nfoo_test.cc:15: Mock function call matches EXPECT_CALL(mock, F("a", "b"))...\n    Function call: F(@0x7fff7c8dada0"a",@0x7fff7c8dad70"b")\nStack trace: ...\n\nfoo_test.cc:16: Failure\nActual function call count doesn\'t match EXPECT_CALL(mock, F("c", HasSubstr("d")))...\n         Expected: to be called once\n           Actual: never called - unsatisfied and active\n[  FAILED  ] Foo.Bar\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Suppose the bug is that the ",(0,s.jsx)(n.code,{children:'"c"'})," in the third ",(0,s.jsx)(n.code,{children:"EXPECT_CALL"})," is a typo and\nshould actually be ",(0,s.jsx)(n.code,{children:'"a"'}),". With the above message, you should see that the actual\n",(0,s.jsx)(n.code,{children:'F("a", "good")'})," call is matched by the first ",(0,s.jsx)(n.code,{children:"EXPECT_CALL"}),", not the third as\nyou thought. From that it should be obvious that the third ",(0,s.jsx)(n.code,{children:"EXPECT_CALL"})," is\nwritten wrong. Case solved."]}),"\n",(0,s.jsxs)(n.p,{children:["If you are interested in the mock call trace but not the stack traces, you can\ncombine ",(0,s.jsx)(n.code,{children:"--gmock_verbose=info"})," with ",(0,s.jsx)(n.code,{children:"--gtest_stack_trace_depth=0"})," on the test\ncommand line."]}),"\n",(0,s.jsx)(n.h3,{id:"running-tests-in-emacs",children:"Running Tests in Emacs"}),"\n",(0,s.jsxs)(n.p,{children:["If you build and run your tests in Emacs using the ",(0,s.jsx)(n.code,{children:"M-x google-compile"})," command\n(as many googletest users do), the source file locations of gMock and googletest\nerrors will be highlighted. Just press ",(0,s.jsx)(n.code,{children:"<Enter>"})," on one of them and you'll be\ntaken to the offending line. Or, you can just type `C-x`` to jump to the next\nerror."]}),"\n",(0,s.jsxs)(n.p,{children:["To make it even easier, you can add the following lines to your ",(0,s.jsx)(n.code,{children:"~/.emacs"})," file:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"(global-set-key \"\\M-m\"  'google-compile)  ; m is for make\n(global-set-key [M-down] 'next-error)\n(global-set-key [M-up]  '(lambda () (interactive) (next-error -1)))\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Then you can type ",(0,s.jsx)(n.code,{children:"M-m"})," to start a build (if you want to run the test as well,\njust make sure ",(0,s.jsx)(n.code,{children:"foo_test.run"})," or ",(0,s.jsx)(n.code,{children:"runtests"})," is in the build command you supply\nafter typing ",(0,s.jsx)(n.code,{children:"M-m"}),"), or ",(0,s.jsx)(n.code,{children:"M-up"}),"/",(0,s.jsx)(n.code,{children:"M-down"})," to move back and forth between errors."]}),"\n",(0,s.jsx)(n.h2,{id:"extending-gmock",children:"Extending gMock"}),"\n",(0,s.jsx)(n.h3,{id:"NewMatchers",children:"Writing New Matchers Quickly"}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsxs)(n.p,{children:["WARNING: gMock does not guarantee when or how many times a matcher will be\ninvoked. Therefore, all matchers must be functionally pure. See\n",(0,s.jsx)(n.a,{href:"#PureMatchers",children:"this section"})," for more details."]})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"MATCHER*"})," family of macros can be used to define custom matchers easily.\nThe syntax:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"MATCHER(name, description_string_expression) { statements; }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["will define a matcher with the given name that executes the statements, which\nmust return a ",(0,s.jsx)(n.code,{children:"bool"})," to indicate if the match succeeds. Inside the statements,\nyou can refer to the value being matched by ",(0,s.jsx)(n.code,{children:"arg"}),", and refer to its type by\n",(0,s.jsx)(n.code,{children:"arg_type"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"description string"})," is a ",(0,s.jsx)(n.code,{children:"string"}),"-typed expression that documents what the\nmatcher does, and is used to generate the failure message when the match fails.\nIt can (and should) reference the special ",(0,s.jsx)(n.code,{children:"bool"})," variable ",(0,s.jsx)(n.code,{children:"negation"}),", and should\nevaluate to the description of the matcher when ",(0,s.jsx)(n.code,{children:"negation"})," is ",(0,s.jsx)(n.code,{children:"false"}),", or that\nof the matcher's negation when ",(0,s.jsx)(n.code,{children:"negation"})," is ",(0,s.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["For convenience, we allow the description string to be empty (",(0,s.jsx)(n.code,{children:'""'}),"), in which\ncase gMock will use the sequence of words in the matcher name as the\ndescription."]}),"\n",(0,s.jsx)(n.h4,{id:"basic-example",children:"Basic Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'MATCHER(IsDivisibleBy7, "") { return (arg % 7) == 0; }\n'})}),"\n",(0,s.jsx)(n.p,{children:"allows you to write"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"  // Expects mock_foo.Bar(n) to be called where n is divisible by 7.\n  EXPECT_CALL(mock_foo, Bar(IsDivisibleBy7()));\n"})}),"\n",(0,s.jsx)(n.p,{children:"or,"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"  using ::testing::Not;\n  ...\n  // Verifies that a value is divisible by 7 and the other is not.\n  EXPECT_THAT(some_expression, IsDivisibleBy7());\n  EXPECT_THAT(some_other_expression, Not(IsDivisibleBy7()));\n"})}),"\n",(0,s.jsx)(n.p,{children:"If the above assertions fail, they will print something like:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"  Value of: some_expression\n  Expected: is divisible by 7\n    Actual: 27\n  ...\n  Value of: some_other_expression\n  Expected: not (is divisible by 7)\n    Actual: 21\n"})}),"\n",(0,s.jsxs)(n.p,{children:["where the descriptions ",(0,s.jsx)(n.code,{children:'"is divisible by 7"'})," and ",(0,s.jsx)(n.code,{children:'"not (is divisible by 7)"'})," are\nautomatically calculated from the matcher name ",(0,s.jsx)(n.code,{children:"IsDivisibleBy7"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"adding-custom-failure-messages",children:"Adding Custom Failure Messages"}),"\n",(0,s.jsxs)(n.p,{children:["As you may have noticed, the auto-generated descriptions (especially those for\nthe negation) may not be so great. You can always override them with a ",(0,s.jsx)(n.code,{children:"string"}),"\nexpression of your own:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'MATCHER(IsDivisibleBy7,\n        absl::StrCat(negation ? "isn\'t" : "is", " divisible by 7")) {\n  return (arg % 7) == 0;\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Optionally, you can stream additional information to a hidden argument named\n",(0,s.jsx)(n.code,{children:"result_listener"})," to explain the match result. For example, a better definition\nof ",(0,s.jsx)(n.code,{children:"IsDivisibleBy7"})," is:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'MATCHER(IsDivisibleBy7, "") {\n  if ((arg % 7) == 0)\n    return true;\n\n  *result_listener << "the remainder is " << (arg % 7);\n  return false;\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"With this definition, the above assertion will give a better message:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"  Value of: some_expression\n  Expected: is divisible by 7\n    Actual: 27 (the remainder is 6)\n"})}),"\n",(0,s.jsx)(n.h4,{id:"using-expect_-statements-in-matchers",children:"Using EXPECT_ Statements in Matchers"}),"\n",(0,s.jsxs)(n.p,{children:["You can also use ",(0,s.jsx)(n.code,{children:"EXPECT_..."})," statements inside custom matcher definitions. In\nmany cases, this allows you to write your matcher more concisely while still\nproviding an informative error message. For example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'MATCHER(IsDivisibleBy7, "") {\n  const auto remainder = arg % 7;\n  EXPECT_EQ(remainder, 0);\n  return true;\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["If you write a test that includes the line ",(0,s.jsx)(n.code,{children:"EXPECT_THAT(27, IsDivisibleBy7());"}),",\nyou will get an error something like the following:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Expected equality of these values:\n  remainder\n    Which is: 6\n  0\n"})}),"\n",(0,s.jsx)(n.h4,{id:"matchandexplain",children:(0,s.jsx)(n.code,{children:"MatchAndExplain"})}),"\n",(0,s.jsxs)(n.p,{children:["You should let ",(0,s.jsx)(n.code,{children:"MatchAndExplain()"})," print ",(0,s.jsx)(n.em,{children:"any additional information"})," that can\nhelp a user understand the match result. Note that it should explain why the\nmatch succeeds in case of a success (unless it's obvious) - this is useful when\nthe matcher is used inside ",(0,s.jsx)(n.code,{children:"Not()"}),". There is no need to print the argument value\nitself, as gMock already prints it for you."]}),"\n",(0,s.jsx)(n.h4,{id:"argument-types",children:"Argument Types"}),"\n",(0,s.jsxs)(n.p,{children:["The type of the value being matched (",(0,s.jsx)(n.code,{children:"arg_type"}),") is determined by the context in\nwhich you use the matcher and is supplied to you by the compiler, so you don't\nneed to worry about declaring it (nor can you). This allows the matcher to be\npolymorphic. For example, ",(0,s.jsx)(n.code,{children:"IsDivisibleBy7()"})," can be used to match any type where\nthe value of ",(0,s.jsx)(n.code,{children:"(arg % 7) == 0"})," can be implicitly converted to a ",(0,s.jsx)(n.code,{children:"bool"}),". In the\n",(0,s.jsx)(n.code,{children:"Bar(IsDivisibleBy7())"})," example above, if method ",(0,s.jsx)(n.code,{children:"Bar()"})," takes an ",(0,s.jsx)(n.code,{children:"int"}),",\n",(0,s.jsx)(n.code,{children:"arg_type"})," will be ",(0,s.jsx)(n.code,{children:"int"}),"; if it takes an ",(0,s.jsx)(n.code,{children:"unsigned long"}),", ",(0,s.jsx)(n.code,{children:"arg_type"})," will be\n",(0,s.jsx)(n.code,{children:"unsigned long"}),"; and so on."]}),"\n",(0,s.jsx)(n.h3,{id:"writing-new-parameterized-matchers-quickly",children:"Writing New Parameterized Matchers Quickly"}),"\n",(0,s.jsx)(n.p,{children:"Sometimes you'll want to define a matcher that has parameters. For that you can\nuse the macro:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"MATCHER_P(name, param_name, description_string) { statements; }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["where the description string can be either ",(0,s.jsx)(n.code,{children:'""'})," or a ",(0,s.jsx)(n.code,{children:"string"})," expression that\nreferences ",(0,s.jsx)(n.code,{children:"negation"})," and ",(0,s.jsx)(n.code,{children:"param_name"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'MATCHER_P(HasAbsoluteValue, value, "") { return abs(arg) == value; }\n'})}),"\n",(0,s.jsx)(n.p,{children:"will allow you to write:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'  EXPECT_THAT(Blah("a"), HasAbsoluteValue(n));\n'})}),"\n",(0,s.jsxs)(n.p,{children:["which may lead to this message (assuming ",(0,s.jsx)(n.code,{children:"n"})," is 10):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:'  Value of: Blah("a")\n  Expected: has absolute value 10\n    Actual: -9\n'})}),"\n",(0,s.jsx)(n.p,{children:"Note that both the matcher description and its parameter are printed, making the\nmessage human-friendly."}),"\n",(0,s.jsxs)(n.p,{children:["In the matcher definition body, you can write ",(0,s.jsx)(n.code,{children:"foo_type"})," to reference the type\nof a parameter named ",(0,s.jsx)(n.code,{children:"foo"}),". For example, in the body of\n",(0,s.jsx)(n.code,{children:"MATCHER_P(HasAbsoluteValue, value)"})," above, you can write ",(0,s.jsx)(n.code,{children:"value_type"})," to refer\nto the type of ",(0,s.jsx)(n.code,{children:"value"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["gMock also provides ",(0,s.jsx)(n.code,{children:"MATCHER_P2"}),", ",(0,s.jsx)(n.code,{children:"MATCHER_P3"}),", ..., up to ",(0,s.jsx)(n.code,{children:"MATCHER_P10"})," to\nsupport multi-parameter matchers:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"MATCHER_Pk(name, param_1, ..., param_k, description_string) { statements; }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Please note that the custom description string is for a particular ",(0,s.jsx)(n.em,{children:"instance"})," of\nthe matcher, where the parameters have been bound to actual values. Therefore\nusually you'll want the parameter values to be part of the description. gMock\nlets you do that by referencing the matcher parameters in the description string\nexpression."]}),"\n",(0,s.jsx)(n.p,{children:"For example,"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'using ::testing::PrintToString;\nMATCHER_P2(InClosedRange, low, hi,\n           absl::StrFormat("%s in range [%s, %s]", negation ? "isn\'t" : "is",\n                           PrintToString(low), PrintToString(hi))) {\n  return low <= arg && arg <= hi;\n}\n...\nEXPECT_THAT(3, InClosedRange(4, 6));\n'})}),"\n",(0,s.jsx)(n.p,{children:"would generate a failure that contains the message:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"  Expected: is in range [4, 6]\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If you specify ",(0,s.jsx)(n.code,{children:'""'})," as the description, the failure message will contain the\nsequence of words in the matcher name followed by the parameter values printed\nas a tuple. For example,"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'  MATCHER_P2(InClosedRange, low, hi, "") { ... }\n  ...\n  EXPECT_THAT(3, InClosedRange(4, 6));\n'})}),"\n",(0,s.jsx)(n.p,{children:"would generate a failure that contains the text:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"  Expected: in closed range (4, 6)\n"})}),"\n",(0,s.jsx)(n.p,{children:"For the purpose of typing, you can view"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"MATCHER_Pk(Foo, p1, ..., pk, description_string) { ... }\n"})}),"\n",(0,s.jsx)(n.p,{children:"as shorthand for"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"template <typename p1_type, ..., typename pk_type>\nFooMatcherPk<p1_type, ..., pk_type>\nFoo(p1_type p1, ..., pk_type pk) { ... }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["When you write ",(0,s.jsx)(n.code,{children:"Foo(v1, ..., vk)"}),", the compiler infers the types of the\nparameters ",(0,s.jsx)(n.code,{children:"v1"}),", ..., and ",(0,s.jsx)(n.code,{children:"vk"})," for you. If you are not happy with the result of\nthe type inference, you can specify the types by explicitly instantiating the\ntemplate, as in ",(0,s.jsx)(n.code,{children:"Foo<long, bool>(5, false)"}),". As said earlier, you don't get to\n(or need to) specify ",(0,s.jsx)(n.code,{children:"arg_type"})," as that's determined by the context in which the\nmatcher is used."]}),"\n",(0,s.jsxs)(n.p,{children:["You can assign the result of expression ",(0,s.jsx)(n.code,{children:"Foo(p1, ..., pk)"})," to a variable of type\n",(0,s.jsx)(n.code,{children:"FooMatcherPk<p1_type, ..., pk_type>"}),". This can be useful when composing\nmatchers. Matchers that don't have a parameter or have only one parameter have\nspecial types: you can assign ",(0,s.jsx)(n.code,{children:"Foo()"})," to a ",(0,s.jsx)(n.code,{children:"FooMatcher"}),"-typed variable, and\nassign ",(0,s.jsx)(n.code,{children:"Foo(p)"})," to a ",(0,s.jsx)(n.code,{children:"FooMatcherP<p_type>"}),"-typed variable."]}),"\n",(0,s.jsx)(n.p,{children:"While you can instantiate a matcher template with reference types, passing the\nparameters by pointer usually makes your code more readable. If, however, you\nstill want to pass a parameter by reference, be aware that in the failure\nmessage generated by the matcher you will see the value of the referenced object\nbut not its address."}),"\n",(0,s.jsx)(n.p,{children:"You can overload matchers with different numbers of parameters:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"MATCHER_P(Blah, a, description_string_1) { ... }\nMATCHER_P2(Blah, a, b, description_string_2) { ... }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["While it's tempting to always use the ",(0,s.jsx)(n.code,{children:"MATCHER*"})," macros when defining a new\nmatcher, you should also consider implementing the matcher interface directly\ninstead (see the recipes that follow), especially if you need to use the matcher\na lot. While these approaches require more work, they give you more control on\nthe types of the value being matched and the matcher parameters, which in\ngeneral leads to better compiler error messages that pay off in the long run.\nThey also allow overloading matchers based on parameter types (as opposed to\njust based on the number of parameters)."]}),"\n",(0,s.jsx)(n.h3,{id:"writing-new-monomorphic-matchers",children:"Writing New Monomorphic Matchers"}),"\n",(0,s.jsxs)(n.p,{children:["A matcher of type ",(0,s.jsx)(n.code,{children:"testing::Matcher<T>"})," implements the matcher interface for ",(0,s.jsx)(n.code,{children:"T"}),"\nand does two things: it tests whether a value of type ",(0,s.jsx)(n.code,{children:"T"})," matches the matcher,\nand can describe what kind of values it matches. The latter ability is used for\ngenerating readable error messages when expectations are violated. Some matchers\ncan even explain why it matches or doesn't match a certain value, which can be\nhelpful when the reason isn't obvious."]}),"\n",(0,s.jsxs)(n.p,{children:["Because a matcher of type ",(0,s.jsx)(n.code,{children:"testing::Matcher<T>"})," for a particular type ",(0,s.jsx)(n.code,{children:"T"})," can\nonly be used to match a value of type ",(0,s.jsx)(n.code,{children:"T"}),', we call it "monomorphic."']}),"\n",(0,s.jsxs)(n.p,{children:["A matcher of ",(0,s.jsx)(n.code,{children:"T"})," must declare a typedef like:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using is_gtest_matcher = void;\n"})}),"\n",(0,s.jsx)(n.p,{children:"and supports the following operations:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Match a value and optionally explain into an ostream.\nbool matched = matcher.MatchAndExplain(value, maybe_os);\n// where `value` is of type `T` and\n// `maybe_os` is of type `std::ostream*`, where it can be null if the caller\n// is not interested in there textual explanation.\n\nmatcher.DescribeTo(os);\nmatcher.DescribeNegationTo(os);\n// where `os` is of type `std::ostream*`.\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If you need a custom matcher but ",(0,s.jsx)(n.code,{children:"Truly()"})," is not a good option (for example,\nyou may not be happy with the way ",(0,s.jsx)(n.code,{children:"Truly(predicate)"})," describes itself, or you\nmay want your matcher to be polymorphic as ",(0,s.jsx)(n.code,{children:"Eq(value)"})," is), you can define a\nmatcher to do whatever you want in two steps: first implement the matcher\ninterface, and then define a factory function to create a matcher instance. The\nsecond step is not strictly needed but it makes the syntax of using the matcher\nnicer."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, you can define a matcher to test whether an ",(0,s.jsx)(n.code,{children:"int"})," is divisible by 7\nand then use it like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'using ::testing::Matcher;\n\nclass DivisibleBy7Matcher {\n public:\n  using is_gtest_matcher = void;\n\n  bool MatchAndExplain(int n, std::ostream*) const {\n    return (n % 7) == 0;\n  }\n\n  void DescribeTo(std::ostream* os) const {\n    *os << "is divisible by 7";\n  }\n\n  void DescribeNegationTo(std::ostream* os) const {\n    *os << "is not divisible by 7";\n  }\n};\n\nMatcher<int> DivisibleBy7() {\n  return DivisibleBy7Matcher();\n}\n\n...\n  EXPECT_CALL(foo, Bar(DivisibleBy7()));\n'})}),"\n",(0,s.jsxs)(n.p,{children:["You may improve the matcher message by streaming additional information to the\n",(0,s.jsx)(n.code,{children:"os"})," argument in ",(0,s.jsx)(n.code,{children:"MatchAndExplain()"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'class DivisibleBy7Matcher {\n public:\n  bool MatchAndExplain(int n, std::ostream* os) const {\n    const int remainder = n % 7;\n    if (remainder != 0 && os != nullptr) {\n      *os << "the remainder is " << remainder;\n    }\n    return remainder == 0;\n  }\n  ...\n};\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Then, ",(0,s.jsx)(n.code,{children:"EXPECT_THAT(x, DivisibleBy7());"})," may generate a message like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Value of: x\nExpected: is divisible by 7\n  Actual: 23 (the remainder is 2)\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["Tip: for convenience, ",(0,s.jsx)(n.code,{children:"MatchAndExplain()"})," can take a ",(0,s.jsx)(n.code,{children:"MatchResultListener*"}),"\ninstead of ",(0,s.jsx)(n.code,{children:"std::ostream*"}),"."]})}),"\n",(0,s.jsx)(n.h3,{id:"writing-new-polymorphic-matchers",children:"Writing New Polymorphic Matchers"}),"\n",(0,s.jsxs)(n.p,{children:["Unlike a monomorphic matcher, which can only be used to match a value of a\nparticular type, a ",(0,s.jsx)(n.em,{children:"polymorphic"})," matcher is one that can be used to match values\nof multiple types. For example, ",(0,s.jsx)(n.code,{children:"Eq(5)"})," is a polymorhpic matcher as it can be\nused to match an ",(0,s.jsx)(n.code,{children:"int"}),", a ",(0,s.jsx)(n.code,{children:"double"}),", a ",(0,s.jsx)(n.code,{children:"float"}),", and so on. You should think of a\npolymorphic matcher as a ",(0,s.jsx)(n.em,{children:"matcher factory"})," as opposed to a\n",(0,s.jsx)(n.code,{children:"testing::Matcher<SomeType>"})," - itself is not an actual matcher, but can be\nimplicitly converted to a ",(0,s.jsx)(n.code,{children:"testing::Matcher<SomeType>"})," depending on the context."]}),"\n",(0,s.jsx)(n.p,{children:"Expanding what we learned above to polymorphic matchers is now as simple as\nadding templates in the right place."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'\nclass NotNullMatcher {\n public:\n  using is_gtest_matcher = void;\n\n  // To implement a polymorphic matcher, we just need to make MatchAndExplain a\n  // template on its first argument.\n\n  // In this example, we want to use NotNull() with any pointer, so\n  // MatchAndExplain() accepts a pointer of any type as its first argument.\n  // In general, you can define MatchAndExplain() as an ordinary method or\n  // a method template, or even overload it.\n  template <typename T>\n  bool MatchAndExplain(T* p, std::ostream*) const {\n    return p != nullptr;\n  }\n\n  // Describes the property of a value matching this matcher.\n  void DescribeTo(std::ostream* os) const { *os << "is not NULL"; }\n\n  // Describes the property of a value NOT matching this matcher.\n  void DescribeNegationTo(std::ostream* os) const { *os << "is NULL"; }\n};\n\nNotNullMatcher NotNull() {\n  return NotNullMatcher();\n}\n\n...\n\n  EXPECT_CALL(foo, Bar(NotNull()));  // The argument must be a non-NULL pointer.\n'})}),"\n",(0,s.jsx)(n.h3,{id:"legacy-matcher-implementation",children:"Legacy Matcher Implementation"}),"\n",(0,s.jsxs)(n.p,{children:["Defining matchers used to be somewhat more complicated, in which it required\nseveral supporting classes and virtual functions. To implement a matcher for\ntype ",(0,s.jsx)(n.code,{children:"T"})," using the legacy API you have to derive from ",(0,s.jsx)(n.code,{children:"MatcherInterface<T>"})," and\ncall ",(0,s.jsx)(n.code,{children:"MakeMatcher"})," to construct the object."]}),"\n",(0,s.jsx)(n.p,{children:"The interface looks like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class MatchResultListener {\n public:\n  ...\n  // Streams x to the underlying ostream; does nothing if the ostream\n  // is NULL.\n  template <typename T>\n  MatchResultListener& operator<<(const T& x);\n\n  // Returns the underlying ostream.\n  std::ostream* stream();\n};\n\ntemplate <typename T>\nclass MatcherInterface {\n public:\n  virtual ~MatcherInterface();\n\n  // Returns true if and only if the matcher matches x; also explains the match\n  // result to 'listener'.\n  virtual bool MatchAndExplain(T x, MatchResultListener* listener) const = 0;\n\n  // Describes this matcher to an ostream.\n  virtual void DescribeTo(std::ostream* os) const = 0;\n\n  // Describes the negation of this matcher to an ostream.\n  virtual void DescribeNegationTo(std::ostream* os) const;\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Fortunately, most of the time you can define a polymorphic matcher easily with\nthe help of ",(0,s.jsx)(n.code,{children:"MakePolymorphicMatcher()"}),". Here's how you can define ",(0,s.jsx)(n.code,{children:"NotNull()"})," as\nan example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'using ::testing::MakePolymorphicMatcher;\nusing ::testing::MatchResultListener;\nusing ::testing::PolymorphicMatcher;\n\nclass NotNullMatcher {\n public:\n  // To implement a polymorphic matcher, first define a COPYABLE class\n  // that has three members MatchAndExplain(), DescribeTo(), and\n  // DescribeNegationTo(), like the following.\n\n  // In this example, we want to use NotNull() with any pointer, so\n  // MatchAndExplain() accepts a pointer of any type as its first argument.\n  // In general, you can define MatchAndExplain() as an ordinary method or\n  // a method template, or even overload it.\n  template <typename T>\n  bool MatchAndExplain(T* p,\n                       MatchResultListener* /* listener */) const {\n    return p != NULL;\n  }\n\n  // Describes the property of a value matching this matcher.\n  void DescribeTo(std::ostream* os) const { *os << "is not NULL"; }\n\n  // Describes the property of a value NOT matching this matcher.\n  void DescribeNegationTo(std::ostream* os) const { *os << "is NULL"; }\n};\n\n// To construct a polymorphic matcher, pass an instance of the class\n// to MakePolymorphicMatcher().  Note the return type.\nPolymorphicMatcher<NotNullMatcher> NotNull() {\n  return MakePolymorphicMatcher(NotNullMatcher());\n}\n\n...\n\n  EXPECT_CALL(foo, Bar(NotNull()));  // The argument must be a non-NULL pointer.\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"})," Your polymorphic matcher class does ",(0,s.jsx)(n.strong,{children:"not"})," need to inherit from\n",(0,s.jsx)(n.code,{children:"MatcherInterface"})," or any other class, and its methods do ",(0,s.jsx)(n.strong,{children:"not"})," need to be\nvirtual."]})}),"\n",(0,s.jsxs)(n.p,{children:["Like in a monomorphic matcher, you may explain the match result by streaming\nadditional information to the ",(0,s.jsx)(n.code,{children:"listener"})," argument in ",(0,s.jsx)(n.code,{children:"MatchAndExplain()"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"CompositeMatchers",children:"Implementing Composite Matchers"}),"\n",(0,s.jsxs)(n.p,{children:["Sometimes we want to define a matcher that takes other matchers as parameters.\nFor example, ",(0,s.jsx)(n.code,{children:"DistanceFrom(target, m)"})," is a polymorphic matcher that takes a\nmatcher ",(0,s.jsx)(n.code,{children:"m"})," as a parameter. It tests that the distance from ",(0,s.jsx)(n.code,{children:"target"})," to the\nvalue being matched satisfies sub-matcher ",(0,s.jsx)(n.code,{children:"m"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["If you are implementing such a composite matcher, you'll need to generate the\ndescription of the matcher based on the description(s) of its sub-matcher(s).\nYou can see the implementation of ",(0,s.jsx)(n.code,{children:"DistanceFrom()"})," in\n",(0,s.jsx)(n.code,{children:"googlemock/include/gmock/gmock-matchers.h"})," for an example. In particular, pay\nattention to ",(0,s.jsx)(n.code,{children:"DistanceFromMatcherImpl"}),". Notice that it stores the sub-matcher as\na ",(0,s.jsx)(n.code,{children:"const Matcher<const Distance&> distance_matcher_"})," instead of a polymorphic\nmatcher - this allows it to call ",(0,s.jsx)(n.code,{children:"distance_matcher_.DescribeTo(os)"})," to describe\nthe sub-matcher. If the sub-matcher is stored as a polymorphic matcher instead,\nit would not be possible to get its description as in general polymorphic\nmatchers don't know how to describe themselves - they are matcher factories\ninstead of actual matchers; only after being converted to ",(0,s.jsx)(n.code,{children:"Matcher<SomeType>"}),"\ncan they be described."]}),"\n",(0,s.jsx)(n.h3,{id:"writing-new-cardinalities",children:"Writing New Cardinalities"}),"\n",(0,s.jsxs)(n.p,{children:["A cardinality is used in ",(0,s.jsx)(n.code,{children:"Times()"})," to tell gMock how many times you expect a\ncall to occur. It doesn't have to be exact. For example, you can say\n",(0,s.jsx)(n.code,{children:"AtLeast(5)"})," or ",(0,s.jsx)(n.code,{children:"Between(2, 4)"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["If the ",(0,s.jsx)(n.a,{href:"/cppdev/docs/foundamentals/testing/gt/gmock_cheat_sheet#CardinalityList",children:"built-in set"})," of cardinalities\ndoesn't suit you, you are free to define your own by implementing the following\ninterface (in namespace ",(0,s.jsx)(n.code,{children:"testing"}),"):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class CardinalityInterface {\n public:\n  virtual ~CardinalityInterface();\n\n  // Returns true if and only if call_count calls will satisfy this cardinality.\n  virtual bool IsSatisfiedByCallCount(int call_count) const = 0;\n\n  // Returns true if and only if call_count calls will saturate this\n  // cardinality.\n  virtual bool IsSaturatedByCallCount(int call_count) const = 0;\n\n  // Describes self to an ostream.\n  virtual void DescribeTo(std::ostream* os) const = 0;\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"For example, to specify that a call must occur even number of times, you can\nwrite"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'using ::testing::Cardinality;\nusing ::testing::CardinalityInterface;\nusing ::testing::MakeCardinality;\n\nclass EvenNumberCardinality : public CardinalityInterface {\n public:\n  bool IsSatisfiedByCallCount(int call_count) const override {\n    return (call_count % 2) == 0;\n  }\n\n  bool IsSaturatedByCallCount(int call_count) const override {\n    return false;\n  }\n\n  void DescribeTo(std::ostream* os) const {\n    *os << "called even number of times";\n  }\n};\n\nCardinality EvenNumber() {\n  return MakeCardinality(new EvenNumberCardinality);\n}\n\n...\n  EXPECT_CALL(foo, Bar(3))\n      .Times(EvenNumber());\n'})}),"\n",(0,s.jsx)(n.h3,{id:"QuickNewActions",children:"Writing New Actions"}),"\n",(0,s.jsx)(n.p,{children:"If the built-in actions don't work for you, you can easily define your own one.\nAll you need is a call operator with a signature compatible with the mocked\nfunction. So you can use a lambda:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"MockFunction<int(int)> mock;\nEXPECT_CALL(mock, Call).WillOnce([](const int input) { return input * 7; });\nEXPECT_EQ(mock.AsStdFunction()(2), 14);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Or a struct with a call operator (even a templated one):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"struct MultiplyBy {\n  template <typename T>\n  T operator()(T arg) { return arg * multiplier; }\n\n  int multiplier;\n};\n\n// Then use:\n// EXPECT_CALL(...).WillOnce(MultiplyBy{7});\n"})}),"\n",(0,s.jsx)(n.p,{children:"It's also fine for the callable to take no arguments, ignoring the arguments\nsupplied to the mock function:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"MockFunction<int(int)> mock;\nEXPECT_CALL(mock, Call).WillOnce([] { return 17; });\nEXPECT_EQ(mock.AsStdFunction()(0), 17);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["When used with ",(0,s.jsx)(n.code,{children:"WillOnce"}),", the callable can assume it will be called at most\nonce and is allowed to be a move-only type:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// An action that contains move-only types and has an &&-qualified operator,\n// demanding in the type system that it be called at most once. This can be\n// used with WillOnce, but the compiler will reject it if handed to\n// WillRepeatedly.\nstruct MoveOnlyAction {\n  std::unique_ptr<int> move_only_state;\n  std::unique_ptr<int> operator()() && { return std::move(move_only_state); }\n};\n\nMockFunction<std::unique_ptr<int>()> mock;\nEXPECT_CALL(mock, Call).WillOnce(MoveOnlyAction{std::make_unique<int>(17)});\nEXPECT_THAT(mock.AsStdFunction()(), Pointee(Eq(17)));\n"})}),"\n",(0,s.jsxs)(n.p,{children:["More generally, to use with a mock function whose signature is ",(0,s.jsx)(n.code,{children:"R(Args...)"})," the\nobject can be anything convertible to ",(0,s.jsx)(n.code,{children:"OnceAction<R(Args...)>"})," or\n",(0,s.jsx)(n.code,{children:"Action<R(Args...)"}),">. The difference between the two is that ",(0,s.jsx)(n.code,{children:"OnceAction"})," has\nweaker requirements (",(0,s.jsx)(n.code,{children:"Action"})," requires a copy-constructible input that can be\ncalled repeatedly whereas ",(0,s.jsx)(n.code,{children:"OnceAction"})," requires only move-constructible and\nsupports ",(0,s.jsx)(n.code,{children:"&&"}),"-qualified call operators), but can be used only with ",(0,s.jsx)(n.code,{children:"WillOnce"}),".\n",(0,s.jsx)(n.code,{children:"OnceAction"})," is typically relevant only when supporting move-only types or\nactions that want a type-system guarantee that they will be called at most once."]}),"\n",(0,s.jsxs)(n.p,{children:["Typically the ",(0,s.jsx)(n.code,{children:"OnceAction"})," and ",(0,s.jsx)(n.code,{children:"Action"})," templates need not be referenced\ndirectly in your actions: a struct or class with a call operator is sufficient,\nas in the examples above. But fancier polymorphic actions that need to know the\nspecific return type of the mock function can define templated conversion\noperators to make that possible. See ",(0,s.jsx)(n.code,{children:"gmock-actions.h"})," for examples."]}),"\n",(0,s.jsx)(n.h4,{id:"legacy-macro-based-actions",children:"Legacy macro-based Actions"}),"\n",(0,s.jsxs)(n.p,{children:["Before C++11, the functor-based actions were not supported; the old way of\nwriting actions was through a set of ",(0,s.jsx)(n.code,{children:"ACTION*"})," macros. We suggest to avoid them\nin new code; they hide a lot of logic behind the macro, potentially leading to\nharder-to-understand compiler errors. Nevertheless, we cover them here for\ncompleteness."]}),"\n",(0,s.jsx)(n.p,{children:"By writing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"ACTION(name) { statements; }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["in a namespace scope (i.e. not inside a class or function), you will define an\naction with the given name that executes the statements. The value returned by\n",(0,s.jsx)(n.code,{children:"statements"})," will be used as the return value of the action. Inside the\nstatements, you can refer to the K-th (0-based) argument of the mock function as\n",(0,s.jsx)(n.code,{children:"argK"}),". For example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"ACTION(IncrementArg1) { return ++(*arg1); }\n"})}),"\n",(0,s.jsx)(n.p,{children:"allows you to write"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"... WillOnce(IncrementArg1());\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Note that you don't need to specify the types of the mock function arguments.\nRest assured that your code is type-safe though: you'll get a compiler error if\n",(0,s.jsx)(n.code,{children:"*arg1"})," doesn't support the ",(0,s.jsx)(n.code,{children:"++"})," operator, or if the type of ",(0,s.jsx)(n.code,{children:"++(*arg1)"})," isn't\ncompatible with the mock function's return type."]}),"\n",(0,s.jsx)(n.p,{children:"Another example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"ACTION(Foo) {\n  (*arg2)(5);\n  Blah();\n  *arg1 = 0;\n  return arg0;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["defines an action ",(0,s.jsx)(n.code,{children:"Foo()"})," that invokes argument #2 (a function pointer) with 5,\ncalls function ",(0,s.jsx)(n.code,{children:"Blah()"}),", sets the value pointed to by argument #1 to 0, and\nreturns argument #0."]}),"\n",(0,s.jsxs)(n.p,{children:["For more convenience and flexibility, you can also use the following pre-defined\nsymbols in the body of ",(0,s.jsx)(n.code,{children:"ACTION"}),":"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"argK_type"})}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"The type of the K-th (0-based) argument of the mock function"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"args"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"All arguments of the mock function as a tuple"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"args_type"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"The type of all arguments of the mock function as a tuple"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"return_type"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"The return type of the mock function"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"function_type"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"The type of the mock function"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["For example, when using an ",(0,s.jsx)(n.code,{children:"ACTION"})," as a stub action for mock function:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"int DoSomething(bool flag, int* ptr);\n"})}),"\n",(0,s.jsx)(n.p,{children:"we have:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Pre-defined Symbol"}),(0,s.jsx)(n.th,{children:"Is Bound To"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"arg0"})}),(0,s.jsxs)(n.td,{children:["the value of ",(0,s.jsx)(n.code,{children:"flag"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"arg0_type"})}),(0,s.jsxs)(n.td,{children:["the type ",(0,s.jsx)(n.code,{children:"bool"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"arg1"})}),(0,s.jsxs)(n.td,{children:["the value of ",(0,s.jsx)(n.code,{children:"ptr"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"arg1_type"})}),(0,s.jsxs)(n.td,{children:["the type ",(0,s.jsx)(n.code,{children:"int*"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"args"})}),(0,s.jsxs)(n.td,{children:["the tuple ",(0,s.jsx)(n.code,{children:"(flag, ptr)"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"args_type"})}),(0,s.jsxs)(n.td,{children:["the type ",(0,s.jsx)(n.code,{children:"std::tuple<bool, int*>"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"return_type"})}),(0,s.jsxs)(n.td,{children:["the type ",(0,s.jsx)(n.code,{children:"int"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"function_type"})}),(0,s.jsxs)(n.td,{children:["the type ",(0,s.jsx)(n.code,{children:"int(bool, int*)"})]})]})]})]}),"\n",(0,s.jsx)(n.h4,{id:"legacy-macro-based-parameterized-actions",children:"Legacy macro-based parameterized Actions"}),"\n",(0,s.jsx)(n.p,{children:"Sometimes you'll want to parameterize an action you define. For that we have\nanother macro"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"ACTION_P(name, param) { statements; }\n"})}),"\n",(0,s.jsx)(n.p,{children:"For example,"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"ACTION_P(Add, n) { return arg0 + n; }\n"})}),"\n",(0,s.jsx)(n.p,{children:"will allow you to write"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Returns argument #0 + 5.\n... WillOnce(Add(5));\n"})}),"\n",(0,s.jsxs)(n.p,{children:["For convenience, we use the term ",(0,s.jsx)(n.em,{children:"arguments"})," for the values used to invoke the\nmock function, and the term ",(0,s.jsx)(n.em,{children:"parameters"})," for the values used to instantiate an\naction."]}),"\n",(0,s.jsxs)(n.p,{children:["Note that you don't need to provide the type of the parameter either. Suppose\nthe parameter is named ",(0,s.jsx)(n.code,{children:"param"}),", you can also use the gMock-defined symbol\n",(0,s.jsx)(n.code,{children:"param_type"})," to refer to the type of the parameter as inferred by the compiler.\nFor example, in the body of ",(0,s.jsx)(n.code,{children:"ACTION_P(Add, n)"})," above, you can write ",(0,s.jsx)(n.code,{children:"n_type"})," for\nthe type of ",(0,s.jsx)(n.code,{children:"n"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["gMock also provides ",(0,s.jsx)(n.code,{children:"ACTION_P2"}),", ",(0,s.jsx)(n.code,{children:"ACTION_P3"}),", and etc to support multi-parameter\nactions. For example,"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"ACTION_P2(ReturnDistanceTo, x, y) {\n  double dx = arg0 - x;\n  double dy = arg1 - y;\n  return sqrt(dx*dx + dy*dy);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"lets you write"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"... WillOnce(ReturnDistanceTo(5.0, 26.5));\n"})}),"\n",(0,s.jsxs)(n.p,{children:["You can view ",(0,s.jsx)(n.code,{children:"ACTION"})," as a degenerated parameterized action where the number of\nparameters is 0."]}),"\n",(0,s.jsx)(n.p,{children:"You can also easily define actions overloaded on the number of parameters:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"ACTION_P(Plus, a) { ... }\nACTION_P2(Plus, a, b) { ... }\n"})}),"\n",(0,s.jsx)(n.h3,{id:"restricting-the-type-of-an-argument-or-parameter-in-an-action",children:"Restricting the Type of an Argument or Parameter in an ACTION"}),"\n",(0,s.jsxs)(n.p,{children:["For maximum brevity and reusability, the ",(0,s.jsx)(n.code,{children:"ACTION*"})," macros don't ask you to\nprovide the types of the mock function arguments and the action parameters.\nInstead, we let the compiler infer the types for us."]}),"\n",(0,s.jsx)(n.p,{children:"Sometimes, however, we may want to be more explicit about the types. There are\nseveral tricks to do that. For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"ACTION(Foo) {\n  // Makes sure arg0 can be converted to int.\n  int n = arg0;\n  ... use n instead of arg0 here ...\n}\n\nACTION_P(Bar, param) {\n  // Makes sure the type of arg1 is const char*.\n  ::testing::StaticAssertTypeEq<const char*, arg1_type>();\n\n  // Makes sure param can be converted to bool.\n  bool flag = param;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["where ",(0,s.jsx)(n.code,{children:"StaticAssertTypeEq"})," is a compile-time assertion in googletest that\nverifies two types are the same."]}),"\n",(0,s.jsx)(n.h3,{id:"writing-new-action-templates-quickly",children:"Writing New Action Templates Quickly"}),"\n",(0,s.jsxs)(n.p,{children:["Sometimes you want to give an action explicit template parameters that cannot be\ninferred from its value parameters. ",(0,s.jsx)(n.code,{children:"ACTION_TEMPLATE()"})," supports that and can be\nviewed as an extension to ",(0,s.jsx)(n.code,{children:"ACTION()"})," and ",(0,s.jsx)(n.code,{children:"ACTION_P*()"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"The syntax:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"ACTION_TEMPLATE(ActionName,\n                HAS_m_TEMPLATE_PARAMS(kind1, name1, ..., kind_m, name_m),\n                AND_n_VALUE_PARAMS(p1, ..., p_n)) { statements; }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["defines an action template that takes ",(0,s.jsx)(n.em,{children:"m"})," explicit template parameters and ",(0,s.jsx)(n.em,{children:"n"}),"\nvalue parameters, where ",(0,s.jsx)(n.em,{children:"m"})," is in [1, 10] and ",(0,s.jsx)(n.em,{children:"n"})," is in [0, 10]. ",(0,s.jsx)(n.code,{children:"name_i"})," is the\nname of the ",(0,s.jsx)(n.em,{children:"i"}),"-th template parameter, and ",(0,s.jsx)(n.code,{children:"kind_i"})," specifies whether it's a\n",(0,s.jsx)(n.code,{children:"typename"}),", an integral constant, or a template. ",(0,s.jsx)(n.code,{children:"p_i"})," is the name of the ",(0,s.jsx)(n.em,{children:"i"}),"-th\nvalue parameter."]}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// DuplicateArg<k, T>(output) converts the k-th argument of the mock\n// function to type T and copies it to *output.\nACTION_TEMPLATE(DuplicateArg,\n                // Note the comma between int and k:\n                HAS_2_TEMPLATE_PARAMS(int, k, typename, T),\n                AND_1_VALUE_PARAMS(output)) {\n  *output = T(std::get<k>(args));\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"To create an instance of an action template, write:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"ActionName<t1, ..., t_m>(v1, ..., v_n)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["where the ",(0,s.jsx)(n.code,{children:"t"}),"s are the template arguments and the ",(0,s.jsx)(n.code,{children:"v"}),"s are the value arguments.\nThe value argument types are inferred by the compiler. For example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::_;\n...\n  int n;\n  EXPECT_CALL(mock, Foo).WillOnce(DuplicateArg<1, unsigned char>(&n));\n"})}),"\n",(0,s.jsx)(n.p,{children:"If you want to explicitly specify the value argument types, you can provide\nadditional template arguments:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"ActionName<t1, ..., t_m, u1, ..., u_k>(v1, ..., v_n)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["where ",(0,s.jsx)(n.code,{children:"u_i"})," is the desired type of ",(0,s.jsx)(n.code,{children:"v_i"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ACTION_TEMPLATE"})," and ",(0,s.jsx)(n.code,{children:"ACTION"}),"/",(0,s.jsx)(n.code,{children:"ACTION_P*"})," can be overloaded on the number of\nvalue parameters, but not on the number of template parameters. Without the\nrestriction, the meaning of the following is unclear:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"  OverloadedAction<int, bool>(x);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Are we using a single-template-parameter action where ",(0,s.jsx)(n.code,{children:"bool"})," refers to the type\nof ",(0,s.jsx)(n.code,{children:"x"}),", or a two-template-parameter action where the compiler is asked to infer\nthe type of ",(0,s.jsx)(n.code,{children:"x"}),"?"]}),"\n",(0,s.jsx)(n.h3,{id:"using-the-action-objects-type",children:"Using the ACTION Object's Type"}),"\n",(0,s.jsxs)(n.p,{children:["If you are writing a function that returns an ",(0,s.jsx)(n.code,{children:"ACTION"})," object, you'll need to\nknow its type. The type depends on the macro used to define the action and the\nparameter types. The rule is relatively simple:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Given Definition"}),(0,s.jsx)(n.th,{children:"Expression"}),(0,s.jsx)(n.th,{children:"Has Type"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ACTION(Foo)"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Foo()"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"FooAction"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ACTION_TEMPLATE(Foo, HAS_m_TEMPLATE_PARAMS(...), AND_0_VALUE_PARAMS())"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Foo<t1, ..., t_m>()"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"FooAction<t1, ..., t_m>"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ACTION_P(Bar, param)"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Bar(int_value)"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"BarActionP<int>"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ACTION_TEMPLATE(Bar, HAS_m_TEMPLATE_PARAMS(...), AND_1_VALUE_PARAMS(p1))"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Bar<t1, ..., t_m>(int_value)"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"BarActionP<t1, ..., t_m, int>"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ACTION_P2(Baz, p1, p2)"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Baz(bool_value, int_value)"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"BazActionP2<bool, int>"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ACTION_TEMPLATE(Baz, HAS_m_TEMPLATE_PARAMS(...), AND_2_VALUE_PARAMS(p1, p2))"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Baz<t1, ..., t_m>(bool_value, int_value)"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"BazActionP2<t1, ..., t_m, bool, int>"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"..."}),(0,s.jsx)(n.td,{children:"..."}),(0,s.jsx)(n.td,{children:"..."})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["Note that we have to pick different suffixes (",(0,s.jsx)(n.code,{children:"Action"}),", ",(0,s.jsx)(n.code,{children:"ActionP"}),", ",(0,s.jsx)(n.code,{children:"ActionP2"}),",\nand etc) for actions with different numbers of value parameters, or the action\ndefinitions cannot be overloaded on the number of them."]}),"\n",(0,s.jsx)(n.h3,{id:"new-mono-actions",children:"Writing New Monomorphic Actions"}),"\n",(0,s.jsxs)(n.p,{children:["While the ",(0,s.jsx)(n.code,{children:"ACTION*"})," macros are very convenient, sometimes they are\ninappropriate. For example, despite the tricks shown in the previous recipes,\nthey don't let you directly specify the types of the mock function arguments and\nthe action parameters, which in general leads to unoptimized compiler error\nmessages that can baffle unfamiliar users. They also don't allow overloading\nactions based on parameter types without jumping through some hoops."]}),"\n",(0,s.jsxs)(n.p,{children:["An alternative to the ",(0,s.jsx)(n.code,{children:"ACTION*"})," macros is to implement\n",(0,s.jsx)(n.code,{children:"::testing::ActionInterface<F>"}),", where ",(0,s.jsx)(n.code,{children:"F"})," is the type of the mock function in\nwhich the action will be used. For example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"template <typename F>\nclass ActionInterface {\n public:\n  virtual ~ActionInterface();\n\n  // Performs the action.  Result is the return type of function type\n  // F, and ArgumentTuple is the tuple of arguments of F.\n  //\n\n  // For example, if F is int(bool, const string&), then Result would\n  // be int, and ArgumentTuple would be std::tuple<bool, const string&>.\n  virtual Result Perform(const ArgumentTuple& args) = 0;\n};\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::_;\nusing ::testing::Action;\nusing ::testing::ActionInterface;\nusing ::testing::MakeAction;\n\ntypedef int IncrementMethod(int*);\n\nclass IncrementArgumentAction : public ActionInterface<IncrementMethod> {\n public:\n  int Perform(const std::tuple<int*>& args) override {\n    int* p = std::get<0>(args);  // Grabs the first argument.\n    return *p++;\n  }\n};\n\nAction<IncrementMethod> IncrementArgument() {\n  return MakeAction(new IncrementArgumentAction);\n}\n\n...\n  EXPECT_CALL(foo, Baz(_))\n      .WillOnce(IncrementArgument());\n\n  int n = 5;\n  foo.Baz(&n);  // Should return 5 and change n to 6.\n"})}),"\n",(0,s.jsx)(n.h3,{id:"NewPolyActions",children:"Writing New Polymorphic Actions"}),"\n",(0,s.jsxs)(n.p,{children:["The previous recipe showed you how to define your own action. This is all good,\nexcept that you need to know the type of the function in which the action will\nbe used. Sometimes that can be a problem. For example, if you want to use the\naction in functions with ",(0,s.jsx)(n.em,{children:"different"})," types (e.g. like ",(0,s.jsx)(n.code,{children:"Return()"})," and\n",(0,s.jsx)(n.code,{children:"SetArgPointee()"}),")."]}),"\n",(0,s.jsxs)(n.p,{children:["If an action can be used in several types of mock functions, we say it's\n",(0,s.jsx)(n.em,{children:"polymorphic"}),". The ",(0,s.jsx)(n.code,{children:"MakePolymorphicAction()"})," function template makes it easy to\ndefine such an action:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"namespace testing {\ntemplate <typename Impl>\nPolymorphicAction<Impl> MakePolymorphicAction(const Impl& impl);\n}  // namespace testing\n"})}),"\n",(0,s.jsx)(n.p,{children:"As an example, let's define an action that returns the second argument in the\nmock function's argument list. The first step is to define an implementation\nclass:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class ReturnSecondArgumentAction {\n public:\n  template <typename Result, typename ArgumentTuple>\n  Result Perform(const ArgumentTuple& args) const {\n    // To get the i-th (0-based) argument, use std::get(args).\n    return std::get<1>(args);\n  }\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This implementation class does ",(0,s.jsx)(n.em,{children:"not"})," need to inherit from any particular class.\nWhat matters is that it must have a ",(0,s.jsx)(n.code,{children:"Perform()"})," method template. This method\ntemplate takes the mock function's arguments as a tuple in a ",(0,s.jsx)(n.strong,{children:"single"}),"\nargument, and returns the result of the action. It can be either ",(0,s.jsx)(n.code,{children:"const"})," or not,\nbut must be invocable with exactly one template argument, which is the result\ntype. In other words, you must be able to call ",(0,s.jsx)(n.code,{children:"Perform<R>(args)"})," where ",(0,s.jsx)(n.code,{children:"R"})," is\nthe mock function's return type and ",(0,s.jsx)(n.code,{children:"args"})," is its arguments in a tuple."]}),"\n",(0,s.jsxs)(n.p,{children:["Next, we use ",(0,s.jsx)(n.code,{children:"MakePolymorphicAction()"})," to turn an instance of the implementation\nclass into the polymorphic action we need. It will be convenient to have a\nwrapper for this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::MakePolymorphicAction;\nusing ::testing::PolymorphicAction;\n\nPolymorphicAction<ReturnSecondArgumentAction> ReturnSecondArgument() {\n  return MakePolymorphicAction(ReturnSecondArgumentAction());\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Now, you can use this polymorphic action the same way you use the built-in ones:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'using ::testing::_;\n\nclass MockFoo : public Foo {\n public:\n  MOCK_METHOD(int, DoThis, (bool flag, int n), (override));\n  MOCK_METHOD(string, DoThat, (int x, const char* str1, const char* str2),\n              (override));\n};\n\n  ...\n  MockFoo foo;\n  EXPECT_CALL(foo, DoThis).WillOnce(ReturnSecondArgument());\n  EXPECT_CALL(foo, DoThat).WillOnce(ReturnSecondArgument());\n  ...\n  foo.DoThis(true, 5);  // Will return 5.\n  foo.DoThat(1, "Hi", "Bye");  // Will return "Hi".\n'})}),"\n",(0,s.jsx)(n.h3,{id:"teaching-gmock-how-to-print-your-values",children:"Teaching gMock How to Print Your Values"}),"\n",(0,s.jsxs)(n.p,{children:["When an uninteresting or unexpected call occurs, gMock prints the argument\nvalues and the stack trace to help you debug. Assertion macros like\n",(0,s.jsx)(n.code,{children:"EXPECT_THAT"})," and ",(0,s.jsx)(n.code,{children:"EXPECT_EQ"})," also print the values in question when the\nassertion fails. gMock and googletest do this using googletest's user-extensible\nvalue printer."]}),"\n",(0,s.jsxs)(n.p,{children:["This printer knows how to print built-in C++ types, native arrays, STL\ncontainers, and any type that supports the ",(0,s.jsx)(n.code,{children:"<<"})," operator. For other types, it\nprints the raw bytes in the value and hopes that you the user can figure it out.\n",(0,s.jsx)(n.a,{href:"/cppdev/docs/foundamentals/testing/gt/advanced#teaching-googletest-how-to-print-your-values",children:"The GoogleTest advanced guide"}),"\nexplains how to extend the printer to do a better job at printing your\nparticular type than to dump the bytes."]}),"\n",(0,s.jsx)(n.h2,{id:"useful-mocks-created-using-gmock",children:"Useful Mocks Created Using gMock"}),"\n",(0,s.jsx)(n.h3,{id:"MockFunction",children:"Mock std::function"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"std::function"})," is a general function type introduced in C++11. It is a\npreferred way of passing callbacks to new interfaces. Functions are copyable,\nand are not usually passed around by pointer, which makes them tricky to mock.\nBut fear not - ",(0,s.jsx)(n.code,{children:"MockFunction"})," can help you with that."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"MockFunction<R(T1, ..., Tn)>"})," has a mock method ",(0,s.jsx)(n.code,{children:"Call()"})," with the signature:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"  R Call(T1, ..., Tn);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["It also has a ",(0,s.jsx)(n.code,{children:"AsStdFunction()"})," method, which creates a ",(0,s.jsx)(n.code,{children:"std::function"})," proxy\nforwarding to Call:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"  std::function<R(T1, ..., Tn)> AsStdFunction();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["To use ",(0,s.jsx)(n.code,{children:"MockFunction"}),", first create ",(0,s.jsx)(n.code,{children:"MockFunction"})," object and set up\nexpectations on its ",(0,s.jsx)(n.code,{children:"Call"})," method. Then pass proxy obtained from\n",(0,s.jsx)(n.code,{children:"AsStdFunction()"})," to the code you are testing. For example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'TEST(FooTest, RunsCallbackWithBarArgument) {\n  // 1. Create a mock object.\n  MockFunction<int(string)> mock_function;\n\n  // 2. Set expectations on Call() method.\n  EXPECT_CALL(mock_function, Call("bar")).WillOnce(Return(1));\n\n  // 3. Exercise code that uses std::function.\n  Foo(mock_function.AsStdFunction());\n  // Foo\'s signature can be either of:\n  // void Foo(const std::function<int(string)>& fun);\n  // void Foo(std::function<int(string)> fun);\n\n  // 4. All expectations will be verified when mock_function\n  //     goes out of scope and is destroyed.\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Remember that function objects created with ",(0,s.jsx)(n.code,{children:"AsStdFunction()"})," are just\nforwarders. If you create multiple of them, they will share the same set of\nexpectations."]}),"\n",(0,s.jsxs)(n.p,{children:["Although ",(0,s.jsx)(n.code,{children:"std::function"})," supports unlimited number of arguments, ",(0,s.jsx)(n.code,{children:"MockFunction"}),"\nimplementation is limited to ten. If you ever hit that limit... well, your\ncallback has bigger problems than being mockable. :-)"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>c});var o=t(6540);const s={},i=o.createContext(s);function a(e){const n=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);