"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[1112],{5960:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"foundamentals/map/concurrent_hash_map","title":"concurrent_hash_map","description":"melon-atomic_hashmap","source":"@site/docs/foundamentals/map/concurrent_hash_map.mdx","sourceDirName":"foundamentals/map","slug":"/foundamentals/map/concurrent_hash_map","permalink":"/cppdev/docs/foundamentals/map/concurrent_hash_map","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Turbo Hash Containers","permalink":"/cppdev/docs/foundamentals/map/turbo_hash"},"next":{"title":"Introduction to parallel-hashmap: High-Performance, Thread-Safe, Memory-Efficient Hash Tables and B-Trees","permalink":"/cppdev/docs/foundamentals/map/pmap"}}');var s=t(4848),a=t(8453);const r={},o=void 0,l={},h=[{value:"<code>melon-atomic_hashmap</code>",id:"melon-atomic_hashmap",level:2},{value:"Limitations",id:"limitations",level:3},{value:"Unique Features",id:"unique-features",level:3},{value:"Usage",id:"usage",level:3},{value:"Implementation",id:"implementation",level:3}];function c(e){const n={code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"melon-atomic_hashmap",children:(0,s.jsx)(n.code,{children:"melon-atomic_hashmap"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"melon-atomic_hashmap"})," introduces a synchronized UnorderedAssociativeContainer\nimplementation designed for extreme performance in heavily multithreaded\nenvironments (about 2-5x faster than tbb::concurrent_hash_map) and good memory\nusage properties.  Find and iteration are wait-free, insert has key-level lock\ngranularity, there is minimal memory overhead, and permanent 32-bit ids can be\nused to reference each element."]}),"\n",(0,s.jsx)(n.h3,{id:"limitations",children:"Limitations"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"Although it can provide extreme performance, AtomicHashmap has some unique\nlimitations as well."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The space for erased elements cannot be reclaimed (they are tombstoned\nforever) so it's generally not a good idea to use this if you're erasing things\na lot."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Only supports 32 or 64 bit keys - this is because they must be atomically\ncompare-and-swap'ed."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Growth beyond initialization reduces performance - if you don't know\nthe approximate number of elements you'll be inserting into the map, you\nprobably shouldn't use this class."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Must manage synchronization externally in order to modify values in the map\nafter insertion.  Lock pools are a common way to do this, or you may\nconsider using ",(0,s.jsx)(n.code,{children:"melon::PackedSyncPtr<T>"})," as your ",(0,s.jsx)(n.code,{children:"ValueT"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Must define special reserved key values for empty, erased, and locked\nelements."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For a complete list of limitations and departures from the\nUnorderedAssociativeContainer concept, see ",(0,s.jsx)(n.code,{children:"melon/AtomicHashMap.h"})]}),"\n",(0,s.jsx)(n.h3,{id:"unique-features",children:"Unique Features"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"value_type"})," references remain valid as long as the map itself.  Note this is\nnot true for most other probing hash maps which will move elements when\nrehashing, which is necessary for them to grow.  AtomicHashMap grows by chaining\nadditional slabs, so elements never need to be moved."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Unique 32-bit ids can be used to reference elements in the map via\n",(0,s.jsx)(n.code,{children:"iterator::getIndex()"}),".  This can be helpful to save memory in the rest of the\napplication by replacing 64-bit pointers or keys."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Iterators are never invalidated.  This means you can iterate through the map\nwhile simultaneously inserting and erasing.  This is particularly useful for\nnon-blocking map serialization."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"usage",children:"Usage"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"Usage is similar to most maps, although note the conspicuous lack of operator[]\nwhich encourages non thread-safe access patterns."}),"\n",(0,s.jsx)(n.p,{children:"Below is a synchronized key counter implementation that allows the counter\nvalues to be incremented in parallel with serializing all the values to a\nstring."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-Cpp",children:'   class Counters {\n    private:\n     AtomicHashMap<int64_t,int64_t> ahm;\n\n    public:\n     explicit Counters(size_t numCounters) : ahm(numCounters) {}\n\n     void increment(int64_t obj_id) {\n       auto ret = ahm.insert(make_pair(obj_id, 1));\n       if (!ret.second) {\n         // obj_id already exists, increment\n         NoBarrier_AtomicIncrement(&ret.first->second, 1);\n       }\n     }\n\n     int64_t getValue(int64_t obj_id) {\n       auto ret = ahm.find(obj_id);\n       return ret != ahm.end() ? ret->second : 0;\n     }\n\n     // Serialize the counters without blocking increments\n     string toString() {\n       string ret = "{\\n";\n       ret.reserve(ahm.size() * 32);\n       for (const auto& e : ahm) {\n         ret += melon::to<string>(\n           "  [", e.first, ":", NoBarrier_Load(&e.second), "]\\n");\n       }\n       ret += "}\\n";\n       return ret;\n     }\n   };\n'})}),"\n",(0,s.jsx)(n.h3,{id:"implementation",children:"Implementation"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"AtomicHashMap is a composition of AtomicHashArray submaps, which implement the\nmeat of the functionality.  Only one AHA is created on initialization, and\nadditional submaps are appended if the first one gets full.  If the AHM grows,\nthere will be multiple submaps that must be probed in series to find a given\nkey.  The more growth, the more submaps will be chained, and the slower it will\nget.  If the initial size estimate is good, only one submap will ever be created\nand performance will be optimal."}),"\n",(0,s.jsx)(n.p,{children:"AtomicHashArray is a fixed-size probing hash map (also referred to as an open\naddressed hash map) where hash collisions are resolved by checking subsequent\nelements.  This means that they can be allocated in slabs as arrays of\nvalue_type elements, have excellent cache performance, and have no memory\noverhead from storing pointers."}),"\n",(0,s.jsx)(n.p,{children:"The algorithm is simple - when inserting, the key is hash-mod'ed to an offset,\nand that element-key is atomically compare-and-swap'ed with the locked key\nvalue.  If successful, the value is written and the element-key is unlocked by\nsetting it to the input key value.  If the compare fails, the next element is\ntried until success or the map is full."}),"\n",(0,s.jsx)(n.p,{children:"Finds are even simpler.  The key is hash-mod'ed to an offset, and the\nelement-key is examined.  If it is the same as the input key, the reference is\nreturned, if it's the empty key, failure is returned, otherwise the next key is\ntried.  This can be done wait-free without any atomic instructions because the\nelements are always in a valid state."}),"\n",(0,s.jsx)(n.p,{children:"Erase is done by finding the key, then compare-and-swap'ing the element-key with\nthe reserved erased key value.  If the swap succeeds, return success, otherwise\nreturn failure (the element was erased by a competing thread).  If the key does\nnot exist, return failure."})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var i=t(6540);const s={},a=i.createContext(s);function r(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);