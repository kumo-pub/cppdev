"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[3754],{5002:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"rpc/grpc","title":"gRPC","description":"gRPC is used in Kumo primarily as a business-facing RPC layer.","source":"@site/docs/rpc/grpc.mdx","sourceDirName":"rpc","slug":"/rpc/grpc","permalink":"/cppdev/docs/rpc/grpc","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"gRPC"},"sidebar":"tutorialSidebar","previous":{"title":"RPC Overview","permalink":"/cppdev/docs/rpc/"},"next":{"title":"brpc","permalink":"/cppdev/docs/rpc/brpc"}}');var r=s(4848),l=s(8453);const t={title:"gRPC"},a=void 0,c={},o=[{value:"1. What gRPC is really for",id:"1-what-grpc-is-really-for",level:2},{value:"2. Why gRPC is not about extreme QPS",id:"2-why-grpc-is-not-about-extreme-qps",level:2},{value:"3. Where gRPC fits in Kumo",id:"3-where-grpc-fits-in-kumo",level:2},{value:"4. Why gRPC is preferred here",id:"4-why-grpc-is-preferred-here",level:2},{value:"5. Multi-language ecosystem",id:"5-multi-language-ecosystem",level:2},{value:"6. C++ integration model",id:"6-c-integration-model",level:2},{value:"7. Minimal C++ example",id:"7-minimal-c-example",level:2},{value:"8. Summary",id:"8-summary",level:2}];function d(e){const n={code:"code",h2:"h2",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["gRPC is used in Kumo primarily as a ",(0,r.jsx)(n.strong,{children:"business-facing RPC layer"}),".\nIt is not designed to be the highest-throughput transport in the system,\nbut to be the ",(0,r.jsx)(n.strong,{children:"most interoperable and controllable"})," one."]}),"\n",(0,r.jsxs)(n.p,{children:["This page explains where gRPC fits, what problems it solves,\nand why it is intentionally placed at the ",(0,r.jsx)(n.strong,{children:"pipeline control layer"}),"."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"1-what-grpc-is-really-for",children:"1. What gRPC is really for"}),"\n",(0,r.jsxs)(n.p,{children:["In real production systems, the entry RPC layer is not a hot data path.\nIt is a ",(0,r.jsx)(n.strong,{children:"control plane for request flows"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"This layer typically handles:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Authentication and authorization"}),"\n",(0,r.jsx)(n.li,{children:"Request routing"}),"\n",(0,r.jsx)(n.li,{children:"Quota and rate limiting"}),"\n",(0,r.jsx)(n.li,{children:"A/B testing and gray release"}),"\n",(0,r.jsx)(n.li,{children:"Fan-out to multiple backend services"}),"\n",(0,r.jsx)(n.li,{children:"Aggregation of multiple responses"}),"\n",(0,r.jsx)(n.li,{children:"Timeout and retry policies"}),"\n",(0,r.jsx)(n.li,{children:"Metadata propagation (trace id, user id, locale, etc)"}),"\n",(0,r.jsx)(n.li,{children:"Observability (metrics, tracing, logging)"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["None of these are about raw throughput.\nThey are about ",(0,r.jsx)(n.strong,{children:"controlling and shaping traffic"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"gRPC is designed exactly for this layer."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"2-why-grpc-is-not-about-extreme-qps",children:"2. Why gRPC is not about extreme QPS"}),"\n",(0,r.jsx)(n.p,{children:'It is common to see claims like "hundreds of thousands of QPS per node".\nIn real business systems, this is mostly unrealistic.'}),"\n",(0,r.jsx)(n.p,{children:"A typical service node has:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Locks and mutexes"}),"\n",(0,r.jsx)(n.li,{children:"Memory allocation"}),"\n",(0,r.jsx)(n.li,{children:"Serialization (protobuf)"}),"\n",(0,r.jsx)(n.li,{children:"TLS"}),"\n",(0,r.jsx)(n.li,{children:"Tracing"}),"\n",(0,r.jsx)(n.li,{children:"Logging"}),"\n",(0,r.jsx)(n.li,{children:"Cache access"}),"\n",(0,r.jsx)(n.li,{children:"Thread scheduling"}),"\n",(0,r.jsx)(n.li,{children:"Business logic"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Even very well-optimized production services usually run at:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"50% to 70% CPU utilization"}),"\n",(0,r.jsx)(n.li,{children:"5k to 30k QPS per node"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Above that, safety margins collapse.\nAny traffic spike, failover, or hot shard can bring the system down."}),"\n",(0,r.jsx)(n.p,{children:"This is especially true for systems using:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Raft"}),"\n",(0,r.jsx)(n.li,{children:"Single-threaded state machines"}),"\n",(0,r.jsx)(n.li,{children:"Ordered logs"}),"\n",(0,r.jsx)(n.li,{children:"Transactional writes"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"In these systems, QPS is often fundamentally limited by single-threaded paths."}),"\n",(0,r.jsxs)(n.p,{children:["gRPC is built with these real constraints in mind.\nIt prioritizes ",(0,r.jsx)(n.strong,{children:"correctness, observability, and control"}),", not paper benchmarks."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"3-where-grpc-fits-in-kumo",children:"3. Where gRPC fits in Kumo"}),"\n",(0,r.jsxs)(n.p,{children:["In Kumo, gRPC is used at the ",(0,r.jsx)(n.strong,{children:"business and integration boundary"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"\nClients\n|\n|  (gRPC)\nv\nBusiness API Layer\n|\n|  (fan-out, routing, policies)\nv\nHigh-QPS internal services (KV, search, storage, compute)\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"This layer:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Accepts requests from many languages"}),"\n",(0,r.jsx)(n.li,{children:"Talks to many downstream systems"}),"\n",(0,r.jsx)(n.li,{children:"Applies routing and policy"}),"\n",(0,r.jsx)(n.li,{children:"Controls traffic"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"It is not the place to squeeze the last bit of QPS.\nIt is the place to keep the system stable, observable, and evolvable."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"4-why-grpc-is-preferred-here",children:"4. Why gRPC is preferred here"}),"\n",(0,r.jsx)(n.p,{children:"gRPC brings things that are extremely hard to re-implement correctly:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Deadline propagation"}),"\n",(0,r.jsx)(n.li,{children:"Request cancellation"}),"\n",(0,r.jsx)(n.li,{children:"Structured metadata"}),"\n",(0,r.jsx)(n.li,{children:"Standard error model"}),"\n",(0,r.jsx)(n.li,{children:"Streaming"}),"\n",(0,r.jsx)(n.li,{children:"Backpressure"}),"\n",(0,r.jsx)(n.li,{children:"Load balancing hooks"}),"\n",(0,r.jsx)(n.li,{children:"Code generation for many languages"}),"\n",(0,r.jsx)(n.li,{children:"Deep ecosystem support"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"These are not optional in a real distributed system.\nThey are required to build a controllable pipeline."}),"\n",(0,r.jsx)(n.p,{children:"If you do not use gRPC, you will end up rebuilding most of these."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"5-multi-language-ecosystem",children:"5. Multi-language ecosystem"}),"\n",(0,r.jsx)(n.p,{children:"The business layer is usually where:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Python"}),"\n",(0,r.jsx)(n.li,{children:"Java"}),"\n",(0,r.jsx)(n.li,{children:"Go"}),"\n",(0,r.jsx)(n.li,{children:"Node.js"}),"\n",(0,r.jsx)(n.li,{children:"C++"}),"\n",(0,r.jsx)(n.li,{children:"Rust"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"all need to connect."}),"\n",(0,r.jsxs)(n.p,{children:["gRPC is one of the few RPC systems with ",(0,r.jsx)(n.strong,{children:"first-class, production-grade support"}),"\nacross all major languages."]}),"\n",(0,r.jsx)(n.p,{children:"This makes it ideal for:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Public APIs"}),"\n",(0,r.jsx)(n.li,{children:"Microservices"}),"\n",(0,r.jsx)(n.li,{children:"Integration with external systems"}),"\n",(0,r.jsx)(n.li,{children:"Tooling and automation"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"6-c-integration-model",children:"6. C++ integration model"}),"\n",(0,r.jsx)(n.p,{children:"On C++, gRPC requires several components:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"protobuf"}),"\n",(0,r.jsx)(n.li,{children:"grpc"}),"\n",(0,r.jsx)(n.li,{children:"transport (c-ares, TLS, etc)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This can be painful to integrate manually."}),"\n",(0,r.jsxs)(n.p,{children:["In Kumo, this is handled by ",(0,r.jsx)(n.code,{children:"kmpkg"}),", which provides:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Prebuilt gRPC"}),"\n",(0,r.jsx)(n.li,{children:"Protobuf"}),"\n",(0,r.jsx)(n.li,{children:"TLS stack"}),"\n",(0,r.jsx)(n.li,{children:"Consistent versions"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"So the complexity is centralized and standardized."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"7-minimal-c-example",children:"7. Minimal C++ example"}),"\n",(0,r.jsx)(n.p,{children:"Service definition:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-proto",children:'syntax = "proto3";\n\nservice Greeter {\n  rpc SayHello (HelloRequest) returns (HelloReply);\n}\n\nmessage HelloRequest {\n  string name = 1;\n}\n\nmessage HelloReply {\n  string message = 1;\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Server:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'class GreeterServiceImpl final : public Greeter::Service {\n  grpc::Status SayHello(grpc::ServerContext* context,\n                        const HelloRequest* request,\n                        HelloReply* reply) override {\n    reply->set_message("Hello " + request->name());\n    return grpc::Status::OK;\n  }\n};\n'})}),"\n",(0,r.jsx)(n.p,{children:"Client:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'auto channel = grpc::CreateChannel("localhost:50051",\n                                   grpc::InsecureChannelCredentials());\nauto stub = Greeter::NewStub(channel);\n\nHelloRequest req;\nreq.set_name("kumo");\n\nHelloReply resp;\ngrpc::ClientContext ctx;\n\nauto status = stub->SayHello(&ctx, req, &resp);\n'})}),"\n",(0,r.jsx)(n.p,{children:"This is enough to demonstrate the model.\nIn real systems, most of the value comes from metadata, deadlines, and streaming."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"8-summary",children:"8. Summary"}),"\n",(0,r.jsx)(n.p,{children:"gRPC in Kumo is not chosen because it is the fastest RPC."}),"\n",(0,r.jsx)(n.p,{children:"It is chosen because:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"It provides the best ecosystem"}),"\n",(0,r.jsx)(n.li,{children:"It provides the best control primitives"}),"\n",(0,r.jsx)(n.li,{children:"It works across languages"}),"\n",(0,r.jsx)(n.li,{children:"It integrates well with observability and policy layers"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["It is the right tool for the ",(0,r.jsx)(n.strong,{children:"pipeline control layer"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"High-QPS, data-path services should use more specialized transports and engines.\nBusiness-facing and integration layers should use gRPC."})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>a});var i=s(6540);const r={},l=i.createContext(r);function t(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);