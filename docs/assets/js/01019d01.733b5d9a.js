"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[4305],{6905:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"foundamentals/compress/index","title":"Comprehensive Guide to Compression Technologies","description":"I. Overview of Compression Algorithms","source":"@site/docs/foundamentals/compress/index.md","sourceDirName":"foundamentals/compress","slug":"/foundamentals/compress/","permalink":"/cppdev/docs/foundamentals/compress/","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/foundamentals/compress/index.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"C++ Hashmap Benchmark","permalink":"/cppdev/docs/foundamentals/map/benchmark"},"next":{"title":"Usage Summary of melon compression Module","permalink":"/cppdev/docs/foundamentals/compress/melon"}}');var t=s(4848),r=s(8453);const o={},d="Comprehensive Guide to Compression Technologies",l={},a=[{value:"I. Overview of Compression Algorithms",id:"i-overview-of-compression-algorithms",level:2},{value:"II. Scenario-Based Selection",id:"ii-scenario-based-selection",level:2},{value:"2.1 KV Storage Integration (Core Requirements: Low Latency, High Throughput)",id:"21-kv-storage-integration-core-requirements-low-latency-high-throughput",level:3},{value:"2.2 Large File Compression (Core Requirements: High Compression Ratio, Storage Savings)",id:"22-large-file-compression-core-requirements-high-compression-ratio-storage-savings",level:3},{value:"2.3 Additional Scenario Recommendations",id:"23-additional-scenario-recommendations",level:3},{value:"III. Engineering Integration (C++ Example)",id:"iii-engineering-integration-c-example",level:2},{value:"3.1 General Integration Steps",id:"31-general-integration-steps",level:3},{value:"3.2 Integration Notes",id:"32-integration-notes",level:3},{value:"IV. Usage Examples (Runnable in C++)",id:"iv-usage-examples-runnable-in-c",level:2},{value:"4.1 LZ4 (Preferred for KV Storage)",id:"41-lz4-preferred-for-kv-storage",level:3},{value:"4.2 Zstd (Preferred for Large Files/Balanced Scenarios)",id:"42-zstd-preferred-for-large-filesbalanced-scenarios",level:3},{value:"4.3 zlib/gzip (General File Compression)",id:"43-zlibgzip-general-file-compression",level:3},{value:"4.4 Snappy (Big Data/Low Latency)",id:"44-snappy-big-datalow-latency",level:3},{value:"4.5 bzip2 (High Compression Ratio/Static Files)",id:"45-bzip2-high-compression-ratiostatic-files",level:3},{value:"4.6 LZO (Embedded/Resource-Constrained)",id:"46-lzo-embeddedresource-constrained",level:3},{value:"Summary",id:"summary",level:2},{value:"Key Takeaways",id:"key-takeaways",level:3},{value:"Critical Format Adjustments for Docusaurus Compatibility",id:"critical-format-adjustments-for-docusaurus-compatibility",level:3}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"comprehensive-guide-to-compression-technologies",children:"Comprehensive Guide to Compression Technologies"})}),"\n",(0,t.jsx)(n.h2,{id:"i-overview-of-compression-algorithms",children:"I. Overview of Compression Algorithms"}),"\n",(0,t.jsx)(n.p,{children:"The following is a comparison of core features of mainstream compression algorithms, covering compression ratio, speed, core principles, and applicable scenarios, to facilitate quick evaluation of algorithm characteristics:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Algorithm"}),(0,t.jsx)(n.th,{children:"Core Principles"}),(0,t.jsx)(n.th,{children:"Compression Ratio (Low \u2192 High)"}),(0,t.jsx)(n.th,{children:"Compression Speed (Fast \u2192 Slow)"}),(0,t.jsx)(n.th,{children:"Decompression Speed (Fast \u2192 Slow)"}),(0,t.jsx)(n.th,{children:"Key Features"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"LZO"}),(0,t.jsx)(n.td,{children:"Lossless Lempel-Ziv compression based on dictionary"}),(0,t.jsx)(n.td,{children:"Low"}),(0,t.jsx)(n.td,{children:"Extremely Fast"}),(0,t.jsx)(n.td,{children:"Extremely Fast"}),(0,t.jsx)(n.td,{children:"Pure C implementation, patent-free, ultra-low memory footprint, ideal for embedded/real-time scenarios"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"LZ4"}),(0,t.jsx)(n.td,{children:"LZ77 variant + hash table matching"}),(0,t.jsx)(n.td,{children:"Low-Medium"}),(0,t.jsx)(n.td,{children:"Fastest"}),(0,t.jsx)(n.td,{children:"Fastest"}),(0,t.jsx)(n.td,{children:"Industrial-grade high-speed compression, slightly better ratio than LZO, widely used in KV storage and real-time data compression"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Snappy"}),(0,t.jsx)(n.td,{children:"LZ77 + hash lookup"}),(0,t.jsx)(n.td,{children:"Low-Medium"}),(0,t.jsx)(n.td,{children:"Extremely Fast"}),(0,t.jsx)(n.td,{children:"Extremely Fast"}),(0,t.jsx)(n.td,{children:"Developed by Google, optimized for big data, balances speed and ratio, no compression level options"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"zlib"}),(0,t.jsx)(n.td,{children:"DEFLATE (LZ77 + Huffman coding)"}),(0,t.jsx)(n.td,{children:"Medium"}),(0,t.jsx)(n.td,{children:"Medium"}),(0,t.jsx)(n.td,{children:"Fast"}),(0,t.jsx)(n.td,{children:"High standardization and compatibility; gzip is built on its core implementation"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"gzip"}),(0,t.jsx)(n.td,{children:"zlib + header checksum"}),(0,t.jsx)(n.td,{children:"Medium"}),(0,t.jsx)(n.td,{children:"Medium"}),(0,t.jsx)(n.td,{children:"Fast"}),(0,t.jsx)(n.td,{children:"Essentially a wrapper for zlib, suitable for file compression; often used with tar (tar.gz)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Zstd (Zstandard)"}),(0,t.jsx)(n.td,{children:"LZ77 + entropy coding + dictionary pre-training"}),(0,t.jsx)(n.td,{children:"Medium-High"}),(0,t.jsx)(n.td,{children:"Fast"}),(0,t.jsx)(n.td,{children:"Fast"}),(0,t.jsx)(n.td,{children:"Developed by Facebook, next-gen algorithm with adjustable ratios (levels 1\u201322), balances speed and compression ratio"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"bzip2"}),(0,t.jsx)(n.td,{children:"Burrows-Wheeler transform + Huffman coding"}),(0,t.jsx)(n.td,{children:"High"}),(0,t.jsx)(n.td,{children:"Slow"}),(0,t.jsx)(n.td,{children:"Medium"}),(0,t.jsx)(n.td,{children:"High compression ratio but slow speed; ideal for static large files, especially effective for text data"})]})]})]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Key Note: gzip is not an independent algorithm but a file-level wrapper for zlib (adding file headers, checksums, etc.). In practical engineering, zlib is commonly used for in-memory data compression, while gzip is used for file compression."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"ii-scenario-based-selection",children:"II. Scenario-Based Selection"}),"\n",(0,t.jsx)(n.h3,{id:"21-kv-storage-integration-core-requirements-low-latency-high-throughput",children:"2.1 KV Storage Integration (Core Requirements: Low Latency, High Throughput)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"LZ4 and Snappy"})," are preferred, based on the following core reasons:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:'Ultra-fast decompression speed (microsecond-level latency), matching the core requirement of "low read/write latency" for KV storage;'}),"\n",(0,t.jsx)(n.li,{children:"Low memory footprint, avoiding reduced KV cache hit rates due to excessive memory usage during compression/decompression;"}),"\n",(0,t.jsx)(n.li,{children:"No complex configuration, low integration cost, suitable for embedding into KV engines (e.g., RocksDB and LevelDB natively support LZ4/Snappy)."}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Supplement: For slightly higher compression ratios with acceptable minor performance overhead, choose Zstd (levels 1\u20133). Avoid high compression levels (> 10) to prevent latency spikes."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"22-large-file-compression-core-requirements-high-compression-ratio-storage-savings",children:"2.2 Large File Compression (Core Requirements: High Compression Ratio, Storage Savings)"}),"\n",(0,t.jsx)(n.p,{children:"Recommended in the following priority order:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Zstd (levels 10\u201319)"}),": Balances compression ratio and speed, offering 10%\u201320% higher ratio than zlib and 50% faster speed; currently the top choice for large file compression;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"gzip/zlib"}),": Excellent compatibility, natively supported by almost all systems, suitable for cross-platform file transfer (e.g., tar.gz);"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"bzip2"}),': Only for scenarios where "ultimate compression ratio is prioritized over speed" (e.g., static text files, archive files);']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"LZ4 (level 9)"}),": For large files requiring fast decompression (e.g., video materials, log archives), LZ4 is preferred\u2014its decompression speed is 10x faster than bzip2 despite a lower compression ratio."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"23-additional-scenario-recommendations",children:"2.3 Additional Scenario Recommendations"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Extended Scenario"}),(0,t.jsx)(n.th,{children:"Recommended Algorithm"}),(0,t.jsx)(n.th,{children:"Core Reason"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Embedded/resource-constrained devices"}),(0,t.jsx)(n.td,{children:"LZO, LZ4"}),(0,t.jsx)(n.td,{children:"Memory footprint < 1MB, pure C implementation with no dependencies"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Network transmission (e.g., RPC data)"}),(0,t.jsx)(n.td,{children:"Zstd (level 3)"}),(0,t.jsx)(n.td,{children:"Better compression ratio than LZ4 with controllable latency"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Log compression (real-time writing)"}),(0,t.jsx)(n.td,{children:"LZ4, Snappy"}),(0,t.jsx)(n.td,{children:"Non-blocking writes, fast decompression for querying"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"iii-engineering-integration-c-example",children:"III. Engineering Integration (C++ Example)"}),"\n",(0,t.jsx)(n.h3,{id:"31-general-integration-steps",children:"3.1 General Integration Steps"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Dependency Installation (Linux)"}),":"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# LZ4\nsudo apt install liblz4-dev  # Debian/Ubuntu\nsudo yum install lz4-devel   # CentOS/RHEL\n\n# Zstd\nsudo apt install libzstd-dev\nsudo yum install libzstd-devel\n\n# Snappy\nsudo apt install libsnappy-dev\nsudo yum install snappy-devel\n\n# zlib/gzip (pre-installed on most systems, no extra installation required)\nsudo apt install zlib1g-dev\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"kmpkg Integration"}),":"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",metastring:'title="kmpkg integrate"',children:"kmpkg install lz4\nkmpkg install zlib\nkmpkg install zstd\nkmpkg install snappy\nkmpkg install bzip2\nkmpkg install lzo\n"})}),"\n",(0,t.jsx)(n.p,{children:"For more kmpkg integration details, refer to:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/cppdev/docs/integration/zlib",children:"zlib Integration Document"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/cppdev/docs/integration/lz4",children:"lz4 Integration Document"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/cppdev/docs/integration/zstd",children:"zstd Integration Document"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/cppdev/docs/integration/snappy",children:"snappy Integration Document"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/cppdev/docs/integration/bzip2",children:"bzip2 Integration Document"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/cppdev/docs/integration/lzo",children:"lzo Integration Document"})}),"\n"]}),"\n",(0,t.jsxs)(n.ol,{start:"3",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Compilation and Linking"}),":\nAdd link dependencies in ",(0,t.jsx)(n.code,{children:"CMakeLists.txt"}),", example:"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cmake",children:"# Example for LZ4\nfind_package(LZ4 REQUIRED)\ninclude_directories(${LZ4_INCLUDE_DIRS})\ntarget_link_libraries(your_project ${LZ4_LIBRARIES})\n\n# Example for Zstd\nfind_package(ZSTD REQUIRED)\ntarget_link_libraries(your_project ${ZSTD_LIBRARIES})\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"4",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Core Encapsulation Approach"}),":\nUnify the encapsulation of compression/decompression interfaces to shield API differences between different algorithms, example template:"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"#include <string>\n\n// Compression interface\nbool compress(const std::string& input, std::string& output, const std::string& algo);\n// Decompression interface\nbool decompress(const std::string& input, std::string& output, const std::string& algo);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"32-integration-notes",children:"3.2 Integration Notes"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Memory Management"}),": Estimate the output buffer size before compression/decompression (each algorithm provides an estimation function, e.g., ",(0,t.jsx)(n.code,{children:"LZ4_compressBound"}),") to avoid memory overflow;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Level Configuration"}),': Zstd and zlib support compression levels. Select the "balanced level" by default (Zstd=3, zlib=6). High levels are only for offline compression;']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Streaming Processing"}),": Use streaming APIs (e.g., zlib\u2019s ",(0,t.jsx)(n.code,{children:"z_stream"}),", Zstd\u2019s ",(0,t.jsx)(n.code,{children:"ZSTD_CStream"}),") for large file compression to avoid loading the entire file into memory at once."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"iv-usage-examples-runnable-in-c",children:"IV. Usage Examples (Runnable in C++)"}),"\n",(0,t.jsx)(n.h3,{id:"41-lz4-preferred-for-kv-storage",children:"4.1 LZ4 (Preferred for KV Storage)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'#include <lz4.h>\n#include <string>\n#include <iostream>\n\n// LZ4 compression\nbool lz4_compress(const std::string& input, std::string& output) {\n    int input_size = input.size();\n    // Estimate maximum compressed length\n    int max_output_size = LZ4_compressBound(input_size);\n    output.resize(max_output_size);\n    \n    // Perform compression\n    int compressed_size = LZ4_compress_default(input.data(), output.data(), input_size, max_output_size);\n    if (compressed_size <= 0) {\n        return false;\n    }\n    output.resize(compressed_size); // Trim to actual compressed length\n    return true;\n}\n\n// LZ4 decompression\nbool lz4_decompress(const std::string& input, std::string& output, int original_size) {\n    output.resize(original_size);\n    int decompressed_size = LZ4_decompress_safe(input.data(), output.data(), input.size(), original_size);\n    return decompressed_size == original_size;\n}\n\n// Test\nint main() {\n    std::string data = "Hello LZ4! This is a test for KV storage compression.";\n    std::string compressed, decompressed;\n    \n    if (lz4_compress(data, compressed)) {\n        std::cout << "LZ4 before compression: " << data.size() << " bytes, after compression: " << compressed.size() << " bytes\\n";\n        if (lz4_decompress(compressed, decompressed, data.size())) {\n            std::cout << "LZ4 decompression result: " << decompressed << "\\n";\n        }\n    }\n    return 0;\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"42-zstd-preferred-for-large-filesbalanced-scenarios",children:"4.2 Zstd (Preferred for Large Files/Balanced Scenarios)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'#include <zstd.h>\n#include <string>\n#include <iostream>\n\n// Zstd compression (level 3, balances speed and compression ratio)\nbool zstd_compress(const std::string& input, std::string& output, int level = 3) {\n    int input_size = input.size();\n    size_t max_output_size = ZSTD_compressBound(input_size);\n    output.resize(max_output_size);\n    \n    size_t compressed_size = ZSTD_compress(output.data(), max_output_size, input.data(), input_size, level);\n    if (ZSTD_isError(compressed_size)) {\n        std::cerr << "Zstd compression failed: " << ZSTD_getErrorName(compressed_size) << "\\n";\n        return false;\n    }\n    output.resize(compressed_size);\n    return true;\n}\n\n// Zstd decompression\nbool zstd_decompress(const std::string& input, std::string& output) {\n    // Get original data size (store this value during compression, or retrieve via ZSTD_getFrameContentSize)\n    unsigned long long original_size = ZSTD_getFrameContentSize(input.data(), input.size());\n    if (original_size == ZSTD_CONTENTSIZE_UNKNOWN || original_size == ZSTD_CONTENTSIZE_ERROR) {\n        return false;\n    }\n    output.resize(original_size);\n    \n    size_t decompressed_size = ZSTD_decompress(output.data(), original_size, input.data(), input.size());\n    if (ZSTD_isError(decompressed_size)) {\n        std::cerr << "Zstd decompression failed: " << ZSTD_getErrorName(decompressed_size) << "\\n";\n        return false;\n    }\n    return true;\n}\n\n// Test\nint main() {\n    std::string data = "Hello Zstd! This is a test for large file compression.";\n    std::string compressed, decompressed;\n    \n    if (zstd_compress(data, compressed)) {\n        std::cout << "Zstd before compression: " << data.size() << " bytes, after compression: " << compressed.size() << " bytes\\n";\n        if (zstd_decompress(compressed, decompressed)) {\n            std::cout << "Zstd decompression result: " << decompressed << "\\n";\n        }\n    }\n    return 0;\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"43-zlibgzip-general-file-compression",children:"4.3 zlib/gzip (General File Compression)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'#include <zlib.h>\n#include <string>\n#include <iostream>\n#include <cstring>\n\n// zlib compression (gzip requires additional headers, this is pure zlib)\nbool zlib_compress(const std::string& input, std::string& output, int level = Z_DEFAULT_COMPRESSION) {\n    z_stream zs;\n    memset(&zs, 0, sizeof(zs));\n    \n    if (deflateInit(&zs, level) != Z_OK) {\n        return false;\n    }\n    zs.next_in = (Bytef*)input.data();\n    zs.avail_in = input.size();\n    \n    int ret;\n    char buffer[4096];\n    do {\n        zs.next_out = (Bytef*)buffer;\n        zs.avail_out = sizeof(buffer);\n        ret = deflate(&zs, Z_FINISH);\n        if (output.size() < zs.total_out) {\n            output.append(buffer, zs.total_out - output.size());\n        }\n    } while (ret == Z_OK);\n    \n    deflateEnd(&zs);\n    return ret == Z_STREAM_END;\n}\n\n// zlib decompression\nbool zlib_decompress(const std::string& input, std::string& output) {\n    z_stream zs;\n    memset(&zs, 0, sizeof(zs));\n    \n    if (inflateInit(&zs) != Z_OK) {\n        return false;\n    }\n    zs.next_in = (Bytef*)input.data();\n    zs.avail_in = input.size();\n    \n    int ret;\n    char buffer[4096];\n    do {\n        zs.next_out = (Bytef*)buffer;\n        zs.avail_out = sizeof(buffer);\n        ret = inflate(&zs, 0);\n        if (output.size() < zs.total_out) {\n            output.append(buffer, zs.total_out - output.size());\n        }\n    } while (ret == Z_OK);\n    \n    inflateEnd(&zs);\n    return ret == Z_STREAM_END;\n}\n\n// Test\nint main() {\n    std::string data = "Hello zlib/gzip! This is a test for general file compression.";\n    std::string compressed, decompressed;\n    \n    if (zlib_compress(data, compressed)) {\n        std::cout << "zlib before compression: " << data.size() << " bytes, after compression: " << compressed.size() << " bytes\\n";\n        if (zlib_decompress(compressed, decompressed)) {\n            std::cout << "zlib decompression result: " << decompressed << "\\n";\n        }\n    }\n    return 0;\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"44-snappy-big-datalow-latency",children:"4.4 Snappy (Big Data/Low Latency)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'#include <snappy.h>\n#include <string>\n#include <iostream>\n\n// Snappy compression\nbool snappy_compress(const std::string& input, std::string& output) {\n    snappy::Compress(input.data(), input.size(), &output);\n    return true;\n}\n\n// Snappy decompression\nbool snappy_decompress(const std::string& input, std::string& output) {\n    return snappy::Uncompress(input.data(), input.size(), &output);\n}\n\n// Test\nint main() {\n    std::string data = "Hello Snappy! This is a test for big data compression.";\n    std::string compressed, decompressed;\n    \n    snappy_compress(data, compressed);\n    std::cout << "Snappy before compression: " << data.size() << " bytes, after compression: " << compressed.size() << " bytes\\n";\n    if (snappy_decompress(compressed, decompressed)) {\n        std::cout << "Snappy decompression result: " << decompressed << "\\n";\n    }\n    return 0;\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"45-bzip2-high-compression-ratiostatic-files",children:"4.5 bzip2 (High Compression Ratio/Static Files)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'#include <bzlib.h>\n#include <string>\n#include <iostream>\n#include <cstring>\n\n// bzip2 compression\nbool bzip2_compress(const std::string& input, std::string& output, int blockSize100k = 9) {\n    bz_stream bzs;\n    memset(&bzs, 0, sizeof(bzs));\n    \n    if (BZ2_bzCompressInit(&bzs, blockSize100k, 0, 0) != BZ_OK) {\n        return false;\n    }\n    bzs.next_in = (char*)input.data();\n    bzs.avail_in = input.size();\n    \n    int ret;\n    char buffer[4096];\n    do {\n        bzs.next_out = buffer;\n        bzs.avail_out = sizeof(buffer);\n        ret = BZ2_bzCompress(&bzs, BZ_FINISH);\n        if (output.size() < bzs.total_out_lo32) {\n            output.append(buffer, bzs.total_out_lo32 - output.size());\n        }\n    } while (ret == BZ_RUN_OK);\n    \n    BZ2_bzCompressEnd(&bzs);\n    return ret == BZ_STREAM_END;\n}\n\n// bzip2 decompression\nbool bzip2_decompress(const std::string& input, std::string& output) {\n    bz_stream bzs;\n    memset(&bzs, 0, sizeof(bzs));\n    \n    if (BZ2_bzDecompressInit(&bzs, 0, 0) != BZ_OK) {\n        return false;\n    }\n    bzs.next_in = (char*)input.data();\n    bzs.avail_in = input.size();\n    \n    int ret;\n    char buffer[4096];\n    do {\n        bzs.next_out = buffer;\n        bzs.avail_out = sizeof(buffer);\n        ret = BZ2_bzDecompress(&bzs);\n        if (output.size() < bzs.total_out_lo32) {\n            output.append(buffer, bzs.total_out_lo32 - output.size());\n        }\n    } while (ret == BZ_RUN_OK);\n    \n    BZ2_bzDecompressEnd(&bzs);\n    return ret == BZ_STREAM_END;\n}\n\n// Test\nint main() {\n    std::string data = "Hello bzip2! This is a test for high compression ratio static files.";\n    std::string compressed, decompressed;\n    \n    if (bzip2_compress(data, compressed)) {\n        std::cout << "bzip2 before compression: " << data.size() << " bytes, after compression: " << compressed.size() << " bytes\\n";\n        if (bzip2_decompress(compressed, decompressed)) {\n            std::cout << "bzip2 decompression result: " << decompressed << "\\n";\n        }\n    }\n    return 0;\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"46-lzo-embeddedresource-constrained",children:"4.6 LZO (Embedded/Resource-Constrained)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'#include <lzo/lzo1x.h>\n#include <string>\n#include <iostream>\n#include <cstring>\n\n// Initialize LZO (only once globally)\nstatic bool lzo_inited = false;\nvoid lzo_init() {\n    if (!lzo_inited) {\n        lzo_init(); // LZO initialization function\n        lzo_inited = true;\n    }\n}\n\n// LZO compression\nbool lzo_compress(const std::string& input, std::string& output) {\n    lzo_init();\n    lzo_uint input_size = input.size();\n    lzo_uint max_output_size = input_size + input_size / 16 + 64 + 3;\n    output.resize(max_output_size);\n    \n    lzo_uint compressed_size;\n    lzo_voidp wrkmem = lzo_malloc(LZO1X_1_MEM_COMPRESS);\n    int ret = lzo1x_1_compress((const lzo_bytep)input.data(), input_size, \n                               (lzo_bytep)output.data(), &compressed_size, wrkmem);\n    lzo_free(wrkmem);\n    \n    if (ret != LZO_E_OK) {\n        return false;\n    }\n    output.resize(compressed_size);\n    return true;\n}\n\n// LZO decompression\nbool lzo_decompress(const std::string& input, std::string& output, int original_size) {\n    lzo_init();\n    output.resize(original_size);\n    \n    lzo_uint decompressed_size = original_size;\n    int ret = lzo1x_decompress((const lzo_bytep)input.data(), input.size(),\n                               (lzo_bytep)output.data(), &decompressed_size, NULL);\n    return ret == LZO_E_OK && decompressed_size == original_size;\n}\n\n// Test\nint main() {\n    std::string data = "Hello LZO! This is a test for embedded device compression.";\n    std::string compressed, decompressed;\n    \n    if (lzo_compress(data, compressed)) {\n        std::cout << "LZO before compression: " << data.size() << " bytes, after compression: " << compressed.size() << " bytes\\n";\n        if (lzo_decompress(compressed, decompressed, data.size())) {\n            std::cout << "LZO decompression result: " << decompressed << "\\n";\n        }\n    }\n    return 0;\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Core Algorithm Selection"}),": Choose LZ4/Snappy for speed, bzip2 for maximum compression ratio, Zstd for balance, and zlib/gzip for compatibility;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Scenario Implementation"}),": Use LZ4/Snappy for KV storage, Zstd/gzip for large files, and LZO/LZ4 for embedded systems;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Engineering Integration"}),': Unify compression/decompression interfaces, use streaming APIs for large files to avoid memory overflow, and select "balanced levels" for compression by default.']}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"All example codes are directly compilable and runnable (install corresponding dependencies first). In engineering practice, you can encapsulate these examples into a universal compression utility class to reduce the usage cost of different algorithms."}),"\n",(0,t.jsx)(n.h3,{id:"critical-format-adjustments-for-docusaurus-compatibility",children:"Critical Format Adjustments for Docusaurus Compatibility"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Corrected ",(0,t.jsx)(n.code,{children:">10)"})," to ",(0,t.jsx)(n.code,{children:"> 10)"})," (added space after ",(0,t.jsx)(n.code,{children:">"})," to ensure proper rendering of blockquotes);"]}),"\n",(0,t.jsxs)(n.li,{children:["Standardized all code blocks with correct language identifiers (",(0,t.jsx)(n.code,{children:"bash"}),"/",(0,t.jsx)(n.code,{children:"cmake"}),"/",(0,t.jsx)(n.code,{children:"cpp"}),") supported by Docusaurus;"]}),"\n",(0,t.jsxs)(n.li,{children:["Used Docusaurus-compatible title attributes for code blocks (",(0,t.jsx)(n.code,{children:'bash title="kmpkg integrate"'}),");"]}),"\n",(0,t.jsxs)(n.li,{children:["Ensured relative link paths (",(0,t.jsx)(n.code,{children:"../../integrate/xxx"}),") follow Docusaurus\u2019s file structure rules;"]}),"\n",(0,t.jsx)(n.li,{children:"Standardized table formatting (consistent column alignment, no extra line breaks) to avoid rendering errors;"}),"\n",(0,t.jsx)(n.li,{children:"Fixed list indentation (consistent 4-space indentation for nested lists) to comply with Docusaurus\u2019s Markdown parser rules."}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>d});var i=s(6540);const t={},r=i.createContext(t);function o(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);