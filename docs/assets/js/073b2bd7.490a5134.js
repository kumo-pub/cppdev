"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[1248],{8453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>a});var s=r(6540);const i={},l=s.createContext(i);function t(e){const n=s.useContext(l);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),s.createElement(l.Provider,{value:n},e.children)}},9557:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"ir/bison-flex","title":"Bison & Flex","description":"Bison and Flex form a traditional parser generator toolchain widely used in C/C++ environments.","source":"@site/docs/ir/bison-flex.mdx","sourceDirName":"ir","slug":"/ir/bison-flex","permalink":"/cppdev/docs/ir/bison-flex","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"PEGTL (Parsing Expression Grammar Template Library)","permalink":"/cppdev/docs/ir/pegtl"},"next":{"title":"ANTLR","permalink":"/cppdev/docs/ir/antlr"}}');var i=r(4848),l=r(8453);const t={},a="Bison & Flex",o={},c=[{value:"What It Is",id:"what-it-is",level:2},{value:"When to Use",id:"when-to-use",level:2},{value:"Advantages",id:"advantages",level:2},{value:"Considerations",id:"considerations",level:2},{value:"Minimal Example",id:"minimal-example",level:2},{value:"References",id:"references",level:2},{value:"Summary",id:"summary",level:3}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"bison--flex",children:"Bison & Flex"})}),"\n",(0,i.jsxs)(n.p,{children:["Bison and Flex form a traditional ",(0,i.jsx)(n.strong,{children:"parser generator toolchain"})," widely used in C/C++ environments.\nThey are suitable for scenarios where you need ",(0,i.jsx)(n.strong,{children:"custom language parsing"}),", including SQL-like expressions, DSLs, or expression evaluation."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"what-it-is",children:"What It Is"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Flex (lexical analyzer)"}),": Tokenizes input text into symbols."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Bison (parser generator)"}),": Builds a parser from grammar rules and produces a parse tree or AST."]}),"\n",(0,i.jsxs)(n.li,{children:["Together, they allow building a ",(0,i.jsx)(n.strong,{children:"full compiler-like pipeline"}),":\n",(0,i.jsx)(n.code,{children:"Input Text -> Lexical Tokens -> AST/Parse Tree -> Execution/Translation"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"when-to-use",children:"When to Use"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Small to medium DSLs"})," in C/C++ projects."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Offline language compilation or code generation"}),", where control over parsing and AST is important."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Real-time SQL or expression parsing"})," in C++ backend systems; Bison has no mature alternative in C++ for complex grammars."]}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Traditional business applications often ",(0,i.jsx)(n.strong,{children:"do not need"})," this level of IR or parsing control."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"advantages",children:"Advantages"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Mature, stable in C/C++ ecosystems."}),"\n",(0,i.jsx)(n.li,{children:"Fine-grained control of grammar, parsing, and AST generation."}),"\n",(0,i.jsx)(n.li,{children:"Integrates with C++ code directly."}),"\n",(0,i.jsxs)(n.li,{children:["Many ",(0,i.jsx)(n.strong,{children:"real-world examples"}),", including SQL parsers in production systems."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"considerations",children:"Considerations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"C mode recommended"})," for better ecosystem compatibility; C++ mode is less mature."]}),"\n",(0,i.jsx)(n.li,{children:"Integration is more complex than PEGTL or DSL-based proto parsers."}),"\n",(0,i.jsxs)(n.li,{children:["Parsing performance is closely related to ",(0,i.jsx)(n.strong,{children:"expression complexity"})," and grammar design, including ",(0,i.jsx)(n.strong,{children:"backtracking requirements"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Good for ",(0,i.jsx)(n.strong,{children:"offline compilation pipelines"}),", not primarily for high-throughput online services."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"minimal-example",children:"Minimal Example"}),"\n",(0,i.jsxs)(n.p,{children:["This example shows a ",(0,i.jsx)(n.strong,{children:"full Flex -> Bison -> C++ integration"})," pipeline."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Lexer (lexer.l)"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'%{\n#include "parser.tab.h"\n#include <cstdlib>\n%}\n\n%%\nSELECT          return SELECT;\nFROM            return FROM;\nWHERE           return WHERE;\n[0-9]+          { yylval.ival = atoi(yytext); return NUMBER; }\n[a-zA-Z_]+      { yylval.sval = strdup(yytext); return IDENTIFIER; }\n[ \\t\\n]+        /* skip whitespace */;\n.               return *yytext;\n%%\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parser (parser.y)"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"%{\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nstruct Column { string name; };\nstruct Table { string name; };\nstruct Condition { string expr; };\nstruct Query {\n    vector<Column> columns;\n    Table table;\n    Condition condition;\n};\nQuery parsedQuery;\n%}\n\n%union {\n    int ival;\n    char* sval;\n}\n\n%token SELECT FROM WHERE IDENTIFIER NUMBER\n%type <sval> IDENTIFIER\n%type <ival> NUMBER\n\n%%\n\nquery:\n      SELECT select_list FROM table_name where_clause\n    ;\n\nselect_list:\n      IDENTIFIER { parsedQuery.columns.push_back({$1}); free($1); }\n    | select_list ',' IDENTIFIER { parsedQuery.columns.push_back({$3}); free($3); }\n    ;\n\ntable_name:\n      IDENTIFIER { parsedQuery.table.name = $1; free($1); }\n    ;\n\nwhere_clause:\n      WHERE condition { parsedQuery.condition.expr = $2; free($2); }\n    | /* empty */ { parsedQuery.condition.expr = \"\"; }\n    ;\n\ncondition:\n      IDENTIFIER '>' NUMBER\n      {\n          string cond = string($1) + \">\" + to_string($3);\n          $$ = strdup(cond.c_str());\n          free($1);\n      }\n    ;\n%%\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"C++ Integration (main.cpp)"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'#include <iostream>\nextern "C" {\n    int yyparse();\n    extern FILE* yyin;\n}\n\nint main() {\n    FILE* f = fopen("example.sql", "r");\n    if (!f) {\n        std::cerr << "Cannot open file" << std::endl;\n        return 1;\n    }\n    yyin = f;\n    yyparse();\n    fclose(f);\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"CMake Build Example"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cmake",children:"cmake_minimum_required(VERSION 3.10)\nproject(sql_parser)\n\nfind_package(FLEX REQUIRED)\nfind_package(BISON REQUIRED)\n\nBISON_TARGET(Parser parser.y ${CMAKE_CURRENT_BINARY_DIR}/parser.tab.cpp)\nFLEX_TARGET(Lexer lexer.l ${CMAKE_CURRENT_BINARY_DIR}/lex.yy.cpp)\nADD_FLEX_BISON_DEPENDENCY(Lexer Parser)\n\nadd_executable(sql_parser main.cpp ${BISON_Parser_OUTPUTS} ${FLEX_Lexer_OUTPUTS})\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://www.gnu.org/software/bison/",children:"GNU Bison Official"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://westes.github.io/flex/",children:"Flex Official"})}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"summary",children:"Summary"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Integration complexity"}),": Medium\u2013High (requires C/C++ linkage, memory management)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance"}),": Good for offline or limited online parsing; depends on grammar complexity."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Best use cases"}),": Offline compilation, expression evaluation, SQL parsing in backend systems."]}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["The minimal example demonstrates ",(0,i.jsx)(n.strong,{children:"complete pipeline integration"}),", which is critical for readers to understand practical usage, not just fragments."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);