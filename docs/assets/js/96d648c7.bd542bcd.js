"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[5850],{1525:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>m,frontMatter:()=>c,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"foundamentals/json/dom","title":"DOM","description":"The Document Object Model (DOM) is an in-memory JSON representation designed for querying and manipulation. We introduced the basic usage of DOM in the Tutorial; this section will cover additional details and advanced usage.","source":"@site/docs/foundamentals/json/dom.mdx","sourceDirName":"foundamentals/json","slug":"/foundamentals/json/dom","permalink":"/cppdev/docs/foundamentals/json/dom","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Encoding","permalink":"/cppdev/docs/foundamentals/json/encoding"},"next":{"title":"SAX","permalink":"/cppdev/docs/foundamentals/json/sax"}}');var i=r(4848),t=r(8453);const a=r.p+"assets/images/normalparsing-14354719e70579b5dc2f319aeeceb557.png",o=r.p+"assets/images/insituparsing-54d3faf4594f733d753391771aacb91e.png",c={},d="DOM",l={},h=[{value:"Encoding",id:"Encoding",level:2},{value:"Allocator",id:"Allocator",level:2},{value:"Parse Error",id:"ParseError",level:2},{value:"In Situ Parsing",id:"InSituParsing",level:2},{value:"Transcoding and Validation",id:"TranscodingAndValidation",level:2},{value:"Using DOM as a SAX Event Publisher",id:"using-dom-as-a-sax-event-publisher",level:2},{value:"User-Provided Buffers",id:"UserBuffer",level:2}];function u(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"dom",children:"DOM"})}),"\n",(0,i.jsxs)(n.p,{children:["The Document Object Model (DOM) is an in-memory JSON representation designed for querying and manipulation. We introduced the basic usage of DOM in the ",(0,i.jsx)(n.a,{href:"/cppdev/docs/foundamentals/json/tutorial",children:"Tutorial"}),"; this section will cover additional details and advanced usage."]}),"\n",(0,i.jsx)(n.p,{children:"[TOC]"}),"\n",(0,i.jsx)(n.h1,{id:"Template",children:"Template"}),"\n",(0,i.jsxs)(n.p,{children:["In the tutorial, we used the ",(0,i.jsx)(n.code,{children:"Value"})," and ",(0,i.jsx)(n.code,{children:"Document"})," types. Similar to ",(0,i.jsx)(n.code,{children:"std::string"}),", these types are actually ",(0,i.jsx)(n.code,{children:"typedef"}),"s of two template classes:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"namespace merak::json {\n\ntemplate <typename Encoding, typename Allocator = MemoryPoolAllocator<> >\nclass GenericValue {\n    // ...\n};\n\ntemplate <typename Encoding, typename Allocator = MemoryPoolAllocator<> >\nclass GenericDocument : public GenericValue<Encoding, Allocator> {\n    // ...\n};\n\ntypedef GenericValue<UTF8<> > Value;\ntypedef GenericDocument<UTF8<> > Document;\n\n} // namespace merak::json\n"})}),"\n",(0,i.jsx)(n.p,{children:"Users can customize these template parameters."}),"\n",(0,i.jsx)(n.h2,{id:"Encoding",children:"Encoding"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Encoding"})," parameter specifies the encoding used for JSON Strings in memory. Valid options are ",(0,i.jsx)(n.code,{children:"UTF8"}),", ",(0,i.jsx)(n.code,{children:"UTF16"}),", and ",(0,i.jsx)(n.code,{children:"UTF32"}),". Note that these three types are also template classes. ",(0,i.jsx)(n.code,{children:"UTF8<>"})," is equivalent to ",(0,i.jsx)(n.code,{children:"UTF8<char>"}),", meaning it uses ",(0,i.jsx)(n.code,{children:"char"})," to store strings. For more details, refer to ",(0,i.jsx)(n.a,{href:"/cppdev/docs/foundamentals/json/encoding",children:"Encoding"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Here is an example: suppose a Windows application needs to query localized strings stored in JSON. Unicode-enabled functions in Windows use UTF-16 (wide character) encoding. Regardless of the encoding used in the JSON file, we can store the strings in memory as UTF-16."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'using namespace merak::json;\n\ntypedef GenericDocument<UTF16<> > WDocument;\ntypedef GenericValue<UTF16<> > WValue;\n\nFILE* fp = fopen("localization.json", "rb"); // Use "r" for non-Windows platforms\n\nchar readBuffer[256];\nFileReadStream bis(fp, readBuffer, sizeof(readBuffer));\n\nAutoUTFInputStream<unsigned, FileReadStream> eis(bis);  // Wrap bis into eis\n\nWDocument d;\nd.ParseStream<0, AutoUTF<unsigned> >(eis);\n\nconst WValue locale(L"ja"); // Japanese\n\nMessageBoxW(hWnd, d[locale].GetString(), L"Test", MB_OK);\n'})}),"\n",(0,i.jsx)(n.h2,{id:"Allocator",children:"Allocator"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Allocator"})," defines which allocation class is used when ",(0,i.jsx)(n.code,{children:"Document"}),"/",(0,i.jsx)(n.code,{children:"Value"})," allocates or frees memory. A ",(0,i.jsx)(n.code,{children:"Document"})," owns or references an ",(0,i.jsx)(n.code,{children:"Allocator"})," instance. To save memory, ",(0,i.jsx)(n.code,{children:"Value"})," does not have this instance."]}),"\n",(0,i.jsxs)(n.p,{children:["The default allocator for ",(0,i.jsx)(n.code,{children:"GenericDocument"})," is ",(0,i.jsx)(n.code,{children:"MemoryPoolAllocator"}),". This allocator actually allocates memory sequentially and cannot free individual blocks. When parsing a JSON to generate a DOM, this allocator is highly suitable."]}),"\n",(0,i.jsxs)(n.p,{children:["Merak also provides another allocator, ",(0,i.jsx)(n.code,{children:"CrtAllocator"})," (CRT stands for C RunTime library). This allocator simply uses the standard ",(0,i.jsx)(n.code,{children:"malloc()"}),"/",(0,i.jsx)(n.code,{children:"realloc()"}),"/",(0,i.jsx)(n.code,{children:"free()"}),". It is more suitable when numerous add/remove operations are required. However, this allocator is far less efficient than ",(0,i.jsx)(n.code,{children:"MemoryPoolAllocator"}),"."]}),"\n",(0,i.jsx)(n.h1,{id:"Parsing",children:"Parsing"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Document"})," provides several parsing functions. Function (1) below is the fundamental one, and the others are helper functions that call (1):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"using namespace merak::json;\n\n// (1) Fundamental\ntemplate <unsigned parseFlags, typename SourceEncoding, typename InputStream>\nGenericDocument& GenericDocument::ParseStream(InputStream& is);\n\n// (2) Use encoding of the stream\ntemplate <unsigned parseFlags, typename InputStream>\nGenericDocument& GenericDocument::ParseStream(InputStream& is);\n\n// (3) Use default flags\ntemplate <typename InputStream>\nGenericDocument& GenericDocument::ParseStream(InputStream& is);\n\n// (4) In situ parsing\ntemplate <unsigned parseFlags>\nGenericDocument& GenericDocument::ParseInsitu(Ch* str);\n\n// (5) In situ parsing with default flags\nGenericDocument& GenericDocument::ParseInsitu(Ch* str);\n\n// (6) Normal parsing of a string\ntemplate <unsigned parseFlags, typename SourceEncoding>\nGenericDocument& GenericDocument::Parse(const Ch* str);\n\n// (7) Normal parsing of a string using Document's encoding\ntemplate <unsigned parseFlags>\nGenericDocument& GenericDocument::Parse(const Ch* str);\n\n// (8) Normal parsing of a string with default flags\nGenericDocument& GenericDocument::Parse(const Ch* str);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Examples in the ",(0,i.jsx)(n.a,{href:"/cppdev/docs/foundamentals/json/tutorial",children:"Tutorial"})," use (8) for normal string parsing, while examples in ",(0,i.jsx)(n.a,{href:"/cppdev/docs/foundamentals/json/stream",children:"Streams"})," use the first three functions. We will introduce in situ parsing later."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"parseFlags"})," is a combination of the following bit flags:"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parse Bit Flag"}),(0,i.jsx)(n.th,{children:"Meaning"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"kParseNoFlags"})}),(0,i.jsx)(n.td,{children:"No flags set."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"kParseDefaultFlags"})}),(0,i.jsxs)(n.td,{children:["Default parsing options. Equivalent to the macro ",(0,i.jsx)(n.code,{children:"RAPIDJSON_PARSE_DEFAULT_FLAGS"}),", which is defined as ",(0,i.jsx)(n.code,{children:"kParseNoFlags"}),"."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"kParseInsituFlag"})}),(0,i.jsx)(n.td,{children:"In situ (destructive) parsing."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"kParseValidateEncodingFlag"})}),(0,i.jsx)(n.td,{children:"Validate the encoding of JSON strings."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"kParseIterativeFlag"})}),(0,i.jsx)(n.td,{children:"Iterative parsing (constant stack space complexity)."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"kParseStopWhenDoneFlag"})}),(0,i.jsxs)(n.td,{children:["Stop processing the remaining stream after parsing a complete JSON root node. When this flag is set, the parser will not generate the ",(0,i.jsx)(n.code,{children:"kParseErrorDocumentRootNotSingular"})," error. This flag can be used to parse multiple JSONs from the same stream."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"kParseFullPrecisionFlag"})}),(0,i.jsxs)(n.td,{children:["Parse numbers with full precision (slower). If not set, normal precision (faster) is used, with a maximum error of 3 ",(0,i.jsx)(n.a,{href:"http://en.wikipedia.org/wiki/Unit_in_the_last_place",children:"ULP"}),"."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"kParseCommentsFlag"})}),(0,i.jsxs)(n.td,{children:["Allow single-line ",(0,i.jsx)(n.code,{children:"// ..."})," and multi-line ",(0,i.jsx)(n.code,{children:"/* ... */"})," comments (relaxed JSON syntax)."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"kParseNumbersAsStringsFlag"})}),(0,i.jsx)(n.td,{children:"Parse numeric types as strings."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"kParseTrailingCommasFlag"})}),(0,i.jsx)(n.td,{children:"Allow trailing commas before the end of objects and arrays (relaxed JSON syntax)."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"kParseNanAndInfFlag"})}),(0,i.jsxs)(n.td,{children:["Allow ",(0,i.jsx)(n.code,{children:"NaN"}),", ",(0,i.jsx)(n.code,{children:"Inf"}),", ",(0,i.jsx)(n.code,{children:"Infinity"}),", ",(0,i.jsx)(n.code,{children:"-Inf"}),", and ",(0,i.jsx)(n.code,{children:"-Infinity"})," as ",(0,i.jsx)(n.code,{children:"double"})," values (relaxed JSON syntax)."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"kParseEscapedApostropheFlag"})}),(0,i.jsxs)(n.td,{children:["Allow escaped apostrophes ",(0,i.jsx)(n.code,{children:"\\'"})," in strings (relaxed JSON syntax)."]})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"Since non-type template parameters are used instead of function parameters, the C++ compiler can generate code for individual combinations to improve performance and reduce code size (when only a single specialization is used). The downside is that flags must be determined at compile time."}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"SourceEncoding"})," parameter defines the encoding used by the stream, which may differ from the ",(0,i.jsx)(n.code,{children:"Encoding"})," of the ",(0,i.jsx)(n.code,{children:"Document"}),". For details, refer to the ",(0,i.jsx)(n.a,{href:"#TranscodingAndValidation",children:"Transcoding and Validation"})," section."]}),"\n",(0,i.jsxs)(n.p,{children:["Additionally, ",(0,i.jsx)(n.code,{children:"InputStream"})," is the type of the input stream."]}),"\n",(0,i.jsx)(n.h2,{id:"ParseError",children:"Parse Error"}),"\n",(0,i.jsxs)(n.p,{children:["If parsing completes successfully, the ",(0,i.jsx)(n.code,{children:"Document"})," will contain the parsing result. If an error occurs during parsing, the original DOM remains ",(0,i.jsx)(n.em,{children:"unchanged"}),". You can use ",(0,i.jsx)(n.code,{children:"bool HasParseError()"}),", ",(0,i.jsx)(n.code,{children:"ParseErrorCode GetParseError()"}),", and ",(0,i.jsx)(n.code,{children:"size_t GetErrorOffset()"})," to retrieve the parsing error status."]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parse Error Code"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"kParseErrorNone"})}),(0,i.jsx)(n.td,{children:"No error."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"kParseErrorDocumentEmpty"})}),(0,i.jsx)(n.td,{children:"The document is empty."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"kParseErrorDocumentRootNotSingular"})}),(0,i.jsx)(n.td,{children:"No additional values are allowed after the document root."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"kParseErrorValueInvalid"})}),(0,i.jsx)(n.td,{children:"Invalid value."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"kParseErrorObjectMissName"})}),(0,i.jsx)(n.td,{children:"Missing name for Object member."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"kParseErrorObjectMissColon"})}),(0,i.jsx)(n.td,{children:"Missing colon after Object member name."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"kParseErrorObjectMissCommaOrCurlyBracket"})}),(0,i.jsxs)(n.td,{children:["Missing comma or ",(0,i.jsx)(n.code,{children:"}"})," after Object member."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"kParseErrorArrayMissCommaOrSquareBracket"})}),(0,i.jsxs)(n.td,{children:["Missing comma or ",(0,i.jsx)(n.code,{children:"]"})," after Array element."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"kParseErrorStringUnicodeEscapeInvalidHex"})}),(0,i.jsxs)(n.td,{children:["Invalid hexadecimal digits after ",(0,i.jsx)(n.code,{children:"\\\\u"})," escape in String."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"kParseErrorStringUnicodeSurrogateInvalid"})}),(0,i.jsx)(n.td,{children:"Invalid surrogate pair in String."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"kParseErrorStringEscapeInvalid"})}),(0,i.jsx)(n.td,{children:"Invalid escape character in String."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"kParseErrorStringMissQuotationMark"})}),(0,i.jsx)(n.td,{children:"Missing closing quotation mark for String."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"kParseErrorStringInvalidEncoding"})}),(0,i.jsx)(n.td,{children:"Invalid encoding in String."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"kParseErrorNumberTooBig"})}),(0,i.jsxs)(n.td,{children:["Numeric value is too large to be stored in a ",(0,i.jsx)(n.code,{children:"double"}),"."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"kParseErrorNumberMissFraction"})}),(0,i.jsx)(n.td,{children:"Missing fractional part for Number."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"kParseErrorNumberMissExponent"})}),(0,i.jsx)(n.td,{children:"Missing exponent for Number."})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"The error offset is defined as the number of characters from the start of the stream to the error location. Currently, Merak does not record error line numbers."}),"\n",(0,i.jsxs)(n.p,{children:["To retrieve error messages, Merak provides English error messages in ",(0,i.jsx)(n.code,{children:"merak/json/error/en.h"}),". Users can modify this file for other language environments or use a custom localization system."]}),"\n",(0,i.jsx)(n.p,{children:"Here is an example of handling errors:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'#include "merak/json/document.h"\n#include "merak/json/error/en.h"\n\n// ...\nDocument d;\nif (d.Parse(json).HasParseError()) {\n    fprintf(stderr, "\\nError(offset %u): %s\\n", \n        (unsigned)d.GetErrorOffset(),\n        GetParseError_En(d.GetParseErrorCode()));\n    // ...\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"InSituParsing",children:"In Situ Parsing"}),"\n",(0,i.jsxs)(n.p,{children:["According to ",(0,i.jsx)(n.a,{href:"http://en.wikipedia.org/wiki/In_situ",children:"Wikipedia"}),":"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"In situ"}),' ... is a Latin phrase that translates literally to "on site" or "in position". It means "locally", "on site", "on the premises" or "in place" to describe an event where it takes place, and is used in many different contexts.\n...\n(In computer science) An algorithm is said to be an in situ algorithm, or in-place algorithm, if the extra amount of memory required to execute the algorithm is O(1), that is, does not exceed a constant no matter how large the input. For example, heapsort is an in situ sorting algorithm.']}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["In the normal parsing process, decoding JSON strings and copying them to other buffers incurs significant overhead. In situ parsing decodes these JSON strings directly in their original storage location. This is feasible because the length of the decoded string is always shorter than or equal to the original string stored in JSON. In this context, decoding a JSON string refers to processing escape characters (e.g., ",(0,i.jsx)(n.code,{children:'"\\n"'}),", ",(0,i.jsx)(n.code,{children:'"\\u1234"'}),"), and adding a null terminator (",(0,i.jsx)(n.code,{children:"'\\0'"}),") at the end of the string."]}),"\n",(0,i.jsx)(n.p,{children:"The diagrams below compare normal parsing and in situ parsing. JSON string values contain pointers to the decoded strings."}),"\n","\n",(0,i.jsx)("img",{src:a}),"\n",(0,i.jsxs)(n.p,{children:["In normal parsing, the decoded string is copied to a newly allocated buffer. ",(0,i.jsx)(n.code,{children:'"\\\\n"'})," (2 characters) is decoded to ",(0,i.jsx)(n.code,{children:'"\\n"'})," (1 character), and ",(0,i.jsx)(n.code,{children:'"\\\\u0073"'})," (6 characters) is decoded to ",(0,i.jsx)(n.code,{children:'"s"'})," (1 character)."]}),"\n","\n",(0,i.jsx)("img",{src:o}),"\n",(0,i.jsxs)(n.p,{children:["In situ parsing modifies the original JSON directly. The updated characters are highlighted in the diagram. If a JSON string contains no escape characters (e.g., ",(0,i.jsx)(n.code,{children:'"msg"'}),"), the parsing process simply replaces the closing double quote with a null character."]}),"\n",(0,i.jsxs)(n.p,{children:["Since in situ parsing modifies the input, its parsing API requires ",(0,i.jsx)(n.code,{children:"char*"})," instead of ",(0,i.jsx)(n.code,{children:"const char*"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'// Read the entire file into a buffer\nFILE* fp = fopen("test.json", "r");\nfseek(fp, 0, SEEK_END);\nsize_t filesize = (size_t)ftell(fp);\nfseek(fp, 0, SEEK_SET);\nchar* buffer = (char*)malloc(filesize + 1);\nsize_t readLength = fread(buffer, 1, filesize, fp);\nbuffer[readLength] = \'\\0\';\nfclose(fp);\n\n// Parse the buffer in situ into d; the buffer content will be modified\nDocument d;\nd.ParseInsitu(buffer);\n\n// Query and modify the DOM here...\n\nfree(buffer);\n// Note: At this point, d may contain dangling pointers to the freed buffer\n'})}),"\n",(0,i.jsx)(n.p,{children:'JSON strings are marked with a const-string flag, but they may not be truly "constant". Their lifetime depends on the buffer storing the JSON.'}),"\n",(0,i.jsx)(n.p,{children:"In situ parsing minimizes allocation overhead and memory copying. This typically improves cache coherence, a critical performance factor for modern computers."}),"\n",(0,i.jsx)(n.p,{children:"In situ parsing has the following limitations:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"The entire JSON must be stored in memory."}),"\n",(0,i.jsx)(n.li,{children:"The source encoding of the stream must match the target encoding of the document."}),"\n",(0,i.jsx)(n.li,{children:"The buffer must be retained until the document is no longer used."}),"\n",(0,i.jsx)(n.li,{children:"If the DOM needs to be used long-term after parsing and contains only a small number of JSON strings, retaining the buffer may result in memory waste."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"In situ parsing is most suitable for short-lived, disposable JSON. In practice, these scenarios are very common\u2014for example, deserializing JSON to C++ objects, processing web requests represented in JSON, etc."}),"\n",(0,i.jsx)(n.h2,{id:"TranscodingAndValidation",children:"Transcoding and Validation"}),"\n",(0,i.jsxs)(n.p,{children:["Merak natively supports conversion between different Unicode formats (officially called UCS Transformation Formats). During DOM parsing, the source encoding of the stream can differ from the encoding of the DOM. For example, the source stream may contain UTF-8 JSON, while the DOM uses UTF-16 encoding. An example is provided in the ",(0,i.jsx)(n.a,{href:"/cppdev/docs/foundamentals/json/stream",children:"EncodedInputStream"})," section."]}),"\n",(0,i.jsxs)(n.p,{children:["Transcoding can also be used when outputting a JSON from the DOM to an output stream. An example is provided in the ",(0,i.jsx)(n.a,{href:"/cppdev/docs/foundamentals/json/stream",children:"EncodedOutputStream"})," section."]}),"\n",(0,i.jsxs)(n.p,{children:["During transcoding, the source string is decoded into Unicode code points, which are then encoded into the target format. During decoding, it validates whether the byte sequence of the source string is legal. If an illegal sequence is encountered, the parser stops and returns the ",(0,i.jsx)(n.code,{children:"kParseErrorStringInvalidEncoding"})," error."]}),"\n",(0,i.jsxs)(n.p,{children:["When the source encoding matches the DOM's encoding, the parser does ",(0,i.jsx)(n.em,{children:"not"})," validate the sequence by default. Users can enable ",(0,i.jsx)(n.code,{children:"kParseValidateEncodingFlag"})," to force validation."]}),"\n",(0,i.jsx)(n.h1,{id:"Techniques",children:"Techniques"}),"\n",(0,i.jsx)(n.p,{children:"This section discusses some usage techniques for the DOM API."}),"\n",(0,i.jsx)(n.h2,{id:"using-dom-as-a-sax-event-publisher",children:"Using DOM as a SAX Event Publisher"}),"\n",(0,i.jsxs)(n.p,{children:["In Merak, generating JSON from a DOM using ",(0,i.jsx)(n.code,{children:"Writer"})," may seem counterintuitive:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// ...\nWriter<StringBuffer> writer(buffer);\nd.Accept(writer);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In fact, ",(0,i.jsx)(n.code,{children:"Value::Accept()"})," is responsible for publishing SAX events related to the value to a handler. This design decouples ",(0,i.jsx)(n.code,{children:"Value"})," and ",(0,i.jsx)(n.code,{children:"Writer"}),": ",(0,i.jsx)(n.code,{children:"Value"})," can generate SAX events, and ",(0,i.jsx)(n.code,{children:"Writer"})," can process these events."]}),"\n",(0,i.jsx)(n.p,{children:"Users can create custom handlers to convert the DOM to other formats\u2014for example, a handler that converts the DOM to XML."}),"\n",(0,i.jsxs)(n.p,{children:["For more information about SAX events and handlers, refer to ",(0,i.jsx)(n.a,{href:"/cppdev/docs/foundamentals/json/sax",children:"SAX"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"UserBuffer",children:"User-Provided Buffers"}),"\n",(0,i.jsx)(n.p,{children:"Many applications may need to minimize memory allocations."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"MemoryPoolAllocator"}),' can help with this, as it allows users to provide a buffer. This buffer may be placed on the program stack or as a statically allocated "scratch buffer" (a static/global array) for storing temporary data.']}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"MemoryPoolAllocator"})," first uses the user-provided buffer to fulfill allocation requests. When the user buffer is exhausted, it allocates a block of memory from the underlying allocator (default: ",(0,i.jsx)(n.code,{children:"CrtAllocator"}),")."]}),"\n",(0,i.jsx)(n.p,{children:"Here is an example using stack memory: the first allocator is used to store values, and the second for temporary buffering during parsing:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"typedef GenericDocument<UTF8<>, MemoryPoolAllocator<>, MemoryPoolAllocator<>> DocumentType;\nchar valueBuffer[4096];\nchar parseBuffer[1024];\nMemoryPoolAllocator<> valueAllocator(valueBuffer, sizeof(valueBuffer));\nMemoryPoolAllocator<> parseAllocator(parseBuffer, sizeof(parseBuffer));\nDocumentType d(&valueAllocator, sizeof(parseBuffer), &parseAllocator);\nd.Parse(json);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If the total allocation during parsing is less than 4096 + 1024 bytes, this code will not cause any heap memory allocations (via ",(0,i.jsx)(n.code,{children:"new"})," or ",(0,i.jsx)(n.code,{children:"malloc()"}),")."]}),"\n",(0,i.jsxs)(n.p,{children:["Users can query the current allocated memory size via ",(0,i.jsx)(n.code,{children:"MemoryPoolAllocator::Size()"}),", allowing them to determine an appropriate size for the user-provided buffer."]})]})}function m(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>o});var s=r(6540);const i={},t=s.createContext(i);function a(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);