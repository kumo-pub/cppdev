"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[7591],{7167:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>d,default:()=>u,frontMatter:()=>o,metadata:()=>n,toc:()=>a});const n=JSON.parse('{"id":"strings/substitution","title":"String Replacement","description":"turbo::substitute() - String Replacement","source":"@site/docs/strings/substitution.mdx","sourceDirName":"strings","slug":"/strings/substitution","permalink":"/docs/strings/substitution","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/strings/substitution.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Joining Elements in Strings","permalink":"/docs/strings/join"},"next":{"title":"Turbo Command-Line Flags (Turbo Flags)","permalink":"/docs/flags/"}}');var r=s(4848),i=s(8453);const o={},d="String Replacement",c={},a=[{value:"<code>turbo::substitute()</code> - String Replacement",id:"turbosubstitute---string-replacement",level:2},{value:"Differences from string_printf()",id:"differences-from-string_printf",level:3},{value:"Supported Types",id:"supported-types",level:3}];function l(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"string-replacement",children:"String Replacement"})}),"\n",(0,r.jsxs)(t.h2,{id:"turbosubstitute---string-replacement",children:[(0,r.jsx)(t.code,{children:"turbo::substitute()"})," - String Replacement"]}),"\n",(0,r.jsxs)(t.p,{children:["Setting the format of strings displayed to users usually has different requirements. Traditionally, most C++ code uses built-in functions such as ",(0,r.jsx)(t.code,{children:"sprintf()"})," and ",(0,r.jsx)(t.code,{children:"snprintf()"}),"; these functions have certain issues because they do not support ",(0,r.jsx)(t.code,{children:"std::string_view"})," and require manual management of formatting buffer memory."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cpp",children:'// Bad. Need to worry about buffer size and NUL-terminations.\n\nstd::string GetErrorMessage(char *op, char *user, int id) {\n  char buffer[50];\n  sprintf(buffer, "Error in %s for user %s (id %i)", op, user, id);\n  return buffer;\n}\n'})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cpp",children:'// Better. Using turbo::str_cat() avoids the pitfalls of sprintf() and is faster.\nstd::string GetErrorMessage(std::string_view op, std::string_view user, int id) {\n  return turbo::str_cat("Error in ", op, " for user ", user, " (", id, ")");\n}\n'})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cpp",children:'// Best. Using turbo::substitute() is easier to read and to understand.\nstd::string GetErrorMessage(std::string_view op, std::string_view user, int id) {\n  return turbo::substitute("Error in $0 for user $1 ($2)", op, user, id);\n}\n'})}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"turbo::substitute()"})," combines the efficiency and type safety features of ",(0,r.jsx)(t.code,{children:"turbo::str_cat()"})," with the parameter binding of traditional functions such as ",(0,r.jsx)(t.code,{children:"sprintf()"}),". ",(0,r.jsx)(t.code,{children:"turbo::substitute"})," uses a format string containing position identifiers indicated by a dollar sign ($) followed by a single-digit position ID, which specifies which replacement argument to use at that position in the format string."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cpp",children:'std::string s = substitute("$1 purchased $0 $2. Thanks $1!", 5, "Bob", "Apples");\n// Produces the string "Bob purchased 5 Apples. Thanks Bob!"\n\nstd::string s = "Hi. ";\nSubstituteAndAppend(&s, "My name is $0 and I am $1 years old.", "Bob", 5);\n// Produces the string "Hi. My name is Bob and I am 5 years old."\n'})}),"\n",(0,r.jsxs)(t.p,{children:["Note, however, that ",(0,r.jsx)(t.code,{children:"turbo::substitute()"})," is slower than ",(0,r.jsx)(t.code,{children:"turbo::str_cat()"})," because it needs to parse the format string at runtime. Choose ",(0,r.jsx)(t.code,{children:"substitute()"})," only when code clarity is more important than speed."]}),"\n",(0,r.jsx)(t.h3,{id:"differences-from-string_printf",children:"Differences from string_printf()"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"turbo::substitute"})," differs from ",(0,r.jsx)(t.code,{children:"string_printf()"})," in the following ways:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"The format string does not recognize the types of arguments. Instead, arguments are implicitly converted to strings."}),"\n",(0,r.jsx)(t.li,{children:'Replacements in the format string are identified by "$" followed by a number. You can use arguments out of order and use the same argument multiple times.'}),"\n",(0,r.jsx)(t.li,{children:'A "$$" sequence in the format string represents a literal "$" character in the output.'}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"turbo::substitute()"})," is significantly faster than ",(0,r.jsx)(t.code,{children:"string_printf()"}),". For very large strings, the speed may be several orders of magnitude faster."]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"supported-types",children:"Supported Types"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"turbo::substitute()"})," understands the following types:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"std::string_view"}),", ",(0,r.jsx)(t.code,{children:"std::string"}),", ",(0,r.jsx)(t.code,{children:"const char*"}),' (null is equivalent to "")']}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"int32_t"}),", ",(0,r.jsx)(t.code,{children:"int64_t"}),", ",(0,r.jsx)(t.code,{children:"uint32_t"}),", ",(0,r.jsx)(t.code,{children:"uint64_t"})]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"float"}),", ",(0,r.jsx)(t.code,{children:"double"})]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"bool"}),' (printed as "true" or "false")']}),"\n",(0,r.jsxs)(t.li,{children:["Pointer types other than char* (printed as ",(0,r.jsx)(t.code,{children:"0x<lowercase hexadecimal string>"}),', except null which is printed as "NULL")']}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>o,x:()=>d});var n=s(6540);const r={},i=n.createContext(r);function o(e){const t=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);