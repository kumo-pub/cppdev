"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[724],{7385:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"foundamentals/fibers/faq","title":"FAQ","description":"Q: Is kthread a coroutine?","source":"@site/docs/foundamentals/fibers/faq.mdx","sourceDirName":"foundamentals/fibers","slug":"/foundamentals/fibers/faq","permalink":"/cppdev/docs/foundamentals/fibers/faq","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/foundamentals/fibers/faq.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Thread Model Selection","permalink":"/cppdev/docs/foundamentals/fibers/kthread_or_not"},"next":{"title":"Monitoring","permalink":"/cppdev/docs/foundamentals/monitor/"}}');var t=r(4848),i=r(8453);const a={},o="FAQ",l={},d=[{value:"Q: Is kthread a coroutine?",id:"q-is-kthread-a-coroutine",level:2},{value:"Q: Should I use kthread extensively in my program?",id:"q-should-i-use-kthread-extensively-in-my-program",level:2},{value:"Q: How do kthreads map to pthread workers?",id:"q-how-do-kthreads-map-to-pthread-workers",level:2},{value:"Q: Can blocking pthread or system functions be called within a kthread?",id:"q-can-blocking-pthread-or-system-functions-be-called-within-a-kthread",level:2},{value:"Q: Does a blocked kthread affect other kthreads?",id:"q-does-a-blocked-kthread-affect-other-kthreads",level:2},{value:"Q: Can kthread APIs be called within a pthread?",id:"q-can-kthread-apis-be-called-within-a-pthread",level:2},{value:"Q: Will a large number of kthreads calling blocking pthread/system functions affect RPC execution?",id:"q-will-a-large-number-of-kthreads-calling-blocking-pthreadsystem-functions-affect-rpc-execution",level:2},{value:"Q: Will kthread support Channel (as in Go)?",id:"q-will-kthread-support-channel-as-in-go",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"faq",children:"FAQ"})}),"\n",(0,t.jsx)(n.h2,{id:"q-is-kthread-a-coroutine",children:"Q: Is kthread a coroutine?"}),"\n",(0,t.jsxs)(n.p,{children:["No. The coroutines we commonly refer to specifically mean ",(0,t.jsx)(n.strong,{children:"N:1 threading libraries"}),"\u2014all coroutines run within a single system thread, with computational capabilities equivalent to various event loop libraries. Since coroutine switching does not involve system calls (no cross-thread operations), it can be extremely fast (100ns-200ns) and less affected by cache coherence. However, this comes at the cost of inefficient multi-core utilization: code must be non-blocking, otherwise all coroutines will be stuck, imposing strict requirements on developers. This characteristic makes coroutines suitable for writing IO servers with deterministic execution time (e.g., HTTP servers), which can achieve extremely high throughput in carefully tuned scenarios."]}),"\n",(0,t.jsxs)(n.p,{children:["However, most online services within Baidu have ",(0,t.jsx)(n.strong,{children:"non-deterministic execution time"}),", and many retrieval tasks are collaboratively developed by dozens of engineers. A single slow function can block all coroutines. Event loops share this limitation: if a callback blocks, the entire loop is stuck. For example, ",(0,t.jsx)(n.strong,{children:"ub"}),"a",(0,t.jsx)(n.strong,{children:"server"}),' (note the letter "a"\u2014not ubserver) was Baidu\'s attempt at an asynchronous framework, composed of multiple parallel event loops. Its real-world performance was poor: slow logging operations, delays in Redis access, or heavy computation workloads in callbacks would cause a large number of pending requests to time out. As a result, this framework never gained popularity.']}),"\n",(0,t.jsxs)(n.p,{children:["kthread is an ",(0,t.jsxs)(n.strong,{children:["M",":N"," threading library"]}),"\u2014a blocked kthread does not affect other kthreads. It relies on two key technologies:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Work stealing scheduling"}),": Enables kthreads to be scheduled to more CPU cores faster."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Butex"}),": A synchronization primitive that allows kthreads and pthreads to wait for and wake each other."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Neither of these technologies is required for coroutines. For more knowledge about threading, refer to ",(0,t.jsx)(n.a,{href:"/cppdev/docs/rpc/krpc/threading_overview",children:"this document"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"q-should-i-use-kthread-extensively-in-my-program",children:"Q: Should I use kthread extensively in my program?"}),"\n",(0,t.jsxs)(n.p,{children:["No. Unless you need to ",(0,t.jsx)(n.a,{href:"/cppdev/docs/foundamentals/fibers/kthread_or_not",children:"run some code concurrently during a single RPC call"}),", you should avoid directly calling kthread functions\u2014leave these operations to krpc instead, as it handles them more appropriately."]}),"\n",(0,t.jsx)(n.h2,{id:"q-how-do-kthreads-map-to-pthread-workers",children:"Q: How do kthreads map to pthread workers?"}),"\n",(0,t.jsx)(n.p,{children:"A pthread worker runs only one kthread at any given time. When the current kthread suspends:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"The pthread worker first attempts to pop a pending kthread from its local runqueue."}),"\n",(0,t.jsx)(n.li,{children:"If no pending kthread exists locally, it randomly steals pending kthreads from another worker's runqueue."}),"\n",(0,t.jsx)(n.li,{children:"If no kthreads are available to steal, the pthread worker sleeps and will be woken up when new pending kthreads are added."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"q-can-blocking-pthread-or-system-functions-be-called-within-a-kthread",children:"Q: Can blocking pthread or system functions be called within a kthread?"}),"\n",(0,t.jsx)(n.p,{children:"Yes. Only the current pthread worker is blocked; other pthread workers remain unaffected."}),"\n",(0,t.jsx)(n.h2,{id:"q-does-a-blocked-kthread-affect-other-kthreads",children:"Q: Does a blocked kthread affect other kthreads?"}),"\n",(0,t.jsx)(n.p,{children:"No."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If a kthread blocks via kthread APIs: It yields the current pthread worker to other kthreads."}),"\n",(0,t.jsx)(n.li,{children:"If a kthread blocks via pthread APIs or system functions: Pending kthreads on the current pthread worker are stolen and executed by other idle pthread workers."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"q-can-kthread-apis-be-called-within-a-pthread",children:"Q: Can kthread APIs be called within a pthread?"}),"\n",(0,t.jsx)(n.p,{children:"Yes."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"When kthread APIs are called in a kthread context: They affect the current kthread."}),"\n",(0,t.jsx)(n.li,{children:"When kthread APIs are called in a pthread context: They affect the current pthread."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Code using kthread APIs can run directly in pthread contexts without modification."}),"\n",(0,t.jsx)(n.h2,{id:"q-will-a-large-number-of-kthreads-calling-blocking-pthreadsystem-functions-affect-rpc-execution",children:"Q: Will a large number of kthreads calling blocking pthread/system functions affect RPC execution?"}),"\n",(0,t.jsxs)(n.p,{children:["Yes. For example, if there are 8 pthread workers and all 8 kthreads call the system ",(0,t.jsx)(n.code,{children:"usleep()"})," function, the RPC code responsible for network I/O (sending/receiving data) will be temporarily unable to run."]}),"\n",(0,t.jsxs)(n.p,{children:["As long as the blocking duration is not too long, this is generally ",(0,t.jsx)(n.strong,{children:"not a significant issue"}),"\u2014after all, all workers are in use, and queuing is the only viable alternative. In krpc, users can mitigate this by increasing the number of workers:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["On the server side: Set ",(0,t.jsx)(n.a,{href:"/cppdev/docs/rpc/krpc/server#number-of-worker-threads",children:"ServerOptions.num_threads"})," or the ",(0,t.jsx)(n.a,{href:"http://krpc.baidu.com:8765/flags/kthread_concurrency",children:"-kthread_concurrency"})," flag."]}),"\n",(0,t.jsxs)(n.li,{children:["On the client side: Set the ",(0,t.jsx)(n.a,{href:"http://krpc.baidu.com:8765/flags/kthread_concurrency",children:"-kthread_concurrency"})," flag."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Are there ways to completely avoid this issue?"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Dynamically increasing worker count"}),": This may not work as expected. When a large number of workers are blocked, they are likely waiting for the same resource (e.g., a single mutex). Adding more workers only increases the number of waiters."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Separating IO threads and worker threads"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"IO threads handle only network I/O (sending/receiving), while worker threads execute user logic. Even if all worker threads block, IO threads remain unaffected."}),"\n",(0,t.jsx)(n.li,{children:'However, adding an extra layer (IO threads) does not resolve congestion: if all worker threads are stuck, the program will still freeze\u2014only the bottleneck shifts from socket buffers to the message queue between IO threads and worker threads. In other words, IO threads may perform useless work when workers are blocked. This is the true meaning of the earlier statement ("not a significant issue").'}),"\n",(0,t.jsx)(n.li,{children:"Another drawback: Each request requires a context switch from IO threads to worker threads. During high system load, these switches may not be scheduled in a timely manner, leading to longer latency tails."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Limiting maximum concurrency"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:['If the number of concurrently processed requests is kept below the number of workers, the scenario where "all workers are blocked" can be avoided entirely. This is a practical solution (see ',(0,t.jsx)(n.a,{href:"/cppdev/docs/rpc/krpc/server#limiting-maximum-concurrency",children:"Limiting Maximum Concurrency"}),")."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Offloading blocked workers to an independent thread pool"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"When the number of blocked workers exceeds a threshold (e.g., 6 out of 8), user code is no longer executed in-place but is dispatched to an independent thread pool. This ensures a few workers remain available to handle RPC I/O even if all user code blocks."}),"\n",(0,t.jsxs)(n.li,{children:["Currently, this mechanism is ",(0,t.jsx)(n.strong,{children:"not implemented in kthread mode"})," but is available when ",(0,t.jsx)(n.a,{href:"/cppdev/docs/rpc/krpc/server#pthread-mode",children:"pthread mode is enabled"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:['Does this mechanism also perform "useless work" when user code is fully blocked? Possibly\u2014but its primary purpose is to avoid deadlocks in extreme cases. For example:',"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"All user code blocks on a pthread mutex, and the mutex can only be unlocked in an RPC callback. If all workers are blocked, no thread can process the RPC callback, leading to a program-wide deadlock."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["While most RPC implementations have this potential issue, it rarely occurs in practice. Following the best practice of ",(0,t.jsx)(n.strong,{children:"avoiding RPC calls within locked sections"})," completely eliminates this risk."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"q-will-kthread-support-channel-as-in-go",children:["Q: Will kthread support ",(0,t.jsx)(n.a,{href:"https://gobyexample.com/channels",children:"Channel"})," (as in Go)?"]}),"\n",(0,t.jsxs)(n.p,{children:["No. A Channel represents a ",(0,t.jsx)(n.strong,{children:"point-to-point relationship"}),", but many real-world problems involve multiple points. The most natural solution with Channels is to:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:'Assign a "role" to manage a specific task/resource.'}),"\n",(0,t.jsx)(n.li,{children:"All other threads send commands to this role via Channels."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"If a program is divided into N such roles (each responsible for its own task), it can operate in an organized manner. However, using Channels implies splitting the program into distinct roles, which comes with tradeoffs:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Context switch overhead"}),": Any operation requires waiting for the target role to be scheduled, process the command, and respond\u2014even with optimizations for cache locality, this overhead is significant."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Complex code"}),": Due to business consistency constraints, resources are often bound together, forcing a single role to handle multiple responsibilities. A role cannot perform other tasks while processing one, and tasks may have varying priorities. This leads to extremely complex code with frequent interruptions, jumps, and resumptions."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["What we typically need is a ",(0,t.jsx)(n.strong,{children:"buffered Channel"}),", which acts as a queue for ordered execution. kthread provides ",(0,t.jsx)(n.a,{href:"/cppdev/docs/foundamentals/fibers/execution_queue",children:"ExecutionQueue"})," to fulfill this purpose, eliminating the need for Channels."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>o});var s=r(6540);const t={},i=s.createContext(t);function a(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);