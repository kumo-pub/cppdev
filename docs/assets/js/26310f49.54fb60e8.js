"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[4188],{1017:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>u});const i=JSON.parse('{"id":"foundamentals/fibers/execution_queue","title":"Execution Queue","description":"Similar to Kylin\'s ExecMan, ExecutionQueue provides the capability for asynchronous serial task execution. The underlying technology of ExecutionQueue was first applied in RPC to implement multi-threaded writing to the same file descriptor. It was integrated into kthread after revision r31345. ExecutionQueue offers the following core features:","source":"@site/docs/foundamentals/fibers/execution_queue.mdx","sourceDirName":"foundamentals/fibers","slug":"/foundamentals/fibers/execution_queue","permalink":"/cppdev/docs/foundamentals/fibers/execution_queue","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/foundamentals/fibers/execution_queue.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"std-future","permalink":"/cppdev/docs/foundamentals/fibers/std-future"},"next":{"title":"kthread Scheduling and Execution Flow","permalink":"/cppdev/docs/foundamentals/fibers/kthread_schedule"}}');var s=t(4848),o=t(8453);const a={},r="Execution Queue",c={},u=[{value:"Background",id:"background",level:2},{value:"ExecutionQueue Vs Mutex",id:"executionqueue-vs-mutex",level:2},{value:"Usage",id:"usage",level:2},{value:"Implement the Execution Function",id:"implement-the-execution-function",level:3},{value:"Start an ExecutionQueue",id:"start-an-executionqueue",level:3},{value:"Stop an ExecutionQueue",id:"stop-an-executionqueue",level:3},{value:"Submit Tasks",id:"submit-tasks",level:3},{value:"Cancel a Submitted Task",id:"cancel-a-submitted-task",level:3}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"execution-queue",children:"Execution Queue"})}),"\n",(0,s.jsxs)(n.p,{children:["Similar to Kylin's ExecMan, ",(0,s.jsx)(n.a,{href:"https://gitee.com/kumo-pub/kthread/blob/master/kthread/internal/execution_queue.h",children:"ExecutionQueue"})," provides the capability for asynchronous serial task execution. The underlying technology of ExecutionQueue was first applied in RPC to implement ",(0,s.jsx)(n.a,{href:"/cppdev/docs/rpc/krpc/io#sending-messages",children:"multi-threaded writing to the same file descriptor"}),". It was integrated into kthread after revision r31345. ExecutionQueue offers the following core features:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Asynchronous Ordered Execution"}),": Tasks are executed in a dedicated separate thread, strictly following the order of submission."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Multi-Producer Support"}),": Multiple threads can submit tasks to a single ExecutionQueue concurrently."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Task Cancellation"}),": Allows cancellation of tasks that have already been submitted."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Queue Termination"}),": Supports graceful stopping of the execution queue."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"High-Priority Task Preemption"}),": Permits high-priority tasks to be inserted ahead of normal-priority tasks in the queue."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Key differences from ExecMan:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Wait-Free Submission Interface"}),": The task submission interface of ExecutionQueue is ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Non-blocking_algorithm#Wait-freedom",children:"wait-free"}),", whereas ExecMan relies on locks. This means that during high system load, ExecutionQueue avoids global thread blocking caused by involuntary process context switches."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Batch Processing Capability"}),": The worker thread of ExecutionQueue can process submitted tasks in batches, achieving better data locality. In contrast, after an ExecMan thread finishes processing an AsyncContext from one AsyncClient, the next task is likely to belong to a different AsyncClient, leading to frequent CPU cache thrashing between resources associated with different AsyncClients."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Unbound Execution Threads"}),": ExecutionQueue tasks are not bound to fixed threads. ExecMan maps tasks to fixed worker threads based on AsyncClient hashing. Tasks across different ExecutionQueues are processed completely independently. When sufficient worker threads are available, all non-idle ExecutionQueues can be scheduled concurrently. Conversely, when thread resources are insufficient, ExecutionQueue cannot guarantee scheduling fairness. In such cases, the overall processing capacity should be scaled by dynamically increasing the number of kthread worker threads."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"kthread Compatibility"}),": ExecutionQueue runs on kthread, enabling safe use of kthread synchronization primitives without the risk of blocking pthread execution. In ExecMan, however, synchronization primitives that are likely to cause blocking should be avoided as much as possible."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"background",children:"Background"}),"\n",(0,s.jsxs)(n.p,{children:["In the field of multi-core concurrent programming, ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Message_passing",children:"Message passing"})," is widely adopted as a mechanism to resolve resource contention. It decomposes business logic into multiple independent actors based on resource dependencies, where each actor is responsible for managing a specific set of resources. When a workflow needs to modify a resource, it encapsulates the operation into a message and sends it to the corresponding actor. The actor (usually running in a separate execution context) processes the resource according to the message content, and then either wakes up the caller (synchronous processing) or forwards the result to the next actor in the pipeline (asynchronous processing)."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"http://web.mit.edu/6.005/www/fa14/classes/20-queues-locks/figures/producer-consumer.png",alt:"img"})}),"\n",(0,s.jsx)(n.h2,{id:"executionqueue-vs-mutex",children:"ExecutionQueue Vs Mutex"}),"\n",(0,s.jsx)(n.p,{children:"Both ExecutionQueue and mutex can be used to eliminate race conditions in multi-threaded scenarios. Compared with\nmutex, ExecutionQueue has the following advantages:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Clear Role Separation"}),": The programming model is conceptually simple, eliminating the need to handle lock-related\nissues such as deadlocks."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Guaranteed Execution Order"}),": Ensures strict FIFO task execution, whereas mutex cannot guarantee the wake-up\norder of waiting threads."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"No Thread Idling"}),": All threads are engaged in productive work without blocking on locks, improving overall\nresource utilization."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Better Throughput Under High Load"}),": Excels at batch task processing during system congestion, achieving\nhigher overall throughput."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"However, it also has notable drawbacks:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scattered Code Logic"}),": The implementation of a single workflow is often split across multiple components, increasing the cost of code comprehension and maintenance."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Increased Inter-Core Overhead"}),": To improve concurrency, a single task is often split across multiple ExecutionQueues for pipeline processing. This leads to frequent inter-core context switches and cache synchronization overhead, which cannot be ignored especially when the critical section of the original task is very small."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Complex Atomic Multi-Resource Operations"}),": Coordinating atomic operations across multiple resources becomes more challenging. While mutex allows acquiring multiple locks simultaneously, ExecutionQueue requires an additional dispatch queue to achieve similar functionality."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Single-Threaded Bottleneck"}),": Since all tasks in an ExecutionQueue are processed sequentially, a slow-running task will block all subsequent tasks in the same queue."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Complex Concurrency Control"}),": ExecutionQueue may consume excessive memory due to accumulating pending tasks, requiring careful capacity management."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"In theory, any system can be implemented using either mutex or ExecutionQueue alone to eliminate contention, regardless of performance and complexity trade-offs. However, for complex system design, it is recommended to flexibly choose the appropriate tool based on specific scenarios:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Prefer Mutex for Small Critical Sections"}),": If the critical section is small and contention is mild, mutex is the optimal choice. You can later use a ",(0,s.jsx)(n.a,{href:"/cppdev/docs/rpc/krpc/contention_profiler",children:"contention profiler"})," to determine if the mutex has become a performance bottleneck."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Prefer ExecutionQueue for Ordered Execution or High Contention"}),": When strict execution order is required, or when contention is unavoidable but can be mitigated through batch processing to improve throughput, ExecutionQueue is the better option."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"In conclusion, there is no one-size-fits-all model for multi-threaded programming. The optimal solution requires balancing complexity and performance based on specific scenarios, combined with comprehensive profiling tools."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"A critical note"}),": On Linux, lock/unlock operations on a mutex with no contention only require a few atomic instructions, and their overhead is negligible in most scenarios."]}),"\n",(0,s.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,s.jsx)(n.h3,{id:"implement-the-execution-function",children:"Implement the Execution Function"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Iterate over the given tasks\n//\n// Example:\n//\n// #include <kthread/execution_queue.h>\n//\n// int demo_execute(void* meta, TaskIterator<T>& iter) {\n//     if (iter.is_queue_stopped()) {\n//         // Destroy meta and related resources\n//         return 0;\n//     }\n//     for (; iter; ++iter) {\n//         // do_something(meta, *iter)\n//         // or do_something(meta, iter->a_member_of_T)\n//     }\n//     return 0;\n// }\ntemplate <typename T>\nclass TaskIterator;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"start-an-executionqueue",children:"Start an ExecutionQueue"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"struct ExecutionQueueOptions {\n    ExecutionQueueOptions();\n\n    // Execute in resident pthread instead of kthread. Default: false.\n    bool use_pthread;\n\n    // Attribute of the kthread which execute runs on. Default: KTHREAD_ATTR_NORMAL\n    // Kthread will be used when executor = NULL and use_pthread == false.\n    kthread_attr_t kthread_attr;\n\n    // Executor that tasks run on. Default: NULL\n    // Note that TaskOptions.in_place_if_possible = false will not work, if implementation of\n    // Executor is in-place(synchronous).\n    Executor * executor;\n};\n\n// Start an ExecutionQueue. If |options| is NULL, the queue will be created with\n// default options.\n// Returns 0 on success, errno otherwise\n// NOTE: type |T| can be non-POD but must be copy-constructible\ntemplate <typename T>\nint execution_queue_start(\n        ExecutionQueueId<T>* id,\n        const ExecutionQueueOptions* options,\n        int (*execute)(void* meta, TaskIterator<T>& iter),\n        void* meta);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The return value is a 64-bit ID, which acts as a ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Weak_reference",children:"weak reference"})," to the ExecutionQueue instance. It allows wait-free O(1) time lookup of the ExecutionQueue. You can copy this ID freely, and even transmit it in RPC calls as a mechanism to locate remote resources."]}),"\n",(0,s.jsxs)(n.p,{children:["You must ensure that the lifecycle of the ",(0,s.jsx)(n.code,{children:"meta"})," pointer extends until the corresponding ExecutionQueue has been completely stopped."]}),"\n",(0,s.jsx)(n.h3,{id:"stop-an-executionqueue",children:"Stop an ExecutionQueue"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Stop the ExecutionQueue.\n// After this function is called:\n//  - All subsequent calls to execution_queue_execute will fail immediately.\n//  - The executor will invoke |execute| exactly once with TaskIterator::is_queue_stopped() \n//    returning true, after all pending tasks have been processed. After this invocation,\n//    it is safe to release the resources referenced by |meta|.\n// Returns 0 on success, errno otherwise\ntemplate <typename T>\nint execution_queue_stop(ExecutionQueueId<T> id);\n \n// Wait until the stop task (where Iterator::is_queue_stopped() returns true) has\n// been executed\ntemplate <typename T>\nint execution_queue_join(ExecutionQueueId<T> id);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Both ",(0,s.jsx)(n.code,{children:"execution_queue_stop"})," and ",(0,s.jsx)(n.code,{children:"execution_queue_join"})," can be called multiple times safely, with well-defined behavior. ",(0,s.jsx)(n.code,{children:"execution_queue_stop"})," is thread-safe and can be invoked at any time."]}),"\n",(0,s.jsxs)(n.p,{children:["Similar to closing a file descriptor, failing to call ",(0,s.jsx)(n.code,{children:"execution_queue_stop"})," will result in permanent resource leaks."]}),"\n",(0,s.jsxs)(n.p,{children:["Safe timing to release ",(0,s.jsx)(n.code,{children:"meta"}),": You can release it either when the ",(0,s.jsx)(n.code,{children:"execute"})," function receives a task with ",(0,s.jsx)(n.code,{children:"iter.is_queue_stopped() == true"}),", or after ",(0,s.jsx)(n.code,{children:"execution_queue_join"})," returns. Be careful to avoid double-free errors."]}),"\n",(0,s.jsx)(n.h3,{id:"submit-tasks",children:"Submit Tasks"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"struct TaskOptions {\n    TaskOptions();\n    TaskOptions(bool high_priority, bool in_place_if_possible);\n \n    // Executor will execute high-priority tasks in FIFO order but before all pending \n    // normal-priority tasks.\n    // NOTE: We do not guarantee any form of real-time execution, as there may be \n    // uninterruptible tasks currently in progress.\n    //\n    // Default: false\n    bool high_priority;\n \n    // If |in_place_if_possible| is true, execution_queue_execute will invoke the \n    // execute function immediately instead of scheduling it to a kthread, if possible.\n    //\n    // Note: Enabling this flag may cause deadlocks or excessive recursion (e.g., \n    // ping-ponging tasks between queues). Ensure your code is free of such issues \n    // before enabling this option.\n    //\n    // Default: false\n    bool in_place_if_possible;\n};\n \nconst static TaskOptions TASK_OPTIONS_NORMAL = TaskOptions(/*high_priority=*/ false, /*in_place_if_possible=*/ false);\nconst static TaskOptions TASK_OPTIONS_URGENT = TaskOptions(/*high_priority=*/ true, /*in_place_if_possible=*/ false);\nconst static TaskOptions TASK_OPTIONS_INPLACE = TaskOptions(/*high_priority=*/ false, /*in_place_if_possible=*/ true);\n \n// Thread-safe and Wait-free.\n// Execute a task with default TaskOptions (normal task);\ntemplate <typename T>\nint execution_queue_execute(ExecutionQueueId<T> id,\n                            typename kutil::add_const_reference<T>::type task);\n \n// Thread-safe and Wait-free.\n// Execute a task with specified options. e.g\n// kthread::execution_queue_execute(queue, task, &kthread::TASK_OPTIONS_URGENT)\n// If |options| is NULL, default options (normal task) will be used.\n// If |handle| is not NULL, it will be assigned the handle of this task.\ntemplate <typename T>\nint execution_queue_execute(ExecutionQueueId<T> id,\n                            typename kutil::add_const_reference<T>::type task,\n                            const TaskOptions* options);\ntemplate <typename T>\nint execution_queue_execute(ExecutionQueueId<T> id,\n                            typename kutil::add_const_reference<T>::type task,\n                            const TaskOptions* options,\n                            TaskHandle* handle);\n                            \ntemplate <typename T>\nint execution_queue_execute(ExecutionQueueId<T> id,\n                            T&& task);\n\ntemplate <typename T>\nint execution_queue_execute(ExecutionQueueId<T> id,\n                            T&& task,\n                            const TaskOptions* options);\n\ntemplate <typename T>\nint execution_queue_execute(ExecutionQueueId<T> id,\n                            T&& task,\n                            const TaskOptions* options,\n                            TaskHandle* handle);\n"})}),"\n",(0,s.jsx)(n.p,{children:"High-priority tasks are also executed in strict FIFO order relative to other high-priority tasks, which differs\nfrom ExecMan where the execution order of QueueExecEmergent AsyncContexts is undefined. However, this also means\nthat no task can be inserted ahead of an existing high-priority task in the queue."}),"\n",(0,s.jsxs)(n.p,{children:["Enabling ",(0,s.jsx)(n.code,{children:"in_place_if_possible"})," eliminates thread scheduling and cache synchronization overhead in contention-free\nscenarios. However, it may lead to deadlocks or excessive recursion (e.g., ping-ponging tasks between queues).\nEnsure your code is free of such risks before enabling this option."]}),"\n",(0,s.jsx)(n.h3,{id:"cancel-a-submitted-task",children:"Cancel a Submitted Task"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"/// [Thread safe and ABA free] Cancel the corresponding task.\n// Returns:\n//  -1: The task has already been executed or the handle is invalid\n//   0: Task canceled successfully\n//   1: The task is currently being executed\nint execution_queue_cancel(const TaskHandle& h);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["A non-zero return value only indicates that the ExecutionQueue has already passed the task to the ",(0,s.jsx)(n.code,{children:"execute"})," function.\nIn practice, the task may still be cached in another container within the business logic. Therefore, this does not\nguarantee that the logical task has completed execution. You need to implement additional business-level checks to\nconfirm task termination."]})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var i=t(6540);const s={},o=i.createContext(s);function a(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);