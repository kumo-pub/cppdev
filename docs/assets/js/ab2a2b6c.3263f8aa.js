"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[3444],{4871:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"foundamentals/json/pointer","title":"Pointer","description":"(This feature was released in v1.1.0)","source":"@site/docs/foundamentals/json/pointer.mdx","sourceDirName":"foundamentals/json","slug":"/foundamentals/json/pointer","permalink":"/cppdev/docs/foundamentals/json/pointer","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/foundamentals/json/pointer.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Tutorial","permalink":"/cppdev/docs/foundamentals/json/tutorial"},"next":{"title":"Streams","permalink":"/cppdev/docs/foundamentals/json/stream"}}');var t=s(4848),i=s(8453);const o={},l="Pointer",a={},c=[{value:"Resolving Negative Sign Token",id:"resolving-negative-sign-token",level:2},{value:"Resolving Document and Value",id:"resolving-document-and-value",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"pointer",children:"Pointer"})}),"\n",(0,t.jsx)(n.p,{children:"(This feature was released in v1.1.0)"}),"\n",(0,t.jsxs)(n.p,{children:["JSON Pointer is a standardized (",(0,t.jsx)(n.a,{href:"https://tools.ietf.org/html/rfc6901",children:"RFC6901"}),") method for selecting a value within a JSON Document (DOM). It is similar to XPath for XML; however, JSON Pointer is much simpler, and each JSON Pointer points to exactly one value."]}),"\n",(0,t.jsx)(n.p,{children:"Using Merak's JSON Pointer implementation can simplify certain DOM operations."}),"\n",(0,t.jsx)(n.p,{children:"[TOC]"}),"\n",(0,t.jsx)(n.h1,{id:"JsonPointer",children:"JSON Pointer"}),"\n",(0,t.jsxs)(n.p,{children:["A JSON Pointer consists of a sequence (zero or more) of tokens, each prefixed with ",(0,t.jsx)(n.code,{children:"/"}),". Each token can be a string or a number. For example, given the following JSON:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'{\n    "foo" : ["bar", "baz"],\n    "pi" : 3.1416\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"The following JSON Pointers resolve to:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:'"/foo"'})," \u2192 ",(0,t.jsx)(n.code,{children:'[ "bar", "baz" ]'})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:'"/foo/0"'})," \u2192 ",(0,t.jsx)(n.code,{children:'"bar"'})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:'"/foo/1"'})," \u2192 ",(0,t.jsx)(n.code,{children:'"baz"'})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:'"/pi"'})," \u2192 ",(0,t.jsx)(n.code,{children:"3.1416"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Note that an empty JSON Pointer ",(0,t.jsx)(n.code,{children:'""'})," (zero tokens) resolves to the entire JSON document."]}),"\n",(0,t.jsx)(n.h1,{id:"BasicUsage",children:"Basic Usage"}),"\n",(0,t.jsx)(n.p,{children:"The following code example is self-explanatory."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'#include "merak/json/pointer.h"\n\n// ...\nDocument d;\n\n// Use Set() to create the DOM\nPointer("/project").Set(d, "Merak");\nPointer("/stars").Set(d, 10);\n\n// { "project" : "Merak", "stars" : 10 }\n\n// Use Get() to access the DOM. Returns nullptr if the value does not exist.\nif (Value* stars = Pointer("/stars").Get(d))\n    stars->SetInt(stars->GetInt() + 1);\n\n// { "project" : "Merak", "stars" : 11 }\n\n// Set() and Create() automatically generate parent values (if they do not exist).\nPointer("/a/b/0").Create(d);\n\n// { "project" : "Merak", "stars" : 11, "a" : { "b" : [ null ] } }\n\n// GetWithDefault() returns a reference. Performs a deep copy of the default value if the target value does not exist.\nValue& hello = Pointer("/hello").GetWithDefault(d, "world");\n\n// { "project" : "Merak", "stars" : 11, "a" : { "b" : [ null ] }, "hello" : "world" }\n\n// Swap() is similar to Set()\nValue x("C++");\nPointer("/hello").Swap(d, x);\n\n// { "project" : "Merak", "stars" : 11, "a" : { "b" : [ null ] }, "hello" : "C++" }\n// x becomes "world"\n\n// Erase a member or element, returns true if the value existed\nbool success = Pointer("/a").Erase(d);\nassert(success);\n\n// { "project" : "Merak", "stars" : 10 }\n'})}),"\n",(0,t.jsx)(n.h1,{id:"HelperFunctions",children:"Helper Functions"}),"\n",(0,t.jsx)(n.p,{children:"Since object-oriented calling conventions may be unintuitive, Merak also provides helper functions that wrap member functions as free functions."}),"\n",(0,t.jsx)(n.p,{children:"The following example performs exactly the same operations as the example above."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'Document d;\n\nSetValueByPointer(d, "/project", "Merak");\nSetValueByPointer(d, "/stars", 10);\n\nif (Value* stars = GetValueByPointer(d, "/stars"))\n    stars->SetInt(stars->GetInt() + 1);\n\nCreateValueByPointer(d, "/a/b/0");\n\nValue& hello = GetValueByPointerWithDefault(d, "/hello", "world");\n\nValue x("C++");\nSwapValueByPointer(d, "/hello", x);\n\nbool success = EraseValueByPointer(d, "/a");\nassert(success);\n'})}),"\n",(0,t.jsx)(n.p,{children:"The three calling styles are compared below:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"Pointer(source).<Method>(root, ...)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"<Method>ValueByPointer(root, Pointer(source), ...)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"<Method>ValueByPointer(root, source, ...)"})}),"\n"]}),"\n",(0,t.jsx)(n.h1,{id:"ResolvingPointer",children:"Resolving Pointer"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"Pointer::Get()"})," or ",(0,t.jsx)(n.code,{children:"GetValueByPointer()"})," functions do not modify the DOM. If the tokens cannot match a value in the DOM, these functions return ",(0,t.jsx)(n.code,{children:"nullptr"}),". Users can use this method to check if a value exists."]}),"\n",(0,t.jsx)(n.p,{children:"Note that numeric tokens can represent array indices or member names. The resolution process matches based on the type of the target value."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'{\n    "0" : 123,\n    "1" : [456]\n}\n'})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:'"/0"'})," \u2192 ",(0,t.jsx)(n.code,{children:"123"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:'"/1/0"'})," \u2192 ",(0,t.jsx)(n.code,{children:"456"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The token ",(0,t.jsx)(n.code,{children:'"0"'})," is treated as a member name in the first pointer, and as an array index in the second pointer."]}),"\n",(0,t.jsxs)(n.p,{children:["Other functions modify the DOM, including ",(0,t.jsx)(n.code,{children:"Create()"}),", ",(0,t.jsx)(n.code,{children:"GetWithDefault()"}),", ",(0,t.jsx)(n.code,{children:"Set()"}),", and ",(0,t.jsx)(n.code,{children:"Swap()"}),". These functions always succeed:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If parent values do not exist, they are created."}),"\n",(0,t.jsx)(n.li,{children:"If the type of a parent value does not match the token, its type is forcibly changed (this completely removes the content of its DOM subtree)."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["For example, after parsing the above JSON into ",(0,t.jsx)(n.code,{children:"d"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'SetValueByPointer(d, "1/a", 789); // { "0" : 123, "1" : { "a" : 789 } }\n'})}),"\n",(0,t.jsx)(n.h2,{id:"resolving-negative-sign-token",children:"Resolving Negative Sign Token"}),"\n",(0,t.jsxs)(n.p,{children:["Additionally, ",(0,t.jsx)(n.a,{href:"https://tools.ietf.org/html/rfc6901",children:"RFC6901"})," defines a special token ",(0,t.jsx)(n.code,{children:"-"})," (a single hyphen) to indicate the position after the last element of an array:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Get()"})," treats this token only as the member name ",(0,t.jsx)(n.code,{children:'"-"'}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Other functions resolve it against arrays (equivalent to calling ",(0,t.jsx)(n.code,{children:"Value::PushBack()"})," on the array)."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'Document d;\nd.Parse("{\\"foo\\":[123]}");\nSetValueByPointer(d, "/foo/-", 456); // { "foo" : [123, 456] }\nSetValueByPointer(d, "/-", 789);    // { "foo" : [123, 456], "-" : 789 }\n'})}),"\n",(0,t.jsx)(n.h2,{id:"resolving-document-and-value",children:"Resolving Document and Value"}),"\n",(0,t.jsxs)(n.p,{children:["When using ",(0,t.jsx)(n.code,{children:"p.Get(root)"})," or ",(0,t.jsx)(n.code,{children:"GetValueByPointer(root, p)"}),", ",(0,t.jsx)(n.code,{children:"root"})," is a (const) ",(0,t.jsx)(n.code,{children:"Value&"}),"\u2014meaning it can also be a subtree within the DOM."]}),"\n",(0,t.jsx)(n.p,{children:"Other functions have two sets of signatures:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["One set takes ",(0,t.jsx)(n.code,{children:"Document& document"})," (uses ",(0,t.jsx)(n.code,{children:"document.GetAllocator()"})," to create values)."]}),"\n",(0,t.jsxs)(n.li,{children:["The other set takes ",(0,t.jsx)(n.code,{children:"Value& root"})," (requires the user to provide an allocator, like DOM functions)."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The examples above do not require an allocator (since the first parameter is ",(0,t.jsx)(n.code,{children:"Document&"}),"). To resolve a pointer against a subtree, provide an allocator as shown:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'class Person {\npublic:\n    Person() {\n        document_ = new Document();\n        // CreateValueByPointer() does not need an allocator here\n        SetLocation(CreateValueByPointer(*document_, "/residence"), ...);\n        SetLocation(CreateValueByPointer(*document_, "/office"), ...);\n    };\n\nprivate:\n    void SetLocation(Value& location, const char* country, const char* addresses[2]) {\n        Value::Allocator& a = document_->GetAllocator();\n        // SetValueByPointer() needs an allocator here\n        SetValueByPointer(location, "/country", country, a);\n        SetValueByPointer(location, "/address/0", addresses[0], a);\n        SetValueByPointer(location, "/address/1", addresses[1], a);\n    }\n\n    // ...\n\n    Document* document_;\n};\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Erase()"})," or ",(0,t.jsx)(n.code,{children:"EraseValueByPointer()"})," do not require an allocator and return ",(0,t.jsx)(n.code,{children:"true"})," if the value was successfully deleted."]}),"\n",(0,t.jsx)(n.h1,{id:"ErrorHandling",children:"Error Handling"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Pointer"})," parses the source string in its constructor:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["If a parsing error occurs, ",(0,t.jsx)(n.code,{children:"Pointer::IsValid()"})," returns ",(0,t.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.code,{children:"Pointer::GetParseErrorCode()"})," and ",(0,t.jsx)(n.code,{children:"GetParseErrorOffset()"})," to retrieve error details."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note"}),": All resolution functions assume the pointer is valid. Resolving an invalid pointer will cause an assertion failure."]}),"\n",(0,t.jsx)(n.h1,{id:"URIFragment",children:"URI Fragment Representation"}),"\n",(0,t.jsxs)(n.p,{children:["In addition to the standard string representation, ",(0,t.jsx)(n.a,{href:"https://tools.ietf.org/html/rfc6901",children:"RFC6901"})," defines a URI fragment representation for JSON Pointer (URI fragments are defined in ",(0,t.jsx)(n.a,{href:"https://tools.ietf.org/html/rfc3986",children:"RFC3986"}),' "Uniform Resource Identifier (URI): Generic Syntax").']}),"\n",(0,t.jsx)(n.p,{children:"Key differences of the URI fragment representation:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Must start with ",(0,t.jsx)(n.code,{children:"#"})," (pound sign)."]}),"\n",(0,t.jsx)(n.li,{children:"Some characters are percent-encoded into UTF-8 sequences."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The table below shows C/C++ string literals in different representations:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"String Representation"}),(0,t.jsx)(n.th,{children:"URI Fragment Representation"}),(0,t.jsx)(n.th,{children:"Pointer Tokens (UTF-8)"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:'"/foo/0"'})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:'"#/foo/0"'})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:'{"foo", 0}'})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:'"/a~1b"'})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:'"#/a~1b"'})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:'{"a/b"}'})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:'"/m~0n"'})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:'"#/m~0n"'})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:'{"m~n"}'})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:'"/ "'})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:'"#/%20"'})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:'{" "}'})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:'"/\\0"'})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:'"#/%00"'})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:'{"\\0"}'})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:'"/\u20ac"'})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:'"#/%E2%82%AC"'})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:'{"\u20ac"}'})})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:["Merak fully supports the URI fragment representation and automatically detects the ",(0,t.jsx)(n.code,{children:"#"})," sign during resolution."]}),"\n",(0,t.jsx)(n.h1,{id:"stringification",children:"Stringification"}),"\n",(0,t.jsxs)(n.p,{children:["You can stringify a ",(0,t.jsx)(n.code,{children:"Pointer"})," and store it in a string or other output stream:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"Pointer p(...);\nStringBuffer sb;\np.Stringify(sb);\nstd::cout << sb.GetString() << std::endl;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Use ",(0,t.jsx)(n.code,{children:"StringifyUriFragment()"})," to stringify the pointer into the URI fragment representation."]}),"\n",(0,t.jsx)(n.h1,{id:"UserSuppliedTokens",children:"User-Supplied Tokens"}),"\n",(0,t.jsx)(n.p,{children:"If a pointer is reused for multiple resolutions:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Create it once and apply it to different DOMs/resolutions (avoids repeated ",(0,t.jsx)(n.code,{children:"Pointer"})," creation and memory allocation)."]}),"\n",(0,t.jsx)(n.li,{children:"For extreme optimization, eliminate parsing and dynamic allocation by directly generating a token array:"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'#define NAME(s) { s, sizeof(s) / sizeof(s[0]) - 1, kPointerInvalidIndex }\n#define INDEX(i) { #i, sizeof(#i) - 1, i }\n\nstatic const Pointer::Token kTokens[] = { NAME("foo"), INDEX(123) };\nstatic const Pointer p(kTokens, sizeof(kTokens) / sizeof(kTokens[0]));\n// Equivalent to static const Pointer p("/foo/123");\n'})}),"\n",(0,t.jsx)(n.p,{children:"This approach is suitable for memory-constrained systems."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>l});var r=s(6540);const t={},i=r.createContext(t);function o(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);