"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[5076],{5383:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>d,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"retrieve/vector/scann","title":"SCANN (Scalable Nearest Neighbor) Overview","description":"- Repository//github.com/google-research/google-research/tree/master/scann","source":"@site/docs/retrieve/vector/scann.mdx","sourceDirName":"retrieve/vector","slug":"/retrieve/vector/scann","permalink":"/cppdev/docs/retrieve/vector/scann","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"SPTAG (Space Partition Tree And Graph) Overview","permalink":"/cppdev/docs/retrieve/vector/sptag"},"next":{"title":"index","permalink":"/cppdev/docs/retrieve/trie/"}}');var s=t(4848),n=t(8453);const d={},c="SCANN (Scalable Nearest Neighbor) Overview",l={},o=[{value:"Purpose &amp; Use Cases",id:"purpose--use-cases",level:2},{value:"Algorithms Supported",id:"algorithms-supported",level:2},{value:"Core Technical Specifications",id:"core-technical-specifications",level:2},{value:"1. Supported Metric Spaces",id:"1-supported-metric-spaces",level:3},{value:"2. Supported Data Types",id:"2-supported-data-types",level:3},{value:"3. Dynamic Data Operations (Insert/Delete/Modify)",id:"3-dynamic-data-operations-insertdeletemodify",level:3},{value:"Characteristics",id:"characteristics",level:2},{value:"Notes",id:"notes",level:2}];function a(e){const i={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"scann-scalable-nearest-neighbor-overview",children:"SCANN (Scalable Nearest Neighbor) Overview"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Repository:"})," ",(0,s.jsx)(i.a,{href:"https://github.com/google-research/google-research/tree/master/scann",children:"https://github.com/google-research/google-research/tree/master/scann"})]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Language:"})," C++ (Python bindings available; CPU/GPU hybrid support)"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"purpose--use-cases",children:"Purpose & Use Cases"}),"\n",(0,s.jsxs)(i.p,{children:["SCANN is an open-source vector similarity search library developed by Google Research, focused on ",(0,s.jsx)(i.strong,{children:"extreme scalability and tunable recall-speed tradeoffs"})," for high-dimensional vector datasets (100\u201310000 dimensions). Its core innovation is a hybrid index architecture that combines quantization and graph-based search, enabling high-throughput, low-latency retrieval for large-scale (100M\u201310B) vector datasets. It is suitable for:"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Large-scale (100M+) high-dimensional vector approximate nearest neighbor (ANN) search with strict latency/throughput requirements."}),"\n",(0,s.jsx)(i.li,{children:"Scenarios requiring fine-grained tuning of recall and speed (e.g., large-scale semantic search, recommendation systems)."}),"\n",(0,s.jsx)(i.li,{children:"Production-grade AI pipelines (Google internal use in search, recommendation, and computer vision applications)."}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"Typical applications include:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"NLP (web-scale text embedding retrieval, semantic search for billions of documents)."}),"\n",(0,s.jsx)(i.li,{children:"Computer vision (large-scale image/video feature matching, face recognition for millions of identities)."}),"\n",(0,s.jsx)(i.li,{children:"Recommendation systems (user/item embedding matching for large-scale catalogs)."}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"algorithms-supported",children:"Algorithms Supported"}),"\n",(0,s.jsxs)(i.p,{children:["SCANN\u2019s core is a ",(0,s.jsx)(i.strong,{children:"hybrid index architecture"})," (Google\u81ea\u7814) that integrates multiple optimized components, rather than standalone traditional indexes:"]}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Core Component"}),(0,s.jsx)(i.th,{children:"Key Characteristics"}),(0,s.jsx)(i.th,{children:"Role in SCANN Architecture"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"Asymmetric Quantization"})}),(0,s.jsx)(i.td,{children:"Google\u81ea\u7814\u975e\u5bf9\u79f0\u91cf\u5316\u7b56\u7565 \u2013 reduces vector size with minimal recall loss, optimized for query speed."}),(0,s.jsx)(i.td,{children:"Reduces memory footprint and accelerates distance calculation."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"IVF (Inverted File)"})}),(0,s.jsx)(i.td,{children:"Optimized inverted file partitioning \u2013 coarse-grained vector clustering to narrow search scope."}),(0,s.jsx)(i.td,{children:"Reduces search space for large-scale datasets."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"Graph-Based Refinement"})}),(0,s.jsx)(i.td,{children:"Lightweight graph search (post-filtering step) \u2013 improves recall on top of quantized/IVF results."}),(0,s.jsx)(i.td,{children:"Fine-grained nearest neighbor refinement for high recall."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"BruteForce"})}),(0,s.jsx)(i.td,{children:"Exact nearest neighbor search \u2013 baseline for recall comparison (CPU/GPU supported)."}),(0,s.jsx)(i.td,{children:"Small datasets or high-recall requirement scenarios."})]})]})]}),"\n",(0,s.jsxs)(i.blockquote,{children:["\n",(0,s.jsx)(i.p,{children:"Note: SCANN does not expose standalone HNSW/KDTree/Annoy indexes \u2013 its core is a tightly integrated hybrid pipeline (IVF + quantization + graph refinement) optimized end-to-end by Google."}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"core-technical-specifications",children:"Core Technical Specifications"}),"\n",(0,s.jsx)(i.h3,{id:"1-supported-metric-spaces",children:"1. Supported Metric Spaces"}),"\n",(0,s.jsx)(i.p,{children:"SCANN supports mainstream metric spaces for numerical vectors (Google internal optimizations for high-dimensional data):"}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Metric Type"}),(0,s.jsx)(i.th,{children:"Full Name"}),(0,s.jsx)(i.th,{children:"Support Status"}),(0,s.jsx)(i.th,{children:"Use Case"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"L2"}),(0,s.jsx)(i.td,{children:"Euclidean Distance"}),(0,s.jsx)(i.td,{children:"Full (CPU/GPU)"}),(0,s.jsx)(i.td,{children:"General numerical vectors (image/video embeddings, dense features)."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Cosine"}),(0,s.jsx)(i.td,{children:"Cosine Similarity/Distance"}),(0,s.jsx)(i.td,{children:"Full (CPU/GPU)"}),(0,s.jsx)(i.td,{children:"Text embeddings (direction-based similarity, e.g., BERT/LLM outputs)."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Inner Product (IP)"}),(0,s.jsx)(i.td,{children:"Dot Product"}),(0,s.jsx)(i.td,{children:"Full (CPU/GPU)"}),(0,s.jsx)(i.td,{children:"Normalized vector similarity (equivalent to cosine for unit vectors)."})]})]})]}),"\n",(0,s.jsxs)(i.blockquote,{children:["\n",(0,s.jsx)(i.p,{children:"Note: Non-metric spaces (Jaccard/Hamming/L1/L\u221e) are not supported; no official custom preprocessing guidance for production."}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"2-supported-data-types",children:"2. Supported Data Types"}),"\n",(0,s.jsx)(i.p,{children:"SCANN is optimized for floating-point vectors, with GPU-accelerated support for low-precision types:"}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Data Type"}),(0,s.jsx)(i.th,{children:"Precision"}),(0,s.jsx)(i.th,{children:"C++ Type"}),(0,s.jsx)(i.th,{children:"Python Binding Mapping"}),(0,s.jsx)(i.th,{children:"CPU Support"}),(0,s.jsx)(i.th,{children:"GPU Support"}),(0,s.jsx)(i.th,{children:"Use Case"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Float32"}),(0,s.jsx)(i.td,{children:"32-bit"}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"float"})}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"numpy.float32"})}),(0,s.jsx)(i.td,{children:"Full"}),(0,s.jsx)(i.td,{children:"Full"}),(0,s.jsx)(i.td,{children:"Default (optimal balance of speed/precision)."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Float16 (FP16)"}),(0,s.jsx)(i.td,{children:"16-bit"}),(0,s.jsxs)(i.td,{children:[(0,s.jsx)(i.code,{children:"half"}),"/",(0,s.jsx)(i.code,{children:"uint16_t"})]}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"numpy.float16"})}),(0,s.jsx)(i.td,{children:"Partial"}),(0,s.jsx)(i.td,{children:"Full"}),(0,s.jsx)(i.td,{children:"GPU-accelerated workloads (50% memory reduction)."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Int8"}),(0,s.jsx)(i.td,{children:"8-bit"}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"int8_t"})}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"numpy.int8"})}),(0,s.jsx)(i.td,{children:"Partial"}),(0,s.jsx)(i.td,{children:"Full"}),(0,s.jsx)(i.td,{children:"Extreme memory-constrained GPU scenarios (4x compression)."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Float64 (Double)"}),(0,s.jsx)(i.td,{children:"64-bit"}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"double"})}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"numpy.float64"})}),(0,s.jsx)(i.td,{children:"Full"}),(0,s.jsx)(i.td,{children:"No"}),(0,s.jsx)(i.td,{children:"High-precision scientific computing only."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Binary"}),(0,s.jsx)(i.td,{children:"Bit-level"}),(0,s.jsxs)(i.td,{children:[(0,s.jsx)(i.code,{children:"uint8_t"})," (packed)"]}),(0,s.jsxs)(i.td,{children:[(0,s.jsx)(i.code,{children:"numpy.uint8"})," (bitpacked)"]}),(0,s.jsx)(i.td,{children:"No"}),(0,s.jsx)(i.td,{children:"No"}),(0,s.jsx)(i.td,{children:"Not supported (use Google\u2019s other specialized libraries)."})]})]})]}),"\n",(0,s.jsx)(i.h3,{id:"3-dynamic-data-operations-insertdeletemodify",children:"3. Dynamic Data Operations (Insert/Delete/Modify)"}),"\n",(0,s.jsxs)(i.p,{children:["SCANN is ",(0,s.jsx)(i.strong,{children:"optimized for static datasets"})," with limited dynamic update capabilities:"]}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Operation"}),(0,s.jsx)(i.th,{children:"Support Level"}),(0,s.jsx)(i.th,{children:"Constraints"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Incremental Insertion"}),(0,s.jsx)(i.td,{children:"Partial (batch-only)"}),(0,s.jsxs)(i.td,{children:["- Batch insertion only (10k+ vectors per batch, latency ~50ms/batch);",(0,s.jsx)("br",{}),"- No single-vector real-time insertion;",(0,s.jsx)("br",{}),"- Index rebuild required for large cumulative inserts (>10% of total vectors)."]})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Real-Time Deletion"}),(0,s.jsx)(i.td,{children:"Not supported"}),(0,s.jsx)(i.td,{children:'No native deletion API; "soft delete" (filter post-query) leads to query performance degradation.'})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Vector Modification"}),(0,s.jsx)(i.td,{children:"Not supported"}),(0,s.jsx)(i.td,{children:"Must re-insert updated vectors (no in-place modification)."})]})]})]}),"\n",(0,s.jsx)(i.h2,{id:"characteristics",children:"Characteristics"}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Feature"}),(0,s.jsx)(i.th,{children:"Description"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Incremental Updates"}),(0,s.jsx)(i.td,{children:"Batch-only insertion (limited); no deletion/modification; static dataset optimized."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Query Speed"}),(0,s.jsx)(i.td,{children:"CPU: 1\u20135ms/query (100M 768-dim vectors); GPU: 0.1\u20130.5ms/query (100M vectors) \u2013 Google-optimized hybrid pipeline outperforms FAISS/HNSWLIB for large-scale datasets."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Index Type"}),(0,s.jsx)(i.td,{children:"Hybrid (IVF + asymmetric quantization + graph refinement) \u2013 Google\u81ea\u7814end-to-end pipeline."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Scalability"}),(0,s.jsx)(i.td,{children:"Handles up to 10B vectors (single-node/multi-node); optimized for distributed deployment."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Language Bindings"}),(0,s.jsx)(i.td,{children:"C++ (full feature set), Python (core features \u2013 GPU tuning limited)."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"GPU Support"}),(0,s.jsx)(i.td,{children:"Native CUDA optimization (query/quantization/index build); multi-GPU support."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Non-Metric Support"}),(0,s.jsx)(i.td,{children:"No native support (requires custom preprocessing)."})]})]})]}),"\n",(0,s.jsx)(i.h2,{id:"notes",children:"Notes"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["SCANN\u2019s core advantage is ",(0,s.jsx)(i.strong,{children:"Google asymmetric quantization + hybrid search pipeline"})," \u2013 it delivers better recall-speed tradeoffs than FAISS/HNSWLIB for 100M+ high-dimensional vectors."]}),"\n",(0,s.jsx)(i.li,{children:"GPU support is production-grade (Google internal use in search/recommendation) \u2013 far more optimized than community-driven GPU implementations."}),"\n",(0,s.jsx)(i.li,{children:"Dynamic updates are not a focus \u2013 ideal for static/low-churn datasets (e.g., daily updated document embedding libraries), not real-time scenarios (e.g., sub-second user behavior embedding insertion)."}),"\n",(0,s.jsx)(i.li,{children:"Limitations: No non-metric space support; Python bindings lack advanced GPU tuning; no official distributed deployment toolkit (Google internal only); community maintenance is slow (tied to Google Research updates)."}),"\n",(0,s.jsx)(i.li,{children:"Best Practices: Use SCANN for 100M+ static high-dimensional vectors (CPU/GPU hybrid); pair with Redis for hot data caching; use batch insertion for weekly/daily updates."}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,n.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},8453:(e,i,t)=>{t.d(i,{R:()=>d,x:()=>c});var r=t(6540);const s={},n=r.createContext(s);function d(e){const i=r.useContext(n);return r.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function c(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),r.createElement(n.Provider,{value:i},e.children)}}}]);