"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[7184],{1158:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>t,default:()=>h,frontMatter:()=>d,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"store/kv/index","title":"Key-Value Storage Overview","description":"Key-Value (KV) storage is the foundation for many database and storage systems. Its choice significantly impacts performance, scalability, and operational complexity.","source":"@site/docs/store/kv/index.mdx","sourceDirName":"store/kv","slug":"/store/kv/","permalink":"/cppdev/docs/store/kv/","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Storage Module Overview","permalink":"/cppdev/docs/store/"},"next":{"title":"rocksdb","permalink":"/cppdev/docs/category/rocksdb"}}');var r=s(4848),l=s(8453);const d={},t="Key-Value Storage Overview",c={},o=[{value:"1. Types of KV Storage",id:"1-types-of-kv-storage",level:2},{value:"2. Focused Comparison: RocksDB, LevelDB, LMDB",id:"2-focused-comparison-rocksdb-leveldb-lmdb",level:2},{value:"3. Key Operational Guidelines",id:"3-key-operational-guidelines",level:2},{value:"RocksDB",id:"rocksdb",level:3},{value:"LMDB",id:"lmdb",level:3},{value:"General Ops Notes",id:"general-ops-notes",level:3}];function a(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"key-value-storage-overview",children:"Key-Value Storage Overview"})}),"\n",(0,r.jsx)(n.p,{children:"Key-Value (KV) storage is the foundation for many database and storage systems. Its choice significantly impacts performance, scalability, and operational complexity."}),"\n",(0,r.jsx)(n.h2,{id:"1-types-of-kv-storage",children:"1. Types of KV Storage"}),"\n",(0,r.jsx)(n.p,{children:"KV stores can be roughly classified into:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"In-memory KV stores"})}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Examples: ",(0,r.jsx)(n.code,{children:"std::unordered_map"}),", ",(0,r.jsx)(n.code,{children:"folly::F14"}),", custom hash tables."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Characteristics:"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Extremely low latency (nanoseconds to microseconds)."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"No persistence unless combined with snapshotting or WAL."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"No ordering guarantees unless explicitly added."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Use cases: caching, fast indexing, ephemeral state."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Embedded on-disk KV stores (LSM-tree / B+Tree based)"})}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Examples: RocksDB, LevelDB, LMDB."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Characteristics:"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Persist data on disk."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Support large data volumes beyond RAM."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Provide ordered keys (prefix/range scans)."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Support snapshots, backups, and transactions (to varying degrees)."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.ol,{start:"3",children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Distributed KV stores"})}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Examples: TiKV, RocksDB+Raft, Cassandra (KV-like API)."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Characteristics:"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Scale horizontally across nodes."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Handle replication, failover, and consistency."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Often build on embedded KV engines internally."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"2-focused-comparison-rocksdb-leveldb-lmdb",children:"2. Focused Comparison: RocksDB, LevelDB, LMDB"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Feature / Engine"}),(0,r.jsx)(n.th,{children:"RocksDB"}),(0,r.jsx)(n.th,{children:"LevelDB"}),(0,r.jsx)(n.th,{children:"LMDB"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Storage type"}),(0,r.jsx)(n.td,{children:"LSM-tree"}),(0,r.jsx)(n.td,{children:"LSM-tree"}),(0,r.jsx)(n.td,{children:"B+Tree (memory-mapped)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Max DB size"}),(0,r.jsx)(n.td,{children:"10\u2013100 TB+"}),(0,r.jsx)(n.td,{children:"~10 TB"}),(0,r.jsx)(n.td,{children:"~16 TB (64-bit OS)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Write throughput"}),(0,r.jsx)(n.td,{children:"50k\u2013200k ops/sec (SSD)"}),(0,r.jsx)(n.td,{children:"30k\u2013100k ops/sec"}),(0,r.jsx)(n.td,{children:"5k\u201350k ops/sec (disk-backed)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Read throughput"}),(0,r.jsx)(n.td,{children:"100k\u2013500k point/sec"}),(0,r.jsx)(n.td,{children:"50k\u2013200k point/sec"}),(0,r.jsx)(n.td,{children:"50k\u2013200k point/sec"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Read range / scan"}),(0,r.jsx)(n.td,{children:"200\u2013800 MB/sec (prefix optimized)"}),(0,r.jsx)(n.td,{children:"100\u2013400 MB/sec"}),(0,r.jsx)(n.td,{children:"100\u2013400 MB/sec"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Memory usage"}),(0,r.jsx)(n.td,{children:"Configurable memtable + block cache"}),(0,r.jsx)(n.td,{children:"Memtable + block cache"}),(0,r.jsx)(n.td,{children:"Mapped entirely into address space"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Persistence & durability"}),(0,r.jsx)(n.td,{children:"WAL + SST"}),(0,r.jsx)(n.td,{children:"WAL + SST"}),(0,r.jsx)(n.td,{children:"Memory-mapped + sync"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Transactions"}),(0,r.jsx)(n.td,{children:"Single key atomic, batch writes"}),(0,r.jsx)(n.td,{children:"Single key atomic, batch writes"}),(0,r.jsx)(n.td,{children:"ACID, MVCC"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Column family support"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{children:"No"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Best suited for"}),(0,r.jsx)(n.td,{children:"Large-scale, high write workloads, prefix scan, multi-CF"}),(0,r.jsx)(n.td,{children:"Small-medium DB, embedded"}),(0,r.jsx)(n.td,{children:"Read-heavy workloads, ACID compliance, memory-mapped scenarios"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Notes"}),(0,r.jsx)(n.td,{children:"Heavy tunable options; suitable for hot LSM tuning"}),(0,r.jsx)(n.td,{children:"Simpler; less configurable; limited compaction tuning"}),(0,r.jsx)(n.td,{children:"Very low read latency; writes block if file system sync is slow"})]})]})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"3-key-operational-guidelines",children:"3. Key Operational Guidelines"}),"\n",(0,r.jsx)(n.p,{children:"For production deployment, KV engines have different operational considerations:"}),"\n",(0,r.jsx)(n.h3,{id:"rocksdb",children:"RocksDB"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"SST file management:"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"RocksDB writes LSM-tree SST files per column family."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Frequent compaction can produce many small SSTs; excessive SSTs can hurt read performance and increase disk usage."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Avoid having too many column families if not necessary; prefer fewer CFs and use ",(0,r.jsx)(n.strong,{children:"key prefix"})," for logical separation."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Backup & snapshot:"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Prefer ",(0,r.jsx)(n.strong,{children:"snapshot-based backups"})," for incremental replication or quick point-in-time copies."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Full ",(0,r.jsx)(n.strong,{children:"file-level backups"})," (checkpointing SSTs) should be limited to avoid high I/O load."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key design for range scan:"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Fixed-length prefix keys improve ",(0,r.jsx)(n.strong,{children:"prefix scan throughput"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Consider partitioning large datasets by key range to simplify compaction and backup."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"I/O and memory tuning:"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Adjust ",(0,r.jsx)(n.strong,{children:"memtable size, block cache, compaction threads"})," to match SSD I/O capabilities."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Monitor SST size distribution and write amplification."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"lmdb",children:"LMDB"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Single-file simplicity:"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"LMDB uses a single memory-mapped file per database (or per environment)."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Simple to manage operationally; no compaction is required."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Read-heavy workload:"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Optimal for mostly-read workloads; multiple readers can access concurrently without locking."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Write considerations:"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Single-writer limitation means ",(0,r.jsx)(n.strong,{children:"write bursts"})," can block reads if the disk sync is slow."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Avoid placing multiple LMDB databases in the same file if high write concurrency is expected."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"general-ops-notes",children:"General Ops Notes"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["For ",(0,r.jsx)(n.strong,{children:"small-scale KV usage"}),", LMDB is simpler and less operationally demanding."]}),"\n",(0,r.jsxs)(n.li,{children:["For ",(0,r.jsx)(n.strong,{children:"large-scale or write-intensive workloads"}),", RocksDB offers higher flexibility and tunability but requires monitoring of SSTs, CFs, and compaction cycles."]}),"\n",(0,r.jsxs)(n.li,{children:["Use snapshots and incremental backups to ",(0,r.jsx)(n.strong,{children:"limit I/O impact"})," and maintain consistent backups without pausing writes."]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:["This provides a ",(0,r.jsx)(n.strong,{children:"full KV layer overview"}),", including storage types, engine characteristics, benchmark data, usage scenarios, and operational guidance for RocksDB and LMDB."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:["If you want, I can ",(0,r.jsx)(n.strong,{children:"also add a small diagram showing RocksDB SST file layout vs. LMDB single-file layout"}),", which makes these operational points visually clearer."]}),"\n",(0,r.jsx)(n.p,{children:"Do you want me to do that?"})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>d,x:()=>t});var i=s(6540);const r={},l=i.createContext(r);function d(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);