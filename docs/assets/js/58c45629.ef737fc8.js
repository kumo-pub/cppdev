"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[3087],{5703:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"foundamentals/testing/doct/main","title":"main() Entry Point","description":"main() Entry Point","source":"@site/docs/foundamentals/testing/doct/main.mdx","sourceDirName":"foundamentals/testing/doct","slug":"/foundamentals/testing/doct/main","permalink":"/cppdev/docs/foundamentals/testing/doct/main","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Command Line","permalink":"/cppdev/docs/foundamentals/testing/doct/commandline"},"next":{"title":"Test Configuration","permalink":"/cppdev/docs/foundamentals/testing/doct/configuration"}}');var i=n(4848),o=n(8453);const r={},a="main() Entry Point",c={},d=[{value:"main() Entry Point",id:"doctest_config_implement_with_main",level:2},{value:"Dealing with Shared Objects (DLLs)",id:"dealing-with-shared-objects-dlls",level:3}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsxs)(t.h1,{id:"main-entry-point",children:[(0,i.jsx)(t.code,{children:"main()"})," Entry Point"]})}),"\n",(0,i.jsx)(t.h2,{id:"doctest_config_implement_with_main",children:"main() Entry Point"}),"\n",(0,i.jsxs)(t.p,{children:["A common approach to writing tests in C++ is always to separate test code into a distinct source file, creating an executable that contains only tests. In such cases, the default ",(0,i.jsx)(t.code,{children:"main()"})," provided by ",(0,i.jsx)(t.strong,{children:"doctest"})," is usually sufficient:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c++",children:'#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN\n#include "doctest.h"\n'})}),"\n",(0,i.jsx)(t.p,{children:"This should be done in one source file, and it is even better to do this in a separate file that contains nothing else."}),"\n",(0,i.jsxs)(t.p,{children:["However, if you need more control - such as wanting to set options for the execution context in code, or wanting to integrate the framework into production code - then the default ",(0,i.jsx)(t.code,{children:"main()"})," will not suffice. In such cases, use ",(0,i.jsx)(t.a,{href:"/cppdev/docs/foundamentals/testing/doct/configuration#doctest_config_implement",children:(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"DOCTEST_CONFIG_IMPLEMENT"})})}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["All ",(0,i.jsx)(t.a,{href:"/cppdev/docs/foundamentals/testing/doct/commandline",children:(0,i.jsx)(t.strong,{children:"command line"})})," options can be set this way (flags cannot, as it makes no sense). Filters can only be added or cleared using the ",(0,i.jsx)(t.code,{children:"addFilter()"})," or ",(0,i.jsx)(t.code,{children:"clearFilters()"})," methods of the ",(0,i.jsx)(t.code,{children:"doctest::Context"})," object - users cannot remove specific filters via code."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c++",children:'#define DOCTEST_CONFIG_IMPLEMENT\n#include "doctest.h"\n\nint main(int argc, char** argv) {\n    doctest::Context context;\n\n    // !!! THIS IS JUST AN EXAMPLE SHOWING HOW DEFAULTS/OVERRIDES ARE SET !!!\n\n    // defaults\n    context.addFilter("test-case-exclude", "*math*"); // exclude test cases with "math" in their name\n    context.setOption("abort-after", 5);              // stop test execution after 5 failed assertions\n    context.setOption("order-by", "name");            // sort the test cases by their name\n\n    context.applyCommandLine(argc, argv);\n\n    // overrides\n    context.setOption("no-breaks", true);             // don\'t break in the debugger when assertions fail\n\n    int res = context.run(); // run\n\n    if(context.shouldExit()) // important - query flags (and --exit) rely on the user doing this\n        return res;          // propagate the result of the tests\n    \n    int client_stuff_return_code = 0;\n    // your program - if the testing framework is integrated in your production code\n    \n    return res + client_stuff_return_code; // the result from doctest is propagated here as well\n}\n\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Note the call to ",(0,i.jsx)(t.code,{children:".shouldExit()"})," on the context - this is very important - it will be set when query flags are used (or the ",(0,i.jsx)(t.code,{children:"--no-run"}),' option is set to "true"), and it is the user\'s responsibility to exit the application in the normal way.']}),"\n",(0,i.jsx)(t.h3,{id:"dealing-with-shared-objects-dlls",children:"Dealing with Shared Objects (DLLs)"}),"\n",(0,i.jsx)(t.p,{children:"The framework can be used independently in binaries (executables/shared objects), with each having its own test runner - this even allows using different versions of doctest - but there is no simple way to execute tests from all loaded binaries and have the results aggregated and summarized."}),"\n",(0,i.jsx)(t.p,{children:"There is also an option to build the test runner (implementation) into one binary and share it with others by exporting its public symbols (the symbols needed for users to write tests - all forward declarations) - thus having a single test registry for the framework."}),"\n",(0,i.jsxs)(t.p,{children:["For more information on this, check the ",(0,i.jsx)(t.a,{href:"/cppdev/docs/foundamentals/testing/doct/configuration#doctest_config_implementation_in_dll",children:(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"DOCTEST_CONFIG_IMPLEMENTATION_IN_DLL"})})})," configuration identifier and ",(0,i.jsx)(t.a,{href:"https://github.com/doctest/doctest/blob/master/examples/executable_dll_and_plugin/",children:(0,i.jsx)(t.strong,{children:"this example"})}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var s=n(6540);const i={},o=s.createContext(i);function r(e){const t=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);