"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[4790],{930:(e,i,s)=>{s.r(i),s.d(i,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>d,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"retrieve/vector/faiss","title":"FAISS (Facebook AI Similarity Search) Overview","description":"- Repository//github.com/facebookresearch/faiss","source":"@site/docs/retrieve/vector/faiss.mdx","sourceDirName":"retrieve/vector","slug":"/retrieve/vector/faiss","permalink":"/cppdev/docs/retrieve/vector/faiss","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Library Selection","permalink":"/cppdev/docs/retrieve/vector/"},"next":{"title":"HNSWLIB (Hierarchical Navigable Small Worlds Library) Overview","permalink":"/cppdev/docs/retrieve/vector/hnswlib"}}');var n=s(4848),t=s(8453);const d={},l="FAISS (Facebook AI Similarity Search) Overview",c={},a=[{value:"Purpose &amp; Use Cases",id:"purpose--use-cases",level:2},{value:"Algorithms Supported",id:"algorithms-supported",level:2},{value:"1. Brute-force (Exact Search)",id:"1-brute-force-exact-search",level:3},{value:"2. Quantization-Based Indexes (Memory-Optimized)",id:"2-quantization-based-indexes-memory-optimized",level:3},{value:"3. Graph-Based Indexes (High-Speed ANN)",id:"3-graph-based-indexes-high-speed-ann",level:3},{value:"4. Dynamic/Incremental Indexes (Semi-Real-Time)",id:"4-dynamicincremental-indexes-semi-real-time",level:3},{value:"5. GPU-Accelerated Indexes",id:"5-gpu-accelerated-indexes",level:3},{value:"Core Technical Specifications",id:"core-technical-specifications",level:2},{value:"1. Supported Metric Spaces (Official Implementation)",id:"1-supported-metric-spaces-official-implementation",level:3},{value:"2. Supported Data Types (Official Implementation)",id:"2-supported-data-types-official-implementation",level:3},{value:"3. Real-Time Data Insertion/Deletion Support",id:"3-real-time-data-insertiondeletion-support",level:3},{value:"Characteristics",id:"characteristics",level:2},{value:"Notes",id:"notes",level:2}];function o(e){const i={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.header,{children:(0,n.jsx)(i.h1,{id:"faiss-facebook-ai-similarity-search-overview",children:"FAISS (Facebook AI Similarity Search) Overview"})}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Repository:"})," ",(0,n.jsx)(i.a,{href:"https://github.com/facebookresearch/faiss",children:"https://github.com/facebookresearch/faiss"})]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Language:"})," C++ (Python bindings available; GPU/CUDA support for accelerated operations)"]}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"purpose--use-cases",children:"Purpose & Use Cases"}),"\n",(0,n.jsxs)(i.p,{children:["FAISS is a ",(0,n.jsx)(i.strong,{children:"highly optimized, industrial-grade vector similarity search library"})," designed for ",(0,n.jsx)(i.strong,{children:"scalable approximate nearest neighbor (ANN) and exact nearest neighbor search"})," over high-dimensional data. It balances speed, memory efficiency, and flexibility, with native support for both offline/static and semi-real-time dynamic workloads (via incremental indexes). It is suitable for:"]}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"Large-scale (billions of vectors) high-dimensional similarity search (10s to 1000s of dimensions)."}),"\n",(0,n.jsx)(i.li,{children:"Both offline batch indexing and semi-real-time incremental insertion/deletion (via specific index types)."}),"\n",(0,n.jsx)(i.li,{children:"Production-grade deployments (CPU/GPU acceleration, distributed support) for AI/ML pipelines."}),"\n"]}),"\n",(0,n.jsx)(i.p,{children:"Typical applications include:"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"Real-time/recommendation systems (user/item embedding retrieval, real-time feature matching)."}),"\n",(0,n.jsx)(i.li,{children:"Computer vision (image feature retrieval, face recognition)."}),"\n",(0,n.jsx)(i.li,{children:"NLP (text embedding similarity search, semantic search)."}),"\n",(0,n.jsx)(i.li,{children:"Large-scale scientific computing (high-dimensional data clustering/analytics)."}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"algorithms-supported",children:"Algorithms Supported"}),"\n",(0,n.jsxs)(i.p,{children:["FAISS provides a ",(0,n.jsx)(i.strong,{children:"comprehensive suite of index algorithms"})," (each optimized for different tradeoffs of speed, memory, recall, and dynamicity), grouped by core architecture:"]}),"\n",(0,n.jsx)(i.h3,{id:"1-brute-force-exact-search",children:"1. Brute-force (Exact Search)"}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Algorithm"}),(0,n.jsx)(i.th,{children:"Key Characteristics"}),(0,n.jsx)(i.th,{children:"Use Case"})]})}),(0,n.jsx)(i.tbody,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsxs)(i.td,{children:[(0,n.jsx)(i.code,{children:"IndexFlatL2"}),"/",(0,n.jsx)(i.code,{children:"IndexFlatIP"})]}),(0,n.jsx)(i.td,{children:"Exact L2/Euclidean or Inner Product search (no approximation, baseline)."}),(0,n.jsxs)(i.td,{children:["Small datasets (",(0,n.jsx)(i.code,{children:"<1M"})," vectors), high-recall requirements."]})]})})]}),"\n",(0,n.jsx)(i.h3,{id:"2-quantization-based-indexes-memory-optimized",children:"2. Quantization-Based Indexes (Memory-Optimized)"}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Algorithm"}),(0,n.jsx)(i.th,{children:"Key Characteristics"}),(0,n.jsx)(i.th,{children:"Use Case"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"IndexIVFFlat"})}),(0,n.jsx)(i.td,{children:"Inverted file (IVF) + flat quantizer (balances speed/memory, no precision loss)."}),(0,n.jsx)(i.td,{children:"Medium-scale datasets (1M\u2013100M vectors), moderate recall."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"IndexIVFPQ"})}),(0,n.jsx)(i.td,{children:"IVF + Product Quantization (PQ) (high memory compression, minor recall loss)."}),(0,n.jsx)(i.td,{children:"Large-scale datasets (100M+ vectors), memory-constrained environments."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"IndexIVFSQ"})}),(0,n.jsx)(i.td,{children:"IVF + Scalar Quantization (SQ) (lightweight compression, low recall loss)."}),(0,n.jsx)(i.td,{children:"Edge/embedded systems, low-memory deployments."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"IndexPQ"})}),(0,n.jsx)(i.td,{children:"Pure Product Quantization (no IVF, fast search for ultra-large datasets)."}),(0,n.jsx)(i.td,{children:"Billion-scale vectors, acceptable recall tradeoff."})]})]})]}),"\n",(0,n.jsx)(i.h3,{id:"3-graph-based-indexes-high-speed-ann",children:"3. Graph-Based Indexes (High-Speed ANN)"}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Algorithm"}),(0,n.jsx)(i.th,{children:"Key Characteristics"}),(0,n.jsx)(i.th,{children:"Use Case"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"IndexHNSWFlat"})}),(0,n.jsx)(i.td,{children:"HNSW (Hierarchical Navigable Small Worlds) + flat quantizer (fastest ANN for high-dim data)."}),(0,n.jsx)(i.td,{children:"Low-latency query scenarios (e.g., real-time retrieval)."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"IndexIVFHNSW"})}),(0,n.jsx)(i.td,{children:"IVF + HNSW (combines IVF\u2019s scalability with HNSW\u2019s speed)."}),(0,n.jsx)(i.td,{children:"100M+ vectors, low query latency requirements."})]})]})]}),"\n",(0,n.jsx)(i.h3,{id:"4-dynamicincremental-indexes-semi-real-time",children:"4. Dynamic/Incremental Indexes (Semi-Real-Time)"}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Algorithm"}),(0,n.jsx)(i.th,{children:"Key Characteristics"}),(0,n.jsx)(i.th,{children:"Use Case"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"IndexIDMap"})}),(0,n.jsx)(i.td,{children:"Wrapper for static indexes to support ID-based insertion/deletion (soft dynamic)."}),(0,n.jsx)(i.td,{children:"Semi-real-time updates (hourly/daily batch)."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"IndexIDMap2"})}),(0,n.jsx)(i.td,{children:"Enhanced IDMap with better memory management for frequent updates."}),(0,n.jsx)(i.td,{children:"Medium-frequency incremental insertion."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsxs)(i.td,{children:[(0,n.jsx)(i.code,{children:"IndexIVFScalarQuantizer"})," (with IDMap)"]}),(0,n.jsx)(i.td,{children:"IVF+SQ + dynamic ID mapping"}),(0,n.jsx)(i.td,{children:"Real-time recommendation systems (10k+ QPS insertion)."})]})]})]}),"\n",(0,n.jsx)(i.h3,{id:"5-gpu-accelerated-indexes",children:"5. GPU-Accelerated Indexes"}),"\n",(0,n.jsxs)(i.p,{children:["All core algorithms (Flat/IVF/PQ/HNSW) have GPU variants (e.g., ",(0,n.jsx)(i.code,{children:"GpuIndexFlatL2"}),", ",(0,n.jsx)(i.code,{children:"GpuIndexIVFPQ"}),") optimized for CUDA-enabled GPUs, delivering 10\u2013100x faster query/insertion speed vs CPU."]}),"\n",(0,n.jsx)(i.h2,{id:"core-technical-specifications",children:"Core Technical Specifications"}),"\n",(0,n.jsx)(i.h3,{id:"1-supported-metric-spaces-official-implementation",children:"1. Supported Metric Spaces (Official Implementation)"}),"\n",(0,n.jsxs)(i.p,{children:["FAISS focuses on ",(0,n.jsx)(i.strong,{children:"metric spaces for numerical vectors"})," (no native non-metric support like Jaccard/Hamming):"]}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Metric Type"}),(0,n.jsx)(i.th,{children:"Full Name"}),(0,n.jsx)(i.th,{children:"Supported Indexes"}),(0,n.jsx)(i.th,{children:"Use Case"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"L2"}),(0,n.jsx)(i.td,{children:"Euclidean Distance"}),(0,n.jsx)(i.td,{children:"All indexes"}),(0,n.jsx)(i.td,{children:"General numerical vectors (image embeddings)."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Inner Product (IP)"}),(0,n.jsx)(i.td,{children:"Dot Product"}),(0,n.jsx)(i.td,{children:"All indexes"}),(0,n.jsx)(i.td,{children:"Text embeddings (equivalent to cosine for normalized vectors)."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Cosine Similarity"}),(0,n.jsx)(i.td,{children:"Cosine Distance (normalized IP)"}),(0,n.jsx)(i.td,{children:"All indexes (via vector normalization)"}),(0,n.jsx)(i.td,{children:"Direction-based vector comparison (NLP embeddings)."})]})]})]}),"\n",(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.p,{children:"Note: Non-metric spaces (Jaccard/Hamming/Levenshtein) require custom preprocessing (e.g., vector normalization for cosine simulation) \u2013 no native support."}),"\n"]}),"\n",(0,n.jsx)(i.h3,{id:"2-supported-data-types-official-implementation",children:"2. Supported Data Types (Official Implementation)"}),"\n",(0,n.jsxs)(i.p,{children:["FAISS has ",(0,n.jsx)(i.strong,{children:"extensive, optimized data type support"})," (CPU/GPU variants differ slightly):"]}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Data Type"}),(0,n.jsx)(i.th,{children:"Precision"}),(0,n.jsx)(i.th,{children:"C++ Type"}),(0,n.jsx)(i.th,{children:"Python Binding Mapping"}),(0,n.jsx)(i.th,{children:"CPU Support"}),(0,n.jsx)(i.th,{children:"GPU Support"}),(0,n.jsx)(i.th,{children:"Use Case"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Float32"}),(0,n.jsx)(i.td,{children:"32-bit"}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"float"})}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"numpy.float32"})}),(0,n.jsx)(i.td,{children:"Full"}),(0,n.jsx)(i.td,{children:"Full"}),(0,n.jsx)(i.td,{children:"Default (optimal balance of speed/precision)."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Float64 (Double)"}),(0,n.jsx)(i.td,{children:"64-bit"}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"double"})}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"numpy.float64"})}),(0,n.jsx)(i.td,{children:"Full"}),(0,n.jsx)(i.td,{children:"Partial"}),(0,n.jsx)(i.td,{children:"High-precision scientific computing."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Float16 (FP16)"}),(0,n.jsx)(i.td,{children:"16-bit"}),(0,n.jsxs)(i.td,{children:[(0,n.jsx)(i.code,{children:"half"}),"/",(0,n.jsx)(i.code,{children:"uint16_t"})]}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"numpy.float16"})}),(0,n.jsx)(i.td,{children:"Partial"}),(0,n.jsx)(i.td,{children:"Full"}),(0,n.jsx)(i.td,{children:"GPU-accelerated workloads (memory-efficient)."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Int8/UInt8"}),(0,n.jsx)(i.td,{children:"8-bit"}),(0,n.jsxs)(i.td,{children:[(0,n.jsx)(i.code,{children:"int8_t"}),"/",(0,n.jsx)(i.code,{children:"uint8_t"})]}),(0,n.jsxs)(i.td,{children:[(0,n.jsx)(i.code,{children:"numpy.int8"}),"/",(0,n.jsx)(i.code,{children:"numpy.uint8"})]}),(0,n.jsx)(i.td,{children:"Full (via SQ)"}),(0,n.jsx)(i.td,{children:"Full (via SQ)"}),(0,n.jsx)(i.td,{children:"Edge devices, ultra-low memory usage."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Binary"}),(0,n.jsx)(i.td,{children:"Bit-level"}),(0,n.jsxs)(i.td,{children:[(0,n.jsx)(i.code,{children:"uint8_t"})," (packed)"]}),(0,n.jsxs)(i.td,{children:[(0,n.jsx)(i.code,{children:"numpy.uint8"})," (bitpacked)"]}),(0,n.jsx)(i.td,{children:"Partial (brute-force only)"}),(0,n.jsx)(i.td,{children:"No"}),(0,n.jsx)(i.td,{children:"Hamming distance (limited use cases)."})]})]})]}),"\n",(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.p,{children:"Key Notes:"}),"\n",(0,n.jsxs)(i.ol,{children:["\n",(0,n.jsx)(i.li,{children:"FP16: GPU indexes fully optimize FP16 (50% memory reduction vs Float32, 2x faster queries); CPU requires manual conversion to Float32."}),"\n",(0,n.jsx)(i.li,{children:"8-bit integers: Supported via scalar quantization (SQ) \u2013 reduces memory by 4x vs Float32 with minimal recall loss."}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(i.h3,{id:"3-real-time-data-insertiondeletion-support",children:"3. Real-Time Data Insertion/Deletion Support"}),"\n",(0,n.jsxs)(i.p,{children:["FAISS\u2019s dynamic capabilities vary by index type \u2013 ",(0,n.jsx)(i.strong,{children:"partial support for semi-real-time workloads"})," (industrial-grade for production):"]}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Operation"}),(0,n.jsx)(i.th,{children:"Support Level"}),(0,n.jsx)(i.th,{children:"Indexes with Best Support"}),(0,n.jsx)(i.th,{children:"Constraints"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Incremental Insertion"}),(0,n.jsx)(i.td,{children:"Full support (real-time optimized)"}),(0,n.jsx)(i.td,{children:"IndexIDMap/IndexIDMap2/IVF-based"}),(0,n.jsxs)(i.td,{children:["- GPU indexes support 10k+ QPS insertion (sub-millisecond latency);",(0,n.jsx)("br",{}),"- CPU indexes support 1k+ QPS;",(0,n.jsx)("br",{}),"- HNSW indexes have slower insertion (graph rebalancing)."]})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Real-Time Deletion"}),(0,n.jsx)(i.td,{children:"Partial support (soft delete + filtered query)"}),(0,n.jsx)(i.td,{children:"IndexIDMap2/IVF-based"}),(0,n.jsxs)(i.td,{children:['- "Soft delete" (mark IDs as invalid, filter post-query);',(0,n.jsx)("br",{}),"- Physical deletion requires index rebuild (IVF) or reinsertion (HNSW);",(0,n.jsx)("br",{}),"- No memory bloat for up to 20% deleted vectors."]})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Vector Modification"}),(0,n.jsx)(i.td,{children:"Indirect support (delete + reinsert)"}),(0,n.jsx)(i.td,{children:"IndexIDMap2"}),(0,n.jsx)(i.td,{children:"Inherits deletion/insertion latency (sub-millisecond for GPU)."})]})]})]}),"\n",(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsxs)(i.p,{children:["Critical Note: FAISS\u2019s dynamic support is production-grade (used in Facebook\u2019s real-time recommendation systems) \u2013 for strict real-time deletion (physical removal), pair with ",(0,n.jsx)(i.code,{children:"IndexIVF"})," + periodic batch rebuilds (hourly/daily)."]}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"characteristics",children:"Characteristics"}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Feature"}),(0,n.jsx)(i.th,{children:"Description"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Incremental Updates"}),(0,n.jsx)(i.td,{children:"Full incremental insertion (all indexes); partial deletion (IDMap wrappers); GPU-optimized for real-time."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Query Speed"}),(0,n.jsx)(i.td,{children:"Industry-leading (GPU indexes: 10\u2013100x faster than NMSLIB/HNSWLIB; CPU HNSW = NMSLIB HNSW)."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Index Type"}),(0,n.jsx)(i.td,{children:"Hybrid (brute-force, quantization-based, graph-based, IVF-based)."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Scalability"}),(0,n.jsx)(i.td,{children:"Handles billions of vectors (distributed FAISS for multi-node clusters; disk-backed storage)."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Language Bindings"}),(0,n.jsx)(i.td,{children:"C++ (full feature set), Python (mature), C#/Java (community-maintained)."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"GPU Support"}),(0,n.jsx)(i.td,{children:"Native CUDA optimization for all core indexes (multi-GPU/distributed GPU support)."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Non-Metric Support"}),(0,n.jsx)(i.td,{children:"No native support (requires custom preprocessing)."})]})]})]}),"\n",(0,n.jsx)(i.h2,{id:"notes",children:"Notes"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:["FAISS is ",(0,n.jsx)(i.strong,{children:"the industry standard for large-scale vector search"})," \u2013 balances offline batch processing and semi-real-time dynamic workloads (unlike NMSLIB/HNSWLIB/NGT which focus on offline)."]}),"\n",(0,n.jsx)(i.li,{children:"GPU acceleration is a key differentiator \u2013 critical for low-latency (sub-millisecond) query scenarios (e.g., real-time recommendation)."}),"\n",(0,n.jsx)(i.li,{children:"Quantization tradeoffs: PQ delivers maximum memory compression (16\u201364x) but minor recall loss; SQ is lightweight (4x compression) with near-zero recall loss."}),"\n",(0,n.jsxs)(i.li,{children:["Distributed FAISS (via ",(0,n.jsx)(i.code,{children:"faiss-cluster"}),") supports multi-node CPU/GPU deployments for trillion-scale vectors."]}),"\n",(0,n.jsx)(i.li,{children:"Limitations: No native non-metric space support (use NMSLIB if Jaccard/Hamming is required); HNSW indexes have higher memory usage vs IVF-PQ."}),"\n",(0,n.jsxs)(i.li,{children:["Real-time best practices: Use ",(0,n.jsx)(i.code,{children:"GpuIndexIVFPQ"})," + ",(0,n.jsx)(i.code,{children:"IndexIDMap2"})," for 10k+ QPS insertion/deletion; pair with Redis for ultra-low-latency hot vector caching."]}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(o,{...e})}):o(e)}},8453:(e,i,s)=>{s.d(i,{R:()=>d,x:()=>l});var r=s(6540);const n={},t=r.createContext(n);function d(e){const i=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:d(e.components),r.createElement(t.Provider,{value:i},e.children)}}}]);