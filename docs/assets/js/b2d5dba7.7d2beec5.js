"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[4612],{8314:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"rpc/brpc","title":"brpc","description":"title: BRPC","source":"@site/docs/rpc/brpc.mdx","sourceDirName":"rpc","slug":"/rpc/brpc","permalink":"/cppdev/docs/rpc/brpc","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"gRPC","permalink":"/cppdev/docs/rpc/grpc"},"next":{"title":"ACL Library Overview","permalink":"/cppdev/docs/rpc/acl"}}');var s=r(4848),t=r(8453);const l={},o=void 0,c={},a=[{value:"title: BRPC",id:"title-brpc",level:2},{value:"1. High-Performance Backend RPC",id:"1-high-performance-backend-rpc",level:2},{value:"2. Kumo Evolution: KRPC",id:"2-kumo-evolution-krpc",level:2},{value:"3. Retained Value of BRPC",id:"3-retained-value-of-brpc",level:2},{value:"4. Ecosystem and Integration",id:"4-ecosystem-and-integration",level:2},{value:"5. Operational Considerations",id:"5-operational-considerations",level:2},{value:"6. Suitable Scenarios",id:"6-suitable-scenarios",level:2},{value:"7. Example Code (C++ Backend Server)",id:"7-example-code-c-backend-server",level:2}];function d(e){const n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"title-brpc",children:"title: BRPC"}),"\n",(0,s.jsx)(n.h1,{id:"brpc-overview",children:"BRPC Overview"}),"\n",(0,s.jsxs)(n.p,{children:["BRPC is a high-performance RPC framework widely used in C++ backend services. In the Kumo ecosystem, it serves as the foundation for the internal ",(0,s.jsx)(n.strong,{children:"KRPC"})," framework."]}),"\n",(0,s.jsx)(n.h2,{id:"1-high-performance-backend-rpc",children:"1. High-Performance Backend RPC"}),"\n",(0,s.jsxs)(n.p,{children:["BRPC is suitable for ",(0,s.jsx)(n.strong,{children:"single-machine high QPS, backend core services"})," that are latency-sensitive and require controlled CPU usage."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Typical backend scenarios:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Internal storage services"}),"\n",(0,s.jsx)(n.li,{children:"Search services"}),"\n",(0,s.jsx)(n.li,{children:"Cache layers"}),"\n",(0,s.jsx)(n.li,{children:"Distributed computation nodes"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Supports asynchronous I/O, thread pool scheduling, and efficient object pooling."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"2-kumo-evolution-krpc",children:"2. Kumo Evolution: KRPC"}),"\n",(0,s.jsxs)(n.p,{children:["Kumo has developed ",(0,s.jsx)(n.strong,{children:"KRPC"})," on top of BRPC, with the main goals of:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Enhancing performance"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Improving operational friendliness"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["KRPC fully covers BRPC functionality. For most business layers, ",(0,s.jsx)(n.strong,{children:"KRPC is the recommended choice"})," to reduce operational complexity."]}),"\n",(0,s.jsx)(n.h2,{id:"3-retained-value-of-brpc",children:"3. Retained Value of BRPC"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"When internal framework choices are limited, KRPC is preferred."}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Necessary scenario:"})," If the system needs to use BRAFT (Raft implementation), BRPC is required since KRPC currently does not support Raft natively."]}),"\n",(0,s.jsx)(n.li,{children:"BRPC can still be used independently, especially for high QPS backends or specific protocol requirements."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"4-ecosystem-and-integration",children:"4. Ecosystem and Integration"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Supports HTTP/HTTPS, protobuf, Thrift, JSON, and other protocols."}),"\n",(0,s.jsxs)(n.li,{children:["Ecosystem is primarily ",(0,s.jsx)(n.strong,{children:"C++ backend"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"Integration complexity is slightly lower than gRPC, suitable for same-team or same-language calls."}),"\n",(0,s.jsx)(n.li,{children:"Functional coverage and ecosystem support are sufficient for backend services."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"5-operational-considerations",children:"5. Operational Considerations"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Provides debug, performance metrics, and thread scheduling tools, but operational cost is relatively higher."}),"\n",(0,s.jsxs)(n.li,{children:["High-QPS services should control CPU usage in the ",(0,s.jsx)(n.strong,{children:"50%-70% range"})," to avoid thread scheduling bottlenecks or queue blocking."]}),"\n",(0,s.jsx)(n.li,{children:"Memory pool management should be reasonable to avoid fragmentation or latency jitter during long-term runtime."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"6-suitable-scenarios",children:"6. Suitable Scenarios"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Layer"}),(0,s.jsx)(n.th,{children:"Recommendation"}),(0,s.jsx)(n.th,{children:"Notes"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Business Entry Layer"}),(0,s.jsx)(n.td,{children:"gRPC"}),(0,s.jsx)(n.td,{children:"Ecosystem integration more important, QPS requirement is moderate"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Backend Core Layer"}),(0,s.jsx)(n.td,{children:"KRPC or BRPC"}),(0,s.jsx)(n.td,{children:"Pursue single-machine performance and low latency"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Online Service"}),(0,s.jsx)(n.td,{children:"gRPC (< 30k QPS)"}),(0,s.jsx)(n.td,{children:"Higher QPS backend \u2192 KRPC/BRPC"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"7-example-code-c-backend-server",children:"7. Example Code (C++ Backend Server)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include <brpc/server.h>\n#include "example.pb.h"\n#include "example.pb.cc"\n\nclass ExampleServiceImpl : public ExampleService {\npublic:\n    void Echo(google::protobuf::RpcController* cntl_base,\n              const EchoRequest* request,\n              EchoResponse* response,\n              google::protobuf::Closure* done) override {\n        brpc::ClosureGuard done_guard(done);\n        response->set_message(request->message());\n    }\n};\n\nint main() {\n    brpc::Server server;\n\n    ExampleServiceImpl service_impl;\n    if (server.AddService(&service_impl, brpc::SERVER_DOESNT_OWN_SERVICE) != 0) {\n        LOG(ERROR) << "Fail to add service";\n        return -1;\n    }\n\n    brpc::ServerOptions options;\n    if (server.Start(8000, &options) != 0) {\n        LOG(ERROR) << "Fail to start server";\n        return -1;\n    }\n\n    server.RunUntilAskedToQuit();\n    return 0;\n}\n'})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Key Points:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["BRPC emphasizes ",(0,s.jsx)(n.strong,{children:"single-machine performance, asynchronous scheduling, and low latency"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"KRPC covers BRPC functionality and improves operational friendliness, recommended as the default internal framework."}),"\n",(0,s.jsx)(n.li,{children:"BRPC is required when using BRAFT."}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>o});var i=r(6540);const s={},t=i.createContext(s);function l(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);