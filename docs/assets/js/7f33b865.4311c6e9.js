"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[9451],{1145:(e,n,r)=>{r.d(n,{A:()=>s});const s=r.p+"assets/images/tutorial-2b3d939067902aeaca369185ea839059.png"},1953:(e,n,r)=>{r.d(n,{A:()=>s});const s=r.p+"assets/images/move3-49374945252d30356165a2a0f3fcf9d0.png"},3731:(e,n,r)=>{r.d(n,{A:()=>s});const s=r.p+"assets/images/move1-b6d2ca997867e5d6a471b72ca6f579b7.png"},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>c});var s=r(6540);const t={},a=s.createContext(t);function i(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(a.Provider,{value:n},e.children)}},8914:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"foundamentals/json/tutorial","title":"Tutorial","description":"This tutorial introduces the Document Object Model (DOM) API.","source":"@site/docs/foundamentals/json/tutorial.mdx","sourceDirName":"foundamentals/json","slug":"/foundamentals/json/tutorial","permalink":"/cppdev/docs/foundamentals/json/tutorial","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/foundamentals/json/tutorial.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Features","permalink":"/cppdev/docs/foundamentals/json/features"},"next":{"title":"Pointer","permalink":"/cppdev/docs/foundamentals/json/pointer"}}');var t=r(4848),a=r(8453);const i={},c="Tutorial",l={},o=[{value:"Querying Arrays",id:"QueryArray",level:2},{value:"Range-based for loops (New in v1.1.0)",id:"range-based-for-loops-new-in-v110",level:3},{value:"Querying Objects",id:"QueryObject",level:2},{value:"Range-based for loops (New in v1.1.0)",id:"range-based-for-loops-new-in-v110-1",level:3},{value:"Querying Numbers",id:"QueryNumber",level:2},{value:"Querying Strings",id:"QueryString",level:2},{value:"Comparing Two Values",id:"comparing-two-values",level:2},{value:"Changing Value Type",id:"ChangeValueType",level:2},{value:"Overloaded Constructors",id:"overloaded-constructors",level:3},{value:"Move Semantics",id:"MoveSemantics",level:2},{value:"Move Semantics and Temporary Values",id:"TemporaryValues",level:3},{value:"Creating Strings",id:"CreateString",level:2},{value:"Modifying Arrays",id:"ModifyArray",level:2},{value:"Modifying Objects",id:"ModifyObject",level:2},{value:"Deep Copying Values",id:"DeepCopyValue",level:2},{value:"Swapping Values",id:"SwapValues",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"tutorial",children:"Tutorial"})}),"\n",(0,t.jsx)(n.p,{children:"This tutorial introduces the Document Object Model (DOM) API."}),"\n",(0,t.jsxs)(n.p,{children:["As shown in ",(0,t.jsx)(n.a,{href:"/cppdev/docs/foundamentals/json/overview#overview",children:"Overview"}),", you can parse a JSON into a DOM, then easily query and modify the DOM, and finally convert it back to JSON."]}),"\n",(0,t.jsx)(n.h1,{id:"value-document",children:"Value and Document"}),"\n",(0,t.jsxs)(n.p,{children:["Each JSON value is stored as a ",(0,t.jsx)(n.code,{children:"Value"})," class, while the ",(0,t.jsx)(n.code,{children:"Document"})," class represents the entire DOM, which stores the root ",(0,t.jsx)(n.code,{children:"Value"})," of a DOM tree. All public types and functions of Merak are in the ",(0,t.jsx)(n.code,{children:"merak::json"})," namespace."]}),"\n",(0,t.jsx)(n.h1,{id:"QueryValue",children:"Querying Values"}),"\n",(0,t.jsxs)(n.p,{children:["In this section, we use code snippets from ",(0,t.jsx)(n.code,{children:"example/tutorial/tutorial.cpp"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Suppose we store a JSON in a C-style string (",(0,t.jsx)(n.code,{children:"const char* json"}),"):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n    "hello": "world",\n    "t": true ,\n    "f": false,\n    "n": null,\n    "i": 123,\n    "pi": 3.1416,\n    "a": [1, 2, 3, 4]\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Parse it into a ",(0,t.jsx)(n.code,{children:"Document"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'#include "merak/json/document.h"\n\nusing namespace merak::json;\n\n// ...\nDocument document;\ndocument.Parse(json);\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Now the JSON is parsed into ",(0,t.jsx)(n.code,{children:"document"})," as a ",(0,t.jsx)(n.em,{children:"DOM tree"}),":"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"DOM Tree",src:r(1145).A+"",width:"707",height:"336"})}),"\n",(0,t.jsx)(n.p,{children:"Per RFC 7159 updates, the root of a valid JSON file can be a JSON value of any type (earlier RFC 4627 only allowed Objects or Arrays as root values). In the example above, the root is an Object:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"assert(document.IsObject());\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Let's check if the root Object has the ",(0,t.jsx)(n.code,{children:'"hello"'})," member. Since a ",(0,t.jsx)(n.code,{children:"Value"})," can contain values of different types, you may need to verify its type and use the appropriate API to retrieve its value. In this case, the ",(0,t.jsx)(n.code,{children:'"hello"'})," member is associated with a JSON String:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'assert(document.HasMember("hello"));\nassert(document["hello"].IsString());\nprintf("hello = %s\\n", document["hello"].GetString());\n'})}),"\n",(0,t.jsx)(n.p,{children:"Output:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"world\n"})}),"\n",(0,t.jsxs)(n.p,{children:["JSON True/False values are represented as ",(0,t.jsx)(n.code,{children:"bool"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'assert(document["t"].IsBool());\nprintf("t = %s\\n", document["t"].GetBool() ? "true" : "false");\n'})}),"\n",(0,t.jsx)(n.p,{children:"Output:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"true\n"})}),"\n",(0,t.jsxs)(n.p,{children:["JSON Null values can be queried with ",(0,t.jsx)(n.code,{children:"IsNull()"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'printf("n = %s\\n", document["n"].IsNull() ? "null" : "?");\n'})}),"\n",(0,t.jsx)(n.p,{children:"Output:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"null\n"})}),"\n",(0,t.jsx)(n.p,{children:"The JSON Number type represents all numeric values. However, C++ requires more specific types:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'assert(document["i"].IsNumber());\n\n// In this case, IsUint()/IsInt64()/IsUint64() also return true\nassert(document["i"].IsInt());          \nprintf("i = %d\\n", document["i"].GetInt());\n// Alternative usage: (int)document["i"]\n\nassert(document["pi"].IsNumber());\nassert(document["pi"].IsDouble());\nprintf("pi = %g\\n", document["pi"].GetDouble());\n'})}),"\n",(0,t.jsx)(n.p,{children:"Output:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"i = 123\npi = 3.1416\n"})}),"\n",(0,t.jsx)(n.p,{children:"A JSON Array contains elements:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'// Using references for consecutive access is convenient and more efficient.\nconst Value& a = document["a"];\nassert(a.IsArray());\nfor (SizeType i = 0; i < a.Size(); i++) // Use SizeType instead of size_t\n        printf("a[%d] = %d\\n", i, a[i].GetInt());\n'})}),"\n",(0,t.jsx)(n.p,{children:"Output:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"a[0] = 1\na[1] = 2\na[2] = 3\na[3] = 4\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Note that Merak does not automatically convert between JSON types. For example, calling ",(0,t.jsx)(n.code,{children:"GetInt()"})," on a String Value is illegal\u2014it triggers an assertion failure in debug mode and results in undefined behavior in release mode."]}),"\n",(0,t.jsx)(n.p,{children:"Details about querying each type are discussed below."}),"\n",(0,t.jsx)(n.h2,{id:"QueryArray",children:"Querying Arrays"}),"\n",(0,t.jsxs)(n.p,{children:["By default, ",(0,t.jsx)(n.code,{children:"SizeType"})," is a typedef of ",(0,t.jsx)(n.code,{children:"unsigned"}),". On most systems, an Array can store up to 2^32-1 elements."]}),"\n",(0,t.jsxs)(n.p,{children:["You can access elements using integer literals like ",(0,t.jsx)(n.code,{children:"a[0]"}),", ",(0,t.jsx)(n.code,{children:"a[1]"}),", ",(0,t.jsx)(n.code,{children:"a[2]"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Similar to ",(0,t.jsx)(n.code,{children:"std::vector"}),", Arrays can also be traversed using iterators (in addition to indexes):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'for (Value::ConstValueIterator itr = a.Begin(); itr != a.End(); ++itr)\n    printf("%d ", itr->GetInt());\n'})}),"\n",(0,t.jsx)(n.p,{children:"Additional familiar query functions:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"SizeType Capacity() const"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"bool Empty() const"})}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"range-based-for-loops-new-in-v110",children:"Range-based for loops (New in v1.1.0)"}),"\n",(0,t.jsx)(n.p,{children:"When using C++11 features, you can traverse all elements in an Array with a range-based for loop:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'for (auto& v : a.GetArray())\n    printf("%d ", v.GetInt());\n'})}),"\n",(0,t.jsx)(n.h2,{id:"QueryObject",children:"Querying Objects"}),"\n",(0,t.jsx)(n.p,{children:"Similar to Arrays, you can use iterators to access all Object members:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'static const char* kTypeNames[] = \n    { "Null", "False", "True", "Object", "Array", "String", "Number" };\n\nfor (Value::ConstMemberIterator itr = document.MemberBegin();\n    itr != document.MemberEnd(); ++itr)\n{\n    printf("Type of member %s is %s\\n",\n        itr->name.GetString(), kTypeNames[itr->value.GetType()]);\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Output:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Type of member hello is String\nType of member t is True\nType of member f is False\nType of member n is Null\nType of member i is Number\nType of member pi is Number\nType of member a is Array\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Note that ",(0,t.jsx)(n.code,{children:"operator[](const char*)"})," triggers an assertion failure if the member is not found."]}),"\n",(0,t.jsxs)(n.p,{children:["If you are unsure whether a member exists, check with ",(0,t.jsx)(n.code,{children:"HasMember()"})," before calling ",(0,t.jsx)(n.code,{children:"operator[](const char*)"}),". However, this causes two lookups. A better approach is to use ",(0,t.jsx)(n.code,{children:"FindMember()"}),", which checks for existence and returns the Value in one operation:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'Value::ConstMemberIterator itr = document.FindMember("hello");\nif (itr != document.MemberEnd())\n    printf("%s\\n", itr->value.GetString());\n'})}),"\n",(0,t.jsx)(n.h3,{id:"range-based-for-loops-new-in-v110-1",children:"Range-based for loops (New in v1.1.0)"}),"\n",(0,t.jsx)(n.p,{children:"When using C++11 features, you can traverse all members in an Object with a range-based for loop:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'for (auto& m : document.GetObject())\n    printf("Type of member %s is %s\\n",\n        m.name.GetString(), kTypeNames[m.value.GetType()]);\n'})}),"\n",(0,t.jsx)(n.h2,{id:"QueryNumber",children:"Querying Numbers"}),"\n",(0,t.jsx)(n.p,{children:"JSON provides only one numeric type\u2014Number (which can be integer or real). RFC 4627 specifies that the range of numbers is determined by the parser."}),"\n",(0,t.jsx)(n.p,{children:"Since C++ offers multiple integer and floating-point types, the DOM attempts to provide the widest range and optimal performance."}),"\n",(0,t.jsx)(n.p,{children:"When parsing a Number, it is stored in the DOM as one of the following types:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"unsigned"})}),(0,t.jsx)(n.td,{children:"32-bit unsigned integer"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"int"})}),(0,t.jsx)(n.td,{children:"32-bit signed integer"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint64_t"})}),(0,t.jsx)(n.td,{children:"64-bit unsigned integer"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"int64_t"})}),(0,t.jsx)(n.td,{children:"64-bit signed integer"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"double"})}),(0,t.jsx)(n.td,{children:"64-bit double-precision floating-point number"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:"When querying a Number, you can check if it can be extracted as the target type:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Check"}),(0,t.jsx)(n.th,{children:"Extraction"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"bool IsNumber()"})}),(0,t.jsx)(n.td,{children:"N/A"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"bool IsUint()"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"unsigned GetUint()"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"bool IsInt()"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"int GetInt()"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"bool IsUint64()"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint64_t GetUint64()"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"bool IsInt64()"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"int64_t GetInt64()"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"bool IsDouble()"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"double GetDouble()"})})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:["Note that an integer can be extracted as multiple types without conversion. For example, if a Value named ",(0,t.jsx)(n.code,{children:"x"})," contains 123, then ",(0,t.jsx)(n.code,{children:"x.IsInt() == x.IsUint() == x.IsInt64() == x.IsUint64() == true"}),". However, if a Value named ",(0,t.jsx)(n.code,{children:"y"})," contains -3000000000, only ",(0,t.jsx)(n.code,{children:"x.IsInt64() == true"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["When extracting a Number type, ",(0,t.jsx)(n.code,{children:"GetDouble()"})," converts the internal integer representation to ",(0,t.jsx)(n.code,{children:"double"}),". Note that ",(0,t.jsx)(n.code,{children:"int"})," and ",(0,t.jsx)(n.code,{children:"unsigned"})," can be safely converted to ",(0,t.jsx)(n.code,{children:"double"}),", but ",(0,t.jsx)(n.code,{children:"int64_t"})," and ",(0,t.jsx)(n.code,{children:"uint64_t"})," may lose precision (since ",(0,t.jsx)(n.code,{children:"double"})," has only 52 mantissa bits)."]}),"\n",(0,t.jsx)(n.h2,{id:"QueryString",children:"Querying Strings"}),"\n",(0,t.jsxs)(n.p,{children:["In addition to ",(0,t.jsx)(n.code,{children:"GetString()"}),", the ",(0,t.jsx)(n.code,{children:"Value"})," class provides ",(0,t.jsx)(n.code,{children:"GetStringLength()"}),". Here's why:"]}),"\n",(0,t.jsxs)(n.p,{children:["Per RFC 4627, JSON Strings can contain the Unicode character ",(0,t.jsx)(n.code,{children:"U+0000"})," (represented as ",(0,t.jsx)(n.code,{children:'"\\u0000"'})," in JSON). The problem is that C/C++ typically uses null-terminated strings, which treat ",(0,t.jsx)(n.code,{children:"\\0"})," as the terminator."]}),"\n",(0,t.jsxs)(n.p,{children:["To comply with RFC 4627, Merak supports Strings containing ",(0,t.jsx)(n.code,{children:"U+0000"}),". If you need to handle such Strings, use ",(0,t.jsx)(n.code,{children:"GetStringLength()"})," to get the correct length."]}),"\n",(0,t.jsxs)(n.p,{children:["For example, after parsing the following JSON into ",(0,t.jsx)(n.code,{children:"Document d"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{ "s" :  "a\\u0000b" }\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The correct length of ",(0,t.jsx)(n.code,{children:'"a\\u0000b"'})," is 3, but ",(0,t.jsx)(n.code,{children:"strlen()"})," returns 1."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"GetStringLength()"})," also improves performance, as you may need to call ",(0,t.jsx)(n.code,{children:"strlen()"})," to allocate buffers."]}),"\n",(0,t.jsxs)(n.p,{children:["Additionally, ",(0,t.jsx)(n.code,{children:"std::string"})," supports this constructor:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"string(const char* s, size_t count);\n"})}),"\n",(0,t.jsx)(n.p,{children:"This constructor accepts the string length as a parameter. It supports storing null characters and typically offers better performance."}),"\n",(0,t.jsx)(n.h2,{id:"comparing-two-values",children:"Comparing Two Values"}),"\n",(0,t.jsxs)(n.p,{children:["You can use ",(0,t.jsx)(n.code,{children:"=="})," and ",(0,t.jsx)(n.code,{children:"!="})," to compare two Values. Two Values are considered equal if and only if their types and contents are identical. You can also compare a Value with its native type value. Here's an example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'if (document["hello"] == document["n"]) /*...*/;    // Compare two values\nif (document["hello"] == "world") /*...*/;          // Compare with string literal\nif (document["i"] != 123) /*...*/;                  // Compare with integer\nif (document["pi"] != 3.14) /*...*/;                // Compare with double\n'})}),"\n",(0,t.jsx)(n.p,{children:"Arrays/Objects are compared by their elements/members in order. They are equal if and only if their entire subtrees are identical."}),"\n",(0,t.jsxs)(n.p,{children:["Note that currently, if an Object contains duplicate-named members, it will always return ",(0,t.jsx)(n.code,{children:"false"})," when compared to any Object."]}),"\n",(0,t.jsx)(n.h1,{id:"CreateModifyValues",children:"Creating/Modifying Values"}),"\n",(0,t.jsxs)(n.p,{children:["There are multiple ways to create values. Once a DOM tree is created or modified, you can use ",(0,t.jsx)(n.code,{children:"Writer"})," to save it back to JSON."]}),"\n",(0,t.jsx)(n.h2,{id:"ChangeValueType",children:"Changing Value Type"}),"\n",(0,t.jsxs)(n.p,{children:["When creating a Value or Document with the default constructor, its type is Null. To change the type, call ",(0,t.jsx)(n.code,{children:"SetXXX()"})," or use the assignment operator\u2014for example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"Document d; // Null\nd.SetObject();\n\nValue v;    // Null\nv.SetInt(10);\nv = 10;     // Shorthand (equivalent to the line above)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"overloaded-constructors",children:"Overloaded Constructors"}),"\n",(0,t.jsx)(n.p,{children:"Several types also have overloaded constructors:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"Value b(true);    // Calls Value(bool)\nValue i(-123);    // Calls Value(int)\nValue u(123u);    // Calls Value(unsigned)\nValue d(1.5);     // Calls Value(double)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["To create an empty Object or Array, use ",(0,t.jsx)(n.code,{children:"SetObject()"}),"/",(0,t.jsx)(n.code,{children:"SetArray()"})," after the default constructor, or use ",(0,t.jsx)(n.code,{children:"Value(Type)"})," directly:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"Value o(kObjectType);\nValue a(kArrayType);\n"})}),"\n",(0,t.jsx)(n.h2,{id:"MoveSemantics",children:"Move Semantics"}),"\n",(0,t.jsxs)(n.p,{children:["A very special design decision in Merak is that Value assignment does not copy the source Value to the destination Value\u2014it ",(0,t.jsx)(n.em,{children:"moves"})," the source Value to the destination Value. For example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"Value a(123);\nValue b(456);\nb = a;         // a becomes Null, b becomes the number 123.\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Move Semantics 1",src:r(3731).A+"",width:"269",height:"255"})}),"\n",(0,t.jsx)(n.p,{children:"Why this design? What are the advantages of this semantics?"}),"\n",(0,t.jsxs)(n.p,{children:["The simplest answer is ",(0,t.jsx)(n.strong,{children:"performance"}),". For fixed-size JSON types (Number, True, False, Null), copying is fast and simple. However, for variable-size JSON types (String, Array, Object), copying incurs significant overhead\u2014often unnoticed. This is especially true when creating temporary Objects, copying them to another variable, then destructing them."]}),"\n",(0,t.jsxs)(n.p,{children:["For example, with normal ",(0,t.jsx)(n.em,{children:"copy"})," semantics:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'Value o(kObjectType);\n{\n    Value contacts(kArrayType);\n    // Add elements to the contacts array.\n    // ...\n    o.AddMember("contacts", contacts, d.GetAllocator());  // Deep copy of contacts (may involve heavy memory allocation)\n    // Destruct contacts.\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Move Semantics 2",src:r(9240).A+"",width:"421",height:"543"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"o"})," Object would need to allocate a buffer of the same size as ",(0,t.jsx)(n.code,{children:"contacts"}),", perform a deep copy of ",(0,t.jsx)(n.code,{children:"contacts"}),", and finally destruct ",(0,t.jsx)(n.code,{children:"contacts"}),". This results in unnecessary memory allocations/frees and memory copies."]}),"\n",(0,t.jsx)(n.p,{children:"Solutions to avoid physical copying include reference counting and garbage collection (GC)."}),"\n",(0,t.jsxs)(n.p,{children:["To keep Merak simple and fast, we chose ",(0,t.jsx)(n.em,{children:"move"})," semantics for assignment. This approach is similar to ",(0,t.jsx)(n.code,{children:"std::auto_ptr"}),"\u2014transferring ownership during assignment. Moving is much faster and simpler: it only requires destructing the original Value, ",(0,t.jsx)(n.code,{children:"memcpy()"}),"-ing the source to the target, and finally setting the source to the Null type."]}),"\n",(0,t.jsx)(n.p,{children:"With move semantics, the example above becomes:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'Value o(kObjectType);\n{\n    Value contacts(kArrayType);\n    // Adding elements to contacts array.\n    o.AddMember("contacts", contacts, d.GetAllocator());  // Only memcpy() contacts itself to the new member\'s Value (16 bytes)\n    // contacts becomes Null here. Its destruction is trivial.\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Move Semantics 3",src:r(1953).A+"",width:"427",height:"543"})}),"\n",(0,t.jsxs)(n.p,{children:["In C++11, this is called the move assignment operator. Since Merak supports C++03, it uses move semantics for assignment operations, as well as for modifying functions like ",(0,t.jsx)(n.code,{children:"AddMember()"})," and ",(0,t.jsx)(n.code,{children:"PushBack()"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"TemporaryValues",children:"Move Semantics and Temporary Values"}),"\n",(0,t.jsxs)(n.p,{children:['Sometimes you want to construct a Value directly and pass it to a "move" function (e.g., ',(0,t.jsx)(n.code,{children:"PushBack()"}),", ",(0,t.jsx)(n.code,{children:"AddMember()"}),"). Since temporary objects cannot be converted to regular Value references, we added a convenient ",(0,t.jsx)(n.code,{children:"Move()"})," function:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"Value a(kArrayType);\nDocument::AllocatorType& allocator = document.GetAllocator();\n// a.PushBack(Value(42), allocator);       // Does not compile\na.PushBack(Value().SetInt(42), allocator); // Fluent API\na.PushBack(Value(42).Move(), allocator);   // Equivalent to the line above\n"})}),"\n",(0,t.jsx)(n.h2,{id:"CreateString",children:"Creating Strings"}),"\n",(0,t.jsx)(n.p,{children:"Merak provides two storage strategies for Strings:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"copy-string"}),": Allocates a buffer and copies the source data into it."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"const-string"}),": Simply stores a pointer to the string."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Copy-strings are always safe because they own a clone of the data. Const-strings are useful for storing string literals and in in-situ parsing (discussed in the DOM section)."}),"\n",(0,t.jsx)(n.p,{children:"To allow custom memory allocation, Merak requires users to pass an allocator instance as an API parameter whenever an operation may need memory allocation. This design avoids storing a pointer to an allocator (or document) in each Value."}),"\n",(0,t.jsxs)(n.p,{children:["Thus, when assigning a copy-string, call the overloaded ",(0,t.jsx)(n.code,{children:"SetString()"})," with an allocator:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'Document document;\nValue author;\nchar buffer[10];\nint len = sprintf(buffer, "%s %s", "Milo", "Yip"); // Dynamically created string.\nauthor.SetString(buffer, len, document.GetAllocator());\nmemset(buffer, 0, sizeof(buffer));\n// author.GetString() still contains "Milo Yip" after clearing buffer\n'})}),"\n",(0,t.jsxs)(n.p,{children:["In this example, we use the allocator from the ",(0,t.jsx)(n.code,{children:"Document"})," instance\u2014a common idiom when using Merak. However, you can use other allocator instances."]}),"\n",(0,t.jsxs)(n.p,{children:["Additionally, the ",(0,t.jsx)(n.code,{children:"SetString()"})," above requires a length parameter. This API handles strings containing null characters. Another overloaded ",(0,t.jsx)(n.code,{children:"SetString()"})," without a length parameter assumes the input is null-terminated and calls a ",(0,t.jsx)(n.code,{children:"strlen()"}),"-like function to get the length."]}),"\n",(0,t.jsxs)(n.p,{children:["Finally, for string literals or strings with a safe lifetime, use the const-string version of ",(0,t.jsx)(n.code,{children:"SetString()"})," (no allocator parameter). For string literals (or constant character arrays), simply pass the literal\u2014safe and efficient:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'Value s;\ns.SetString("merak");    // Can contain null characters; length deduced at compile time\ns = "merak";             // Shorthand (equivalent to the line above)\n'})}),"\n",(0,t.jsxs)(n.p,{children:["For character pointers, Merak requires a marker to indicate that it is safe not to copy. Use the ",(0,t.jsx)(n.code,{children:"StringRef"})," function:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'const char * cstr = getenv("USER");\nsize_t cstr_len = ...;                 // If length is available\nValue s;\n// s.SetString(cstr);                  // Does not compile\ns.SetString(StringRef(cstr));          // Allowed (assumes safe lifetime and null-terminated)\ns = StringRef(cstr);                   // Shorthand (equivalent to the line above)\ns.SetString(StringRef(cstr, cstr_len));// Faster; handles null characters\ns = StringRef(cstr, cstr_len);         // Shorthand (equivalent to the line above)\n\n'})}),"\n",(0,t.jsx)(n.h2,{id:"ModifyArray",children:"Modifying Arrays"}),"\n",(0,t.jsxs)(n.p,{children:["Array-type Values provide an API similar to ",(0,t.jsx)(n.code,{children:"std::vector"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"Clear()"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"Reserve(SizeType, Allocator&)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"Value& PushBack(Value&, Allocator&)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"template <typename T> GenericValue& PushBack(T, Allocator&)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"Value& PopBack()"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"ValueIterator Erase(ConstValueIterator pos)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"ValueIterator Erase(ConstValueIterator first, ConstValueIterator last)"})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Note that ",(0,t.jsx)(n.code,{children:"Reserve(...)"})," and ",(0,t.jsx)(n.code,{children:"PushBack(...)"})," may allocate memory for array elements and thus require an allocator."]}),"\n",(0,t.jsxs)(n.p,{children:["Here's an example of ",(0,t.jsx)(n.code,{children:"PushBack()"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'Value a(kArrayType);\nDocument::AllocatorType& allocator = document.GetAllocator();\n\nfor (int i = 5; i <= 10; i++)\n    a.PushBack(i, allocator);   // May call realloc()\u2014allocator required\n\n// Fluent interface\na.PushBack("Lua", allocator).PushBack("Mio", allocator);\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Unlike STL, ",(0,t.jsx)(n.code,{children:"PushBack()"}),"/",(0,t.jsx)(n.code,{children:"PopBack()"})," return a reference to the Array itself (known as a ",(0,t.jsx)(n.em,{children:"fluent interface"}),")."]}),"\n",(0,t.jsxs)(n.p,{children:["If you want to add a non-constant string or a string with an insufficient lifetime (see ",(0,t.jsx)(n.a,{href:"#CreateString",children:"Creating Strings"}),") to an Array, use the copy-string API to create the String. To avoid intermediate variables, use a ",(0,t.jsx)(n.a,{href:"#TemporaryValues",children:"temporary value"})," in place:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'// In-place Value parameter\ncontact.PushBack(Value("copy", document.GetAllocator()).Move(), // copy string\n                 document.GetAllocator());\n\n// Explicit Value parameter\nValue val("key", document.GetAllocator()); // copy string\ncontact.PushBack(val, document.GetAllocator());\n'})}),"\n",(0,t.jsx)(n.h2,{id:"ModifyObject",children:"Modifying Objects"}),"\n",(0,t.jsx)(n.p,{children:"Objects are collections of key-value pairs (each key must be a String). To modify an Object, add or remove members. The following APIs add members:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"Value& AddMember(Value&, Value&, Allocator& allocator)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"Value& AddMember(StringRefType, Value&, Allocator&)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"template <typename T> Value& AddMember(StringRefType, T value, Allocator&)"})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Here's an example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'Value contact(kObject);\ncontact.AddMember("name", "Milo", document.GetAllocator());\ncontact.AddMember("married", true, document.GetAllocator());\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Overloads using ",(0,t.jsx)(n.code,{children:"StringRefType"})," for the name parameter are similar to the string ",(0,t.jsx)(n.code,{children:"SetString"})," interface. These overloads avoid copying the ",(0,t.jsx)(n.code,{children:"name"})," string\u2014useful since JSON objects often use constant key names."]}),"\n",(0,t.jsxs)(n.p,{children:["If you need to create a key name from a non-constant string or a string with an insufficient lifetime (see ",(0,t.jsx)(n.a,{href:"#CreateString",children:"Creating Strings"}),"), use the copy-string API. To avoid intermediate variables, use a ",(0,t.jsx)(n.a,{href:"#TemporaryValues",children:"temporary value"})," in place:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'// In-place Value parameter\ncontact.AddMember(Value("copy", document.GetAllocator()).Move(), // copy string\n                  Value().Move(),                                // null value\n                  document.GetAllocator());\n\n// Explicit parameters\nValue key("key", document.GetAllocator()); // copy string name\nValue val(42);                             // some Value\ncontact.AddMember(key, val, document.GetAllocator());\n'})}),"\n",(0,t.jsx)(n.p,{children:"There are several options to remove members:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"bool RemoveMember(const Ch* name)"}),": Remove a member by name (linear time complexity)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"bool RemoveMember(const Value& name)"}),": Same as above, but ",(0,t.jsx)(n.code,{children:"name"})," is a Value."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"MemberIterator RemoveMember(MemberIterator)"}),": Remove a member by iterator (",(0,t.jsx)(n.em,{children:"constant"})," time complexity)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"MemberIterator EraseMember(MemberIterator)"}),": Similar to above but preserves member order (linear time complexity)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"MemberIterator EraseMember(MemberIterator first, MemberIterator last)"}),": Remove a range of members (preserves order; linear time complexity)."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"MemberIterator RemoveMember(MemberIterator)"}),' uses a "move last" technique to achieve constant time complexity: it destructs the member at the iterator position, then moves the last member to the iterator position. Thus, member order is changed.']}),"\n",(0,t.jsx)(n.h2,{id:"DeepCopyValue",children:"Deep Copying Values"}),"\n",(0,t.jsxs)(n.p,{children:["If you need to copy a DOM tree, use two APIs for deep copying: the constructor with an allocator and ",(0,t.jsx)(n.code,{children:"CopyFrom()"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'Document d;\nDocument::AllocatorType& a = d.GetAllocator();\nValue v1("foo");\n// Value v2(v1); // Not allowed\n\nValue v2(v1, a);                      // Create a clone\nassert(v1.IsString());                // v1 remains unchanged\nd.SetArray().PushBack(v1, a).PushBack(v2, a);\nassert(v1.IsNull() && v2.IsNull());   // Both are moved into d\n\nv2.CopyFrom(d, a);                    // Copy entire document to v2\nassert(d.IsArray() && d.Size() == 2); // d remains unchanged\nv1.SetObject().AddMember("array", v2, a);\nd.PushBack(v1, a);\n'})}),"\n",(0,t.jsx)(n.h2,{id:"SwapValues",children:"Swapping Values"}),"\n",(0,t.jsxs)(n.p,{children:["Merak also provides ",(0,t.jsx)(n.code,{children:"Swap()"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'Value a(123);\nValue b("Hello");\na.Swap(b);\nassert(a.IsString());\nassert(b.IsInt());\n'})}),"\n",(0,t.jsx)(n.p,{children:"Swapping is fast (constant time) regardless of how complex the DOM trees are."}),"\n",(0,t.jsx)(n.h1,{id:"WhatsNext",children:"What's Next"}),"\n",(0,t.jsx)(n.p,{children:"This tutorial demonstrates how to query and modify DOM trees. Merak has several other important concepts:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/cppdev/docs/foundamentals/json/stream",children:"Streams"})," are channels for reading/writing JSON. Streams can be in-memory strings, file streams, etc. Users can also define custom streams."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/cppdev/docs/foundamentals/json/encoding",children:"Encodings"})," define character encodings used in streams or memory. Merak also provides internal Unicode conversion and validation."]}),"\n",(0,t.jsxs)(n.li,{children:["Basic DOM functionality is introduced in this tutorial. Advanced features include in-situ parsing, additional parsing options, and advanced usage (see ",(0,t.jsx)(n.a,{href:"/cppdev/docs/foundamentals/json/dom",children:"DOM"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/cppdev/docs/foundamentals/json/sax",children:"SAX"})," is the foundation of Merak's parsing/generation capabilities. Learn to use ",(0,t.jsx)(n.code,{children:"Reader"}),"/",(0,t.jsx)(n.code,{children:"Writer"})," to build higher-performance applications. You can also use ",(0,t.jsx)(n.code,{children:"PrettyWriter"})," to format JSON."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/cppdev/docs/foundamentals/json/performance",children:"Performance"})," shows internal and third-party performance tests."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/cppdev/docs/foundamentals/json/internals",children:"Internals"})," covers Merak's internal design and techniques."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["You can also refer to the ",(0,t.jsx)(n.a,{href:"/cppdev/docs/foundamentals/json/faq",children:"FAQ"}),", API documentation, examples, and unit tests."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},9240:(e,n,r)=>{r.d(n,{A:()=>s});const s=r.p+"assets/images/move2-bcfd276d92641299d915b15132c1780d.png"}}]);