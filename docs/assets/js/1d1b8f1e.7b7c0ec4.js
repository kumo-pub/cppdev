"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[7273],{2639:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"testing/gt/gmock_for_dummies","title":"gMock for Dummies","description":"What Is gMock?","source":"@site/docs/testing/gt/gmock_for_dummies.md","sourceDirName":"testing/gt","slug":"/testing/gt/gmock_for_dummies","permalink":"/cppdev/docs/testing/gt/gmock_for_dummies","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/testing/gt/gmock_for_dummies.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Advanced GoogleTest Topics","permalink":"/cppdev/docs/testing/gt/advanced"},"next":{"title":"gMock Cookbook","permalink":"/cppdev/docs/testing/gt/gmock_cook_book"}}');var s=t(4848),o=t(8453);const a={},r="gMock for Dummies",c={},l=[{value:"What Is gMock?",id:"what-is-gmock",level:2},{value:"Why gMock?",id:"why-gmock",level:2},{value:"Getting Started",id:"getting-started",level:2},{value:"A Case for Mock Turtles",id:"a-case-for-mock-turtles",level:2},{value:"Writing the Mock Class",id:"writing-the-mock-class",level:2},{value:"How to Define It",id:"how-to-define-it",level:3},{value:"Where to Put It",id:"where-to-put-it",level:3},{value:"Using Mocks in Tests",id:"using-mocks-in-tests",level:2},{value:"Expectation Ordering",id:"expectation-ordering",level:6},{value:"Setting Expectations",id:"setting-expectations",level:2},{value:"General Syntax",id:"general-syntax",level:3},{value:"Matchers: What Arguments Do We Expect?",id:"matchers-what-arguments-do-we-expect",level:3},{value:"Cardinalities: How Many Times Will It Be Called?",id:"cardinalities-how-many-times-will-it-be-called",level:3},{value:"Actions: What Should It Do?",id:"actions-what-should-it-do",level:3},{value:"Using Multiple Expectations",id:"MultiExpectations",level:3},{value:"Ordered vs Unordered Calls",id:"OrderedCalls",level:3},{value:"All Expectations Are Sticky (Unless Said Otherwise)",id:"StickyExpectations",level:3},{value:"Uninteresting Calls",id:"uninteresting-calls",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h6:"h6",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"gmock-for-dummies",children:"gMock for Dummies"})}),"\n",(0,s.jsx)(n.h2,{id:"what-is-gmock",children:"What Is gMock?"}),"\n",(0,s.jsxs)(n.p,{children:["When you write a prototype or test, often it's not feasible or wise to rely on\nreal objects entirely. A ",(0,s.jsx)(n.strong,{children:"mock object"})," implements the same interface as a real\nobject (so it can be used as one), but lets you specify at run time how it will\nbe used and what it should do (which methods will be called? in which order? how\nmany times? with what arguments? what will they return? etc)."]}),"\n",(0,s.jsxs)(n.p,{children:["It is easy to confuse the term ",(0,s.jsx)(n.em,{children:"fake objects"})," with mock objects. Fakes and mocks\nactually mean very different things in the Test-Driven Development (TDD)\ncommunity:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fake"})," objects have working implementations, but usually take some\nshortcut (perhaps to make the operations less expensive), which makes them\nnot suitable for production. An in-memory file system would be an example of\na fake."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Mocks"})," are objects pre-programmed with ",(0,s.jsx)(n.em,{children:"expectations"}),", which form a\nspecification of the calls they are expected to receive."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["If all this seems too abstract for you, don't worry - the most important thing\nto remember is that a mock allows you to check the ",(0,s.jsx)(n.em,{children:"interaction"})," between itself\nand code that uses it. The difference between fakes and mocks shall become much\nclearer once you start to use mocks."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"gMock"}),' is a library (sometimes we also call it a "framework" to make it sound\ncool) for creating mock classes and using them. It does to C++ what\njMock/EasyMock does to Java (well, more or less).']}),"\n",(0,s.jsx)(n.p,{children:"When using gMock,"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"first, you use some simple macros to describe the interface you want to\nmock, and they will expand to the implementation of your mock class;"}),"\n",(0,s.jsx)(n.li,{children:"next, you create some mock objects and specify its expectations and behavior\nusing an intuitive syntax;"}),"\n",(0,s.jsx)(n.li,{children:"then you exercise code that uses the mock objects. gMock will catch any\nviolation to the expectations as soon as it arises."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"why-gmock",children:"Why gMock?"}),"\n",(0,s.jsxs)(n.p,{children:["While mock objects help you remove unnecessary dependencies in tests and make\nthem fast and reliable, using mocks manually in C++ is ",(0,s.jsx)(n.em,{children:"hard"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Someone has to implement the mocks. The job is usually tedious and\nerror-prone. No wonder people go great distance to avoid it."}),"\n",(0,s.jsx)(n.li,{children:"The quality of those manually written mocks is a bit, uh, unpredictable. You\nmay see some really polished ones, but you may also see some that were\nhacked up in a hurry and have all sorts of ad hoc restrictions."}),"\n",(0,s.jsx)(n.li,{children:"The knowledge you gained from using one mock doesn't transfer to the next\none."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"In contrast, Java and Python programmers have some fine mock frameworks (jMock,\nEasyMock, etc), which automate the creation of mocks. As a result, mocking is a\nproven effective technique and widely adopted practice in those communities.\nHaving the right tool absolutely makes the difference."}),"\n",(0,s.jsx)(n.p,{children:"gMock was built to help C++ programmers. It was inspired by jMock and EasyMock,\nbut designed with C++'s specifics in mind. It is your friend if any of the\nfollowing problems is bothering you:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'You are stuck with a sub-optimal design and wish you had done more\nprototyping before it was too late, but prototyping in C++ is by no means\n"rapid".'}),"\n",(0,s.jsx)(n.li,{children:"Your tests are slow as they depend on too many libraries or use expensive\nresources (e.g. a database)."}),"\n",(0,s.jsx)(n.li,{children:"Your tests are brittle as some resources they use are unreliable (e.g. the\nnetwork)."}),"\n",(0,s.jsx)(n.li,{children:"You want to test how your code handles a failure (e.g. a file checksum\nerror), but it's not easy to cause one."}),"\n",(0,s.jsx)(n.li,{children:"You need to make sure that your module interacts with other modules in the\nright way, but it's hard to observe the interaction; therefore you resort to\nobserving the side effects at the end of the action, but it's awkward at\nbest."}),"\n",(0,s.jsx)(n.li,{children:"You want to \"mock out\" your dependencies, except that they don't have mock\nimplementations yet; and, frankly, you aren't thrilled by some of those\nhand-written mocks."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"We encourage you to use gMock as"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["a ",(0,s.jsx)(n.em,{children:"design"})," tool, for it lets you experiment with your interface design early\nand often. More iterations lead to better designs!"]}),"\n",(0,s.jsxs)(n.li,{children:["a ",(0,s.jsx)(n.em,{children:"testing"})," tool to cut your tests' outbound dependencies and probe the\ninteraction between your module and its collaborators."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"getting-started",children:"Getting Started"}),"\n",(0,s.jsx)(n.p,{children:"gMock is bundled with googletest."}),"\n",(0,s.jsx)(n.h2,{id:"a-case-for-mock-turtles",children:"A Case for Mock Turtles"}),"\n",(0,s.jsxs)(n.p,{children:["Let's look at an example. Suppose you are developing a graphics program that\nrelies on a ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Logo_programming_language",children:"LOGO"}),"-like\nAPI for drawing. How would you test that it does the right thing? Well, you can\nrun it and compare the screen with a golden screen snapshot, but let's admit it:\ntests like this are expensive to run and fragile (What if you just upgraded to a\nshiny new graphics card that has better anti-aliasing? Suddenly you have to\nupdate all your golden images.). It would be too painful if all your tests are\nlike this. Fortunately, you learned about\n",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Dependency_injection",children:"Dependency Injection"})," and know the right thing\nto do: instead of having your application talk to the system API directly, wrap\nthe API in an interface (say, ",(0,s.jsx)(n.code,{children:"Turtle"}),") and code to that interface:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class Turtle {\n  ...\n  virtual ~Turtle() {}\n  virtual void PenUp() = 0;\n  virtual void PenDown() = 0;\n  virtual void Forward(int distance) = 0;\n  virtual void Turn(int degrees) = 0;\n  virtual void GoTo(int x, int y) = 0;\n  virtual int GetX() const = 0;\n  virtual int GetY() const = 0;\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["(Note that the destructor of ",(0,s.jsx)(n.code,{children:"Turtle"})," ",(0,s.jsx)(n.strong,{children:"must"})," be virtual, as is the case for\n",(0,s.jsx)(n.strong,{children:"all"})," classes you intend to inherit from - otherwise the destructor of the\nderived class will not be called when you delete an object through a base\npointer, and you'll get corrupted program states like memory leaks.)"]}),"\n",(0,s.jsxs)(n.p,{children:["You can control whether the turtle's movement will leave a trace using ",(0,s.jsx)(n.code,{children:"PenUp()"}),"\nand ",(0,s.jsx)(n.code,{children:"PenDown()"}),", and control its movement using ",(0,s.jsx)(n.code,{children:"Forward()"}),", ",(0,s.jsx)(n.code,{children:"Turn()"}),", and\n",(0,s.jsx)(n.code,{children:"GoTo()"}),". Finally, ",(0,s.jsx)(n.code,{children:"GetX()"})," and ",(0,s.jsx)(n.code,{children:"GetY()"})," tell you the current position of the\nturtle."]}),"\n",(0,s.jsxs)(n.p,{children:["Your program will normally use a real implementation of this interface. In\ntests, you can use a mock implementation instead. This allows you to easily\ncheck what drawing primitives your program is calling, with what arguments, and\nin which order. Tests written this way are much more robust (they won't break\nbecause your new machine does anti-aliasing differently), easier to read and\nmaintain (the intent of a test is expressed in the code, not in some binary\nimages), and run ",(0,s.jsx)(n.em,{children:"much, much faster"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"writing-the-mock-class",children:"Writing the Mock Class"}),"\n",(0,s.jsx)(n.p,{children:"If you are lucky, the mocks you need to use have already been implemented by\nsome nice people. If, however, you find yourself in the position to write a mock\nclass, relax - gMock turns this task into a fun game! (Well, almost.)"}),"\n",(0,s.jsx)(n.h3,{id:"how-to-define-it",children:"How to Define It"}),"\n",(0,s.jsxs)(n.p,{children:["Using the ",(0,s.jsx)(n.code,{children:"Turtle"})," interface as example, here are the simple steps you need to\nfollow:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Derive a class ",(0,s.jsx)(n.code,{children:"MockTurtle"})," from ",(0,s.jsx)(n.code,{children:"Turtle"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Take a ",(0,s.jsx)(n.em,{children:"virtual"})," function of ",(0,s.jsx)(n.code,{children:"Turtle"})," (while it's possible to\n",(0,s.jsx)(n.a,{href:"/cppdev/docs/testing/gt/gmock_cook_book#MockingNonVirtualMethods",children:"mock non-virtual methods using templates"}),",\nit's much more involved)."]}),"\n",(0,s.jsxs)(n.li,{children:["In the ",(0,s.jsx)(n.code,{children:"public:"})," section of the child class, write ",(0,s.jsx)(n.code,{children:"MOCK_METHOD();"})]}),"\n",(0,s.jsx)(n.li,{children:"Now comes the fun part: you take the function signature, cut-and-paste it\ninto the macro, and add two commas - one between the return type and the\nname, another between the name and the argument list."}),"\n",(0,s.jsxs)(n.li,{children:["If you're mocking a const method, add a 4th parameter containing ",(0,s.jsx)(n.code,{children:"(const)"}),"\n(the parentheses are required)."]}),"\n",(0,s.jsxs)(n.li,{children:["Since you're overriding a virtual method, we suggest adding the ",(0,s.jsx)(n.code,{children:"override"}),"\nkeyword. For const methods the 4th parameter becomes ",(0,s.jsx)(n.code,{children:"(const, override)"}),",\nfor non-const methods just ",(0,s.jsx)(n.code,{children:"(override)"}),". This isn't mandatory."]}),"\n",(0,s.jsxs)(n.li,{children:["Repeat until all virtual functions you want to mock are done. (It goes\nwithout saying that ",(0,s.jsx)(n.em,{children:"all"})," pure virtual methods in your abstract class must\nbe either mocked or overridden.)"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"After the process, you should have something like:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"#include <gmock/gmock.h>  // Brings in gMock.\n\nclass MockTurtle : public Turtle {\n public:\n  ...\n  MOCK_METHOD(void, PenUp, (), (override));\n  MOCK_METHOD(void, PenDown, (), (override));\n  MOCK_METHOD(void, Forward, (int distance), (override));\n  MOCK_METHOD(void, Turn, (int degrees), (override));\n  MOCK_METHOD(void, GoTo, (int x, int y), (override));\n  MOCK_METHOD(int, GetX, (), (const, override));\n  MOCK_METHOD(int, GetY, (), (const, override));\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["You don't need to define these mock methods somewhere else - the ",(0,s.jsx)(n.code,{children:"MOCK_METHOD"}),"\nmacro will generate the definitions for you. It's that simple!"]}),"\n",(0,s.jsx)(n.h3,{id:"where-to-put-it",children:"Where to Put It"}),"\n",(0,s.jsxs)(n.p,{children:["When you define a mock class, you need to decide where to put its definition.\nSome people put it in a ",(0,s.jsx)(n.code,{children:"_test.cc"}),". This is fine when the interface being mocked\n(say, ",(0,s.jsx)(n.code,{children:"Foo"}),") is owned by the same person or team. Otherwise, when the owner of\n",(0,s.jsx)(n.code,{children:"Foo"})," changes it, your test could break. (You can't really expect ",(0,s.jsx)(n.code,{children:"Foo"}),"'s\nmaintainer to fix every test that uses ",(0,s.jsx)(n.code,{children:"Foo"}),", can you?)"]}),"\n",(0,s.jsxs)(n.p,{children:["Generally, you should not mock classes you don't own. If you must mock such a\nclass owned by others, define the mock class in ",(0,s.jsx)(n.code,{children:"Foo"}),"'s Bazel package (usually\nthe same directory or a ",(0,s.jsx)(n.code,{children:"testing"})," sub-directory), and put it in a ",(0,s.jsx)(n.code,{children:".h"})," and a\n",(0,s.jsx)(n.code,{children:"cc_library"})," with ",(0,s.jsx)(n.code,{children:"testonly=True"}),". Then everyone can reference them from their\ntests. If ",(0,s.jsx)(n.code,{children:"Foo"})," ever changes, there is only one copy of ",(0,s.jsx)(n.code,{children:"MockFoo"})," to change, and\nonly tests that depend on the changed methods need to be fixed."]}),"\n",(0,s.jsxs)(n.p,{children:["Another way to do it: you can introduce a thin layer ",(0,s.jsx)(n.code,{children:"FooAdaptor"})," on top of\n",(0,s.jsx)(n.code,{children:"Foo"})," and code to this new interface. Since you own ",(0,s.jsx)(n.code,{children:"FooAdaptor"}),", you can absorb\nchanges in ",(0,s.jsx)(n.code,{children:"Foo"})," much more easily. While this is more work initially, carefully\nchoosing the adaptor interface can make your code easier to write and more\nreadable (a net win in the long run), as you can choose ",(0,s.jsx)(n.code,{children:"FooAdaptor"})," to fit your\nspecific domain much better than ",(0,s.jsx)(n.code,{children:"Foo"})," does."]}),"\n",(0,s.jsx)(n.h2,{id:"using-mocks-in-tests",children:"Using Mocks in Tests"}),"\n",(0,s.jsx)(n.p,{children:"Once you have a mock class, using it is easy. The typical work flow is:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Import the gMock names from the ",(0,s.jsx)(n.code,{children:"testing"})," namespace such that you can use\nthem unqualified (You only have to do it once per file). Remember that\nnamespaces are a good idea."]}),"\n",(0,s.jsx)(n.li,{children:"Create some mock objects."}),"\n",(0,s.jsx)(n.li,{children:"Specify your expectations on them (How many times will a method be called?\nWith what arguments? What should it do? etc.)."}),"\n",(0,s.jsx)(n.li,{children:"Exercise some code that uses the mocks; optionally, check the result using\ngoogletest assertions. If a mock method is called more than expected or with\nwrong arguments, you'll get an error immediately."}),"\n",(0,s.jsx)(n.li,{children:"When a mock is destructed, gMock will automatically check whether all\nexpectations on it have been satisfied."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Here's an example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include "path/to/mock-turtle.h"\n#include <gmock/gmock.h>\n#include <gtest/gtest.h>\n\nusing ::testing::AtLeast;                         // #1\n\nTEST(PainterTest, CanDrawSomething) {\n  MockTurtle turtle;                              // #2\n  EXPECT_CALL(turtle, PenDown())                  // #3\n      .Times(AtLeast(1));\n\n  Painter painter(&turtle);                       // #4\n\n  EXPECT_TRUE(painter.DrawCircle(0, 0, 10));      // #5\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["As you might have guessed, this test checks that ",(0,s.jsx)(n.code,{children:"PenDown()"})," is called at least\nonce. If the ",(0,s.jsx)(n.code,{children:"painter"})," object didn't call this method, your test will fail with\na message like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"path/to/my_test.cc:119: Failure\nActual function call count doesn't match this expectation:\nActually: never called;\nExpected: called at least once.\nStack trace:\n...\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Tip 1:"})," If you run the test from an Emacs buffer, you can hit ",(0,s.jsx)(n.code,{children:"<Enter>"})," on\nthe line number to jump right to the failed expectation."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Tip 2:"})," If your mock objects are never deleted, the final verification won't\nhappen. Therefore it's a good idea to turn on the heap checker in your tests\nwhen you allocate mocks on the heap. You get that automatically if you use the\n",(0,s.jsx)(n.code,{children:"gtest_main"})," library already."]}),"\n",(0,s.jsx)(n.h6,{id:"expectation-ordering",children:"Expectation Ordering"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Important note:"})," gMock requires expectations to be set ",(0,s.jsx)(n.strong,{children:"before"})," the mock\nfunctions are called, otherwise the behavior is ",(0,s.jsx)(n.strong,{children:"undefined"}),". Do not alternate\nbetween calls to ",(0,s.jsx)(n.code,{children:"EXPECT_CALL()"})," and calls to the mock functions, and do not set\nany expectations on a mock after passing the mock to an API."]}),"\n",(0,s.jsxs)(n.p,{children:["This means ",(0,s.jsx)(n.code,{children:"EXPECT_CALL()"})," should be read as expecting that a call will occur\n",(0,s.jsx)(n.em,{children:"in the future"}),", not that a call has occurred. Why does gMock work like that?\nWell, specifying the expectation beforehand allows gMock to report a violation\nas soon as it rises, when the context (stack trace, etc) is still available.\nThis makes debugging much easier."]}),"\n",(0,s.jsxs)(n.p,{children:["Admittedly, this test is contrived and doesn't do much. You can easily achieve\nthe same effect without using gMock. However, as we shall reveal soon, gMock\nallows you to do ",(0,s.jsx)(n.em,{children:"so much more"})," with the mocks."]}),"\n",(0,s.jsx)(n.h2,{id:"setting-expectations",children:"Setting Expectations"}),"\n",(0,s.jsxs)(n.p,{children:["The key to using a mock object successfully is to set the ",(0,s.jsx)(n.em,{children:"right expectations"}),'\non it. If you set the expectations too strict, your test will fail as the result\nof unrelated changes. If you set them too loose, bugs can slip through. You want\nto do it just right such that your test can catch exactly the kind of bugs you\nintend it to catch. gMock provides the necessary means for you to do it "just\nright."']}),"\n",(0,s.jsx)(n.h3,{id:"general-syntax",children:"General Syntax"}),"\n",(0,s.jsxs)(n.p,{children:["In gMock we use the ",(0,s.jsx)(n.code,{children:"EXPECT_CALL()"})," macro to set an expectation on a mock\nmethod. The general syntax is:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"EXPECT_CALL(mock_object, method(matchers))\n    .Times(cardinality)\n    .WillOnce(action)\n    .WillRepeatedly(action);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The macro has two arguments: first the mock object, and then the method and its\narguments. Note that the two are separated by a comma (",(0,s.jsx)(n.code,{children:","}),"), not a period (",(0,s.jsx)(n.code,{children:"."}),").\n(Why using a comma? The answer is that it was necessary for technical reasons.)\nIf the method is not overloaded, the macro can also be called without matchers:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"EXPECT_CALL(mock_object, non-overloaded-method)\n    .Times(cardinality)\n    .WillOnce(action)\n    .WillRepeatedly(action);\n"})}),"\n",(0,s.jsx)(n.p,{children:'This syntax allows the test writer to specify "called with any arguments"\nwithout explicitly specifying the number or types of arguments. To avoid\nunintended ambiguity, this syntax may only be used for methods that are not\noverloaded.'}),"\n",(0,s.jsxs)(n.p,{children:["Either form of the macro can be followed by some optional ",(0,s.jsx)(n.em,{children:"clauses"})," that provide\nmore information about the expectation. We'll discuss how each clause works in\nthe coming sections."]}),"\n",(0,s.jsx)(n.p,{children:"This syntax is designed to make an expectation read like English. For example,\nyou can probably guess that"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::Return;\n...\nEXPECT_CALL(turtle, GetX())\n    .Times(5)\n    .WillOnce(Return(100))\n    .WillOnce(Return(150))\n    .WillRepeatedly(Return(200));\n"})}),"\n",(0,s.jsxs)(n.p,{children:["says that the ",(0,s.jsx)(n.code,{children:"turtle"})," object's ",(0,s.jsx)(n.code,{children:"GetX()"})," method will be called five times, it\nwill return 100 the first time, 150 the second time, and then 200 every time.\nSome people like to call this style of syntax a Domain-Specific Language (DSL)."]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"})," Why do we use a macro to do this? Well it serves two purposes: first\nit makes expectations easily identifiable (either by ",(0,s.jsx)(n.code,{children:"grep"})," or by a human\nreader), and second it allows gMock to include the source file location of a\nfailed expectation in messages, making debugging easier."]})}),"\n",(0,s.jsx)(n.h3,{id:"matchers-what-arguments-do-we-expect",children:"Matchers: What Arguments Do We Expect?"}),"\n",(0,s.jsx)(n.p,{children:"When a mock function takes arguments, we may specify what arguments we are\nexpecting, for example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Expects the turtle to move forward by 100 units.\nEXPECT_CALL(turtle, Forward(100));\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Oftentimes you do not want to be too specific. Remember that talk about tests\nbeing too rigid? Over specification leads to brittle tests and obscures the\nintent of tests. Therefore we encourage you to specify only what's necessary\u2014no\nmore, no less. If you aren't interested in the value of an argument, write ",(0,s.jsx)(n.code,{children:"_"}),'\nas the argument, which means "anything goes":']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::_;\n...\n// Expects that the turtle jumps to somewhere on the x=50 line.\nEXPECT_CALL(turtle, GoTo(50, _));\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"_"})," is an instance of what we call ",(0,s.jsx)(n.strong,{children:"matchers"}),". A matcher is like a predicate\nand can test whether an argument is what we'd expect. You can use a matcher\ninside ",(0,s.jsx)(n.code,{children:"EXPECT_CALL()"})," wherever a function argument is expected. ",(0,s.jsx)(n.code,{children:"_"}),' is a\nconvenient way of saying "any value".']}),"\n",(0,s.jsxs)(n.p,{children:["In the above examples, ",(0,s.jsx)(n.code,{children:"100"})," and ",(0,s.jsx)(n.code,{children:"50"})," are also matchers; implicitly, they are\nthe same as ",(0,s.jsx)(n.code,{children:"Eq(100)"})," and ",(0,s.jsx)(n.code,{children:"Eq(50)"}),", which specify that the argument must be\nequal (using ",(0,s.jsx)(n.code,{children:"operator=="}),") to the matcher argument. There are many\n",(0,s.jsx)(n.a,{href:"/cppdev/docs/testing/gt/reference/matchers",children:"built-in matchers"})," for common types (as well as\n",(0,s.jsx)(n.a,{href:"/cppdev/docs/testing/gt/gmock_cook_book#NewMatchers",children:"custom matchers"}),"); for example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::Ge;\n...\n// Expects the turtle moves forward by at least 100.\nEXPECT_CALL(turtle, Forward(Ge(100)));\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If you don't care about ",(0,s.jsx)(n.em,{children:"any"})," arguments, rather than specify ",(0,s.jsx)(n.code,{children:"_"})," for each of\nthem you may instead omit the parameter list:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Expects the turtle to move forward.\nEXPECT_CALL(turtle, Forward);\n// Expects the turtle to jump somewhere.\nEXPECT_CALL(turtle, GoTo);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This works for all non-overloaded methods; if a method is overloaded, you need\nto help gMock resolve which overload is expected by specifying the number of\narguments and possibly also the\n",(0,s.jsx)(n.a,{href:"/cppdev/docs/testing/gt/gmock_cook_book#SelectOverload",children:"types of the arguments"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"cardinalities-how-many-times-will-it-be-called",children:"Cardinalities: How Many Times Will It Be Called?"}),"\n",(0,s.jsxs)(n.p,{children:["The first clause we can specify following an ",(0,s.jsx)(n.code,{children:"EXPECT_CALL()"})," is ",(0,s.jsx)(n.code,{children:"Times()"}),". We\ncall its argument a ",(0,s.jsx)(n.strong,{children:"cardinality"})," as it tells ",(0,s.jsx)(n.em,{children:"how many times"}),' the call should\noccur. It allows us to repeat an expectation many times without actually writing\nit as many times. More importantly, a cardinality can be "fuzzy", just like a\nmatcher can be. This allows a user to express the intent of a test exactly.']}),"\n",(0,s.jsxs)(n.p,{children:["An interesting special case is when we say ",(0,s.jsx)(n.code,{children:"Times(0)"}),". You may have guessed - it\nmeans that the function shouldn't be called with the given arguments at all, and\ngMock will report a googletest failure whenever the function is (wrongfully)\ncalled."]}),"\n",(0,s.jsxs)(n.p,{children:["We've seen ",(0,s.jsx)(n.code,{children:"AtLeast(n)"})," as an example of fuzzy cardinalities earlier. For the\nlist of built-in cardinalities you can use, see\n",(0,s.jsx)(n.a,{href:"/cppdev/docs/testing/gt/gmock_cheat_sheet#CardinalityList",children:"here"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Times()"})," clause can be omitted. ",(0,s.jsxs)(n.strong,{children:["If you omit ",(0,s.jsx)(n.code,{children:"Times()"}),", gMock will infer\nthe cardinality for you."]})," The rules are easy to remember:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.strong,{children:"neither"})," ",(0,s.jsx)(n.code,{children:"WillOnce()"})," ",(0,s.jsx)(n.strong,{children:"nor"})," ",(0,s.jsx)(n.code,{children:"WillRepeatedly()"})," is in the\n",(0,s.jsx)(n.code,{children:"EXPECT_CALL()"}),", the inferred cardinality is ",(0,s.jsx)(n.code,{children:"Times(1)"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["If there are ",(0,s.jsx)(n.em,{children:"n"})," ",(0,s.jsx)(n.code,{children:"WillOnce()"}),"'s but ",(0,s.jsx)(n.strong,{children:"no"})," ",(0,s.jsx)(n.code,{children:"WillRepeatedly()"}),", where ",(0,s.jsx)(n.em,{children:"n"})," >=\n1, the cardinality is ",(0,s.jsx)(n.code,{children:"Times(n)"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["If there are ",(0,s.jsx)(n.em,{children:"n"})," ",(0,s.jsx)(n.code,{children:"WillOnce()"}),"'s and ",(0,s.jsx)(n.strong,{children:"one"})," ",(0,s.jsx)(n.code,{children:"WillRepeatedly()"}),", where ",(0,s.jsx)(n.em,{children:"n"})," >=\n0, the cardinality is ",(0,s.jsx)(n.code,{children:"Times(AtLeast(n))"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Quick quiz:"})," what do you think will happen if a function is expected to be\ncalled twice but actually called four times?"]}),"\n",(0,s.jsx)(n.h3,{id:"actions-what-should-it-do",children:"Actions: What Should It Do?"}),"\n",(0,s.jsx)(n.p,{children:"Remember that a mock object doesn't really have a working implementation? We as\nusers have to tell it what to do when a method is invoked. This is easy in\ngMock."}),"\n",(0,s.jsxs)(n.p,{children:["First, if the return type of a mock function is a built-in type or a pointer,\nthe function has a ",(0,s.jsx)(n.strong,{children:"default action"})," (a ",(0,s.jsx)(n.code,{children:"void"})," function will just return, a\n",(0,s.jsx)(n.code,{children:"bool"})," function will return ",(0,s.jsx)(n.code,{children:"false"}),", and other functions will return 0). In\naddition, in C++ 11 and above, a mock function whose return type is\ndefault-constructible (i.e. has a default constructor) has a default action of\nreturning a default-constructed value. If you don't say anything, this behavior\nwill be used."]}),"\n",(0,s.jsxs)(n.p,{children:["Second, if a mock function doesn't have a default action, or the default action\ndoesn't suit you, you can specify the action to be taken each time the\nexpectation matches using a series of ",(0,s.jsx)(n.code,{children:"WillOnce()"})," clauses followed by an\noptional ",(0,s.jsx)(n.code,{children:"WillRepeatedly()"}),". For example,"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::Return;\n...\nEXPECT_CALL(turtle, GetX())\n     .WillOnce(Return(100))\n     .WillOnce(Return(200))\n     .WillOnce(Return(300));\n"})}),"\n",(0,s.jsxs)(n.p,{children:["says that ",(0,s.jsx)(n.code,{children:"turtle.GetX()"})," will be called ",(0,s.jsx)(n.em,{children:"exactly three times"})," (gMock inferred\nthis from how many ",(0,s.jsx)(n.code,{children:"WillOnce()"})," clauses we've written, since we didn't\nexplicitly write ",(0,s.jsx)(n.code,{children:"Times()"}),"), and will return 100, 200, and 300 respectively."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::Return;\n...\nEXPECT_CALL(turtle, GetY())\n     .WillOnce(Return(100))\n     .WillOnce(Return(200))\n     .WillRepeatedly(Return(300));\n"})}),"\n",(0,s.jsxs)(n.p,{children:["says that ",(0,s.jsx)(n.code,{children:"turtle.GetY()"})," will be called ",(0,s.jsx)(n.em,{children:"at least twice"})," (gMock knows this as\nwe've written two ",(0,s.jsx)(n.code,{children:"WillOnce()"})," clauses and a ",(0,s.jsx)(n.code,{children:"WillRepeatedly()"})," while having no\nexplicit ",(0,s.jsx)(n.code,{children:"Times()"}),"), will return 100 and 200 respectively the first two times,\nand 300 from the third time on."]}),"\n",(0,s.jsxs)(n.p,{children:["Of course, if you explicitly write a ",(0,s.jsx)(n.code,{children:"Times()"}),", gMock will not try to infer the\ncardinality itself. What if the number you specified is larger than there are\n",(0,s.jsx)(n.code,{children:"WillOnce()"})," clauses? Well, after all ",(0,s.jsx)(n.code,{children:"WillOnce()"}),"s are used up, gMock will do\nthe ",(0,s.jsx)(n.em,{children:"default"})," action for the function every time (unless, of course, you have a\n",(0,s.jsx)(n.code,{children:"WillRepeatedly()"}),".)."]}),"\n",(0,s.jsxs)(n.p,{children:["What can we do inside ",(0,s.jsx)(n.code,{children:"WillOnce()"})," besides ",(0,s.jsx)(n.code,{children:"Return()"}),"? You can return a\nreference using ",(0,s.jsx)(n.code,{children:"ReturnRef("}),(0,s.jsx)(n.em,{children:(0,s.jsx)(n.code,{children:"variable"})}),(0,s.jsx)(n.code,{children:")"}),", or invoke a pre-defined function,\namong ",(0,s.jsx)(n.a,{href:"/cppdev/docs/testing/gt/gmock_cook_book#using-actions",children:"others"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Important note:"})," The ",(0,s.jsx)(n.code,{children:"EXPECT_CALL()"})," statement evaluates the action clause\nonly once, even though the action may be performed many times. Therefore you\nmust be careful about side effects. The following may not do what you want:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::Return;\n...\nint n = 100;\nEXPECT_CALL(turtle, GetX())\n    .Times(4)\n    .WillRepeatedly(Return(n++));\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Instead of returning 100, 101, 102, ..., consecutively, this mock function will\nalways return 100 as ",(0,s.jsx)(n.code,{children:"n++"})," is only evaluated once. Similarly, ",(0,s.jsx)(n.code,{children:"Return(new Foo)"}),"\nwill create a new ",(0,s.jsx)(n.code,{children:"Foo"})," object when the ",(0,s.jsx)(n.code,{children:"EXPECT_CALL()"})," is executed, and will\nreturn the same pointer every time. If you want the side effect to happen every\ntime, you need to define a custom action, which we'll teach in the\n",(0,s.jsx)(n.a,{href:"/cppdev/docs/testing/gt/gmock_cook_book",children:"cook book"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Time for another quiz! What do you think the following means?"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::Return;\n...\nEXPECT_CALL(turtle, GetY())\n    .Times(4)\n    .WillOnce(Return(100));\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Obviously ",(0,s.jsx)(n.code,{children:"turtle.GetY()"})," is expected to be called four times. But if you think\nit will return 100 every time, think twice! Remember that one ",(0,s.jsx)(n.code,{children:"WillOnce()"}),"\nclause will be consumed each time the function is invoked and the default action\nwill be taken afterwards. So the right answer is that ",(0,s.jsx)(n.code,{children:"turtle.GetY()"})," will\nreturn 100 the first time, but ",(0,s.jsx)(n.strong,{children:"return 0 from the second time on"}),", as\nreturning 0 is the default action for ",(0,s.jsx)(n.code,{children:"int"})," functions."]}),"\n",(0,s.jsx)(n.h3,{id:"MultiExpectations",children:"Using Multiple Expectations"}),"\n",(0,s.jsx)(n.p,{children:"So far we've only shown examples where you have a single expectation. More\nrealistically, you'll specify expectations on multiple mock methods which may be\nfrom multiple mock objects."}),"\n",(0,s.jsxs)(n.p,{children:["By default, when a mock method is invoked, gMock will search the expectations in\nthe ",(0,s.jsx)(n.strong,{children:"reverse order"}),' they are defined, and stop when an active expectation that\nmatches the arguments is found (you can think of it as "newer rules override\nolder ones."). If the matching expectation cannot take any more calls, you will\nget an upper-bound-violated failure. Here\'s an example:']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::_;\n...\nEXPECT_CALL(turtle, Forward(_));  // #1\nEXPECT_CALL(turtle, Forward(10))  // #2\n    .Times(2);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.code,{children:"Forward(10)"})," is called three times in a row, the third time it will be an\nerror, as the last matching expectation (#2) has been saturated. If, however,\nthe third ",(0,s.jsx)(n.code,{children:"Forward(10)"})," call is replaced by ",(0,s.jsx)(n.code,{children:"Forward(20)"}),", then it would be OK,\nas now #1 will be the matching expectation."]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"})," Why does gMock search for a match in the ",(0,s.jsx)(n.em,{children:"reverse"})," order of the\nexpectations? The reason is that this allows a user to set up the default\nexpectations in a mock object's constructor or the test fixture's set-up phase\nand then customize the mock by writing more specific expectations in the test\nbody. So, if you have two expectations on the same method, you want to put the\none with more specific matchers ",(0,s.jsx)(n.strong,{children:"after"})," the other, or the more specific rule\nwould be shadowed by the more general one that comes after it."]})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Tip:"})," It is very common to start with a catch-all expectation for a method\nand ",(0,s.jsx)(n.code,{children:"Times(AnyNumber())"})," (omitting arguments, or with ",(0,s.jsx)(n.code,{children:"_"}),' for all arguments, if\noverloaded). This makes any calls to the method expected. This is not necessary\nfor methods that are not mentioned at all (these are "uninteresting"), but is\nuseful for methods that have some expectations, but for which other calls are\nok. See\n',(0,s.jsx)(n.a,{href:"/cppdev/docs/testing/gt/gmock_cook_book#uninteresting-vs-unexpected",children:"Understanding Uninteresting vs Unexpected Calls"}),"."]})}),"\n",(0,s.jsx)(n.h3,{id:"OrderedCalls",children:"Ordered vs Unordered Calls"}),"\n",(0,s.jsx)(n.p,{children:"By default, an expectation can match a call even though an earlier expectation\nhasn't been satisfied. In other words, the calls don't have to occur in the\norder the expectations are specified."}),"\n",(0,s.jsx)(n.p,{children:"Sometimes, you may want all the expected calls to occur in a strict order. To\nsay this in gMock is easy:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::InSequence;\n...\nTEST(FooTest, DrawsLineSegment) {\n  ...\n  {\n    InSequence seq;\n\n    EXPECT_CALL(turtle, PenDown());\n    EXPECT_CALL(turtle, Forward(100));\n    EXPECT_CALL(turtle, PenUp());\n  }\n  Foo();\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["By creating an object of type ",(0,s.jsx)(n.code,{children:"InSequence"}),", all expectations in its scope are\nput into a ",(0,s.jsx)(n.em,{children:"sequence"})," and have to occur ",(0,s.jsx)(n.em,{children:"sequentially"}),". Since we are just\nrelying on the constructor and destructor of this object to do the actual work,\nits name is really irrelevant."]}),"\n",(0,s.jsxs)(n.p,{children:["In this example, we test that ",(0,s.jsx)(n.code,{children:"Foo()"})," calls the three expected functions in the\norder as written. If a call is made out-of-order, it will be an error."]}),"\n",(0,s.jsxs)(n.p,{children:["(What if you care about the relative order of some of the calls, but not all of\nthem? Can you specify an arbitrary partial order? The answer is ... yes! The\ndetails can be found ",(0,s.jsx)(n.a,{href:"/cppdev/docs/testing/gt/gmock_cook_book#OrderedCalls",children:"here"}),".)"]}),"\n",(0,s.jsx)(n.h3,{id:"StickyExpectations",children:"All Expectations Are Sticky (Unless Said Otherwise)"}),"\n",(0,s.jsxs)(n.p,{children:["Now let's do a quick quiz to see how well you can use this mock stuff already.\nHow would you test that the turtle is asked to go to the origin ",(0,s.jsx)(n.em,{children:"exactly twice"}),"\n(you want to ignore any other instructions it receives)?"]}),"\n",(0,s.jsx)(n.p,{children:"After you've come up with your answer, take a look at ours and compare notes\n(solve it yourself first - don't cheat!):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::_;\nusing ::testing::AnyNumber;\n...\nEXPECT_CALL(turtle, GoTo(_, _))  // #1\n     .Times(AnyNumber());\nEXPECT_CALL(turtle, GoTo(0, 0))  // #2\n     .Times(2);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Suppose ",(0,s.jsx)(n.code,{children:"turtle.GoTo(0, 0)"})," is called three times. In the third time, gMock will\nsee that the arguments match expectation #2 (remember that we always pick the\nlast matching expectation). Now, since we said that there should be only two\nsuch calls, gMock will report an error immediately. This is basically what we've\ntold you in the ",(0,s.jsx)(n.a,{href:"#MultiExpectations",children:"Using Multiple Expectations"})," section above."]}),"\n",(0,s.jsxs)(n.p,{children:["This example shows that ",(0,s.jsx)(n.strong,{children:'expectations in gMock are "sticky" by default'}),", in\nthe sense that they remain active even after we have reached their invocation\nupper bounds. This is an important rule to remember, as it affects the meaning\nof the spec, and is ",(0,s.jsx)(n.strong,{children:"different"})," to how it's done in many other mocking\nframeworks (Why'd we do that? Because we think our rule makes the common cases\neasier to express and understand.)."]}),"\n",(0,s.jsx)(n.p,{children:"Simple? Let's see if you've really understood it: what does the following code\nsay?"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::Return;\n...\nfor (int i = n; i > 0; i--) {\n  EXPECT_CALL(turtle, GetX())\n      .WillOnce(Return(10*i));\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If you think it says that ",(0,s.jsx)(n.code,{children:"turtle.GetX()"})," will be called ",(0,s.jsx)(n.code,{children:"n"})," times and will\nreturn 10, 20, 30, ..., consecutively, think twice! The problem is that, as we\nsaid, expectations are sticky. So, the second time ",(0,s.jsx)(n.code,{children:"turtle.GetX()"})," is called,\nthe last (latest) ",(0,s.jsx)(n.code,{children:"EXPECT_CALL()"}),' statement will match, and will immediately\nlead to an "upper bound violated" error - this piece of code is not very useful!']}),"\n",(0,s.jsxs)(n.p,{children:["One correct way of saying that ",(0,s.jsx)(n.code,{children:"turtle.GetX()"})," will return 10, 20, 30, ..., is\nto explicitly say that the expectations are ",(0,s.jsx)(n.em,{children:"not"})," sticky. In other words, they\nshould ",(0,s.jsx)(n.em,{children:"retire"})," as soon as they are saturated:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::Return;\n...\nfor (int i = n; i > 0; i--) {\n  EXPECT_CALL(turtle, GetX())\n      .WillOnce(Return(10*i))\n      .RetiresOnSaturation();\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"And, there's a better way to do it: in this case, we expect the calls to occur\nin a specific order, and we line up the actions to match the order. Since the\norder is important here, we should make it explicit using a sequence:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using ::testing::InSequence;\nusing ::testing::Return;\n...\n{\n  InSequence s;\n\n  for (int i = 1; i <= n; i++) {\n    EXPECT_CALL(turtle, GetX())\n        .WillOnce(Return(10*i))\n        .RetiresOnSaturation();\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["By the way, the other situation where an expectation may ",(0,s.jsx)(n.em,{children:"not"})," be sticky is when\nit's in a sequence - as soon as another expectation that comes after it in the\nsequence has been used, it automatically retires (and will never be used to\nmatch any call)."]}),"\n",(0,s.jsx)(n.h3,{id:"uninteresting-calls",children:"Uninteresting Calls"}),"\n",(0,s.jsxs)(n.p,{children:["A mock object may have many methods, and not all of them are that interesting.\nFor example, in some tests we may not care about how many times ",(0,s.jsx)(n.code,{children:"GetX()"})," and\n",(0,s.jsx)(n.code,{children:"GetY()"})," get called."]}),"\n",(0,s.jsxs)(n.p,{children:["In gMock, if you are not interested in a method, just don't say anything about\nit. If a call to this method occurs, you'll see a warning in the test output,\nbut it won't be a failure. This is called \"naggy\" behavior; to change, see\n",(0,s.jsx)(n.a,{href:"/cppdev/docs/testing/gt/gmock_cook_book#NiceStrictNaggy",children:"The Nice, the Strict, and the Naggy"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var i=t(6540);const s={},o=i.createContext(s);function a(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);