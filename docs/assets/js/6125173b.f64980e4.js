"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[3744],{1440:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"retrieve/post/index","title":"Posting List Implementations (C++ / Industrial)","description":"Overview","source":"@site/docs/retrieve/post/index.mdx","sourceDirName":"retrieve/post","slug":"/retrieve/post/","permalink":"/cppdev/docs/retrieve/post/","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"PCRE \u2013 Perl Compatible Regular Expressions","permalink":"/cppdev/docs/retrieve/regex/pcre"},"next":{"title":"Storage Module Overview","permalink":"/cppdev/docs/store/"}}');var r=n(4848),t=n(8453);const l={},d="Posting List Implementations (C++ / Industrial)",c={},o=[{value:"Overview",id:"overview",level:2},{value:"Overview",id:"overview-1",level:2},{value:"Characteristics",id:"characteristics",level:2},{value:"Typical Use Cases",id:"typical-use-cases",level:2},{value:"Simple C++ Sketch",id:"simple-c-sketch",level:2},{value:"Overview",id:"overview-2",level:2},{value:"Characteristics",id:"characteristics-1",level:2},{value:"Typical Use Cases",id:"typical-use-cases-1",level:2},{value:"Principle",id:"principle",level:2},{value:"Common Industrial Codecs",id:"common-industrial-codecs",level:2},{value:"Example Libraries",id:"example-libraries",level:2},{value:"<strong>FastPForLib</strong>",id:"fastpforlib",level:2},{value:"Typical Uses",id:"typical-uses",level:2},{value:"Uncompressed",id:"uncompressed",level:2},{value:"Compressed (PFor / PFORDelta)",id:"compressed-pfor--pfordelta",level:2},{value:"Block / Skip Structure",id:"block--skip-structure",level:2}];function a(e){const s={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"posting-list-implementations-c--industrial",children:"Posting List Implementations (C++ / Industrial)"})}),"\n",(0,r.jsx)(s.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsxs)(s.p,{children:["A ",(0,r.jsx)(s.strong,{children:"posting list"})," (or inverted list) is a fundamental data structure in large\u2011scale retrieval and search systems. It stores the list of document IDs (and optionally positions) where a given term appears. An efficient posting list engine must balance:"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.strong,{children:"memory footprint"})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.strong,{children:"scan and random access performance"})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.strong,{children:"intersection / skip efficiency"})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.strong,{children:"compression / unpacking cost"})}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["In practical systems, posting lists are implemented as either ",(0,r.jsx)(s.strong,{children:"uncompressed arrays"})," or ",(0,r.jsx)(s.strong,{children:"compressed integer lists"})," with optional ",(0,r.jsx)(s.strong,{children:"block/skip indexing"}),"."]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h1,{id:"1-uncompressed-posting-list",children:"1) Uncompressed Posting List"}),"\n",(0,r.jsx)(s.h2,{id:"overview-1",children:"Overview"}),"\n",(0,r.jsxs)(s.p,{children:["An uncompressed posting list is a sorted array of ",(0,r.jsx)(s.code,{children:"uint32_t"})," document IDs (or positions). It is conceptually simple and provides fast access without decode overhead."]}),"\n",(0,r.jsx)(s.h2,{id:"characteristics",children:"Characteristics"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Space:"})," largest (no compression)"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Scan performance:"})," best for sequential / random access"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Skip support:"})," trivial"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Serialization:"})," direct binary dump"]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"typical-use-cases",children:"Typical Use Cases"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Short posting lists"}),"\n",(0,r.jsx)(s.li,{children:"Memory\u2011rich systems"}),"\n",(0,r.jsx)(s.li,{children:"Scenarios where CPU decode cost must be minimal"}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"simple-c-sketch",children:"Simple C++ Sketch"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"std::vector<uint32_t> postlist = {3, 7, 15, 29, 102};\n\n// Sequential scan\nfor (uint32_t doc : postlist) {\n    process(doc);\n}\n\n// Random access\nuint32_t doc = postlist[2];\n"})}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h1,{id:"2-block--skip-structures",children:"2) Block / Skip Structures"}),"\n",(0,r.jsx)(s.h2,{id:"overview-2",children:"Overview"}),"\n",(0,r.jsxs)(s.p,{children:["Block or skip indexing partitions a posting list into fixed or variable sized blocks, and stores ",(0,r.jsx)(s.strong,{children:"skip pointers"})," (or summary metadata) to accelerate traversal and intersection. Many modern retrieval engines combine block indexing with compressed posting formats for optimal performance."]}),"\n",(0,r.jsx)(s.h2,{id:"characteristics-1",children:"Characteristics"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Skip support:"})," allows jumping past irrelevant blocks"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Intersection speed:"})," improved for long lists"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Extra metadata:"})," cost proportional to block count"]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"typical-use-cases-1",children:"Typical Use Cases"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Long posting lists"}),"\n",(0,r.jsx)(s.li,{children:"High term intersection frequencies"}),"\n",(0,r.jsx)(s.li,{children:"Real\u2011time query processing"}),"\n"]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h1,{id:"3-delta--compressed-integer-lists",children:"3) Delta + Compressed Integer Lists"}),"\n",(0,r.jsx)(s.h2,{id:"principle",children:"Principle"}),"\n",(0,r.jsx)(s.p,{children:"Delta encoding exploits the fact that sorted document IDs often have small differences between adjacent values. For a posting list:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{children:"original: [d1, d2, d3, ...]\ndelta:    [d1, d2 - d1, d3 - d2, ...]\n"})}),"\n",(0,r.jsx)(s.p,{children:"Delta values tend to be small and more compressible. A second stage integer codec then compresses these deltas."}),"\n",(0,r.jsx)(s.h2,{id:"common-industrial-codecs",children:"Common Industrial Codecs"}),"\n",(0,r.jsx)(s.p,{children:"Industry uses several established integer compression codecs:"}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"Codec Category"}),(0,r.jsx)(s.th,{children:"Example Algorithms"})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"Variable\u2011byte"}),(0,r.jsx)(s.td,{children:"VByte"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"Bit\u2011packing"}),(0,r.jsx)(s.td,{children:"PFor (Frame of Reference)"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"SIMD\u2011friendly"}),(0,r.jsx)(s.td,{children:"SIMD\u2011FOR / SIMD\u2011PFor"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"Simple integer"}),(0,r.jsx)(s.td,{children:"Simple9 / Simple16"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"Legacy gamma"}),(0,r.jsx)(s.td,{children:"Elias Gamma / Delta / Rice"})]})]})]}),"\n",(0,r.jsx)(s.h2,{id:"example-libraries",children:"Example Libraries"}),"\n",(0,r.jsx)(s.p,{children:"These are real, industrially used libraries:"}),"\n",(0,r.jsx)(s.h2,{id:"fastpforlib",children:(0,r.jsx)(s.strong,{children:"FastPForLib"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:["GitHub: ",(0,r.jsx)(s.a,{href:"https://github.com/lemire/FastPFor",children:"https://github.com/lemire/FastPFor"})]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"Implements:"}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Frame of Reference (FOR)"})}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Patched Frame of Reference (PFor)"})}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"SIMD\u2011PFor / SIMD\u2011FOR"})," variants"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"Variable\u2011byte, Simple9, Simple16, etc."}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"Widely used in inverted index systems for posting list compression."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Encoding / Decoding Pattern (Pseudo)"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:'#include "common/headers.hpp"\n#include "FastPFor/headers.hpp"\n\n// assume posting list in \'postings\'\nauto deltas = delta_encode(postings);\n\n// choose a codec, e.g., PFor\nFastPForLib::PFor<32> codec;\n\n// encode into compressed buffer\nstd::vector<uint32_t> compressed(deltas.size());\nsize_t outSize = 0;\ncodec.encodeArray(deltas.data(), deltas.size(), compressed.data(), outSize);\n\n// decode back\nstd::vector<uint32_t> decoded(deltas.size());\nsize_t decodedSize = 0;\ncodec.decodeArray(compressed.data(), outSize, decoded.data(), decodedSize);\n\n// restore original\nauto restored = delta_decode(decoded);\n'})}),"\n",(0,r.jsxs)(s.blockquote,{children:["\n",(0,r.jsx)(s.p,{children:"Note: actual API names vary by FastPForLib version; above is schematic."}),"\n"]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h1,{id:"4-simple9--simple16--variable-byte",children:"4) Simple9 / Simple16 / Variable Byte"}),"\n",(0,r.jsx)(s.p,{children:"These codecs compress integer lists without SIMD optimization but remain common in older systems:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Variable Byte (VByte):"})," easy decode, moderate compression"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Simple9 / Simple16:"})," better compression, slightly higher decode cost"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Elias / Gamma / Delta / Rice:"})," good theoretical compression, weaker random access"]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"typical-uses",children:"Typical Uses"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Legacy systems"}),"\n",(0,r.jsx)(s.li,{children:"Compatibility scenarios"}),"\n",(0,r.jsx)(s.li,{children:"Lightweight compression where SIMD is unnecessary"}),"\n"]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h1,{id:"5-emerging-simdoptimized-schemes",children:"5) Emerging SIMD\u2011Optimized Schemes"}),"\n",(0,r.jsxs)(s.p,{children:["Newer schemes focus on ",(0,r.jsx)(s.strong,{children:"balancing compression with SIMD decode throughput"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Bit\u2011packing with SIMD instructions"}),"\n",(0,r.jsx)(s.li,{children:"Block\u2011oriented ANS / Bulk coding"}),"\n",(0,r.jsx)(s.li,{children:"Byte/bit shuffle + entropy coding (zstd\u2010style)"}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"While research demonstrates high throughput, adoption in large retrieval stacks is still catching up compared to established codecs like SIMD\u2011PFor / FastPFor."}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h1,{id:"industrial-comparison",children:"Industrial Comparison"}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"Scheme"}),(0,r.jsx)(s.th,{children:"Space Efficiency"}),(0,r.jsx)(s.th,{children:"Decode Speed"}),(0,r.jsx)(s.th,{children:"Random Access"}),(0,r.jsx)(s.th,{children:"Skip Support"}),(0,r.jsx)(s.th,{children:"SIMD Friendly"})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"Uncompressed"}),(0,r.jsx)(s.td,{children:"\u274c"}),(0,r.jsx)(s.td,{children:"\u2714\ufe0f"}),(0,r.jsx)(s.td,{children:"\u2714\ufe0f"}),(0,r.jsx)(s.td,{children:"\u2714\ufe0f"}),(0,r.jsx)(s.td,{children:"\u2014"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"Block / Skip Structure"}),(0,r.jsx)(s.td,{children:"\u2b06\ufe0f"}),(0,r.jsx)(s.td,{children:"\u2714\ufe0f"}),(0,r.jsx)(s.td,{children:"\u2714\ufe0f"}),(0,r.jsx)(s.td,{children:"\u2714\ufe0f"}),(0,r.jsx)(s.td,{children:"optional"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"PFor / PFORDelta"}),(0,r.jsx)(s.td,{children:"\u2714\ufe0f"}),(0,r.jsx)(s.td,{children:"\u2714\ufe0f\u2714\ufe0f"}),(0,r.jsx)(s.td,{children:"\u26a0\ufe0f"}),(0,r.jsx)(s.td,{children:"\u2b06\ufe0f via blocks"}),(0,r.jsx)(s.td,{children:"\u2714\ufe0f"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"Simple9 / Simple16"}),(0,r.jsx)(s.td,{children:"\u2b06\ufe0f"}),(0,r.jsx)(s.td,{children:"\u2714\ufe0f"}),(0,r.jsx)(s.td,{children:"\u26a0\ufe0f"}),(0,r.jsx)(s.td,{children:"\u2b06\ufe0f"}),(0,r.jsx)(s.td,{children:"\u2014"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"Variable Byte"}),(0,r.jsx)(s.td,{children:"\u2796"}),(0,r.jsx)(s.td,{children:"\u2714\ufe0f\u2714\ufe0f"}),(0,r.jsx)(s.td,{children:"\u26a0\ufe0f"}),(0,r.jsx)(s.td,{children:"limited"}),(0,r.jsx)(s.td,{children:"\u2014"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"New SIMD Schemes"}),(0,r.jsx)(s.td,{children:"\u2714\ufe0f\u2714\ufe0f"}),(0,r.jsx)(s.td,{children:"\u2714\ufe0f\u2714\ufe0f\u2714\ufe0f"}),(0,r.jsx)(s.td,{children:"\u26a0\ufe0f"}),(0,r.jsx)(s.td,{children:"plugin"}),(0,r.jsx)(s.td,{children:"\u2714\ufe0f"})]})]})]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h1,{id:"typical-scenarios",children:"Typical Scenarios"}),"\n",(0,r.jsx)(s.h2,{id:"uncompressed",children:"Uncompressed"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Very short lists"}),"\n",(0,r.jsx)(s.li,{children:"Memory available"}),"\n",(0,r.jsx)(s.li,{children:"Lowest CPU cost"}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"compressed-pfor--pfordelta",children:"Compressed (PFor / PFORDelta)"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Long posting lists (millions of entries)"}),"\n",(0,r.jsx)(s.li,{children:"Disk / memory bandwidth constrained"}),"\n",(0,r.jsx)(s.li,{children:"Intersection and batch processing dominant"}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"block--skip-structure",children:"Block / Skip Structure"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Frequent skipping required"}),"\n",(0,r.jsx)(s.li,{children:"Multi\u2010term intersection heavy workloads"}),"\n",(0,r.jsx)(s.li,{children:"Real\u2010time low latency retrieval"}),"\n"]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h1,{id:"implementation-notes",children:"Implementation Notes"}),"\n",(0,r.jsx)(s.p,{children:"Practical industrial systems often combine:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{children:"Block Index + Delta Encoding + SIMD\u2011friendly Codec\n"})}),"\n",(0,r.jsxs)(s.p,{children:["to achieve a balance of ",(0,r.jsx)(s.strong,{children:"compact storage"}),", ",(0,r.jsx)(s.strong,{children:"fast sequential scan"}),", and ",(0,r.jsx)(s.strong,{children:"efficient intersection"}),"."]}),"\n",(0,r.jsx)(s.p,{children:"Posting lists are typically part of a larger inverted index which may include:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Position lists"})," (for phrase queries)"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Payloads"})," (term frequency, field boosts)"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Bitmap filters"})," (for quick disqualification)"]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"Engineering considerations include:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.strong,{children:"Memory pool / mmap support"})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.strong,{children:"Batch decode interfaces"})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.strong,{children:"Cache\u2011friendly layout"})}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Concurrency support"})," (read parallelism)"]}),"\n"]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h1,{id:"posting-list-encoding-example-fastpforlib",children:"Posting List Encoding Example (FastPForLib)"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:'#include "FastPFor/headers.hpp"\n#include <vector>\n\n// delta_encode / delta_decode implemented separately\n\nstd::vector<uint32_t> postings = {10, 15, 102, 205, 2200};\n\n// compute deltas\nauto deltas = delta_encode(postings);\n\n// choose PFor codec from FastPForLib\nFastPForLib::PFor<32> codec;\n\n// encode\nstd::vector<uint32_t> compressed(deltas.size());\nsize_t outSize = 0;\ncodec.encodeArray(deltas.data(), deltas.size(), compressed.data(), outSize);\n\n// decode\nstd::vector<uint32_t> recovered(deltas.size());\nsize_t recSize = 0;\ncodec.decodeArray(compressed.data(), outSize, recovered.data(), recSize);\n\n// restore postings\nauto restored = delta_decode(recovered);\n'})})]})}function h(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>l,x:()=>d});var i=n(6540);const r={},t=i.createContext(r);function l(e){const s=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function d(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(t.Provider,{value:s},e.children)}}}]);