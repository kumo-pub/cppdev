"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[4538],{1747:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"store/kv/rocksdb/overview","title":"RocksDB Overview","description":"RocksDB is a high performance, embeddable key-value store designed for fast storage, large datasets, and efficient range queries. It is widely used in distributed systems for both OLTP and analytical workloads.","source":"@site/docs/store/kv/rocksdb/overview.mdx","sourceDirName":"store/kv/rocksdb","slug":"/store/kv/rocksdb/overview","permalink":"/cppdev/docs/store/kv/rocksdb/overview","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"RocksDB Overview"},"sidebar":"tutorialSidebar","previous":{"title":"rocksdb","permalink":"/cppdev/docs/category/rocksdb"},"next":{"title":"RocksDB Types","permalink":"/cppdev/docs/store/kv/rocksdb/types"}}');var r=s(4848),d=s(8453);const t={title:"RocksDB Overview"},l=void 0,c={},a=[{value:"1. Column Family Support",id:"1-column-family-support",level:2},{value:"2. Handling Large Data Volumes",id:"2-handling-large-data-volumes",level:2},{value:"3. Snapshot and Backup Strategies",id:"3-snapshot-and-backup-strategies",level:2},{value:"4. Key and Prefix Design",id:"4-key-and-prefix-design",level:2},{value:"5. Typical Performance Metrics (SSD-based)",id:"5-typical-performance-metrics-ssd-based",level:2}];function o(e){const n={code:"code",h2:"h2",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,d.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"RocksDB is a high performance, embeddable key-value store designed for fast storage, large datasets, and efficient range queries. It is widely used in distributed systems for both OLTP and analytical workloads."}),"\n",(0,r.jsx)(n.h2,{id:"1-column-family-support",children:"1. Column Family Support"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["RocksDB supports multiple ",(0,r.jsx)(n.strong,{children:"Column Families (CFs)"})," for logical separation of data."]}),"\n",(0,r.jsx)(n.li,{children:"Each CF has its own WAL, memtable, and SST files."}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Recommendation"}),": Minimize CFs where possible; each CF adds memory and compaction overhead."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"2-handling-large-data-volumes",children:"2. Handling Large Data Volumes"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["RocksDB is optimized for ",(0,r.jsx)(n.strong,{children:"terabytes of data"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Data is organized in an ",(0,r.jsx)(n.strong,{children:"LSM-tree"})," structure:"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Memtables buffer writes in memory."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"SSTables store immutable files on disk."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Compactions merge SST files to maintain read efficiency."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Efficient for workloads with heavy writes and sequential or prefix-based scans."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"3-snapshot-and-backup-strategies",children:"3. Snapshot and Backup Strategies"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Snapshot-based backup"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Lightweight, point-in-time view of DB."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Used for replication and catching up follower nodes."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Minimal I/O overhead."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"File-based backup (Checkpoint / BackupEngine)"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Durable copy of SST and WAL files."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Useful for disaster recovery or migration."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Recommendation"}),": Use snapshot for replication, file-based backup for full persistence. Minimize CFs to reduce backup complexity."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"4-key-and-prefix-design",children:"4. Key and Prefix Design"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Fixed-length prefix keys"})," improve range scan performance."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Design keys so frequently scanned ranges share a common prefix."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example"}),":"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Prefix: RegionID + EntityType"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Suffix: Timestamp or unique ID"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Avoid variable-length prefixes in hot paths, as they reduce prefix indexing efficiency."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"5-typical-performance-metrics-ssd-based",children:"5. Typical Performance Metrics (SSD-based)"}),"\n",(0,r.jsxs)(n.p,{children:["These numbers are ",(0,r.jsx)(n.strong,{children:"empirical references from medium-to-large deployments"}),", with RocksDB tuned for batch writes and prefix scans:"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Metric"}),(0,r.jsx)(n.th,{children:"Typical Value (SSD/NVMe)"}),(0,r.jsx)(n.th,{children:"Notes"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Write throughput (random writes)"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"50k\u2013200k ops/sec"})," per DB instance (",(0,r.jsx)(n.code,{children:"16\u201332 MB"})," memtable)"]}),(0,r.jsx)(n.td,{children:"Depends on write batch size"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Write amplification"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"2\u20135x"})}),(0,r.jsx)(n.td,{children:"With tuned compaction and CF count ~1\u20132"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Read throughput (point lookup)"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"100k\u2013500k ops/sec"})}),(0,r.jsx)(n.td,{children:"Using 8\u201316 GB block cache"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Read throughput (prefix scan)"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"200\u2013800 MB/sec"})}),(0,r.jsx)(n.td,{children:"With fixed prefix keys"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Compaction I/O"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"100\u2013400 MB/sec"})}),(0,r.jsxs)(n.td,{children:["Tuned via ",(0,r.jsx)(n.code,{children:"level0_file_num_compaction_trigger"})," and ",(0,r.jsx)(n.code,{children:"max_bytes_for_level_base"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Latency (write)"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"~0.5\u20132"})," ms"]}),(0,r.jsx)(n.td,{children:"Depends on WAL sync policy"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Latency (read, cached)"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"<0.1"})," ms"]}),(0,r.jsx)(n.td,{children:"Cached in block cache"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"SST file size"}),(0,r.jsx)(n.td,{children:"64 MB (default)"}),(0,r.jsxs)(n.td,{children:["Tunable via ",(0,r.jsx)(n.code,{children:"target_file_size_base"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Max DB size"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"~10\u2013100"})," TB+"]}),(0,r.jsx)(n.td,{children:"Depends on hardware and LSM tuning"})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Notes on tuning"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"SSD/NVMe storage is essential for predictable write performance."}),"\n",(0,r.jsxs)(n.li,{children:["Prefix-based fixed keys allow ",(0,r.jsx)(n.strong,{children:"memtable prefix bloom"})," and reduce disk seeks."]}),"\n",(0,r.jsx)(n.li,{children:"Backup and snapshot strategy affect I/O; prefer incremental snapshots for high-frequency backups."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,d.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>l});var i=s(6540);const r={},d=i.createContext(r);function t(e){const n=i.useContext(d);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(d.Provider,{value:n},e.children)}}}]);