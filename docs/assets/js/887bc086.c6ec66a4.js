"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[2827],{4323:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>i,metadata:()=>n,toc:()=>a});const n=JSON.parse('{"id":"foundamentals/testing/doct/extensions","title":"Extensions","description":"Extensions","source":"@site/docs/foundamentals/testing/doct/extensions.mdx","sourceDirName":"foundamentals/testing/doct","slug":"/foundamentals/testing/doct/extensions","permalink":"/cppdev/docs/foundamentals/testing/doct/extensions","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/foundamentals/testing/doct/extensions.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Test Reporters","permalink":"/cppdev/docs/foundamentals/testing/doct/reporters"},"next":{"title":"FAQ","permalink":"/cppdev/docs/foundamentals/testing/doct/faq"}}');var r=s(4848),o=s(8453);const i={},c="Extensions",d={},a=[{value:"Extensions",id:"extensions-1",level:2},{value:"Examples",id:"examples",level:2},{value:"MPI_TEST_CASE",id:"mpi_test_case",level:3},{value:"Assertions",id:"assertions",level:3},{value:"Main Entry Point and MPI Test Reporting",id:"main-entry-point-and-mpi-test-reporting",level:2},{value:"MpiConsoleReporter",id:"mpiconsolereporter",level:3},{value:"MpiFileReporter",id:"mpifilereporter",level:3},{value:"Other Reporters",id:"other-reporters",level:3},{value:"Explanation",id:"explanation",level:2},{value:"TODO",id:"todo",level:2}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"extensions",children:"Extensions"})}),"\n",(0,r.jsx)(t.h2,{id:"extensions-1",children:"Extensions"}),"\n",(0,r.jsxs)(t.p,{children:["The doctest header does not include any external or standard library headers in its interface section to ensure optimal build performance, but this results in limited functionality it can provide ",(0,r.jsx)(t.code,{children:"=>"})," this is where extensions come into play. They exist as header files in the ",(0,r.jsx)(t.a,{href:"https://github.com/doctest/doctest/blob/master/doctest/extensions",children:(0,r.jsx)(t.code,{children:"doctest/extensions"})})," directory, and each file is documented in a dedicated section here."]}),"\n",(0,r.jsx)(t.h1,{id:"utils",children:(0,r.jsx)(t.a,{href:"https://github.com/doctest/doctest/blob/master/doctest/extensions/doctest_util.h",children:"Utils"})}),"\n",(0,r.jsx)(t.p,{children:"Nothing here yet..."}),"\n",(0,r.jsx)(t.h1,{id:"distributed-tests-with-mpi",children:(0,r.jsx)(t.a,{href:"https://github.com/doctest/doctest/blob/master/doctest/extensions/doctest_mpi.h",children:"Distributed tests with MPI"})}),"\n",(0,r.jsxs)(t.p,{children:["Testing code across distributed processes requires support from the test framework. ",(0,r.jsx)(t.strong,{children:"Doctest"})," support for MPI parallel communication is provided in the ",(0,r.jsx)(t.code,{children:'"doctest/extensions/doctest_mpi.h"'})," header file."]}),"\n",(0,r.jsx)(t.h2,{id:"examples",children:"Examples"}),"\n",(0,r.jsxs)(t.p,{children:["Refer to ",(0,r.jsx)(t.a,{href:"https://github.com/doctest/doctest/blob/master/examples/mpi/mpi.cpp",children:(0,r.jsx)(t.strong,{children:"the complete test"})})," and ",(0,r.jsx)(t.a,{href:"https://github.com/doctest/doctest/blob/master/examples/mpi/main.cpp",children:(0,r.jsx)(t.strong,{children:"the configuration of main()"})})]}),"\n",(0,r.jsx)(t.h3,{id:"mpi_test_case",children:"MPI_TEST_CASE"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-c++",children:'#include "doctest/extensions/doctest_mpi.h"\n\nint my_function_to_test(MPI_Comm comm) {\n  int rank;\n  MPI_Comm_rank(comm,&rank);\n  if (rank == 0) {\n    return 10;\n  }\n  return 11;\n}\n\n\nMPI_TEST_CASE("test over two processes",2) { // Parallel test on 2 processes\n  int x = my_function_to_test(test_comm);\n\n  MPI_CHECK( 0,  x==10 ); // CHECK for rank 0, that x==10\n  MPI_CHECK( 1,  x==11 ); // CHECK for rank 1, that x==11\n}\n'})}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"MPI_TEST_CASE"})," is similar to the regular ",(0,r.jsx)(t.code,{children:"TEST_CASE"}),", except it requires a second parameter specifying the number of processes needed to run the test. If the number of processes is less than 2, the test fails. If the number of processes is 2 or more, it creates a sub-communicator on 2 processes (named ",(0,r.jsx)(t.code,{children:"test_comm"}),") and executes the test on these processes. ",(0,r.jsx)(t.code,{children:"MPI_TEST_CASE"})," provides three objects:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"test_comm"})," (type ",(0,r.jsx)(t.code,{children:"MPI_Comm"}),"): the MPI communicator for running the test,"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"test_rank"})," and ",(0,r.jsx)(t.code,{children:"test_nb_procs"})," (two ",(0,r.jsx)(t.code,{children:"int"})," values): respectively representing the rank of the current process and the size of the ",(0,r.jsx)(t.code,{children:"test_comm"})," communicator. The latter two are provided for convenience and can be retrieved from ",(0,r.jsx)(t.code,{children:"test_comm"}),"."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"The following always holds true:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-c++",children:'MPI_TEST_CASE("my_test",N) {\n  CHECK( test_nb_procs == N );\n  MPI_CHECK( i, test_rank==i ); // for any i<N\n}\n'})}),"\n",(0,r.jsx)(t.h3,{id:"assertions",children:"Assertions"}),"\n",(0,r.jsxs)(t.p,{children:["Regular assertions can be used in ",(0,r.jsx)(t.code,{children:"MPI_TEST_CASE"}),". MPI-specific assertions are also provided, all prefixed with ",(0,r.jsx)(t.code,{children:"MPI_"})," (",(0,r.jsx)(t.code,{children:"MPI_CHECK"}),", ",(0,r.jsx)(t.code,{children:"MPI_ASSERT"}),", etc.). The first parameter is the target rank for the check, and the second parameter is the regular expression to verify."]}),"\n",(0,r.jsx)(t.h2,{id:"main-entry-point-and-mpi-test-reporting",children:"Main Entry Point and MPI Test Reporting"}),"\n",(0,r.jsxs)(t.p,{children:["You need to launch the unit tests using the ",(0,r.jsx)(t.code,{children:"mpirun"})," or ",(0,r.jsx)(t.code,{children:"mpiexec"})," command:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"mpirun -np 2 unit_test_executable.exe\n"})}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"doctest::mpi_init_thread()"})," must be called before running the unit tests, and ",(0,r.jsx)(t.code,{children:"doctest::mpi_finalize()"})," must be called at the end of the program.\nAdditionally, using the default console reporter will cause every process to write all output to the same location, which is undesirable. Two dedicated reporters are provided and can be enabled. A complete ",(0,r.jsx)(t.code,{children:"main()"})," function should look like this:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-c++",children:'#define DOCTEST_CONFIG_IMPLEMENT\n\n#include "doctest/extensions/doctest_mpi.h"\n\nint main(int argc, char** argv) {\n  doctest::mpi_init_thread(argc,argv,MPI_THREAD_MULTIPLE); // Or any MPI thread level\n\n  doctest::Context ctx;\n  ctx.setOption("reporters", "MpiConsoleReporter");\n  ctx.setOption("reporters", "MpiFileReporter");\n  ctx.setOption("force-colors", true);\n  ctx.applyCommandLine(argc, argv);\n\n  int test_result = ctx.run();\n\n  doctest::mpi_finalize();\n\n  return test_result;\n}\n'})}),"\n",(0,r.jsx)(t.h3,{id:"mpiconsolereporter",children:"MpiConsoleReporter"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"MpiConsoleReporter"})," should replace the default reporter. It behaves the same as the default console reporter for regular assertions but only outputs on process 0. For MPI test cases, if a failure occurs, it indicates the process where the failure happened:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:'[doctest] doctest version is "2.4.0"\n[doctest] run with "--help" for options\n===============================================================================\n[doctest] test cases:    171 |    171 passed |      0 failed |      0 skipped\n[doctest] assertions:    864 |    864 passed |      0 failed |\n[doctest] Status: SUCCESS!\nstd_e_mpi_unit_tests\n[doctest] doctest version is "2.4.0"\n[doctest] run with "--help" for options\n===============================================================================\npath/to/test.cpp:30:\nTEST CASE: my test case\n\nOn rank [2] : path/to/test.cpp:35: CHECK( x==-1 ) is NOT correct!\n  values: CHECK( 0 == -1 )\n\n===============================================================================\n[doctest] test cases:      2 |      2 passed |      0 failed |      0 skipped\n[doctest] assertions:      2 |      2 passed |      0 failed |\n[doctest] Status: SUCCESS!\n===============================================================================\n[doctest] assertions on all processes:   5 |   4 passed |      1 failed |\n===============================================================================\n[doctest] fail on rank:\n    -> On rank [2] with 1 test failed\n[doctest] Status: FAILURE!\n'})}),"\n",(0,r.jsx)(t.p,{children:"If the number of processes used to launch the test executable is less than the number required by a test case, the test will be skipped and marked as such in the MPI console reporter:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-c++",children:'MPI_TEST_CASE("my_test",3) {\n  // ...\n}\n'})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"mpirun -np 2 unit_test_executable.exe\n"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"===============================================================================\n[doctest] test cases:      1 |      1 passed |      0 failed |      1 skipped\n[doctest] assertions:      1 |      1 passed |      0 failed |\n[doctest] Status: SUCCESS!\n===============================================================================\n[doctest] assertions on all processes:   1 |   1 passed |      0 failed |\n[doctest] WARNING: Skipped 1 test requiring more than 2 MPI processes to run\n===============================================================================\n"})}),"\n",(0,r.jsx)(t.h3,{id:"mpifilereporter",children:"MpiFileReporter"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"MpiFileReporter"})," prints the results of each process to its own file (named ",(0,r.jsx)(t.code,{children:"doctest_[rank].log"}),"). Use this reporter only as a debugging tool to investigate the exact cause of failures in parallel test cases."]}),"\n",(0,r.jsx)(t.h3,{id:"other-reporters",children:"Other Reporters"}),"\n",(0,r.jsxs)(t.p,{children:["Other reporters (jUnit, XML) are not directly supported. This means you can always print each process's results to its own file, but there is (currently) no equivalent of ",(0,r.jsx)(t.code,{children:"MpiConsoleReporter"})," to aggregate results from all processes."]}),"\n",(0,r.jsx)(t.h2,{id:"explanation",children:"Explanation"}),"\n",(0,r.jsxs)(t.p,{children:["This feature is designed for unit testing MPI-distributed code. It is ",(0,r.jsx)(t.strong,{children:"not"})," a method to parallelize multiple unit tests across multiple processes (for that purpose, refer to the ",(0,r.jsx)(t.a,{href:"https://github.com/doctest/doctest/blob/master/examples/range_based_execution.py",children:(0,r.jsx)(t.strong,{children:"example python script"})}),")."]}),"\n",(0,r.jsx)(t.h2,{id:"todo",children:"TODO"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Pass the ",(0,r.jsx)(t.code,{children:"s"})," member variable of ",(0,r.jsx)(t.code,{children:"ConsoleReporter"})," as a parameter to member functions, enabling reuse with other objects (will help refactor ",(0,r.jsx)(t.code,{children:"MPIConsoleReporter"}),")"]}),"\n",(0,r.jsxs)(t.li,{children:["Only ",(0,r.jsx)(t.code,{children:"MPI_CHECK"})," has been tested. ",(0,r.jsx)(t.code,{children:"MPI_REQUIRE"})," and exception handling: no tests have been performed"]}),"\n",(0,r.jsx)(t.li,{children:"Add more tests and automated testing"}),"\n",(0,r.jsxs)(t.li,{children:["Packaging: Create a new target ",(0,r.jsx)(t.code,{children:"mpi_doctest"}),"? (It would be cleaner for ",(0,r.jsx)(t.code,{children:"mpi/doctest.h"})," to explicitly depend on MPI)"]}),"\n",(0,r.jsx)(t.li,{children:"In the future (maybe): Implement a generic mechanism for representing assertions, separating report formats (console, XML, jUnit, etc.) from reporting strategies (sequential vs MPI)"}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>i,x:()=>c});var n=s(6540);const r={},o=n.createContext(r);function i(e){const t=n.useContext(o);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);