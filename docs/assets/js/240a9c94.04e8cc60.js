"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[4199],{1405:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"foundamentals/json/index","title":"Overview","description":"I. Core Feature Summary of 6 JSON Libraries","source":"@site/docs/foundamentals/json/index.mdx","sourceDirName":"foundamentals/json","slug":"/foundamentals/json/","permalink":"/cppdev/docs/foundamentals/json/","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/foundamentals/json/index.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Turbo File System Library (turbo::files) - Usage Guide & Function Details","permalink":"/cppdev/docs/foundamentals/filesystem/fs"},"next":{"title":"merak json","permalink":"/cppdev/docs/foundamentals/json/overview"}}');var o=n(4848),r=n(8453);const t={},l="Overview",a={},c=[{value:"I. Core Feature Summary of 6 JSON Libraries",id:"i-core-feature-summary-of-6-json-libraries",level:2},{value:"II. Revised &amp; Optimized Quick Selection Guide",id:"ii-revised--optimized-quick-selection-guide",level:2},{value:"1. Prioritize nlohmann-json",id:"1-prioritize-nlohmann-json",level:3},{value:"2. Must Choose merak/rapidjson",id:"2-must-choose-merakrapidjson",level:3},{value:"3. Choose simdjson",id:"3-choose-simdjson",level:3},{value:"4. Choose melon/json",id:"4-choose-melonjson",level:3},{value:"5. Choose cJSON",id:"5-choose-cjson",level:3},{value:"6. Choose jsoncoin Cautiously",id:"6-choose-jsoncoin-cautiously",level:3},{value:"III. Revision and Supplementary Suggestions for the Original Selection Rules",id:"iii-revision-and-supplementary-suggestions-for-the-original-selection-rules",level:2},{value:"1. Core Rules (Revised)",id:"1-core-rules-revised",level:3},{value:"2. Key Details to Revise in the Original Rules",id:"2-key-details-to-revise-in-the-original-rules",level:3},{value:"3. Additional Notes (for jsoncoin)",id:"3-additional-notes-for-jsoncoin",level:3},{value:"Final Simplified Selection Process",id:"final-simplified-selection-process",level:2}];function d(e){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(i.header,{children:(0,o.jsx)(i.h1,{id:"overview",children:"Overview"})}),"\n",(0,o.jsx)(i.h2,{id:"i-core-feature-summary-of-6-json-libraries",children:"I. Core Feature Summary of 6 JSON Libraries"}),"\n",(0,o.jsx)(i.p,{children:"Based on the design positioning, performance, memory footprint, and functional scalability (e.g., Protobuf-JSON conversion) of each library, the revised summary is as follows:"}),"\n",(0,o.jsxs)(i.table,{children:[(0,o.jsx)(i.thead,{children:(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.th,{children:"Library Name"}),(0,o.jsx)(i.th,{children:"Core Advantages"}),(0,o.jsx)(i.th,{children:"Key Features"}),(0,o.jsx)(i.th,{children:"Applicable Scenarios"}),(0,o.jsx)(i.th,{children:"Limitations"})]})}),(0,o.jsxs)(i.tbody,{children:[(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:"nlohmann-json"}),(0,o.jsx)(i.td,{children:"Ultra-easy to use, low integration cost"}),(0,o.jsx)(i.td,{children:"Header-only, STL-like API, C++11+ support, automatic type conversion, no compilation configuration required"}),(0,o.jsx)(i.td,{children:"Business scenarios with non-critical performance, rapid development, small-to-medium-sized JSON processing"}),(0,o.jsx)(i.td,{children:"Moderate runtime performance, no native Protobuf-JSON conversion, relatively high memory footprint"})]}),(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:"merak/rapidjson"}),(0,o.jsx)(i.td,{children:"High performance, full-featured, native Protobuf-JSON conversion"}),(0,o.jsx)(i.td,{children:"SIMD-optimized, dual DOM/SAX parsing modes, memory-efficient, native Protobuf-JSON conversion support, low overhead"}),(0,o.jsx)(i.td,{children:"Scenarios with clear performance requirements, need for Protobuf-JSON conversion, server/client-side applications"}),(0,o.jsx)(i.td,{children:"Slightly complex configuration (e.g., compilation macros), requires familiarity with DOM/SAX APIs"})]}),(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:"cJSON"}),(0,o.jsx)(i.td,{children:"Lightweight, low memory usage, small binary size"}),(0,o.jsx)(i.td,{children:"Implemented in C, zero dependencies, minimal memory footprint, binary size < 100KB"}),(0,o.jsx)(i.td,{children:"Memory/binary size-sensitive scenarios, embedded systems, resource-constrained environments"}),(0,o.jsx)(i.td,{children:"Inconvenient C API, no C++ type safety, no Protobuf-JSON conversion"})]}),(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:"jsoncoin"}),(0,o.jsx)(i.td,{children:"Lightweight cross-platform, C/C++ dual compatibility"}),(0,o.jsx)(i.td,{children:"Lightweight DOM implementation, no redundant dependencies, simple compilation configuration, compatible with legacy C/C++ projects"}),(0,o.jsx)(i.td,{children:"Small-to-medium-sized mixed C/C++ projects, basic JSON serialization/deserialization"}),(0,o.jsx)(i.td,{children:"Single-functionality (no Protobuf-JSON conversion or SIMD optimization), moderate performance, low community activity"})]}),(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:"melon/json"}),(0,o.jsx)(i.td,{children:"High performance in both build and runtime, memory-efficient"}),(0,o.jsx)(i.td,{children:"Open-sourced by ByteDance, server-side optimized, low latency, minimal memory footprint, C++17+ support"}),(0,o.jsx)(i.td,{children:"Performance-sensitive server-side applications, large-scale JSON processing"}),(0,o.jsx)(i.td,{children:"Relatively niche ecosystem, slightly high integration cost, no native Protobuf-JSON conversion"})]}),(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:"simdjson"}),(0,o.jsx)(i.td,{children:"Extreme parsing speed, optimized for ultra-large JSON"}),(0,o.jsx)(i.td,{children:"Pure SIMD instruction acceleration, ultra-high parsing throughput, supports GB-scale JSON"}),(0,o.jsx)(i.td,{children:"Read-only scenarios requiring ultra-fast JSON parsing (e.g., log analysis)"}),(0,o.jsx)(i.td,{children:"Weak JSON generation capability, no native Protobuf-JSON conversion, relatively single functionality"})]})]})]}),"\n",(0,o.jsx)(i.h2,{id:"ii-revised--optimized-quick-selection-guide",children:"II. Revised & Optimized Quick Selection Guide"}),"\n",(0,o.jsx)(i.p,{children:'Based on your clarification of "jsoncoin" (instead of jsoncpp), detailed supplements are provided below to ensure precise library selection:'}),"\n",(0,o.jsx)(i.h3,{id:"1-prioritize-nlohmann-json",children:"1. Prioritize nlohmann-json"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Applicable Scenarios"}),": Business logic-first development, non-critical performance requirements, high development efficiency, no need for Protobuf-JSON conversion."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Rationale"}),": Header-only library that can be used directly with ",(0,o.jsx)(i.code,{children:"#include"}),". It features an intuitive API (e.g., ",(0,o.jsx)(i.code,{children:'json j = {"key": "value"}'}),"), is debugging-friendly, has an active community, and minimizes problem-solving costs."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Note"}),": Not suitable for ultra-large JSON (e.g., 100MB+) or high-frequency JSON processing scenarios."]}),"\n"]}),"\n",(0,o.jsx)(i.h3,{id:"2-must-choose-merakrapidjson",children:"2. Must Choose merak/rapidjson"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Applicable Scenarios"}),": Need for Protobuf-JSON conversion, high performance requirements, memory constraints, need for flexible control over parsing/generation modes (DOM/SAX)."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Rationale"}),": The only library with native support for bidirectional Protobuf-JSON conversion (no additional encapsulation required). SIMD optimization delivers parsing speed close to simdjson, while also supporting complete JSON generation and modification functions, balancing performance and flexibility."]}),"\n"]}),"\n",(0,o.jsx)(i.h3,{id:"3-choose-simdjson",children:"3. Choose simdjson"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Applicable Scenarios"}),": Need for ultra-fast JSON parsing (read-only), processing GB-scale ultra-large JSON (e.g., log analysis, data import)."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Rationale"}),': Industry-leading parsing speed (10%-30% faster than Merak), but focuses solely on "parsing". Functions such as JSON generation and Protobuf-JSON conversion need to be implemented manually, making it suitable for "parsing-first" single scenarios.']}),"\n"]}),"\n",(0,o.jsx)(i.h3,{id:"4-choose-melonjson",children:"4. Choose melon/json"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Applicable Scenarios"}),": High-concurrency server-side applications with performance sensitivity, requiring optimized build and runtime latency."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Rationale"}),": Optimized by ByteDance for server-side scenarios, it offers fast build speeds (no redundant dependencies), stable runtime latency, and minimal memory footprint, making it ideal for high-concurrency services (e.g., API gateways, microservices)."]}),"\n"]}),"\n",(0,o.jsx)(i.h3,{id:"5-choose-cjson",children:"5. Choose cJSON"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Applicable Scenarios"}),": Pure C projects, embedded devices, resource-constrained environments with strict memory limits."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Rationale"}),": Implemented in C with zero dependencies, it compiles to an extremely small binary size and has controllable memory usage. However, its API requires manual memory management (e.g., creating/releasing nodes). It needs additional encapsulation for use in C++ projects and lacks type safety."]}),"\n"]}),"\n",(0,o.jsx)(i.h3,{id:"6-choose-jsoncoin-cautiously",children:"6. Choose jsoncoin Cautiously"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Applicable Scenarios"}),": Maintenance of legacy mixed C/C++ projects, need for only basic JSON serialization/deserialization, strict restrictions on third-party library dependencies."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Rationale"}),": Lightweight and cross-compatible with C/C++, it minimizes adaptation costs for legacy projects. However, it has single functionality, no performance optimization or expansion capabilities (e.g., Protobuf-JSON conversion), and is not recommended for new projects."]}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"iii-revision-and-supplementary-suggestions-for-the-original-selection-rules",children:"III. Revision and Supplementary Suggestions for the Original Selection Rules"}),"\n",(0,o.jsx)(i.p,{children:"Your core selection logic is generally sound. The following revisions and supplements are made specifically for jsoncoin:"}),"\n",(0,o.jsx)(i.h3,{id:"1-core-rules-revised",children:"1. Core Rules (Revised)"}),"\n",(0,o.jsxs)(i.table,{children:[(0,o.jsx)(i.thead,{children:(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.th,{children:"Business Requirement"}),(0,o.jsx)(i.th,{children:"Recommended Library"}),(0,o.jsx)(i.th,{children:"Supplementary Notes"})]})}),(0,o.jsxs)(i.tbody,{children:[(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:"Non-critical performance, ease of use first"}),(0,o.jsx)(i.td,{children:"nlohmann-json"}),(0,o.jsx)(i.td,{children:"First choice for new projects; maximizes development efficiency without low-level details"})]}),(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:"Need for Protobuf-JSON conversion"}),(0,o.jsx)(i.td,{children:"merak/rapidjson"}),(0,o.jsx)(i.td,{children:"Only library with native support; no additional encapsulation required, balancing performance and functionality"})]}),(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:"Extremely high parsing speed (read-only)"}),(0,o.jsx)(i.td,{children:"merak/rapidjson + simdjson"}),(0,o.jsx)(i.td,{children:"Use simdjson for simple scenarios; use merak for full-featured needs (parsing + generation + modification)"})]}),(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:"High performance sensitivity in both build and runtime"}),(0,o.jsx)(i.td,{children:"melon/json or merak/rapidjson"}),(0,o.jsx)(i.td,{children:"melon/json is compatible with ByteDance's tech stack; merak has a more universal ecosystem"})]}),(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:"Extreme sensitivity to memory/binary size"}),(0,o.jsx)(i.td,{children:"cJSON"}),(0,o.jsx)(i.td,{children:"Priority for pure C/embedded scenarios; prefer merak (with memory pool optimization) for C++ scenarios"})]}),(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:"Maintenance of legacy mixed C/C++ projects"}),(0,o.jsx)(i.td,{children:"jsoncoin"}),(0,o.jsx)(i.td,{children:"Not recommended for new projects; only for legacy project compatibility"})]})]})]}),"\n",(0,o.jsx)(i.h3,{id:"2-key-details-to-revise-in-the-original-rules",children:"2. Key Details to Revise in the Original Rules"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Revision 1"}),': The original "jsoncon" refers to "jsoncoin". This library has no outstanding advantages and is only suitable for maintaining legacy mixed C/C++ projects. It is not a priority for new projects, and its positioning as "compatibility-first, single-functionality" should be clarified.']}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Revision 2"}),': Supplement to the original rule "Use merak/simdjson for high parsing speed requirements": simdjson is only suitable for "read-only parsing". If JSON generation, modification, or Protobuf-JSON conversion are required, merak should still be the priority even with high parsing speed requirements.']}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Revision 3"}),': Supplement to the original rule "Use cJSON for memory-sensitive scenarios": For memory-sensitive C++ scenarios, prefer merak (configured with memory pool + in-situ parsing) instead of directly choosing cJSON (which has low development efficiency with C APIs). Only use cJSON for pure C/embedded scenarios.']}),"\n"]}),"\n",(0,o.jsx)(i.h3,{id:"3-additional-notes-for-jsoncoin",children:"3. Additional Notes (for jsoncoin)"}),"\n",(0,o.jsxs)(i.p,{children:["As a niche lightweight library, jsoncoin lacks active community maintenance, performance optimization, and expansion functions (e.g., Protobuf-JSON conversion). ",(0,o.jsx)(i.strong,{children:"It is absolutely not recommended for new projects"})," and should only be used for minimal adaptation of legacy projects. If legacy projects need to upgrade performance/functionality, migration to merak or nlohmann-json is recommended."]}),"\n",(0,o.jsx)(i.h2,{id:"final-simplified-selection-process",children:"Final Simplified Selection Process"}),"\n",(0,o.jsxs)(i.ol,{children:["\n",(0,o.jsxs)(i.li,{children:["New project + non-critical business performance + ease of use first \u2192 ",(0,o.jsx)(i.strong,{children:"nlohmann-json"})]}),"\n",(0,o.jsxs)(i.li,{children:["Need for Protobuf-JSON conversion \u2192 ",(0,o.jsx)(i.strong,{children:"merak/rapidjson (mandatory)"})]}),"\n",(0,o.jsxs)(i.li,{children:["Read-only parsing + ultra-large JSON \u2192 ",(0,o.jsx)(i.strong,{children:"simdjson"})]}),"\n",(0,o.jsxs)(i.li,{children:["High-concurrency server-side + high performance sensitivity in both build and runtime \u2192 ",(0,o.jsx)(i.strong,{children:"melon/json (ByteDance stack) / merak (universal stack)"})]}),"\n",(0,o.jsxs)(i.li,{children:["Pure C/embedded + extremely resource-constrained \u2192 ",(0,o.jsx)(i.strong,{children:"cJSON"})]}),"\n",(0,o.jsxs)(i.li,{children:["Maintenance of legacy mixed C/C++ projects \u2192 ",(0,o.jsx)(i.strong,{children:"jsoncoin (compatibility-only scenarios)"})]}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,o.jsx)(i,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>t,x:()=>l});var s=n(6540);const o={},r=s.createContext(o);function t(e){const i=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),s.createElement(r.Provider,{value:i},e.children)}}}]);