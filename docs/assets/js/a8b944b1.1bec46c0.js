"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[6848],{644:(e,r,i)=>{i.r(r),i.d(r,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>d,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"rpc/index","title":"RPC Overview","description":"This section provides an overview of RPC frameworks relevant to Kumo systems. The focus is scene-driven selection rather than deep protocol analysis. Each framework is compared along three dimensions: ecosystem & usage scenario, performance, and integration & operational complexity.","source":"@site/docs/rpc/index.md","sourceDirName":"rpc","slug":"/rpc/","permalink":"/cppdev/docs/rpc/","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Protobuf-JSON conversion","permalink":"/cppdev/docs/foundamentals/json/protobuf"},"next":{"title":"gRPC","permalink":"/cppdev/docs/rpc/grpc"}}');var t=i(4848),n=i(8453);const d={},c="RPC Overview",l={},a=[{value:"Ecosystem &amp; Usage Scenarios",id:"ecosystem--usage-scenarios",level:2},{value:"Performance Metrics",id:"performance-metrics",level:2},{value:"Integration &amp; Operational Complexity",id:"integration--operational-complexity",level:2},{value:"Summary",id:"summary",level:2}];function o(e){const r={code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,n.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.header,{children:(0,t.jsx)(r.h1,{id:"rpc-overview",children:"RPC Overview"})}),"\n",(0,t.jsx)(r.p,{children:"This section provides an overview of RPC frameworks relevant to Kumo systems. The focus is scene-driven selection rather than deep protocol analysis. Each framework is compared along three dimensions: ecosystem & usage scenario, performance, and integration & operational complexity."}),"\n",(0,t.jsx)(r.p,{children:"The goal is to guide quick selection based on practical business or backend needs. High QPS claims should be treated cautiously, as typical server CPU load constraints and single-thread limitations make extreme values unrealistic."}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsx)(r.h2,{id:"ecosystem--usage-scenarios",children:"Ecosystem & Usage Scenarios"}),"\n",(0,t.jsxs)(r.table,{children:[(0,t.jsx)(r.thead,{children:(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.th,{children:"Framework"}),(0,t.jsx)(r.th,{children:"Layer"}),(0,t.jsx)(r.th,{children:"Strengths"}),(0,t.jsx)(r.th,{children:"Typical Usage / Scenario"})]})}),(0,t.jsxs)(r.tbody,{children:[(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"gRPC"}),(0,t.jsx)(r.td,{children:"Business"}),(0,t.jsx)(r.td,{children:"Multi-language ecosystem, widely adopted"}),(0,t.jsx)(r.td,{children:"Business layer, pipeline orchestration, multi-language clients"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"httplib"}),(0,t.jsx)(r.td,{children:"Business"}),(0,t.jsx)(r.td,{children:"Header-only, lightweight"}),(0,t.jsx)(r.td,{children:"Quick prototyping, temporary services, validation"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"brpc"}),(0,t.jsx)(r.td,{children:"Backend"}),(0,t.jsx)(r.td,{children:"Mature, high throughput, Raft-compatible"}),(0,t.jsx)(r.td,{children:"Backend services, Raft consensus, high reliability"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"krpc"}),(0,t.jsx)(r.td,{children:"Backend"}),(0,t.jsx)(r.td,{children:"Kumo-enhanced brpc, better ops"}),(0,t.jsx)(r.td,{children:"Internal backend preferred choice"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"ACL"}),(0,t.jsx)(r.td,{children:"Backend"}),(0,t.jsx)(r.td,{children:"High-quality C++ library"}),(0,t.jsx)(r.td,{children:"High-performance backend services, IO-intensive tasks"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Thrift"}),(0,t.jsx)(r.td,{children:"Legacy"}),(0,t.jsx)(r.td,{children:"Moderate performance"}),(0,t.jsx)(r.td,{children:"Legacy interop, declining ecosystem"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Seastar"}),(0,t.jsx)(r.td,{children:"Extreme IO"}),(0,t.jsx)(r.td,{children:"NUMA-aware, very high throughput"}),(0,t.jsx)(r.td,{children:"Extreme IO services, dedicated ops required"})]})]})]}),"\n",(0,t.jsx)(r.p,{children:"Business layer favors gRPC for multi-language integration and pipeline control. Backend layer favors brpc/krpc for throughput and operational reliability. Extreme IO frameworks like Seastar require specialized environments."}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsx)(r.h2,{id:"performance-metrics",children:"Performance Metrics"}),"\n",(0,t.jsxs)(r.table,{children:[(0,t.jsx)(r.thead,{children:(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.th,{children:"Framework"}),(0,t.jsx)(r.th,{children:"Typical QPS per Server"}),(0,t.jsx)(r.th,{children:"CPU Load"}),(0,t.jsx)(r.th,{children:"Notes"})]})}),(0,t.jsxs)(r.tbody,{children:[(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"gRPC"}),(0,t.jsx)(r.td,{children:"3k\u201310k"}),(0,t.jsx)(r.td,{children:"30\u201350%"}),(0,t.jsx)(r.td,{children:"Suitable for orchestrating pipelines; practical business throughput"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"httplib"}),(0,t.jsx)(r.td,{children:(0,t.jsx)(r.code,{children:"<1k"})}),(0,t.jsx)(r.td,{children:(0,t.jsx)(r.code,{children:"<20%"})}),(0,t.jsx)(r.td,{children:"Lightweight testing or prototyping only"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"brpc"}),(0,t.jsx)(r.td,{children:"10k\u201330k"}),(0,t.jsx)(r.td,{children:"40\u201370%"}),(0,t.jsx)(r.td,{children:"Required for Raft; operational expertise needed"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"krpc"}),(0,t.jsx)(r.td,{children:"10k\u201330k"}),(0,t.jsx)(r.td,{children:"40\u201370%"}),(0,t.jsx)(r.td,{children:"Optimized brpc with better internal ops"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"ACL"}),(0,t.jsx)(r.td,{children:"10k\u201330k"}),(0,t.jsx)(r.td,{children:"40\u201370%"}),(0,t.jsx)(r.td,{children:"High-quality backend C++ services"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Thrift"}),(0,t.jsx)(r.td,{children:"5k\u201315k"}),(0,t.jsx)(r.td,{children:"40\u201360%"}),(0,t.jsx)(r.td,{children:"Legacy support only"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Seastar"}),(0,t.jsx)(r.td,{children:"50k\u2013100k+ (pure IO)"}),(0,t.jsx)(r.td,{children:"50\u201370%"}),(0,t.jsx)(r.td,{children:"Extreme IO; dedicated ops required"})]})]})]}),"\n",(0,t.jsx)(r.p,{children:'CPU load above 70% is risky. Most claimed "million QPS" values are theoretical. Business layer rarely exceeds 10k QPS per server; backend systems may target 30k QPS. Extreme IO scenarios require dedicated operational expertise.'}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsx)(r.h2,{id:"integration--operational-complexity",children:"Integration & Operational Complexity"}),"\n",(0,t.jsxs)(r.table,{children:[(0,t.jsx)(r.thead,{children:(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.th,{children:"Framework"}),(0,t.jsx)(r.th,{children:"Language Support"}),(0,t.jsx)(r.th,{children:"Integration Difficulty"}),(0,t.jsx)(r.th,{children:"Ops Notes"})]})}),(0,t.jsxs)(r.tbody,{children:[(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"gRPC"}),(0,t.jsx)(r.td,{children:"Multi-language"}),(0,t.jsx)(r.td,{children:"Medium"}),(0,t.jsx)(r.td,{children:"Multiple C++ libraries; kmpkg simplifies integration"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"httplib"}),(0,t.jsx)(r.td,{children:"C++"}),(0,t.jsx)(r.td,{children:"Very Low"}),(0,t.jsx)(r.td,{children:"Header-only, trivial integration"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"brpc"}),(0,t.jsx)(r.td,{children:"C++"}),(0,t.jsx)(r.td,{children:"Medium"}),(0,t.jsx)(r.td,{children:"Requires ops expertise; Raft-compatible"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"krpc"}),(0,t.jsx)(r.td,{children:"C++"}),(0,t.jsx)(r.td,{children:"Medium"}),(0,t.jsx)(r.td,{children:"Kumo-enhanced brpc; easier internal ops"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"ACL"}),(0,t.jsx)(r.td,{children:"C++"}),(0,t.jsx)(r.td,{children:"Low-Medium"}),(0,t.jsx)(r.td,{children:"High-quality library; not ideal for multi-language business layer"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Thrift"}),(0,t.jsx)(r.td,{children:"Multi-language"}),(0,t.jsx)(r.td,{children:"Medium"}),(0,t.jsx)(r.td,{children:"Ecosystem declining; mainly for legacy support"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Seastar"}),(0,t.jsx)(r.td,{children:"C++"}),(0,t.jsx)(r.td,{children:"High"}),(0,t.jsx)(r.td,{children:"Complex ops; NUMA-aware; dedicated environment; high cost"})]})]})]}),"\n",(0,t.jsx)(r.p,{children:"Business layer frameworks prioritize ecosystem integration over raw throughput. Backend frameworks must handle high CPU and throughput reliably. Extreme IO frameworks like Seastar require professional operations for protocol stack management."}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsx)(r.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(r.p,{children:"The RPC ecosystem is diverse. Selection should be scene-driven:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Business layer: Use gRPC for multi-language clients and pipeline orchestration. Lightweight alternatives like httplib are only for rapid prototyping."}),"\n",(0,t.jsx)(r.li,{children:"Backend layer: brpc or krpc provides high throughput, mature operations, and Raft compatibility. ACL can be used for high-performance C++ backend tasks."}),"\n",(0,t.jsx)(r.li,{children:"Extreme IO: Seastar is suitable only for specialized, high-throughput IO services and requires dedicated operational expertise."}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"Because of ecosystem limitations, implementation choices are relatively fixed. For special requirements, custom implementations may be necessary."})]})}function h(e={}){const{wrapper:r}={...(0,n.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},8453:(e,r,i)=>{i.d(r,{R:()=>d,x:()=>c});var s=i(6540);const t={},n=s.createContext(t);function d(e){const r=s.useContext(n);return s.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function c(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),s.createElement(n.Provider,{value:r},e.children)}}}]);