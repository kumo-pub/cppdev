"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[8436],{7921:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"foundamentals/monitor/var","title":"Variables","description":"Introduction","source":"@site/docs/foundamentals/monitor/var.mdx","sourceDirName":"foundamentals/monitor","slug":"/foundamentals/monitor/var","permalink":"/cppdev/docs/foundamentals/monitor/var","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/foundamentals/monitor/var.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Monitoring","permalink":"/cppdev/docs/foundamentals/monitor/"},"next":{"title":"Metrics","permalink":"/cppdev/docs/foundamentals/monitor/metrics"}}');var a=r(4848),s=r(8453);const l={},i="Variables",o={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Thread Safety",id:"thread-safety",level:3},{value:"Variables",id:"variables-1",level:2},{value:"Variable Constraints: tally::Scope",id:"scope",level:3},{value:"Core Variable Class: tally::Variable",id:"core-variable-class-tallyvariable",level:3},{value:"Exporting Variables",id:"exporting-variables",level:2},{value:"Prometheus",id:"prometheus",level:3},{value:"JSON",id:"json",level:3},{value:"tally::Reducer",id:"tallyreducer",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"variables",children:"Variables"})}),"\n",(0,a.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(n.p,{children:"Tally variables are categorized into multiple concrete classes. The commonly used ones are listed below:"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Type"}),(0,a.jsx)(n.th,{children:"Description"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"tally::Counter<T>"})}),(0,a.jsxs)(n.td,{children:["Counter with a default value of 0; ",(0,a.jsx)(n.code,{children:"varname << N"})," is equivalent to ",(0,a.jsx)(n.code,{children:"varname += N"})]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"tally::MaxerGauge<T>"})}),(0,a.jsxs)(n.td,{children:["Maximum value gauge with a default value of ",(0,a.jsx)(n.code,{children:"std::numeric_limits<T>::min()"}),"; ",(0,a.jsx)(n.code,{children:"varname << N"})," is equivalent to ",(0,a.jsx)(n.code,{children:"varname = max(varname, N)"})]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"tally::MinerGauge<T>"})}),(0,a.jsxs)(n.td,{children:["Minimum value gauge with a default value of ",(0,a.jsx)(n.code,{children:"std::numeric_limits<T>::max()"}),"; ",(0,a.jsx)(n.code,{children:"varname << N"})," is equivalent to ",(0,a.jsx)(n.code,{children:"varname = min(varname, N)"})]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"tally::IntRecorder"})}),(0,a.jsxs)(n.td,{children:["Calculates the average value since its first use. Note: the average is ",(0,a.jsx)(n.strong,{children:"not"})," restricted to a time window. To obtain the average within a specific time window, wrap it with ",(0,a.jsx)(n.code,{children:"Window"})," in general."]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"tally::Window<VAR>"})}),(0,a.jsx)(n.td,{children:"Retrieves the accumulated value of a tally over a time window. Derived from an existing tally and updates automatically."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"tally::PerSecond<VAR>"})}),(0,a.jsx)(n.td,{children:"Retrieves the average per-second accumulated value of a tally over a time window. Also a derived variable that updates automatically."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"tally::WindowEx<T>"})}),(0,a.jsx)(n.td,{children:"Retrieves the accumulated value of a tally over a time window. Does not depend on other tallies and requires explicit data input."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"tally::PerSecondEx<T>"})}),(0,a.jsx)(n.td,{children:"Retrieves the average per-second accumulated value of a tally over a time window. Does not depend on other tallies and requires explicit data input."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"tally::LatencyRecorder"})}),(0,a.jsx)(n.td,{children:"Specialized variable for recording latency and QPS. Input latency values to get average latency, max latency, QPS, and total count."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"tally::Status<T>"})}),(0,a.jsxs)(n.td,{children:["Records and displays a value with an additional ",(0,a.jsx)(n.code,{children:"set_value"})," function."]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"tally::FuncGauge"})}),(0,a.jsxs)(n.td,{children:["Displays values on demand. In scenarios where ",(0,a.jsx)(n.code,{children:"set_value"})," cannot be invoked or its invocation frequency is unknown, it is more appropriate to retrieve and display values only when needed. Users implement this by passing a callback function for value retrieval."]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"tally::Flag"})}),(0,a.jsxs)(n.td,{children:["Exposes critical ",(0,a.jsx)(n.code,{children:"turbo::Flags"})," as tallies for monitoring purposes."]})]})]})]}),"\n",(0,a.jsx)(n.p,{children:"Example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c++",children:'#include <tally/tally.h>\n\nnamespace foo {\nnamespace bar {\n\n// tally::Counter<T> is for accumulation; the following defines a Counter to count total read errors\ntally::Counter<int> g_read_error;\n// Wrap a Window around another tally to get its value within a time window\ntally::Window<tally::Counter<int> > g_read_error_minute("foo_bar", "read_error_minute", &g_read_error, 60);\n//                                                     ^          ^                         ^\n//                                                    Metric Name  Metric Description        60 seconds (10 seconds if omitted)\n\n// tally::LatencyRecorder is a composite variable that can count: total count, QPS, average latency, latency percentiles, max latency\ntally::LatencyRecorder g_write_latency("foo_bar_write", "write latency");\n//                                      ^               ^ Metric Description\n//                                     Metric Name (DO NOT add "latency" suffix! LatencyRecorder contains multiple tallies that append their own suffixes like write_qps, write_latency, etc.)\n\n// Define a variable to count the number of pushed tasks\ntally::Counter<int> g_task_pushed("foo_bar", "task_pushed");\n// Wrap a PerSecond around another tally to get its average per-second value within a time window (tasks pushed per second here)\ntally::PerSecond<tally::Counter<int> > g_task_pushed_second("foo_bar", "task pushed second", &g_task_pushed);\n//       ^                                                                                             ^\n//    Unlike Window, PerSecond divides the value by the time window size.                              Time window (last parameter; defaults to 10 seconds if omitted)\n\n}  // namespace bar\n}  // namespace foo\n'})}),"\n",(0,a.jsx)(n.p,{children:"Usage in application code:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c++",children:"// Triggered on a read error\nfoo::bar::g_read_error << 1;\n\n// Write latency is 23ms\nfoo::bar::g_write_latency << 23;\n\n// Pushed 1 task\nfoo::bar::g_task_pushed << 1;\n"})}),"\n",(0,a.jsxs)(n.admonition,{type:"info",children:[(0,a.jsxs)(n.p,{children:["Note that ",(0,a.jsx)(n.code,{children:"Window<>"})," and ",(0,a.jsx)(n.code,{children:"PerSecond<>"})," are derived variables that update automatically\u2014",(0,a.jsx)(n.strong,{children:"do not push values to them"}),". You can also use tallies as member variables or local variables."]}),(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Ensure variable names are globally unique!"})," Otherwise, exposure will fail. If the ",(0,a.jsx)(n.code,{children:"-tally_abort_on_same_name"})," flag is set to ",(0,a.jsx)(n.code,{children:"true"}),", the program will abort immediately."]}),(0,a.jsxs)(n.p,{children:["A program may contain tallies from various modules. To avoid name conflicts, we recommend the naming convention: ",(0,a.jsx)(n.strong,{children:"module_classname_metric"})]}),(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Module"}),": Generally the program name, optionally prefixed with a product line abbreviation (e.g., inf_ds, ecom_retrbs)."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Classname"}),": Generally the class or function name (e.g., storage_manager, file_transfer, rank_stage1)."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Metric"}),": Generally terms like count, qps, latency."]}),"\n"]})]}),"\n",(0,a.jsx)(n.p,{children:"Examples of valid naming:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"iobuf_block_count : 29                          # Module=iobuf   Classname=block  Metric=count\niobuf_block_memory : 237568                     # Module=iobuf   Classname=block  Metric=memory\nprocess_memory_resident : 34709504              # Module=process Classname=memory Metric=resident\nprocess_memory_shared : 6844416                 # Module=process Classname=memory Metric=shared\nrpc_channel_connection_count : 0                # Module=rpc     Classname=channel_connection  Metric=count\nrpc_controller_count : 1                        # Module=rpc     Classname=controller Metric=count\nrpc_socket_count : 6                            # Module=rpc     Classname=socket     Metric=count\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Tally performs automatic name normalization: regardless of input formats like ",(0,a.jsx)(n.code,{children:"foo::BarNum"}),", ",(0,a.jsx)(n.code,{children:"foo.bar.num"}),", ",(0,a.jsx)(n.code,{children:"foo bar num"}),", or ",(0,a.jsx)(n.code,{children:"foo-bar-num"}),", the final name will be ",(0,a.jsx)(n.code,{children:"foo_bar_num"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Metric Naming Rules:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Use the ",(0,a.jsx)(n.code,{children:"_count"})," suffix for counts (e.g., ",(0,a.jsx)(n.code,{children:"request_count"}),", ",(0,a.jsx)(n.code,{children:"error_count"}),")."]}),"\n",(0,a.jsxs)(n.li,{children:["Use the ",(0,a.jsx)(n.code,{children:"_second"})," suffix for per-second counts (e.g., ",(0,a.jsx)(n.code,{children:"request_second"}),", ",(0,a.jsx)(n.code,{children:"process_inblocks_second"}),"). This is sufficiently clear\u2014avoid redundant suffixes like ",(0,a.jsx)(n.code,{children:"_count_second"})," or ",(0,a.jsx)(n.code,{children:"_per_second"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Use the ",(0,a.jsx)(n.code,{children:"_minute"})," suffix for per-minute counts (e.g., ",(0,a.jsx)(n.code,{children:"request_minute"}),", ",(0,a.jsx)(n.code,{children:"process_inblocks_minute"}),")."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"To use a counter defined in another file, declare the corresponding variable in a header file:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c++",children:"namespace foo {\nnamespace bar {\n// Note: g_read_error_minute and g_task_pushed_second are derived tallies that update automatically\u2014do NOT declare them.\nextern tally::Counter<int> g_read_error;\nextern tally::LatencyRecorder g_write_latency;\nextern tally::Counter<int> g_task_pushed;\n}  // namespace bar\n}  // namespace foo\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsxs)(n.strong,{children:["Do NOT define global ",(0,a.jsx)(n.code,{children:"Window"})," or ",(0,a.jsx)(n.code,{children:"PerSecond"})," across files."]})," The initialization order of global variables in different compilation units is ",(0,a.jsx)(n.a,{href:"https://isocpp.org/wiki/faq/ctors#static-init-order",children:"undefined"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Defining ",(0,a.jsx)(n.code,{children:"Counter<int> foo_count"})," in ",(0,a.jsx)(n.code,{children:"foo.cpp"})," and ",(0,a.jsx)(n.code,{children:"PerSecond<Counter<int> > foo_qps(&foo_count);"})," in ",(0,a.jsx)(n.code,{children:"foo_qps.cpp"})," is ",(0,a.jsx)(n.strong,{children:"incorrect"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"thread-safety",children:"Thread Safety"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Tally is ",(0,a.jsx)(n.strong,{children:"thread-compatible"}),": You can operate different tallies in different threads. For example, you can safely ",(0,a.jsx)(n.code,{children:"expose"})," or ",(0,a.jsx)(n.code,{children:"hide"})," ",(0,a.jsx)(n.strong,{children:"different"})," tallies in multiple threads\u2014they will operate shared global data properly."]}),"\n",(0,a.jsxs)(n.li,{children:["All tally functions ",(0,a.jsx)(n.strong,{children:"except read/write interfaces"})," are ",(0,a.jsx)(n.strong,{children:"not thread-safe"}),": For example, do not ",(0,a.jsx)(n.code,{children:"expose"})," or ",(0,a.jsx)(n.code,{children:"hide"})," the ",(0,a.jsx)(n.strong,{children:"same"})," tally in multiple threads, as this may cause program crashes. In general, there is no need to execute non-read/write interfaces concurrently across threads."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["For timing operations, use ",(0,a.jsx)(n.code,{children:"turbo::TimeCost"})," (interface below):"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c++",children:"#include <kutil/time.h>\nnamespace turbo {\nclass TimeCost {\npublic:\n\n    TimeCost();\n\n    explicit TimeCost();\n\n    // Start the timer\n    void reset();\n\n    // Stop the timer\n    void stop();\n\n    // Get the elapsed time from reset() to stop()\n    int64_t n_elapsed() const;  // in nanoseconds\n    int64_t u_elapsed() const;  // in microseconds\n    int64_t m_elapsed() const;  // in milliseconds\n    int64_t s_elapsed() const;  // in seconds\n};\n}  // namespace kutil\n"})}),"\n",(0,a.jsx)(n.h2,{id:"variables-1",children:"Variables"}),"\n",(0,a.jsx)(n.h3,{id:"scope",children:"Variable Constraints: tally::Scope"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"tally::Scope"})," serves as a scope constraint for all ",(0,a.jsx)(n.code,{children:"tally::Variable"})," instances, limiting the ",(0,a.jsx)(n.code,{children:"prefix"})," and ",(0,a.jsx)(n.code,{children:"tag"})," of ",(0,a.jsx)(n.code,{children:"tally::Variable"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Each ",(0,a.jsx)(n.code,{children:"tally::Variable"})," belongs to a unique ",(0,a.jsx)(n.code,{children:"Scope"}),". By default, it uses the global scope provided by ",(0,a.jsx)(n.code,{children:"ScopeInstance::get_sys_scope"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"core-variable-class-tallyvariable",children:"Core Variable Class: tally::Variable"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"Variable"})," is the base class for all tallies, primarily providing global registration, enumeration, query, and other core functions."]}),"\n",(0,a.jsxs)(n.p,{children:["When a tally is created with default parameters, it is ",(0,a.jsx)(n.strong,{children:"not"}),' registered in any global structure\u2014in this case, the tally functions purely as a high-performance counter. Registering a tally in the global table is called "exposure", which can be done via the ',(0,a.jsx)(n.code,{children:"expose"})," function:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c++",children:"// Expose this variable globally so that it can be accessed via the following functions:\n//   list_exposed\n//   count_exposed\n//   describe_exposed\n//   find_exposed\n// Return 0 on success, -1 on failure.\nturbo::Status expose(std::string_view name, std::string_view help, Scope *scope = nullptr);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The name of a globally exposed tally is either ",(0,a.jsx)(n.code,{children:"name"})," or ",(0,a.jsx)(n.code,{children:"scope_id + name"}),". You can query exposed tallies using static functions suffixed with ",(0,a.jsx)(n.code,{children:"_exposed"})," (e.g., ",(0,a.jsx)(n.code,{children:"Variable::describe_exposed(name)"})," returns the description of the tally with the specified name)."]}),"\n",(0,a.jsxs)(n.p,{children:["If a tally with the same name already exists, ",(0,a.jsx)(n.code,{children:"expose"})," will print a FATAL log and return ",(0,a.jsx)(n.code,{children:"-1"}),". If the ",(0,a.jsx)(n.code,{children:"-tally_abort_on_same_name"})," flag is set to ",(0,a.jsx)(n.code,{children:"true"})," (default: ",(0,a.jsx)(n.code,{children:"false"}),"), the program will abort immediately."]}),"\n",(0,a.jsx)(n.p,{children:"Examples of exposing tallies:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c++",children:'tally::Counter<int> count1;\n// Values sum up to 60\ncount1 << 10 << 20 << 30;\n// Expose the variable globally\ncount1.expose("count1","help");\nauto f_name = count1.full_name();\nCHECK_EQ("60", tally::Variable::describe_exposed(f_name));\n// Expose the variable with a different name\ncount1.expose("another_name_for_count1","help");\nauto new_f_name = count1.full_name();\nCHECK_EQ("", tally::Variable::describe_exposed(f_name));\nCHECK_EQ("60", tally::Variable::describe_exposed(new_f_name));\n// Expose directly via the constructor\ntally::Counter<int> count2("count2");\nf_name = count2.full_name();\n// Default value of Counter<int> is 0\nCHECK_EQ("0", tally::Variable::describe_exposed(f_name));\n\n// Name conflict: if -tally_abort_on_same_name is true,\n// the program aborts; otherwise, a FATAL log is printed\ntally::Status<std::string> status1("count2", "hello");\n'})}),"\n",(0,a.jsx)(n.h2,{id:"exporting-variables",children:"Exporting Variables"}),"\n",(0,a.jsxs)(n.p,{children:["The base class for variable export interfaces is ",(0,a.jsx)(n.code,{children:"tally::StatsReporter"}),". All export methods must inherit from ",(0,a.jsx)(n.code,{children:"tally::StatsReporter"}),". Tally provides built-in serialization support for ",(0,a.jsx)(n.code,{children:"Prometheus"})," and ",(0,a.jsx)(n.code,{children:"JSON"})," by default."]}),"\n",(0,a.jsx)(n.h3,{id:"prometheus",children:"Prometheus"}),"\n",(0,a.jsxs)(n.p,{children:["Note: ",(0,a.jsx)(n.code,{children:"PrometheusStatsReporter"})," can only export monitoring metrics\u2014non-metric variables are not supported."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"std::stringstream ss;\ntally::PrometheusStatsReporter reporter(ss);\ntally::Variable::report(&reporter, now);\nreporter.flush();\n"})}),"\n",(0,a.jsx)(n.h3,{id:"json",children:"JSON"}),"\n",(0,a.jsxs)(n.p,{children:["Note: ",(0,a.jsx)(n.code,{children:"JsonStatsReporter"})," can export all types of variables."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"nlohmann::ordered_json result;\nauto json_reporter = tally::JsonStatsReporter(result);\ntally::Variable::report(&json_reporter, now);\njson_reporter.flush();\n"})}),"\n",(0,a.jsx)(n.h2,{id:"tallyreducer",children:"tally::Reducer"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"Reducer"})," combines multiple values into a single value using a binary operator. The operator must satisfy the ",(0,a.jsx)(n.strong,{children:"associative law"}),", ",(0,a.jsx)(n.strong,{children:"commutative law"}),", and have ",(0,a.jsx)(n.strong,{children:"no side effects"}),". Only when these three conditions are met can we ensure the merged result is not affected by the distribution of thread-private data. For example, subtraction does not satisfy the associative and commutative laws, so it cannot be used here."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c++",children:"// Reduce multiple values into one with `Op': e1 Op e2 Op e3 ...\n// `Op' shall satisfy:\n//   - associative:     a Op (b Op c) == (a Op b) Op c\n//   - commutative:     a Op b == b Op a;\n//   - no side effects: a Op b never changes if a and b are fixed.\n// otherwise the result is undefined.\ntemplate <typename T, typename Op>\nclass Reducer : public Variable;\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"reducer << e1 << e2 << e3"})," is equivalent to ",(0,a.jsx)(n.code,{children:"reducer = e1 op e2 op e3"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Common subclasses of ",(0,a.jsx)(n.code,{children:"Reducer"})," for metrics include ",(0,a.jsx)(n.code,{children:"tally::Counter"}),", ",(0,a.jsx)(n.code,{children:"tally::MaxerGauge"}),", ",(0,a.jsx)(n.code,{children:"tally::MinerGauge"}),", etc."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>i});var t=r(6540);const a={},s=t.createContext(a);function l(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);