"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[4727],{4658:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>d,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"foundamentals/compress/melon","title":"Usage Summary of melon compression Module","description":"I. Supported Compression Algorithms and Features","source":"@site/docs/foundamentals/compress/melon.md","sourceDirName":"foundamentals/compress","slug":"/foundamentals/compress/melon","permalink":"/cppdev/docs/foundamentals/compress/melon","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/foundamentals/compress/melon.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Comprehensive Guide to Compression Technologies","permalink":"/cppdev/docs/foundamentals/compress/"},"next":{"title":"Fiber Pattern Selection: A Multi-threaded Contention Perspective (Supplemented with Memory Contention Management Costs)","permalink":"/cppdev/docs/foundamentals/fibers/"}}');var r=n(4848),t=n(8453);const i={},d="Usage Summary of melon compression Module",c={},l=[{value:"I. Supported Compression Algorithms and Features",id:"i-supported-compression-algorithms-and-features",level:2},{value:"II. Core Interfaces and Usage Methods",id:"ii-core-interfaces-and-usage-methods",level:2},{value:"1. Basic Compression/Decompression (<code>Codec</code> Class)",id:"1-basic-compressiondecompression-codec-class",level:3},{value:"2. Stream Compression/Decompression (<code>StreamCodec</code> Class)",id:"2-stream-compressiondecompression-streamcodec-class",level:3},{value:"III. Key Auxiliary Functions",id:"iii-key-auxiliary-functions",level:2},{value:"IV. Notes",id:"iv-notes",level:2}];function a(e){const s={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"usage-summary-of-melon-compression-module",children:"Usage Summary of melon compression Module"})}),"\n",(0,r.jsx)(s.h2,{id:"i-supported-compression-algorithms-and-features",children:"I. Supported Compression Algorithms and Features"}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"CodecType"})," enumeration defines 12 compression algorithms, with core features as follows:"]}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"Algorithm Type"}),(0,r.jsx)(s.th,{children:"Compression Level Range"}),(0,r.jsx)(s.th,{children:"Default Level"}),(0,r.jsx)(s.th,{children:"Special Notes"})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"NO_COMPRESSION"})}),(0,r.jsx)(s.td,{children:"Level 0 only"}),(0,r.jsx)(s.td,{children:"0"}),(0,r.jsx)(s.td,{children:"No compression applied"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"LZ4"})}),(0,r.jsx)(s.td,{children:"1 (fast), 2 (optimal)"}),(0,r.jsx)(s.td,{children:"1"}),(0,r.jsx)(s.td,{children:"Max supports 1.9GiB uncompressed data"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"SNAPPY"})}),(0,r.jsx)(s.td,{children:"Level 1 only"}),(0,r.jsx)(s.td,{children:"1"}),(0,r.jsx)(s.td,{children:"Max supports 4GiB uncompressed data"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"ZLIB"})}),(0,r.jsx)(s.td,{children:"0\u20139 (0 = no compression, 9 = optimal)"}),(0,r.jsx)(s.td,{children:"6"}),(0,r.jsx)(s.td,{children:"Supports stream compression, no length limit"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"ZSTD"})}),(0,r.jsx)(s.td,{children:"1\u201319 (1 = fast, 19 = optimal)"}),(0,r.jsx)(s.td,{children:"3"}),(0,r.jsx)(s.td,{children:"Supports stream compression"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"ZSTD_FAST"})}),(0,r.jsx)(s.td,{children:"1\u20135 (1 = relatively optimal, 5 = fastest)"}),(0,r.jsx)(s.td,{children:"1"}),(0,r.jsx)(s.td,{children:"Compatible with ZSTD, faster decompression speed"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"GZIP"})}),(0,r.jsx)(s.td,{children:"0\u20139"}),(0,r.jsx)(s.td,{children:"6"}),(0,r.jsx)(s.td,{children:"Same algorithm as ZLIB, compatible with gzip tool, supports stream compression"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"BZIP2"})}),(0,r.jsx)(s.td,{children:"1\u20139"}),(0,r.jsx)(s.td,{children:"9"}),(0,r.jsxs)(s.td,{children:["Supports stream compression, but the ",(0,r.jsx)(s.code,{children:"FLUSH"})," operation does not guarantee full readability"]})]})]})]}),"\n",(0,r.jsx)(s.h2,{id:"ii-core-interfaces-and-usage-methods",children:"II. Core Interfaces and Usage Methods"}),"\n",(0,r.jsxs)(s.h3,{id:"1-basic-compressiondecompression-codec-class",children:["1. Basic Compression/Decompression (",(0,r.jsx)(s.code,{children:"Codec"})," Class)"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Create Codec Instance"}),": Obtain instances via ",(0,r.jsx)(s.code,{children:"getCodec(CodecType type, int level)"}),". Levels support ",(0,r.jsx)(s.code,{children:"COMPRESSION_LEVEL_FASTEST"})," (fastest speed), ",(0,r.jsx)(s.code,{children:"COMPRESSION_LEVEL_DEFAULT"})," (default configuration), and ",(0,r.jsx)(s.code,{children:"COMPRESSION_LEVEL_BEST"})," (optimal compression ratio)."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"auto zstdCodec = melon::compression::getCodec(melon::compression::CodecType::ZSTD);\nauto lz4Codec = melon::compression::getCodec(melon::compression::CodecType::LZ4, melon::compression::COMPRESSION_LEVEL_FASTEST);\n"})}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Compression Operation"}),": Supports both ",(0,r.jsx)(s.code,{children:"IOBuf"})," and string input"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:'// Compress string\nstd::string original = "test data";\nstd::string compressed = zstdCodec->compress(original);\n\n// Compress IOBuf\nauto data = melon::IOBuf::copyBuffer(original);\nstd::unique_ptr<melon::IOBuf> compressedBuf = zstdCodec->compress(data.get());\n'})}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Decompression Operation"}),": Some algorithms (e.g., LZ4) require specifying the uncompressed length"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"// Decompress string\nstd::string decompressed = zstdCodec->uncompress(compressed);\n\n// Decompress IOBuf (when uncompressed length is required)\nauto decompressedBuf = lz4Codec->uncompress(compressedBuf.get(), original.size());\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.h3,{id:"2-stream-compressiondecompression-streamcodec-class",children:["2. Stream Compression/Decompression (",(0,r.jsx)(s.code,{children:"StreamCodec"})," Class)"]}),"\n",(0,r.jsxs)(s.p,{children:["Suitable for chunked processing of large data. Create instances via ",(0,r.jsx)(s.code,{children:"getStreamCodec"}),", with core methods:"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"resetStream()"}),": Reset the codec state to start a new stream processing task"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"compressStream()"}),"/",(0,r.jsx)(s.code,{children:"uncompressStream()"}),": Process data in chunks"]}),"\n",(0,r.jsxs)(s.li,{children:["Supports ",(0,r.jsx)(s.code,{children:"FlushOp"})," control (",(0,r.jsx)(s.code,{children:"NONE"}),"/",(0,r.jsx)(s.code,{children:"FLUSH"}),"/",(0,r.jsx)(s.code,{children:"END"}),")"]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"Example:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"auto streamCodec = melon::compression::getStreamCodec(melon::compression::CodecType::ZLIB);\nstreamCodec->resetStream(original.size()); // Uncompressed length is known\n\nmelon::ByteRange input(reinterpret_cast<const uint8_t*>(original.data()), original.size());\nstd::vector<uint8_t> outputBuf(original.size() * 2);\nmelon::MutableByteRange output(outputBuf.data(), outputBuf.size());\n\n// Stream compression\nbool done = false;\nwhile (!done) {\n  done = streamCodec->compressStream(input, output, melon::compression::StreamCodec::FlushOp::END);\n}\n"})}),"\n",(0,r.jsx)(s.h2,{id:"iii-key-auxiliary-functions",children:"III. Key Auxiliary Functions"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Auto-Decompression Codec"}),": ",(0,r.jsx)(s.code,{children:"getAutoUncompressionCodec"})," creates a decoder that automatically identifies multiple algorithms, attempting decompression in sequence"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"auto autoCodec = melon::compression::getAutoUncompressionCodec();\nstd::string decompressed = autoCodec->uncompress(unknownCompressedData);\n"})}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Algorithm Support Check"}),": ",(0,r.jsx)(s.code,{children:"hasCodec(type)"})," and ",(0,r.jsx)(s.code,{children:"hasStreamCodec(type)"})," determine whether a specified algorithm is supported"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Length-Related Methods"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"maxUncompressedLength()"}),": Get the maximum supported uncompressed data length for the algorithm"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"maxCompressedLength(len)"}),": Estimate the maximum compressed length for input data of length ",(0,r.jsx)(s.code,{children:"len"})]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"needsUncompressedLength()"}),": Check if the decompression operation requires specifying the original data length"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"iv-notes",children:"IV. Notes"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Compression levels only affect compression speed and ratio, without impacting decompression compatibility"}),"\n",(0,r.jsxs)(s.li,{children:["Stream processing must follow strict stateful calling sequences (",(0,r.jsx)(s.code,{children:"resetStream"})," \u2192 loop ",(0,r.jsx)(s.code,{children:"compressStream"}),"/",(0,r.jsx)(s.code,{children:"uncompressStream"})," \u2192 call ",(0,r.jsx)(s.code,{children:"resetStream"})," again before reuse)"]}),"\n",(0,r.jsxs)(s.li,{children:["The ",(0,r.jsx)(s.code,{children:"FLUSH"})," operation of ",(0,r.jsx)(s.code,{children:"BZIP2"})," does not guarantee that the decompressor can read all data, so use it with caution"]}),"\n"]})]})}function p(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>i,x:()=>d});var o=n(6540);const r={},t=o.createContext(r);function i(e){const s=o.useContext(t);return o.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function d(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(t.Provider,{value:s},e.children)}}}]);