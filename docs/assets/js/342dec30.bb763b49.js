"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[2937],{8453:(e,r,n)=>{n.d(r,{R:()=>l,x:()=>o});var t=n(6540);const i={},s=t.createContext(i);function l(e){const r=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(s.Provider,{value:r},e.children)}},8576:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"retrieve/trie/tsl","title":"tsl","description":"TSL Trie","source":"@site/docs/retrieve/trie/tsl.mdx","sourceDirName":"retrieve/trie","slug":"/retrieve/trie/tsl","permalink":"/cppdev/docs/retrieve/trie/tsl","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"darts","permalink":"/cppdev/docs/retrieve/trie/darts"},"next":{"title":"marisa","permalink":"/cppdev/docs/retrieve/trie/marisa"}}');var i=n(4848),s=n(8453);const l={},o=void 0,a={},d=[{value:"TSL Trie",id:"tsl-trie",level:2},{value:"Overview",id:"overview",level:3},{value:"Key Features",id:"key-features",level:3},{value:"Typical Use Cases",id:"typical-use-cases",level:3},{value:"Not Suitable For",id:"not-suitable-for",level:3},{value:"Industrial Fit",id:"industrial-fit",level:3},{value:"C++ Example",id:"c-example",level:3},{value:"Ternary Search Tree Node",id:"ternary-search-tree-node",level:4},{value:"Insert Function",id:"insert-function",level:4},{value:"Search Function",id:"search-function",level:4},{value:"Example Usage",id:"example-usage",level:4}];function c(e){const r={code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.h2,{id:"tsl-trie",children:"TSL Trie"}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Project:"})," TSL \u2014 ",(0,i.jsx)(r.em,{children:"Ternary Search Trie / Ternary Search Tree"}),"\n",(0,i.jsx)(r.strong,{children:"Concept:"})," A balanced tree\u2013based trie structure optimized for dynamic updates."]}),"\n",(0,i.jsx)(r.h3,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(r.p,{children:["TSL Trie refers to a family of ",(0,i.jsx)(r.strong,{children:"ternary search tree (TST)"})," implementations in C++, designed for ",(0,i.jsx)(r.strong,{children:"dynamic insertion, deletion, and lookup"})," of English string sets. Unlike static trie variants (e.g., MARISA or DARTS), TSL supports ",(0,i.jsx)(r.strong,{children:"online updates"})," with efficient memory usage and reasonable lookup performance."]}),"\n",(0,i.jsx)(r.p,{children:"A ternary search tree stores characters in nodes with three child pointers:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"left:"})," characters less than the node"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"mid:"})," characters equal to the node"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"right:"})," characters greater than the node"]}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"This structure combines aspects of binary search trees and tries, enabling dynamic workloads and ordered traversal."}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h3,{id:"key-features",children:"Key Features"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Dynamic updates:"})," supports insertions and deletions at runtime."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Prefix search:"})," supports lookup of all keys with a given prefix."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Balanced access:"})," favorable performance for balanced datasets."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Memory efficient:"})," nodes allocated on demand."]}),"\n"]}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h3,{id:"typical-use-cases",children:"Typical Use Cases"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["English ",(0,i.jsx)(r.strong,{children:"dynamic dictionaries"})," with insert/delete workloads"]}),"\n",(0,i.jsx)(r.li,{children:"Search systems requiring runtime term additions"}),"\n",(0,i.jsx)(r.li,{children:"Prefix search on evolving word sets"}),"\n",(0,i.jsx)(r.li,{children:"Applications where static build is insufficient"}),"\n"]}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h3,{id:"not-suitable-for",children:"Not Suitable For"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Extreme performance requirements in static read\u2011only environments"}),"\n",(0,i.jsx)(r.li,{children:"Very large dictionaries where static double\u2011array structures are optimal"}),"\n",(0,i.jsx)(r.li,{children:"Non\u2011English or Unicode\u2011heavy applications"}),"\n"]}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h3,{id:"industrial-fit",children:"Industrial Fit"}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Requirement"}),(0,i.jsx)(r.th,{children:"TSL Support"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Online dynamic insert/delete"}),(0,i.jsx)(r.td,{children:"\u2714\ufe0f"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Prefix search"}),(0,i.jsx)(r.td,{children:"\u2714\ufe0f"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"mmap\u2011able dictionary"}),(0,i.jsx)(r.td,{children:"\u274c"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Static serialization"}),(0,i.jsx)(r.td,{children:"\u274c"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Attaching payload (bitmap / counts)"}),(0,i.jsx)(r.td,{children:"\u274c"})]})]})]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Conclusion:"}),"\nTSL Trie is suited for ",(0,i.jsx)(r.strong,{children:"dynamic English key workloads"})," where insertions and deletions occur during runtime, and prefix search is required."]}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h3,{id:"c-example",children:"C++ Example"}),"\n",(0,i.jsx)(r.p,{children:"Below is a simple ternary search tree implementation example for build, insert, and search. This is a standalone implementation (no external library)."}),"\n",(0,i.jsx)(r.h4,{id:"ternary-search-tree-node",children:"Ternary Search Tree Node"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-cpp",children:"struct TSTNode {\n    char ch;\n    bool isEnd;\n    TSTNode *left, *mid, *right;\n    TSTNode(char c): ch(c), isEnd(false), left(nullptr), mid(nullptr), right(nullptr) {}\n};\n"})}),"\n",(0,i.jsx)(r.h4,{id:"insert-function",children:"Insert Function"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-cpp",children:"TSTNode* insert(TSTNode* root, const char* word) {\n    if (!root) {\n        root = new TSTNode(*word);\n    }\n\n    if (*word < root->ch) {\n        root->left = insert(root->left, word);\n    } else if (*word > root->ch) {\n        root->right = insert(root->right, word);\n    } else {\n        if (*(word + 1)) {\n            root->mid = insert(root->mid, word + 1);\n        } else {\n            root->isEnd = true;\n        }\n    }\n    return root;\n}\n"})}),"\n",(0,i.jsx)(r.h4,{id:"search-function",children:"Search Function"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-cpp",children:"bool search(TSTNode* root, const char* word) {\n    if (!root) return false;\n\n    if (*word < root->ch) {\n        return search(root->left, word);\n    } else if (*word > root->ch) {\n        return search(root->right, word);\n    } else {\n        if (*(word + 1) == '\\0') {\n            return root->isEnd;\n        }\n        return search(root->mid, word + 1);\n    }\n}\n"})}),"\n",(0,i.jsx)(r.h4,{id:"example-usage",children:"Example Usage"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-cpp",children:'#include <iostream>\n\nint main() {\n    TSTNode* root = nullptr;\n    root = insert(root, "apple");\n    root = insert(root, "application");\n    root = insert(root, "banana");\n    root = insert(root, "band");\n\n    std::cout << std::boolalpha;\n    std::cout << "search(\\"apple\\"): " << search(root, "apple") << "\\n";\n    std::cout << "search(\\"app\\"): " << search(root, "app") << "\\n";\n\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsxs)(r.p,{children:["This implementation is ",(0,i.jsx)(r.strong,{children:"simple and direct"}),", illustrating how TSL/TST works in C++ for dynamic workloads. You can expand it with traversal and prefix search as needed."]})]})}function h(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);