"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[2610],{977:(e,i,r)=>{r.r(i),r.d(i,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"retrieve/vector/hnswlib","title":"HNSWLIB (Hierarchical Navigable Small Worlds Library) Overview","description":"- Repository//github.com/nmslib/hnswlib","source":"@site/docs/retrieve/vector/hnswlib.mdx","sourceDirName":"retrieve/vector","slug":"/retrieve/vector/hnswlib","permalink":"/cppdev/docs/retrieve/vector/hnswlib","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"FAISS (Facebook AI Similarity Search) Overview","permalink":"/cppdev/docs/retrieve/vector/faiss"},"next":{"title":"NMSLIB (Non-Metric Space Library) Overview","permalink":"/cppdev/docs/retrieve/vector/nmslib"}}');var n=r(4848),s=r(8453);const l={},d="HNSWLIB (Hierarchical Navigable Small Worlds Library) Overview",c={},o=[{value:"Purpose &amp; Use Cases",id:"purpose--use-cases",level:2},{value:"Algorithms Supported",id:"algorithms-supported",level:2},{value:"Core Technical Specifications",id:"core-technical-specifications",level:2},{value:"1. Supported Metric Spaces (Official Implementation Only)",id:"1-supported-metric-spaces-official-implementation-only",level:3},{value:"2. Supported Data Types (Official Implementation Only)",id:"2-supported-data-types-official-implementation-only",level:3},{value:"3. Dynamic Data Operations (Insert/Delete/Modify)",id:"3-dynamic-data-operations-insertdeletemodify",level:3},{value:"Characteristics",id:"characteristics",level:2},{value:"Notes",id:"notes",level:2}];function a(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.header,{children:(0,n.jsx)(i.h1,{id:"hnswlib-hierarchical-navigable-small-worlds-library-overview",children:"HNSWLIB (Hierarchical Navigable Small Worlds Library) Overview"})}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Repository:"})," ",(0,n.jsx)(i.a,{href:"https://github.com/nmslib/hnswlib",children:"https://github.com/nmslib/hnswlib"})]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Language:"})," C++ (header-only core, Python bindings available)"]}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"purpose--use-cases",children:"Purpose & Use Cases"}),"\n",(0,n.jsxs)(i.p,{children:["HNSWLIB is a lightweight, minimalistic library dedicated to the pure implementation of the Hierarchical Navigable Small Worlds (HNSW) algorithm \u2013 extracted from NMSLIB to focus on raw query speed and minimal overhead. It ",(0,n.jsx)(i.strong,{children:"supports incremental vector insertion"})," (unlike pure offline engines) but is NOT optimized for high-frequency real-time dynamic workloads (e.g., sub-millisecond insertion, high-concurrency writes). It is suitable for:"]}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"Approximate nearest neighbor (ANN) search over large vector datasets (millions to billions of vectors)."}),"\n",(0,n.jsx)(i.li,{children:"Scenarios with low-to-medium frequency incremental insertion (e.g., hourly/daily batch updates, not real-time single-vector writes)."}),"\n",(0,n.jsx)(i.li,{children:"Resource-constrained environments (edge/embedded systems) due to its header-only, dependency-free C++ core."}),"\n",(0,n.jsx)(i.li,{children:"HNSW hyperparameter tuning (M, ef_construction, ef) for research/prototyping (no extra NMSLIB complexity)."}),"\n"]}),"\n",(0,n.jsx)(i.p,{children:"Typical applications:"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"Semi-dynamic embedding retrieval (e.g., product embedding libraries updated daily)."}),"\n",(0,n.jsx)(i.li,{children:"High-speed batch feature matching for image/video analytics."}),"\n",(0,n.jsx)(i.li,{children:"Edge-side vector search (e.g., on-device face recognition with occasional feature updates)."}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"algorithms-supported",children:"Algorithms Supported"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Hierarchical Navigable Small Worlds (HNSW)"})," \u2013 the only native algorithm (no brute-force/VP-tree/hybrid alternatives)."]}),"\n"]}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"Configurable hyperparameters:"}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"M"}),": Number of bi-directional links per node (balances index size/query speed)."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"ef_construction"}),": Index build accuracy (higher = better recall, slower build)."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"ef"}),": Query-time accuracy (higher = better recall, slower query)."]}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"core-technical-specifications",children:"Core Technical Specifications"}),"\n",(0,n.jsx)(i.h3,{id:"1-supported-metric-spaces-official-implementation-only",children:"1. Supported Metric Spaces (Official Implementation Only)"}),"\n",(0,n.jsx)(i.p,{children:"HNSWLIB has narrow, strict support for 3 metric spaces \u2013 no non-metric (Jaccard/Hamming/Edit Distance) or other metric (L1/L\u221e) support:"}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Metric Type"}),(0,n.jsx)(i.th,{children:"Full Name"}),(0,n.jsx)(i.th,{children:"C++ Identifier"}),(0,n.jsx)(i.th,{children:"Python Parameter"}),(0,n.jsx)(i.th,{children:"Use Case"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"L2"}),(0,n.jsx)(i.td,{children:"Euclidean Distance"}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"hnswlib::L2"})}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"'l2'"})}),(0,n.jsx)(i.td,{children:"General numerical vectors (image embeddings)."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Cosine"}),(0,n.jsx)(i.td,{children:"Cosine Similarity"}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"hnswlib::COSINE"})}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"'cosine'"})}),(0,n.jsx)(i.td,{children:"Text embeddings (vectors auto-normalized)."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Inner Product"}),(0,n.jsx)(i.td,{children:"Dot Product"}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"hnswlib::IP"})}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"'ip'"})}),(0,n.jsx)(i.td,{children:"Normalized vector similarity (equivalent to cosine for unit vectors)."})]})]})]}),"\n",(0,n.jsx)(i.h3,{id:"2-supported-data-types-official-implementation-only",children:"2. Supported Data Types (Official Implementation Only)"}),"\n",(0,n.jsx)(i.p,{children:"HNSWLIB ONLY supports 32/64-bit floating-point vectors \u2013 NO Float16 (FP16), integer, or binary type support (no official or stable community workarounds):"}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Data Type"}),(0,n.jsx)(i.th,{children:"Precision"}),(0,n.jsx)(i.th,{children:"C++ Type"}),(0,n.jsx)(i.th,{children:"Python Binding Mapping"}),(0,n.jsx)(i.th,{children:"Support Status"}),(0,n.jsx)(i.th,{children:"Key Note"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Float32"}),(0,n.jsx)(i.td,{children:"32-bit"}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"float"})}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"numpy.float32"})}),(0,n.jsx)(i.td,{children:"Fully supported (optimal performance)"}),(0,n.jsx)(i.td,{children:"Official recommended type (SIMD optimized)."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Float64 (Double)"}),(0,n.jsx)(i.td,{children:"64-bit"}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"double"})}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"numpy.float64"})}),(0,n.jsx)(i.td,{children:"Fully supported (slower)"}),(0,n.jsx)(i.td,{children:"Only for high-precision scenarios."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Float16 (FP16)"}),(0,n.jsx)(i.td,{children:"16-bit"}),(0,n.jsx)(i.td,{children:"-"}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"numpy.float16"})}),(0,n.jsx)(i.td,{children:"Not supported"}),(0,n.jsx)(i.td,{children:"Input throws error; manual conversion to FP32 has no FP16 benefits."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Integer/Binary"}),(0,n.jsx)(i.td,{children:"-"}),(0,n.jsx)(i.td,{children:"-"}),(0,n.jsx)(i.td,{children:"-"}),(0,n.jsx)(i.td,{children:"Not supported"}),(0,n.jsx)(i.td,{children:"No native handling; custom code is unmaintained."})]})]})]}),"\n",(0,n.jsx)(i.h3,{id:"3-dynamic-data-operations-insertdeletemodify",children:"3. Dynamic Data Operations (Insert/Delete/Modify)"}),"\n",(0,n.jsx)(i.p,{children:"HNSWLIB\u2019s dynamic capabilities are limited to incremental insertion \u2013 deletion/modification are NOT supported (no official API):"}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Operation"}),(0,n.jsx)(i.th,{children:"Support Status"}),(0,n.jsx)(i.th,{children:"Critical Limitations"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Incremental Insertion"}),(0,n.jsx)(i.td,{children:"Supported (non-real-time optimized)"}),(0,n.jsxs)(i.td,{children:["- Insert latency increases with index size (0.1ms/vector for small indexes \u2192 10ms+/vector for 100M+ vectors).",(0,n.jsx)("br",{}),"- No async/batch insertion API (high-concurrency writes trigger lock contention).",(0,n.jsx)("br",{}),"- Max sustainable QPS: ~500 (vs 10k+ for real-time engines)."]})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Deletion"}),(0,n.jsx)(i.td,{children:"Not supported"}),(0,n.jsx)(i.td,{children:'No API to delete vectors; "soft delete" (filter post-query) bloats index and degrades performance.'})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Modification"}),(0,n.jsx)(i.td,{children:"Not supported"}),(0,n.jsx)(i.td,{children:"Must re-insert updated vectors (no in-place modification); inherits insertion limitations."})]})]})]}),"\n",(0,n.jsx)(i.h2,{id:"characteristics",children:"Characteristics"}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Feature"}),(0,n.jsx)(i.th,{children:"Description"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Incremental Updates"}),(0,n.jsx)(i.td,{children:"Incremental insertion supported (non-real-time); deletion/modification not supported."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Query Speed"}),(0,n.jsx)(i.td,{children:"Industry-leading for HNSW (faster than NMSLIB\u2019s HNSW due to minimal overhead); Float32 > Float64."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Index Type"}),(0,n.jsx)(i.td,{children:"Pure graph-based (HNSW only; no tree/hybrid structures)."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Scalability"}),(0,n.jsx)(i.td,{children:"Handles 100M+ vectors (disk-backed storage); memory footprint ~30-50% lower than NMSLIB."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Language Bindings"}),(0,n.jsx)(i.td,{children:"C++ (full feature set); Python (only core features \u2013 no custom distance functions)."})]})]})]}),"\n",(0,n.jsx)(i.h2,{id:"notes",children:"Notes"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"HNSWLIB supports incremental insertion but is NOT a real-time engine \u2013 it lacks write buffers, async flushing, and distributed write support."}),"\n",(0,n.jsx)(i.li,{children:"For semi-dynamic workloads (hourly/daily updates), batch insertion (1k+ vectors) is recommended to minimize latency."}),"\n",(0,n.jsx)(i.li,{children:"Float32 is the only type for optimal performance \u2013 Float64 is 2-3x slower with no meaningful precision gain for most embeddings."}),"\n",(0,n.jsx)(i.li,{children:"No non-metric space support \u2013 use NMSLIB if Jaccard/Hamming/Edit Distance is required."}),"\n",(0,n.jsx)(i.li,{children:"Real-time alternative: Pair HNSWLIB (static historical data) with Milvus/PGVector (real-time hot data) for dynamic workloads."}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(a,{...e})}):a(e)}},8453:(e,i,r)=>{r.d(i,{R:()=>l,x:()=>d});var t=r(6540);const n={},s=t.createContext(n);function l(e){const i=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function d(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:l(e.components),t.createElement(s.Provider,{value:i},e.children)}}}]);