"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[6737],{4913:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>d,default:()=>_,frontMatter:()=>c,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"foundamentals/fibers/kthread_schedule","title":"kthread Scheduling and Execution Flow","description":"Overall Flow","source":"@site/docs/foundamentals/fibers/kthread_schedule.mdx","sourceDirName":"foundamentals/fibers","slug":"/foundamentals/fibers/kthread_schedule","permalink":"/cppdev/docs/foundamentals/fibers/kthread_schedule","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Execution Queue","permalink":"/cppdev/docs/foundamentals/fibers/execution_queue"},"next":{"title":"Thread Model Selection","permalink":"/cppdev/docs/foundamentals/fibers/kthread_or_not"}}');var s=n(4848),a=n(8453);const i=n.p+"assets/images/kthread-71802009e41c435e779a6258744147d0.png",c={},d="kthread Scheduling and Execution Flow",o={},l=[{value:"Overall Flow",id:"overall-flow",level:2},{value:"Core Interfaces",id:"core-interfaces",level:3},{value:"TaskControl",id:"taskcontrol",level:4},{value:"TaskGroup",id:"taskgroup",level:4},{value:"Main tid",id:"main-tid",level:4},{value:"Key Interfaces",id:"key-interfaces",level:4},{value:"kthread_start_urgent",id:"kthread_start_urgent",level:5},{value:"kthread_start_background",id:"kthread_start_background",level:5}];function h(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"kthread-scheduling-and-execution-flow",children:"kthread Scheduling and Execution Flow"})}),"\n",(0,s.jsx)(t.h2,{id:"overall-flow",children:"Overall Flow"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"TaskGroup"})," is responsible for scheduling and executing kthreads. Each ",(0,s.jsx)(t.code,{children:"TaskGroup"})," corresponds to one pthread and contains two execution queues: ",(0,s.jsx)(t.code,{children:"_rq"})," and ",(0,s.jsx)(t.code,{children:"_remote_rq"}),", which store pending kthreads. Kthreads created by other kthreads are placed in ",(0,s.jsx)(t.code,{children:"_rq"}),", while kthreads created by pthreads are placed in ",(0,s.jsx)(t.code,{children:"_remote_rq"}),". ",(0,s.jsx)(t.code,{children:"TaskControl"})," is a global singleton that manages multiple ",(0,s.jsx)(t.code,{children:"TaskGroup"})," instances internally."]}),"\n","\n",(0,s.jsx)("img",{src:i}),"\n",(0,s.jsx)(t.h3,{id:"core-interfaces",children:"Core Interfaces"}),"\n",(0,s.jsx)(t.h4,{id:"taskcontrol",children:"TaskControl"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"TaskControl"})," is a singleton. Below is its initialization process\u2014the core logic is to create ",(0,s.jsx)(t.code,{children:"_concurrency"})," worker (kthread_worker) threads, with each worker executing the ",(0,s.jsx)(t.code,{children:"worker_thread"})," function:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c++",children:"int TaskControl::init(int concurrency) {\n    _concurrency = concurrency;\n    _workers.resize(_concurrency);   \n    for (int i = 0; i < _concurrency; ++i) {\n        const int rc = pthread_create(&_workers[i], NULL, worker_thread, this);\n        ...\n    }\n    ...\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The logic of ",(0,s.jsx)(t.code,{children:"worker_thread"})," is to create a ",(0,s.jsx)(t.code,{children:"TaskGroup g"})," via ",(0,s.jsx)(t.code,{children:"create_group"}),", add it to ",(0,s.jsx)(t.code,{children:"TaskControl"}),", and set ",(0,s.jsx)(t.code,{children:"tls_task_group"})," (a Thread-Local Storage, TLS variable) to ",(0,s.jsx)(t.code,{children:"g"}),". Only worker threads have a non-null ",(0,s.jsx)(t.code,{children:"tls_task_group"}),". It then executes ",(0,s.jsx)(t.code,{children:"TaskGroup"}),"'s ",(0,s.jsx)(t.code,{children:"run_main_task"})," function:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c++",children:"void* TaskControl::worker_thread(void* arg) {\n    TaskControl* c = static_cast<TaskControl*>(arg);\n    TaskGroup* g = c->create_group();\n    ...\n    tls_task_group = g;\n    c->_nworkers << 1;\n    g->run_main_task();\n    ...\n}\nTaskGroup* TaskControl::create_group() {\n    ...\n    g->init(FLAGS_task_group_runqueue_capacity);\n    ...\n}\n"})}),"\n",(0,s.jsx)(t.h4,{id:"taskgroup",children:"TaskGroup"}),"\n",(0,s.jsxs)(t.p,{children:["Each ",(0,s.jsx)(t.code,{children:"TaskGroup"})," maps to one pthread. Its initialization function is shown below: it creates ",(0,s.jsx)(t.code,{children:"rq"})," and ",(0,s.jsx)(t.code,{children:"remote_rq"})," (both queues for pending kthreads), then initializes ",(0,s.jsx)(t.code,{children:"main_stack"})," and ",(0,s.jsx)(t.code,{children:"main_tid"}),". ",(0,s.jsx)(t.code,{children:"main_tid"})," represents the kthread ID of the main execution flow, and the roles of ",(0,s.jsx)(t.code,{children:"main_stack"})," and ",(0,s.jsx)(t.code,{children:"main_tid"})," are explained in detail later. ",(0,s.jsx)(t.code,{children:"TaskMeta"})," stores metadata for a kthread (e.g., execution function, arguments, local storage). Here, ",(0,s.jsx)(t.code,{children:"cur_meta"})," is set to the ",(0,s.jsx)(t.code,{children:"TaskMeta"})," corresponding to ",(0,s.jsx)(t.code,{children:"main_tid"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c++",children:"int TaskGroup::init(size_t runqueue_capacity) {\n    _rq.init(runqueue_capacity);\n    _remote_rq.init(runqueue_capacity / 2);\n    ContextualStack* stk = get_stack(STACK_TYPE_MAIN, NULL);\n    ...\n    butil::ResourceId<TaskMeta> slot;\n    TaskMeta* m = butil::get_resource<TaskMeta>(&slot);\n    ...\n    m->stop = false;\n    m->interrupted = false;\n    m->about_to_quit = false;\n    m->fn = NULL;\n    m->arg = NULL;\n    m->local_storage = LOCAL_STORAGE_INIT;\n    m->cpuwide_start_ns = butil::cpuwide_time_ns();\n    m->stat = EMPTY_STAT;\n    m->attr = BTHREAD_ATTR_TASKGROUP;\n    m->tid = make_tid(*m->version_butex, slot);\n    m->set_stack(stk);\n\n    _cur_meta = m;\n    _main_tid = m->tid;\n    _main_stack = stk;\n    _last_run_ns = butil::cpuwide_time_ns();\n    return 0;\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Each worker runs in an infinite ",(0,s.jsx)(t.code,{children:"while"})," loop: ",(0,s.jsx)(t.code,{children:"wait_task"})," returns the tid of a runnable kthread if available, otherwise the worker blocks. The logic of ",(0,s.jsx)(t.code,{children:"wait_task"})," is to first pop from the current ",(0,s.jsx)(t.code,{children:"TaskGroup"}),"'s ",(0,s.jsx)(t.code,{children:"_remote_rq"}),"; if empty, it steals (pops) from the ",(0,s.jsx)(t.code,{children:"_rq"})," and ",(0,s.jsx)(t.code,{children:"_remote_rq"})," of other ",(0,s.jsx)(t.code,{children:"TaskGroup"})," instances."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c++",children:"void TaskGroup::run_main_task() {\n    bvar::PassiveStatus<double> cumulated_cputime(\n        get_cumulated_cputime_from_this, this);\n    std::unique_ptr<bvar::PerSecond<bvar::PassiveStatus<double> > > usage_bvar;\n\n    TaskGroup* dummy = this;\n    kthread_t tid;\n    while (wait_task(&tid)) {\n        TaskGroup::sched_to(&dummy, tid);\n        DCHECK_EQ(this, dummy);\n        DCHECK_EQ(_cur_meta->stack, _main_stack);\n        if (_cur_meta->tid != _main_tid) {\n            TaskGroup::task_runner(1/*skip remained*/);\n        }\n    }\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Once a runnable tid is obtained, ",(0,s.jsx)(t.code,{children:"sched_to"})," is called. It first retrieves the ",(0,s.jsx)(t.code,{children:"TaskMeta"})," corresponding to the tid:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["If a stack has already been allocated for this ",(0,s.jsx)(t.code,{children:"TaskMeta"}),", ",(0,s.jsx)(t.code,{children:"sched_to(pg, next_meta)"})," is called. The core logic of this function is to jump to ",(0,s.jsx)(t.code,{children:"next_meta"})," via ",(0,s.jsx)(t.code,{children:"jump_stack(cur_meta->stack, next_meta->stack)"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:["Otherwise, a new stack is allocated via ",(0,s.jsx)(t.code,{children:"get_stack"}),", and the entry point of the stack is set to the ",(0,s.jsx)(t.code,{children:"task_runner"})," function."]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c++",children:"inline void TaskGroup::sched_to(TaskGroup** pg, kthread_t next_tid) {\n    TaskMeta* next_meta = address_meta(next_tid);\n    if (next_meta->stack == NULL) {\n        ContextualStack* stk = get_stack(next_meta->stack_type(), task_runner);\n        if (stk) {\n            next_meta->set_stack(stk);\n        } else {\n            // stack_type is BTHREAD_STACKTYPE_PTHREAD or out of memory,\n            // In latter case, attr is forced to be BTHREAD_STACKTYPE_PTHREAD.\n            // This basically means that if we can't allocate stack, run\n            // the task in pthread directly.\n            next_meta->attr.stack_type = BTHREAD_STACKTYPE_PTHREAD;\n            next_meta->set_stack((*pg)->_main_stack);\n        }\n    }\n    // Update now_ns only when wait_task did yield.\n    sched_to(pg, next_meta);\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The core logic of ",(0,s.jsx)(t.code,{children:"task_runner"})," is as follows:"]}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["Execute the ",(0,s.jsx)(t.code,{children:"remain"})," function (preliminary work a kthread must complete before running its core logic\u2014explained later)."]}),"\n",(0,s.jsxs)(t.li,{children:["Execute the function stored in the ",(0,s.jsx)(t.code,{children:"TaskMeta"}),". Since the kthread may be scheduled to another worker during execution, the ",(0,s.jsx)(t.code,{children:"TaskGroup"})," may change\u2014so ",(0,s.jsx)(t.code,{children:"g"})," is reinitialized after execution."]}),"\n",(0,s.jsxs)(t.li,{children:["Finally, call ",(0,s.jsx)(t.code,{children:"ending_sched"}),"."]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c++",children:"void TaskGroup::task_runner(intptr_t skip_remained) {\n    // NOTE: tls_task_group is volatile since tasks are moved around\n    //       different groups.\n    TaskGroup* g = tls_task_group;\n\n    if (!skip_remained) {\n        while (g->_last_context_remained) {\n            RemainedFn fn = g->_last_context_remained;\n            g->_last_context_remained = NULL;\n            fn(g->_last_context_remained_arg);\n            g = tls_task_group;\n        }\n    }\n\n    do {\n       \n        TaskMeta* const m = g->_cur_meta;\n        try {\n            thread_return = m->fn(m->arg);\n        } catch (ExitException& e) {\n            thread_return = e.value();\n        }\n\n        // Group is probably changed\n        g = tls_task_group;\n        ...\n        g->set_remained(TaskGroup::_release_last_context, m);\n        ending_sched(&g);\n\n    } while (g->_cur_meta->tid != g->_main_tid);\n\n    // Was called from a pthread and we don't have BTHREAD_STACKTYPE_PTHREAD\n    // tasks to run, quit for more tasks.\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"ending_sched"})," attempts to fetch a runnable kthread:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["If none is found, the next execution target is the ",(0,s.jsx)(t.code,{children:"TaskMeta"})," corresponding to ",(0,s.jsx)(t.code,{children:"main_tid"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:["It then jumps to ",(0,s.jsx)(t.code,{children:"next_meta"})," via ",(0,s.jsx)(t.code,{children:"sched_to(next_meta)"})," (described above)."]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c++",children:"void TaskGroup::ending_sched(TaskGroup** pg) {\n    TaskGroup* g = *pg;\n    kthread_t next_tid = 0;\n    // Find next task to run, if none, switch to idle thread of the group.\n#ifndef BTHREAD_FAIR_WSQ\n    // When BTHREAD_FAIR_WSQ is defined, profiling shows that cpu cost of\n    // WSQ::steal() in example/multi_threaded_echo_c++ changes from 1.9%\n    // to 2.9%\n    const bool popped = g->_rq.pop(&next_tid);\n#else\n    const bool popped = g->_rq.steal(&next_tid);\n#endif\n    if (!popped && !g->steal_task(&next_tid)) {\n        // Jump to main task if there's no task to run.\n        next_tid = g->_main_tid;\n    }\n\n    TaskMeta* const cur_meta = g->_cur_meta;\n    TaskMeta* next_meta = address_meta(next_tid);\n    if (next_meta->stack == NULL) {\n        if (next_meta->stack_type() == cur_meta->stack_type()) {\n            // also works with pthread_task scheduling to pthread_task, the\n            // transfered stack is just _main_stack.\n            next_meta->set_stack(cur_meta->release_stack());\n        } else {\n            ContextualStack* stk = get_stack(next_meta->stack_type(), task_runner);\n            if (stk) {\n                next_meta->set_stack(stk);\n            } else {\n                // stack_type is BTHREAD_STACKTYPE_PTHREAD or out of memory,\n                // In latter case, attr is forced to be BTHREAD_STACKTYPE_PTHREAD.\n                // This basically means that if we can't allocate stack, run\n                // the task in pthread directly.\n                next_meta->attr.stack_type = BTHREAD_STACKTYPE_PTHREAD;\n                next_meta->set_stack(g->_main_stack);\n            }\n        }\n    }\n    sched_to(pg, next_meta);\n}\n"})}),"\n",(0,s.jsx)(t.h4,{id:"main-tid",children:"Main tid"}),"\n",(0,s.jsxs)(t.p,{children:["Now we explain ",(0,s.jsx)(t.code,{children:"main_tid"}),"/",(0,s.jsx)(t.code,{children:"main_stack"})," (mentioned earlier):\nA ",(0,s.jsx)(t.code,{children:"TaskGroup"})," is bound to a pthread. When executing a kthread, the pthread runs on the kthread's stack; at all other times, it runs on the pthread's native stack. brpc does not allocate a new stack for the pthread\u2014it only records the address of the pthread's native stack. ",(0,s.jsx)(t.code,{children:"main_stack"})," refers to this pthread stack, and ",(0,s.jsx)(t.code,{children:"main_tid"})," uniquely identifies the pthread."]}),"\n",(0,s.jsx)(t.p,{children:"Let\u2019s examine how this is implemented:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c++",children:"int TaskGroup::init(size_t runqueue_capacity) {\n    ...\n    ContextualStack* stk = get_stack(STACK_TYPE_MAIN, NULL);\n    ...\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["In ",(0,s.jsx)(t.code,{children:"TaskGroup::init"})," above, we see ",(0,s.jsx)(t.code,{children:"ContextualStack* stk = get_stack(STACK_TYPE_MAIN, NULL);"}),":"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"STACK_TYPE_MAIN"})," is the type of ",(0,s.jsx)(t.code,{children:"main_stack"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"get_stack"})," calls ",(0,s.jsx)(t.code,{children:"StackFactory::get_stack"}),". ",(0,s.jsx)(t.code,{children:"StackFactory"})," is a template class that allocates stack space by default, but it is ",(0,s.jsxs)(t.strong,{children:["specialized for ",(0,s.jsx)(t.code,{children:"STACK_TYPE_MAIN"})]}),": no stack space is allocated\u2014only a ",(0,s.jsx)(t.code,{children:"ContextualStack"})," object is returned."]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c++",children:"template <> struct StackFactory<MainStackClass> {\n    static ContextualStack* get_stack(void (*)(intptr_t)) {\n        ContextualStack* s = new (std::nothrow) ContextualStack;\n        if (NULL == s) {\n            return NULL;\n        }\n        s->context = NULL;\n        s->stacktype = STACK_TYPE_MAIN;\n        s->storage.zeroize();\n        return s;\n    }\n    \n    static void return_stack(ContextualStack* s) {\n        delete s;\n    }\n};\n"})}),"\n",(0,s.jsxs)(t.p,{children:["During the switch to kthread execution, ",(0,s.jsx)(t.code,{children:"jump_stack(cur_meta->stack, next_meta->stack)"})," is called:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c++",children:"inline void jump_stack(ContextualStack* from, ContextualStack* to) {\n    kthread_jump_fcontext(&from->context, to->context, 0/*not skip remained*/);\n}\n"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"cur_meta"})," is the ",(0,s.jsx)(t.code,{children:"TaskMeta"})," corresponding to ",(0,s.jsx)(t.code,{children:"main_tid"})," (the pthread's metadata)."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"next_meta"})," is the metadata of the kthread to be executed."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["As explained in previous documentation, ",(0,s.jsx)(t.code,{children:"kthread_jump_fcontext"})," pushes the current register state to the ",(0,s.jsx)(t.strong,{children:"current stack (pthread stack)"})," and assigns ",(0,s.jsx)(t.code,{children:"esp"})," (stack pointer) to ",(0,s.jsx)(t.code,{children:"rdi"})," (i.e., ",(0,s.jsx)(t.code,{children:"from->context"}),"). Thus, ",(0,s.jsx)(t.code,{children:"main_tid"}),"'s stack points to the pthread's native stack."]}),"\n",(0,s.jsx)(t.h4,{id:"key-interfaces",children:"Key Interfaces"}),"\n",(0,s.jsxs)(t.p,{children:["Next, we examine the interfaces provided by kthread, using ",(0,s.jsx)(t.code,{children:"kthread_start_urgent"})," and ",(0,s.jsx)(t.code,{children:"kthread_start_background"})," as examples:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"kthread_start_urgent"}),': Treats the new kthread as "high priority".']}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"kthread_start_background"}),': Treats the new kthread as "low priority".']}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:'The meaning of "priority" is explained below.'}),"\n",(0,s.jsx)(t.h5,{id:"kthread_start_urgent",children:"kthread_start_urgent"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c++",children:"int kthread_start_urgent(kthread_t* __restrict tid,\n                         const kthread_attr_t* __restrict attr,\n                         void * (*fn)(void*),\n                         void* __restrict arg) {\n    kthread::TaskGroup* g = kthread::tls_task_group;\n    if (g) {\n        // start from worker\n        return kthread::TaskGroup::start_foreground(&g, tid, attr, fn, arg);\n    }\n    return kthread::start_from_non_worker(tid, attr, fn, arg);\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Recall that ",(0,s.jsx)(t.code,{children:"tls_task_group"})," is a TLS variable\u2014ordinary pthreads have a null ",(0,s.jsx)(t.code,{children:"tls_task_group"}),". Let\u2019s first analyze the flow for ordinary pthreads: they call ",(0,s.jsx)(t.code,{children:"start_from_non_worker"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c++",children:"BUTIL_FORCE_INLINE int\nstart_from_non_worker(kthread_t* __restrict tid,\n                      const kthread_attr_t* __restrict attr,\n                      void * (*fn)(void*),\n                      void* __restrict arg) {\n    TaskControl* c = get_or_new_task_control();\n    if (NULL == c) {\n        return ENOMEM;\n    }\n    if (attr != NULL && (attr->flags & BTHREAD_NOSIGNAL)) {\n        // Remember the TaskGroup to insert NOSIGNAL tasks for 2 reasons:\n        // 1. NOSIGNAL is often for creating many kthreads in batch,\n        //    inserting into the same TaskGroup maximizes the batch.\n        // 2. kthread_flush() needs to know which TaskGroup to flush.\n        TaskGroup* g = tls_task_group_nosignal;\n        if (NULL == g) {\n            g = c->choose_one_group();\n            tls_task_group_nosignal = g;\n        }\n        return g->start_background<true>(tid, attr, fn, arg);\n    }\n    return c->choose_one_group()->start_background<true>(\n        tid, attr, fn, arg);\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"start_from_non_worker"})," attempts to retrieve the ",(0,s.jsx)(t.code,{children:"TaskControl"})," singleton (creates it if missing, initializing a set of ",(0,s.jsx)(t.code,{children:"TaskGroup"}),"s). It then selects a ",(0,s.jsx)(t.code,{children:"TaskGroup"})," and calls ",(0,s.jsx)(t.code,{children:"start_background<true>"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c++",children:"template <bool REMOTE>\nint TaskGroup::start_background(kthread_t* __restrict th,\n                                const kthread_attr_t* __restrict attr,\n                                void * (*fn)(void*),\n                                void* __restrict arg) {\n    ...\n    butil::ResourceId<TaskMeta> slot;\n    TaskMeta* m = butil::get_resource(&slot);\n    ...\n    m->fn = fn;\n    m->arg = arg;\n    ...\n    if (REMOTE) {\n        ready_to_run_remote(m->tid, (using_attr.flags & BTHREAD_NOSIGNAL));\n    } else {\n        ready_to_run(m->tid, (using_attr.flags & BTHREAD_NOSIGNAL));\n    }\n    return 0;\n}\n"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"REMOTE"}),": A template flag indicating whether the kthread is created by an ordinary pthread (",(0,s.jsx)(t.code,{children:"true"}),") or a kthread worker (",(0,s.jsx)(t.code,{children:"false"}),")."]}),"\n",(0,s.jsxs)(t.li,{children:["Core logic: Create a ",(0,s.jsx)(t.code,{children:"TaskMeta"})," for the new kthread, then call ",(0,s.jsx)(t.code,{children:"ready_to_run_remote"})," to add the tid to the ",(0,s.jsx)(t.code,{children:"TaskGroup"}),"'s ",(0,s.jsx)(t.code,{children:"remote_rq"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Now analyze the flow when ",(0,s.jsx)(t.code,{children:"kthread_start_urgent"})," is called by a kthread worker (i.e., creating a kthread from within a kthread):"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"tls_task_group"})," is non-null, so ",(0,s.jsx)(t.code,{children:"start_foreground"})," is called."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"start_foreground"})," creates a ",(0,s.jsx)(t.code,{children:"TaskMeta"})," and ",(0,s.jsx)(t.strong,{children:"immediately switches execution to the new kthread"}),' (hence "high priority").']}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c++",children:"int TaskGroup::start_foreground(TaskGroup** pg,\n                                kthread_t* __restrict th,\n                                const kthread_attr_t* __restrict attr,\n                                void * (*fn)(void*),\n                                void* __restrict arg) {\n    ...\n    TaskGroup* g = *pg;\n    g->_control->_nkthreads << 1;\n    if (g->is_current_pthread_task()) {\n        // never create foreground task in pthread.\n        g->ready_to_run(m->tid, (using_attr.flags & BTHREAD_NOSIGNAL));\n    } else {\n        // NOSIGNAL affects current task, not the new task.\n        RemainedFn fn = NULL;\n        if (g->current_task()->about_to_quit) {\n            fn = ready_to_run_in_worker_ignoresignal;\n        } else {\n            fn = ready_to_run_in_worker;\n        }\n        ReadyToRunArgs args = {\n            g->current_tid(),\n            (bool)(using_attr.flags & BTHREAD_NOSIGNAL)\n        };\n        g->set_remained(fn, &args);\n        TaskGroup::sched_to(pg, m->tid);\n    }\n    return 0;\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["At the end of ",(0,s.jsx)(t.code,{children:"start_foreground"}),":"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["The ",(0,s.jsx)(t.code,{children:"remained"})," logic of the current ",(0,s.jsx)(t.code,{children:"TaskGroup"})," is set. As mentioned earlier, ",(0,s.jsx)(t.code,{children:"task_runner"})," executes the ",(0,s.jsx)(t.code,{children:"remained"})," logic before running the kthread's core function."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"start_foreground"})," preempts the current kthread's execution: the current kthread is pushed back to ",(0,s.jsx)(t.code,{children:"rq"})," via the ",(0,s.jsx)(t.code,{children:"remained"})," logic to wait for re-execution."]}),"\n"]}),"\n",(0,s.jsx)(t.h5,{id:"kthread_start_background",children:"kthread_start_background"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["For ordinary pthreads: The flow is identical to ",(0,s.jsx)(t.code,{children:"kthread_start_urgent"})," (calls ",(0,s.jsx)(t.code,{children:"start_from_non_worker"})," \u2192 ",(0,s.jsx)(t.code,{children:"start_background<true>"}),")."]}),"\n",(0,s.jsxs)(t.li,{children:["For kthread workers: Calls ",(0,s.jsx)(t.code,{children:"start_background<false>"}),". After creating the ",(0,s.jsx)(t.code,{children:"TaskMeta"}),", it calls ",(0,s.jsx)(t.code,{children:"ready_to_run"})," to push the kthread to ",(0,s.jsx)(t.code,{children:"rq"}),' (instead of immediate execution\u2014hence "low priority").']}),"\n"]})]})}function _(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>c});var r=n(6540);const s={},a=r.createContext(s);function i(e){const t=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(a.Provider,{value:t},e.children)}}}]);