"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[926],{2735:(e,i,s)=>{s.r(i),s.d(i,{assets:()=>l,contentTitle:()=>d,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"retrieve/bitmap/index","title":"Industrial Bitmap Solutions in C++","description":"Bitmaps are a fundamental data structure in industrial systems, especially for high-performance filtering, analytics, and large-scale set operations. Choosing the right bitmap implementation is critical for balancing memory efficiency, dynamic updates, SIMD acceleration, serialization, and rank/select capabilities. This article summarizes the most widely used C++ bitmap libraries and approaches, highlighting their strengths, limitations, and typical use cases.","source":"@site/docs/retrieve/bitmap/index.mdx","sourceDirName":"retrieve/bitmap","slug":"/retrieve/bitmap/","permalink":"/cppdev/docs/retrieve/bitmap/","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Retrieval Modules Index","permalink":"/cppdev/docs/retrieve/"},"next":{"title":"CRoaring","permalink":"/cppdev/docs/retrieve/bitmap/roaring"}}');var n=s(4848),r=s(8453);const a={},d="Industrial Bitmap Solutions in C++",l={},o=[{value:"CRoaring / Roaring Bitmaps",id:"croaring--roaring-bitmaps",level:2},{value:"BitMagic",id:"bitmagic",level:2},{value:"Boost Dynamic Bitset",id:"boost-dynamic-bitset",level:2},{value:"std::bitset and <code>vector&lt;bool&gt;</code>",id:"stdbitset-and-vectorbool",level:2},{value:"WAH / EWAH / Concise",id:"wah--ewah--concise",level:2},{value:"Custom Raw Memory Bitmaps",id:"custom-raw-memory-bitmaps",level:2},{value:"Industrial Comparison Table",id:"industrial-comparison-table",level:2}];function c(e){const i={code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.header,{children:(0,n.jsx)(i.h1,{id:"industrial-bitmap-solutions-in-c",children:"Industrial Bitmap Solutions in C++"})}),"\n",(0,n.jsxs)(i.p,{children:["Bitmaps are a fundamental data structure in industrial systems, especially for high-performance filtering, analytics, and large-scale set operations. Choosing the right bitmap implementation is critical for balancing ",(0,n.jsx)(i.strong,{children:"memory efficiency, dynamic updates, SIMD acceleration, serialization, and rank/select capabilities"}),". This article summarizes the most widely used C++ bitmap libraries and approaches, highlighting their strengths, limitations, and typical use cases."]}),"\n",(0,n.jsx)(i.hr,{}),"\n",(0,n.jsx)(i.h2,{id:"croaring--roaring-bitmaps",children:"CRoaring / Roaring Bitmaps"}),"\n",(0,n.jsxs)(i.p,{children:["CRoaring, also known as Roaring Bitmaps, is a ",(0,n.jsx)(i.strong,{children:"compressed, dynamic, SIMD-optimized bitmap library"})," widely used in production systems such as ClickHouse, Druid, Lucene, and Pinot. Its core strength lies in efficiently handling ",(0,n.jsx)(i.strong,{children:"sparse and mixed-density datasets"})," while providing dynamic operations (",(0,n.jsx)(i.code,{children:"set"}),"/",(0,n.jsx)(i.code,{children:"unset"}),") and fast logical operations (AND/OR/XOR/NOT)."]}),"\n",(0,n.jsxs)(i.p,{children:["CRoaring also supports ",(0,n.jsx)(i.strong,{children:"serialization"}),", enabling cross-platform storage and fast cold-start initialization. Its block-based container structure allows hybrid density handling and extendable rank/select operations. CRoaring is particularly suitable for ",(0,n.jsx)(i.strong,{children:"large-scale bitsets in analytics or OLAP systems"}),"."]}),"\n",(0,n.jsx)(i.hr,{}),"\n",(0,n.jsx)(i.h2,{id:"bitmagic",children:"BitMagic"}),"\n",(0,n.jsxs)(i.p,{children:["BitMagic is a ",(0,n.jsx)(i.strong,{children:"comprehensive bitmap engine"})," in C++, designed for medium to large-scale dynamic sets. Unlike simple bitsets, BitMagic provides ",(0,n.jsx)(i.strong,{children:"dense bitvectors with optional run/cluster compression"})," and automatically adapts internal containers based on density. It supports dynamic updates, SIMD acceleration, binary serialization, and partial rank/select functionality."]}),"\n",(0,n.jsxs)(i.p,{children:["BitMagic excels in scenarios requiring ",(0,n.jsx)(i.strong,{children:"complex boolean combinations"}),", medium-scale in-memory filtering, or high-performance industrial set operations. Its flexible API allows precise control over memory layout, making it suitable for performance-sensitive applications."]}),"\n",(0,n.jsx)(i.hr,{}),"\n",(0,n.jsx)(i.h2,{id:"boost-dynamic-bitset",children:"Boost Dynamic Bitset"}),"\n",(0,n.jsxs)(i.p,{children:["Boost Dynamic Bitset offers a ",(0,n.jsx)(i.strong,{children:"dynamic, dense bitset implementation"})," in pure C++. It supports set/unset operations and moderate-size dynamic sets but ",(0,n.jsx)(i.strong,{children:"does not provide compression, SIMD acceleration, or built-in serialization"}),". Rank/select and hybrid density handling are also not supported."]}),"\n",(0,n.jsxs)(i.p,{children:["Boost Dynamic Bitset is best suited for ",(0,n.jsx)(i.strong,{children:"small to medium-scale dynamic dense sets"}),", where the performance requirements are moderate, and advanced bitmap features are unnecessary."]}),"\n",(0,n.jsx)(i.hr,{}),"\n",(0,n.jsxs)(i.h2,{id:"stdbitset-and-vectorbool",children:["std::bitset and ",(0,n.jsx)(i.code,{children:"vector<bool>"})]}),"\n",(0,n.jsxs)(i.p,{children:["The standard C++ ",(0,n.jsx)(i.code,{children:"std::bitset"})," and ",(0,n.jsx)(i.code,{children:"vector<bool>"})," provide lightweight bitsets for fixed-size or small-scale dense datasets. While ",(0,n.jsx)(i.code,{children:"vector<bool>"})," offers some dynamic sizing capabilities, neither supports compression, SIMD optimization, serialization, rank/select, or hybrid density handling."]}),"\n",(0,n.jsxs)(i.p,{children:["These implementations are suitable for ",(0,n.jsx)(i.strong,{children:"low-scale filtering, fixed-size dense sets, and lightweight internal logic operations"}),"."]}),"\n",(0,n.jsx)(i.hr,{}),"\n",(0,n.jsx)(i.h2,{id:"wah--ewah--concise",children:"WAH / EWAH / Concise"}),"\n",(0,n.jsxs)(i.p,{children:["Older bitmap formats such as WAH, EWAH, and Concise provide compressed representations but ",(0,n.jsx)(i.strong,{children:"lack dynamic update support, SIMD acceleration, and reliable serialization"}),". These legacy formats are rarely used in modern industrial systems."]}),"\n",(0,n.jsx)(i.hr,{}),"\n",(0,n.jsx)(i.h2,{id:"custom-raw-memory-bitmaps",children:"Custom Raw Memory Bitmaps"}),"\n",(0,n.jsxs)(i.p,{children:["For ultra-high-performance scenarios, many industrial systems implement ",(0,n.jsx)(i.strong,{children:"custom raw memory bitmaps"}),". These bitmaps operate directly on contiguous memory blocks, enabling ",(0,n.jsx)(i.strong,{children:"manual SIMD optimization, precise memory layout control, and custom serialization"})," (including mmap-based zero-copy loading)."]}),"\n",(0,n.jsxs)(i.p,{children:["Custom raw memory bitmaps are ideal for ",(0,n.jsx)(i.strong,{children:"billion-scale filtering, high-concurrency applications, and scenarios where maximum performance is required"}),". However, they require careful implementation to handle memory management, thread safety, and rank/select operations."]}),"\n",(0,n.jsx)(i.hr,{}),"\n",(0,n.jsx)(i.h2,{id:"industrial-comparison-table",children:"Industrial Comparison Table"}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Library / Format"}),(0,n.jsx)(i.th,{children:"Compressed"}),(0,n.jsx)(i.th,{children:"Dynamic"}),(0,n.jsx)(i.th,{children:"SIMD"}),(0,n.jsx)(i.th,{children:"Serialization"}),(0,n.jsx)(i.th,{children:"Rank/Select"}),(0,n.jsx)(i.th,{children:"Hybrid Density"}),(0,n.jsx)(i.th,{children:"Notes"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"CRoaring"}),(0,n.jsx)(i.td,{children:"\u2714\ufe0f"}),(0,n.jsx)(i.td,{children:"\u2714\ufe0f"}),(0,n.jsx)(i.td,{children:"\u2714\ufe0f"}),(0,n.jsx)(i.td,{children:"\u2714\ufe0f"}),(0,n.jsx)(i.td,{children:"Extendable"}),(0,n.jsx)(i.td,{children:"\u2714\ufe0f"}),(0,n.jsx)(i.td,{children:"Large-scale sparse/mixed bitsets"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"BitMagic"}),(0,n.jsx)(i.td,{children:"\u274c (dense efficient, optional run/cluster)"}),(0,n.jsx)(i.td,{children:"\u2714\ufe0f"}),(0,n.jsx)(i.td,{children:"\u2714\ufe0f"}),(0,n.jsx)(i.td,{children:"\u2714\ufe0f"}),(0,n.jsx)(i.td,{children:"Partial"}),(0,n.jsx)(i.td,{children:"\u2714\ufe0f"}),(0,n.jsx)(i.td,{children:"Medium-scale dynamic filtering, complex operations"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Boost Dynamic Bitset"}),(0,n.jsx)(i.td,{children:"\u274c"}),(0,n.jsx)(i.td,{children:"\u2714\ufe0f"}),(0,n.jsx)(i.td,{children:"\u274c"}),(0,n.jsx)(i.td,{children:"\u274c"}),(0,n.jsx)(i.td,{children:"\u274c"}),(0,n.jsx)(i.td,{children:"\u274c"}),(0,n.jsx)(i.td,{children:"Small to medium dynamic dense sets"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsxs)(i.td,{children:["std::bitset / ",(0,n.jsx)(i.code,{children:"vector<bool>"})]}),(0,n.jsx)(i.td,{children:"\u274c"}),(0,n.jsx)(i.td,{children:"\u274c / partial"}),(0,n.jsx)(i.td,{children:"\u274c"}),(0,n.jsx)(i.td,{children:"\u274c"}),(0,n.jsx)(i.td,{children:"\u274c"}),(0,n.jsx)(i.td,{children:"\u274c"}),(0,n.jsx)(i.td,{children:"Fixed-size, small dense sets"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"WAH / EWAH / Concise"}),(0,n.jsx)(i.td,{children:"\u2714\ufe0f"}),(0,n.jsx)(i.td,{children:"\u274c"}),(0,n.jsx)(i.td,{children:"\u274c"}),(0,n.jsx)(i.td,{children:"\u274c / limited"}),(0,n.jsx)(i.td,{children:"\u274c"}),(0,n.jsx)(i.td,{children:"\u274c"}),(0,n.jsx)(i.td,{children:"Legacy compressed formats"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Custom Raw Memory"}),(0,n.jsx)(i.td,{children:"\u274c (manual)"}),(0,n.jsx)(i.td,{children:"\u2714\ufe0f"}),(0,n.jsx)(i.td,{children:"\u2714\ufe0f"}),(0,n.jsx)(i.td,{children:"Custom/mmap"}),(0,n.jsx)(i.td,{children:"Custom"}),(0,n.jsx)(i.td,{children:"Custom"}),(0,n.jsx)(i.td,{children:"Ultra high-performance, fully controlled memory"})]})]})]}),"\n",(0,n.jsx)(i.hr,{}),"\n",(0,n.jsxs)(i.p,{children:["This format keeps the ",(0,n.jsx)(i.strong,{children:"article readable with narrative paragraphs"})," for each library while placing the ",(0,n.jsx)(i.strong,{children:"key industrial comparison in a concise table"})," for quick reference."]})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},8453:(e,i,s)=>{s.d(i,{R:()=>a,x:()=>d});var t=s(6540);const n={},r=t.createContext(n);function a(e){const i=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function d(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),t.createElement(r.Provider,{value:i},e.children)}}}]);