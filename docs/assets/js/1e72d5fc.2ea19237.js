"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[170],{176:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"flags/flags","title":"Turbo Command-Line Flags (Turbo Flags)","description":"The turbo/flags library enables programmatic access to command-line flag values passed to binary executables. The turbo/flags library provides the following features:","source":"@site/docs/flags/flags.mdx","sourceDirName":"flags","slug":"/flags/","permalink":"/docs/flags/","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/flags/flags.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"String Replacement","permalink":"/docs/strings/substitution"}}');var a=s(4848),i=s(8453);const r={},l="Turbo Command-Line Flags (Turbo Flags)",o={},d=[{value:"Defining Flags",id:"define_flags",level:2},{value:"Standard Flags",id:"standard-flags",level:3},{value:"Turbo Flags",id:"turbo-flags",level:3},{value:"Optional Flags",id:"optional-flags",level:3},{value:"Reading Flags",id:"accessing-flags",level:2},{value:"Using Flags in Different Files",id:"declaring_flags",level:2},{value:"Validating Flag Values",id:"validating-flag-values",level:2},{value:"Changing Default Flag Values",id:"changing-default-flag-value",level:2},{value:"Removing/Retiring Flags",id:"removing-retiring-flags",level:2},{value:"Defining Custom Flag Types",id:"custom",level:2},{value:"Best Practices for Defining Custom Flag Types",id:"best-practices-for-defining-custom-flag-types",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"turbo-command-line-flags-turbo-flags",children:"Turbo Command-Line Flags (Turbo Flags)"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"turbo/flags"})," library enables programmatic access to command-line flag values passed to binary executables. The ",(0,a.jsx)(n.code,{children:"turbo/flags"})," library provides the following features:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Thread-safe access to ",(0,a.jsx)(n.code,{children:"turbo/flags"})]}),"\n",(0,a.jsx)(n.li,{children:"Access to valid flag values at any point during the program lifecycle"}),"\n",(0,a.jsx)(n.li,{children:"Prevention of flag name collisions by ensuring uniqueness of flag names within a single binary"}),"\n",(0,a.jsx)(n.li,{children:"Associated help text provided by many built-in flags"}),"\n",(0,a.jsxs)(n.li,{children:["Native type support for ",(0,a.jsx)(n.code,{children:"bool"}),", ",(0,a.jsx)(n.code,{children:"int"}),", and ",(0,a.jsx)(n.code,{children:"string"}),", with extensibility to support other Turbo types and custom types"]}),"\n",(0,a.jsx)(n.li,{children:"Default values and programmatic access to flag values for reading and writing"}),"\n",(0,a.jsx)(n.li,{children:"Allows separate declaration and definition of flags (though this usage has drawbacks and should generally be avoided)"}),"\n",(0,a.jsx)(n.li,{children:"Supports pre-set validation when flags are dynamically set"}),"\n",(0,a.jsx)(n.li,{children:"Supports post-set callbacks when flags are dynamically set"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["The values of these flags can be parsed from command-line arguments or files. The resulting value of each flag is stored in a global variable of type ",(0,a.jsx)(n.code,{children:"turbo::Flag<T>"})," (where ",(0,a.jsx)(n.code,{children:"T"})," is the specific type of the flag)."]}),"\n",(0,a.jsx)(n.h2,{id:"define_flags",children:"Defining Flags"}),"\n",(0,a.jsxs)(n.p,{children:["Define a flag of the appropriate type using the ",(0,a.jsx)(n.code,{children:"TURBO_FLAG(type, name, default, help-text)"})," macro:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:'#include "turbo/flags/flag.h"\n#include "turbo/time/time.h"\n\nTURBO_FLAG(bool, big_menu, true,\n          "Include \'advanced\' options in the menu listing");\nTURBO_FLAG(std::string, output_dir, "foo/bar/baz/", "output file directory");\nTURBO_FLAG(std::vector<std::string>, languages,\n          std::vector<std::string>({"english", "french", "german"}),\n          "comma-separated list of languages to offer in the \'lang\' menu");\nTURBO_FLAG(turbo::Duration, timeout, turbo::Seconds(30), "Default RPC deadline");\nTURBO_FLAG(std::optional<std::string>, image_file, std::nullopt,\n          "Sets the image input from a file.");\n'})}),"\n",(0,a.jsxs)(n.p,{children:["A flag defined with ",(0,a.jsx)(n.code,{children:"TURBO_FLAG"})," creates a global variable named ",(0,a.jsx)(n.code,{children:"FLAGS_name"})," with the specified type and default value:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"FLAGS_name\n"})}),"\n",(0,a.jsx)(n.h3,{id:"standard-flags",children:"Standard Flags"}),"\n",(0,a.jsx)(n.p,{children:"The Turbo flags library supports the following types out of the box:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"bool"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"int16_t"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"uint16_t"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"int32_t"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"uint32_t"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"int64_t"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"uint64_t"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"float"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"double"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"std::string"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"std::vector<std::string>"})}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"std::optional<T>"}),' (see "Optional Flags" below)']}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"turbo::LogSeverity"})," (provided natively for layering reasons)"]}),"\n"]}),"\n",(0,a.jsx)(n.admonition,{title:"TIPS",type:"info",children:(0,a.jsxs)(n.p,{children:["Support for integer types is implemented using overloading for variable-width fundamental types (",(0,a.jsx)(n.code,{children:"short"}),", ",(0,a.jsx)(n.code,{children:"int"}),", ",(0,a.jsx)(n.code,{children:"long"}),", etc.). However, applications should prefer the fixed-width integer types listed above (",(0,a.jsx)(n.code,{children:"int32_t"}),", ",(0,a.jsx)(n.code,{children:"uint64_t"}),", etc.)."]})}),"\n",(0,a.jsx)(n.h3,{id:"turbo-flags",children:"Turbo Flags"}),"\n",(0,a.jsxs)(n.p,{children:["In addition, some Turbo libraries provide their own custom support for ",(0,a.jsx)(n.code,{children:"turbo flags"}),". Documentation for these formats is available in the documentation for the type where ",(0,a.jsx)(n.code,{children:"turbo_parse_flag()"})," is defined."]}),"\n",(0,a.jsxs)(n.p,{children:["The Turbo ",(0,a.jsx)(n.a,{href:"/docs/time/#time-durations",children:"Time Library"})," provides flag support for absolute time values:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"turbo::Duration"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"turbo::Time"})}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.a,{href:"/docs/time/#civil-times",children:"Civil Time Library"})," also provides flag support for the following civil time values:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"turbo::CivilSecond"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"turbo::CivilMinute"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"turbo::CivilHour"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"turbo::CivilDay"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"turbo::CivilMonth"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"turbo::CivilYear"})}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Additional support for other Turbo types will be noted here when added."}),"\n",(0,a.jsxs)(n.p,{children:["See ",(0,a.jsx)(n.a,{href:"#custom",children:"Defining Custom Flag Types"})," for how to provide support for new flag types."]}),"\n",(0,a.jsxs)(n.p,{children:["You can define a flag in any ",(0,a.jsx)(n.code,{children:".cc"})," file in an executable, but ",(0,a.jsx)(n.strong,{children:"only define a flag once"}),"! All flags should be defined outside of any C++ namespaces, so if multiple definitions of the same-named flag are linked into a single program, the linker will report an error. If you need to access a flag from multiple source files, define it in one ",(0,a.jsx)(n.code,{children:".cc"})," file and ",(0,a.jsx)(n.a,{href:"#declaring_flags",children:"declare"})," it in the corresponding header file."]}),"\n",(0,a.jsx)(n.h3,{id:"optional-flags",children:"Optional Flags"}),"\n",(0,a.jsxs)(n.p,{children:["The Turbo flags library supports flags of type ",(0,a.jsx)(n.code,{children:"std::Optional<T>"}),", where ",(0,a.jsx)(n.code,{children:"T"})," is one of the supported flag types. We refer to this flag type as an ",(0,a.jsxs)(n.em,{children:["optional flag of type ",(0,a.jsx)(n.code,{children:"T"})]}),".\nAn optional flag is either ",(0,a.jsx)(n.em,{children:"valueless"})," (containing no value of type ",(0,a.jsx)(n.code,{children:"T"}),", indicating the flag has not been set) or holds a value of type ",(0,a.jsx)(n.code,{children:"T"}),". The valueless state in C++ code is represented by the value ",(0,a.jsx)(n.code,{children:"std::nullopt"})," for the optional flag."]}),"\n",(0,a.jsxs)(n.p,{children:["Using ",(0,a.jsx)(n.code,{children:"std::nullopt"})," as the default value for an optional flag allows you to check whether such a flag was ever specified on the command line:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"if (turbo::GetFlag(FLAGS_foo).has_value()) {\n  // flag was set on command line\n} else {\n  // flag was not passed on command line\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Using ",(0,a.jsx)(n.code,{children:"std::Optional<T>"})," in this way avoids common workarounds to indicate such an unset flag (e.g., using a sentinel value to indicate this state)."]}),"\n",(0,a.jsxs)(n.p,{children:['Optional flags also allow developers to pass a flag in a valueless "unset" state on the command line, allowing the flag to be set later in the binary logic. A valueless state for an optional flag is represented by passing the special syntax ',(0,a.jsx)(n.code,{children:"--flag="})," or ",(0,a.jsx)(n.code,{children:'--flag ""'})," to set the value to an empty string."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sh",children:'$ binary_with_optional --flag_in_unset_state=\n$ binary_with_optional --flag_in_unset_state ""\n'})}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.p,{children:["Note: Due to the above syntax requirement, an optional flag cannot be set to any value of ",(0,a.jsx)(n.code,{children:"T"})," that would parse to an empty string."]})}),"\n",(0,a.jsx)(n.h2,{id:"accessing-flags",children:"Reading Flags"}),"\n",(0,a.jsxs)(n.p,{children:["Flags defined via ",(0,a.jsx)(n.code,{children:"TURBO_FLAG"})," are available as variables of the unspecified type and named using the name passed to ",(0,a.jsx)(n.code,{children:"TURBO_FLAG"}),". ",(0,a.jsx)(n.code,{children:"turbo::GetFlag()"})," and ",(0,a.jsx)(n.code,{children:"turbo::SetFlag()"})," can be used to access such flags. For example, for a flag of type ",(0,a.jsx)(n.code,{children:"turbo::Duration"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:'// Creates variable "turbo::Flag<turbo::Duration> FLAGS_timeout;"\n// Example command line usage: --timeout=1m30s\nTURBO_FLAG(turbo::Duration, timeout, turbo::Seconds(30), "Default RPC timeout");\n\n// Read the flag\nturbo::Duration d = turbo::GetFlag(FLAGS_timeout);\n\n// Modify the flag\nturbo::SetFlag(&FLAGS_timeout, d + turbo::Seconds(10));\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Access to ",(0,a.jsx)(n.code,{children:"TURBO_FLAG"})," flags is ",(0,a.jsx)(n.strong,{children:"thread-safe"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"declaring_flags",children:"Using Flags in Different Files"}),"\n",(0,a.jsxs)(n.p,{children:["Accessing a flag in the manner of the previous section is only valid if the flag was defined earlier in the same ",(0,a.jsx)(n.code,{children:".cc"})," file. If not, you will get an ",(0,a.jsx)(n.code,{children:"'unknown variable'"})," error."]}),"\n",(0,a.jsxs)(n.p,{children:["If you need to allow other modules to access the flag, you must export it to some header file included by those modules. For a ",(0,a.jsx)(n.code,{children:"TURBO_FLAG"})," flag named ",(0,a.jsx)(n.code,{children:"FLAGS_name"})," of type ",(0,a.jsx)(n.code,{children:"T"}),", use the ",(0,a.jsx)(n.code,{children:"TURBO_DECLARE_FLAG(T, name);"})," macro defined in ",(0,a.jsx)(n.code,{children:"turbo/flags/declare.h"})," to do so:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:'#include "turbo/flags/declare.h"\n\nTURBO_DECLARE_FLAG(turbo::Duration, timeout);\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Declarations should always be placed in the header file associated with the ",(0,a.jsx)(n.code,{children:".cc"})," file that defines and owns the flag, just like any other exported entity.\nIf you need to do this only for testing, you can pair it with a ",(0,a.jsx)(n.code,{children:"// Exposed for testing only"})," comment."]}),"\n",(0,a.jsx)(n.admonition,{type:"warning",children:(0,a.jsx)(n.p,{children:'Warning: The need to access flags from different files, especially in libraries, is often a sign of poor design. Given the "global variable" nature of flags, they should be avoided in libraries and instead injected (e.g., in constructors).'})}),"\n",(0,a.jsx)(n.h2,{id:"validating-flag-values",children:"Validating Flag Values"}),"\n",(0,a.jsx)(n.p,{children:"Certain flag values may be invalid. For example, the underlying type may have a larger range than is desired for the flag."}),"\n",(0,a.jsxs)(n.p,{children:["For ",(0,a.jsx)(n.code,{children:"TURBO_FLAG"})," flags, additional checks on flag values can be done by providing a custom type and adding an appropriate validation to the corresponding ",(0,a.jsx)(n.code,{children:"turbo_parse_flag()"})," function, which defines how a specific flag should be parsed."]}),"\n",(0,a.jsx)(n.p,{children:"Example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c++",children:'#include <string>\n\n#include "turbo/flags/flag.h"\n#include "turbo/flags/marshalling.h"\n#include "turbo/strings/string_view.h"\n\nstruct PortNumber {\n  explicit PortNumber(int p = 0) : port(p) {}\n\n  int port;  // Valid range is [0..32767]\n};\n\n// Returns a textual flag value corresponding to the PortNumber `p`.\nstd::string turbo_unparse_flag(PortNumber p) {\n  // Delegate to the usual unparsing for int.\n  return turbo::unparse_flag(p.port);\n}\n\n// Parses a PortNumber from the command line flag value `text`.\n// Returns true and sets `*p` on success; returns false and sets `*error`\n// on failure.\nbool turbo_parse_flag(turbo::string_view text, PortNumber* p, std::string* error) {\n  // Convert from text to int using the int-flag parser.\n  if (!turbo::parse_flag(text, &p->port, error)) {\n    return false;\n  }\n  if (p->port < 0 || p->port > 32767) {\n    *error = "not in range [0,32767]";\n    return false;\n  }\n  return true;\n}\n\nTURBO_FLAG(PortNumber, port, PortNumber(0), "What port to listen on");\n'})}),"\n",(0,a.jsxs)(n.p,{children:["If ",(0,a.jsx)(n.code,{children:"turbo_parse_flag()"})," returns ",(0,a.jsx)(n.code,{children:"false"})," for a value specified on the command line, the process will exit with an error message. Note that ",(0,a.jsx)(n.code,{children:"turbo_parse_flag()"})," does not initiate any parsing itself, but only defines parsing behavior."]}),"\n",(0,a.jsx)(n.h2,{id:"changing-default-flag-value",children:"Changing Default Flag Values"}),"\n",(0,a.jsxs)(n.p,{children:["Sometimes a flag is defined in a library, and you want to change its default value in one application but not in others.\nTo do this, you can use ",(0,a.jsx)(n.code,{children:"turbo::SetFlag()"})," to override this default value before invoking program startup; if the user does not pass a value on the command line, this new default value will be used:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"int main(int argc, char** argv) {\n  // Overrides the default for FLAGS_logtostderr\n  turbo::SetFlag(&FLAGS_logtostderr, true);\n  // If the command-line contains a value for logtostderr, use that. Otherwise,\n  // use the default (as set above).\n  ...\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Note that setting a flag ",(0,a.jsx)(n.em,{children:"after"})," parsing the command line is generally neither useful nor recommended, as it ignores the user's intent with command-line flags, essentially setting the flag to a constant value."]}),"\n",(0,a.jsx)(n.h2,{id:"removing-retiring-flags",children:"Removing/Retiring Flags"}),"\n",(0,a.jsxs)(n.p,{children:["When a flag is no longer useful (and no longer referenced in code), in some cases the definition can simply be deleted. However, if the flag is referenced in configuration files, job startup scripts, etc., simply deleting the definition will cause deployment issues. For flags referenced in complex deployments where a single configuration may be used for multiple builds, it is impossible to satisfy all constraints. Handling timing and coordination in these cases is difficult, and you can mark some flags as ",(0,a.jsx)(n.em,{children:"retiring"})," via ",(0,a.jsx)(n.code,{children:"TURBO_RETIRED_FLAG()"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:'TURBO_RETIRED_FLAG(bool, old_bool_flag, true, "old description");\n'})}),"\n",(0,a.jsx)(n.p,{children:"Retired flags have a number of important behaviors. Specifically, they:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Do not define a C++ ",(0,a.jsx)(n.code,{children:"FLAGS_"})," variable."]}),"\n",(0,a.jsx)(n.li,{children:"Have a type and a value, but the value is intentionally inaccessible."}),"\n",(0,a.jsxs)(n.li,{children:["Do not appear in ",(0,a.jsx)(n.code,{children:"--help"})," messages."]}),"\n",(0,a.jsxs)(n.li,{children:["Are fully supported by ",(0,a.jsx)(n.em,{children:"all"})," flag parsing routines."]}),"\n",(0,a.jsx)(n.li,{children:"Consume arguments normally, and complain about type mismatches in those arguments."}),"\n",(0,a.jsx)(n.li,{children:"Emit a complaint but do not die if accessed by name via flag APIs for parsing or other purposes."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"In this way, you can safely remove flags used in complex deployments: retire the flag, wait for releases of the affected binaries, then remove references to the flag from configuration files and startup scripts. Once all jobs start without logging warnings about referencing the retired flag, the retired flag can be deleted entirely."}),"\n",(0,a.jsx)(n.h2,{id:"custom",children:"Defining Custom Flag Types"}),"\n",(0,a.jsxs)(n.p,{children:["For a type ",(0,a.jsx)(n.code,{children:"T"})," to be usable as a Turbo flag type, it must support conversion to and from the strings provided on the command line. Custom types may have unique formats for this command-line string, and thus may require custom support for ",(0,a.jsx)(n.code,{children:"turbo/flags"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["To add support for a user-defined type, add overloads of ",(0,a.jsx)(n.code,{children:"turbo_parse_flag()"})," and ",(0,a.jsx)(n.code,{children:"turbo_unparse_flag()"})," as free (non-member) functions for your type. If ",(0,a.jsx)(n.code,{children:"T"})," is a class type, these functions can be friend function definitions. These overloads must be added to the same namespace where the type is defined so they can be discovered via argument-dependent lookup (ADL)."]}),"\n",(0,a.jsx)(n.p,{children:"Example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:'namespace foo {\nenum class OutputMode { kPlainText, kHtml };\n\n// turbo_parse_flag converts from a string to OutputMode.\n// Must be in same namespace as OutputMode.\n\n// Parses an OutputMode from the command line flag value `text`. Returns\n// `true` and sets `*mode` on success; returns `false` and sets `*error`\n// on failure.\nbool turbo_parse_flag(turbo::string_view text,\n                   OutputMode* mode,\n                   std::string* error) {\n  if (text == "plaintext") {\n    *mode = OutputMode::kPlainText;\n    return true;\n  }\n  if (text == "html") {\n    *mode = OutputMode::kHtml;\n    return true;\n  }\n  *error = "unknown value for enumeration";\n  return false;\n}\n\n// turbo_unparse_flag converts from an OutputMode to a string.\n// Must be in same namespace as OutputMode.\n\n// Returns a textual flag value corresponding to the OutputMode `mode`.\nstd::string turbo_unparse_flag(OutputMode mode) {\n  switch (mode) {\n    case OutputMode::kPlainText: return "plaintext";\n    case OutputMode::kHtml: return "html";\n    default: return turbo::StrCat(mode);\n  }\n}\n}  // namespace foo\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Note that both ",(0,a.jsx)(n.code,{children:"turbo_parse_flag()"})," and ",(0,a.jsx)(n.code,{children:"turbo_unparse_flag()"})," are not class members, but free functions. Overloads of ",(0,a.jsx)(n.code,{children:"turbo_parse_flag/turbo_unparse_flag()"})," for a type can only be declared in the same file and namespace where the type is defined. The correct ",(0,a.jsx)(n.code,{children:"turbo_parse_flag/turbo_unparse_flag()"})," implementation for a given type will be discovered via argument-dependent lookup (ADL)."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"turbo_parse_flag()"})," may need to in turn parse simpler constituent types using ",(0,a.jsx)(n.code,{children:"turbo::parse_flag()"}),". For example, a custom struct ",(0,a.jsx)(n.code,{children:"MyFlagType"})," composed of ",(0,a.jsx)(n.code,{children:"std::pair<int, std::string>"})," would add an overload of ",(0,a.jsx)(n.code,{children:"turbo_parse_flag()"})," for its ",(0,a.jsx)(n.code,{children:"MyFlagType"})," as follows:"]}),"\n",(0,a.jsx)(n.p,{children:"Example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"namespace my_flag_namespace {\n\nstruct MyFlagType {\n  std::pair<int, std::string> my_flag_data;\n};\n\nbool turbo_parse_flag(turbo::string_view text, MyFlagType* flag,\n                   std::string* err);\n\nstd::string turbo_unparse_flag(const MyFlagType&);\n\n// Within the implementation, `turbo_parse_flag()` will, in turn invoke\n// `turbo::parse_flag()` on its constituent `int` and `std::string` types\n// (which have built-in Turbo flag support.\n\nbool turbo_parse_flag(turbo::string_view text, MyFlagType* flag,\n                   std::string* err) {\n  std::pair<turbo::string_view, turbo::string_view> tokens =\n      turbo::str_split(text, ',');\n  if (!turbo::parse_flag(tokens.first, &flag->my_flag_data.first, err))\n    return false;\n  if (!turbo::parse_flag(tokens.second, &flag->my_flag_data.second, err))\n    return false;\n  return true;\n}\n\n// Similarly, for unparsing, we can simply invoke `turbo::unparse_flag()` on\n// the constituent types.\nstd::string turbo_unparse_flag(const MyFlagType& flag) {\n  return turbo::StrCat(turbo::unparse_flag(flag.my_flag_data.first),\n                      \",\",\n                      turbo::unparse_flag(flag.my_flag_data.second));\n}\n}  // my_flag_namespace\n"})}),"\n",(0,a.jsx)(n.h3,{id:"best-practices-for-defining-custom-flag-types",children:"Best Practices for Defining Custom Flag Types"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Declare ",(0,a.jsx)(n.code,{children:"turbo_parse_flag()"})," and ",(0,a.jsx)(n.code,{children:"turbo_unparse_flag()"})," in the same location as ",(0,a.jsx)(n.code,{children:"T"}),", typically in the same file where ",(0,a.jsx)(n.code,{children:"T"})," is declared.\nIf ",(0,a.jsx)(n.code,{children:"T"})," is a class type, they can be defined with ",(0,a.jsxs)(n.a,{href:"http://en.cppreference.com/w/cpp/language/friend",children:["friend ",(0,a.jsx)(n.em,{children:"function-definitions"})]}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["If you must declare ",(0,a.jsx)(n.code,{children:"turbo_parse_flag()"})," and ",(0,a.jsx)(n.code,{children:"turbo_unparse_flag()"})," far from the declaration of ",(0,a.jsx)(n.code,{children:"T"}),", you must still be the owner of ",(0,a.jsx)(n.code,{children:"T"})," and must guarantee that these functions are defined only once in the codebase."]}),"\n",(0,a.jsxs)(n.li,{children:["Document the format string for flags that declare ",(0,a.jsx)(n.code,{children:"turbo_parse_flag()"})," and ",(0,a.jsx)(n.code,{children:"turbo_unparse_flag()"}),". As the owner of ",(0,a.jsx)(n.code,{children:"T"}),", you are responsible for documenting this format."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:'turbo::str_split("")'})," returns ",(0,a.jsx)(n.code,{children:'{""}'})," (a list containing one element), so be careful with this if you are defining composite flag types.\nFlags defined as ",(0,a.jsx)(n.code,{children:"TURBO_FLAG(std::vector<std::string>, ...)"})," treat the empty string as an empty container."]}),"\n",(0,a.jsx)(n.li,{children:"Escape delimiters if they appear in values of composite flag types."}),"\n",(0,a.jsxs)(n.li,{children:["Call ",(0,a.jsx)(n.code,{children:"turbo::parse_flag()"})," and ",(0,a.jsx)(n.code,{children:"turbo::unparse_flag()"})," in your free function overloads to get the string conversion behavior implemented for constituent built-in types."]}),"\n",(0,a.jsxs)(n.li,{children:["Only allow boolean flags to be passed without a value: e.g., ",(0,a.jsx)(n.code,{children:"--enable_foo"})," or ",(0,a.jsx)(n.code,{children:"--noenable_foo"}),". Thus, all custom flag types require an explicit value to be passed to ",(0,a.jsx)(n.code,{children:"turbo_parse_flag()"})," and ",(0,a.jsx)(n.code,{children:"turbo_unparse_flag()"}),", even if that value is an empty string (e.g., ",(0,a.jsx)(n.code,{children:'--my_custom_flag=""'}),")."]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>l});var t=s(6540);const a={},i=t.createContext(a);function r(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);