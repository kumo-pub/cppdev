"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[9820],{3505:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"foundamentals/strings/strcat","title":"String Concatenation","description":"turbo::strappend() for String Concatenation","source":"@site/docs/foundamentals/strings/strcat.mdx","sourceDirName":"foundamentals/strings","slug":"/foundamentals/strings/strcat","permalink":"/cppdev/docs/foundamentals/strings/strcat","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/foundamentals/strings/strcat.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"String Splitting","permalink":"/cppdev/docs/foundamentals/strings/split"},"next":{"title":"Joining Elements in Strings","permalink":"/cppdev/docs/foundamentals/strings/join"}}');var s=t(4848),o=t(8453);const i={},a="String Concatenation",c={},d=[{value:"<code>turbo::str_cat()</code> and <code>turbo::str_append()</code> for String Concatenation",id:"turbostr_cat-and-turbostr_append-for-string-concatenation",level:2},{value:"<code>turbo::str_cat()</code>",id:"turbostr_cat",level:3},{value:"<code>turbo::str_append()</code>",id:"turbostr_append",level:3}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"string-concatenation",children:"String Concatenation"})}),"\n",(0,s.jsxs)(n.h2,{id:"turbostr_cat-and-turbostr_append-for-string-concatenation",children:[(0,s.jsx)(n.code,{children:"turbo::str_cat()"})," and ",(0,s.jsx)(n.code,{children:"turbo::str_append()"})," for String Concatenation"]}),"\n",(0,s.jsx)(n.p,{children:"Most documentation on C++ string usage mentions that, unlike other languages, strings in C++ are mutable;\nhowever, modifying strings can be costly because strings typically contain large amounts of data, and many patterns involve creating temporary copies,\nwhich can incur significant overhead. Always look for ways to reduce the creation of such temporaries."}),"\n",(0,s.jsx)(n.p,{children:"For example, the following code is inefficient:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'// Inefficient code\nstd::string s1 = "A string";\ns1 = s1 + " another string";\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The assignment operator above creates a temporary string, copies ",(0,s.jsx)(n.code,{children:"s1"})," into this temporary string, concatenates the temporary string, and then assigns it back to ",(0,s.jsx)(n.code,{children:"s1"}),". Instead, use the optimized ",(0,s.jsx)(n.code,{children:"+="})," operator for such concatenations:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'// Efficient code\ns1 += " another string";\n'})}),"\n",(0,s.jsx)(n.p,{children:"A good compiler may be able to optimize the previous inefficient code. However, operations involving multiple concatenations usually cannot avoid temporaries:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'// Inefficient code\nstd::string s1 = "A string";\nstd::string another = " and another string";\ns1 += " and some other string" + another;\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Therefore, Turbo provides the ",(0,s.jsx)(n.code,{children:"turbo::str_cat()"})," and ",(0,s.jsx)(n.code,{children:"turbo::str_append()"})," functions for efficiently concatenating and appending strings. ",(0,s.jsx)(n.code,{children:"turbo::str_cat()"}),"\nand ",(0,s.jsx)(n.code,{children:"turbo::str_append()"})," are generally more efficient than operators like ",(0,s.jsx)(n.code,{children:"+="})," because they do not require creating temporary ",(0,s.jsx)(n.code,{children:"std::string"})," objects, and their memory is preallocated during string construction."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'// Inefficient code\nstd::string s1 = "A string";\nstd::string another = " and another string";\ns1 += " and some other string" + another;\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'// Efficient code\nstd::string s1 = "A string";\nstd::string another = " and another string";\nturbo::str_append(&s1, " and some other string", another);\n'})}),"\n",(0,s.jsxs)(n.p,{children:["For this reason, you should make a habit of choosing ",(0,s.jsx)(n.code,{children:"turbo::str_cat()"})," or ",(0,s.jsx)(n.code,{children:"turbo::str_append()"})," over using concatenation operators."]}),"\n",(0,s.jsx)(n.h3,{id:"turbostr_cat",children:(0,s.jsx)(n.code,{children:"turbo::str_cat()"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"turbo::str_cat()"})," merges an arbitrary number of strings or numbers into a single string, and is designed to be the fastest way to construct strings from a mix of raw C strings, ",(0,s.jsx)(n.code,{children:"turbo::string_view"})," elements, ",(0,s.jsx)(n.code,{children:"std::string"})," values, as well as boolean and numeric values. ",(0,s.jsx)(n.code,{children:"str_cat()"})," is generally more efficient for string concatenations involving multiple binary operators (e.g., ",(0,s.jsx)(n.code,{children:"a + b + c"})," or ",(0,s.jsx)(n.code,{children:"a += b + c"}),") because they avoid creating temporary string objects during string construction."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'// turbo::str_cat() can merge an arbitrary number of strings\nstd::string s1;\ns1 = turbo::str_cat("A string ", " another string", "yet another string");\n\n// str_cat() also can mix types, including std::string, string_view, literals,\n// and more.\nstd::string s1;\nstd::string s2 = "Foo";\nturbo::string_view sv1 = MyFunction();\ns1 = turbo::str_cat(s2, sv1, "a literal");\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"str_cat()"})," provides automatic formatting for the following types:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"std::string"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"turbo::string_view"})}),"\n",(0,s.jsx)(n.li,{children:"String literals"}),"\n",(0,s.jsx)(n.li,{children:"Numeric values (floats, ints)"}),"\n",(0,s.jsx)(n.li,{children:'Boolean values (convert to "0" or "1")'}),"\n",(0,s.jsxs)(n.li,{children:["Hex values through use of the ",(0,s.jsx)(n.code,{children:"turbo::Hex()"})," conversion function"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Floating-point values are converted to strings using the same format as the STL's ",(0,s.jsx)(n.code,{children:"std::basic_ostream::operator<<"}),', i.e., 6 digits of precision, using "e" format when the magnitude is less than ',(0,s.jsx)(n.code,{children:"0.001"})," or greater than or equal to ",(0,s.jsx)(n.code,{children:"1e+6"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["You can convert to hexadecimal output instead of decimal using the ",(0,s.jsx)(n.code,{children:"turbo::Hex"})," type. To do this, pass ",(0,s.jsx)(n.code,{children:"Hex(my_int)"})," as an argument to ",(0,s.jsx)(n.code,{children:"str_cat()"})," or ",(0,s.jsx)(n.code,{children:"str_append()"}),". You can specify a minimum hexadecimal field width using the ",(0,s.jsx)(n.code,{children:"turbo::PadSpec"})," enumeration, so the equivalent of ",(0,s.jsx)(n.code,{children:'StringPrintf("%04x", my_int)'})," is ",(0,s.jsx)(n.code,{children:"turbo::str_cat(turbo::Hex(my_int,turbo::kZeroPad4))"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"turbostr_append",children:(0,s.jsx)(n.code,{children:"turbo::str_append()"})}),"\n",(0,s.jsxs)(n.p,{children:["For clarity and performance, do not use ",(0,s.jsx)(n.code,{children:"turbo::str_cat()"})," when appending to a string. Use ",(0,s.jsx)(n.code,{children:"turbo::str_append()"})," instead. In particular, avoid any of the following (anti-)patterns:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"str.append(turbo::str_cat(...))\nstr += turbo::str_cat(...)\nstr = turbo::str_cat(str, ...)\n"})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var r=t(6540);const s={},o=r.createContext(s);function i(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);