"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[5564],{7807:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"foundamentals/testing/doct/stringification","title":"Stringification","description":"String Conversions","source":"@site/docs/foundamentals/testing/doct/stringification.mdx","sourceDirName":"foundamentals/testing/doct","slug":"/foundamentals/testing/doct/stringification","permalink":"/cppdev/docs/foundamentals/testing/doct/stringification","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/foundamentals/testing/doct/stringification.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Test Configuration","permalink":"/cppdev/docs/foundamentals/testing/doct/configuration"},"next":{"title":"Test Reporters","permalink":"/cppdev/docs/foundamentals/testing/doct/reporters"}}');var s=n(4848),i=n(8453);const r={},a="Stringification",c={},d=[{value:"String Conversions",id:"string-conversions",level:2},{value:"<code>operator&lt;&lt;</code> overload for <code>std::ostream</code>",id:"operator-overload-for-stdostream",level:2},{value:"<code>doctest::toString</code> overload",id:"doctesttostring-overload",level:2},{value:"<code>doctest::StringMaker&lt;T&gt;</code> specialisation",id:"docteststringmakert-specialisation",level:2},{value:"Translating Exceptions",id:"translated-exceptions",level:2}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"stringification",children:"Stringification"})}),"\n",(0,s.jsx)(t.h2,{id:"string-conversions",children:"String Conversions"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"doctest"})," needs to be able to convert types used in assertion and logging expressions into strings (for logging and reporting purposes).\nMost built-in types work out of the box, but you can tell ",(0,s.jsx)(t.strong,{children:"doctest"})," how to convert your own types (or other third-party types) into strings in three ways."]}),"\n",(0,s.jsxs)(t.p,{children:["For stringifying enums, check out ",(0,s.jsx)(t.a,{href:"https://github.com/doctest/doctest/issues/121",children:"this issue"}),"."]}),"\n",(0,s.jsxs)(t.h2,{id:"operator-overload-for-stdostream",children:[(0,s.jsx)(t.code,{children:"operator<<"})," overload for ",(0,s.jsx)(t.code,{children:"std::ostream"})]}),"\n",(0,s.jsx)(t.p,{children:"This is the standard way to provide string conversion in C++ - you may already have this for your own purposes. If you're unfamiliar with this idiom, it involves writing a free function of the form:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c++",children:"std::ostream& operator<< (std::ostream& os, const T& value) {\n    os << convertMyTypeToString(value);\n    return os;\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:['(where "T" is your type, and ',(0,s.jsx)(t.code,{children:"convertMyTypeToString"})," is where you write whatever code is needed to make your type printable - it doesn't have to be in a separate function)."]}),"\n",(0,s.jsx)(t.p,{children:"You should place this function in the same namespace as your type."}),"\n",(0,s.jsx)(t.p,{children:"Alternatively, you may prefer to write it as a member function:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c++",children:"std::ostream& T::operator<<(std::ostream& os) const {\n    os << convertMyTypeToString(*this);\n    return os;\n}\n"})}),"\n",(0,s.jsxs)(t.h2,{id:"doctesttostring-overload",children:[(0,s.jsx)(t.code,{children:"doctest::toString"})," overload"]}),"\n",(0,s.jsxs)(t.p,{children:["If you don't want to provide a ",(0,s.jsx)(t.code,{children:"operator<<``` overload, or you want to convert a type differently for testing purposes, you can provide a "}),"toString()",(0,s.jsx)(t.code,{children:" overload for your type that returns a ``doctest::String"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c++",children:"namespace user {\n    struct udt {};\n    \n    doctest::String toString(const udt& value) {\n        return convertMyTypeToString(value);\n    }\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Note that the function must be in the same namespace as your type. If the type is not in any namespace - then the overload should be in the global namespace. ",(0,s.jsx)(t.code,{children:"convertMyTypeToString"})," is where you write whatever code is needed to make your type printable."]}),"\n",(0,s.jsxs)(t.h2,{id:"docteststringmakert-specialisation",children:[(0,s.jsx)(t.code,{children:"doctest::StringMaker<T>"})," specialisation"]}),"\n",(0,s.jsxs)(t.p,{children:["In some cases, overloading ",(0,s.jsx)(t.code,{children:"toString"})," may not work as expected. Specialising ",(0,s.jsx)(t.code,{children:"StringMaker<T>"})," can give you more precise and reliable control - but at the cost of a little more code and complexity:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c++",children:"namespace doctest {\n    template<> struct StringMaker<T> {\n        static String convert(const T& value) {\n            return convertMyTypeToString(value);\n        }\n    };\n}\n"})}),"\n",(0,s.jsx)(t.h2,{id:"translated-exceptions",children:"Translating Exceptions"}),"\n",(0,s.jsxs)(t.p,{children:["By default, all exceptions derived from ",(0,s.jsx)(t.code,{children:"std::exception"})," will be converted to strings by calling the ",(0,s.jsx)(t.code,{children:"what()"})," method (which is also a C string). For exception types not derived from ",(0,s.jsx)(t.code,{children:"std::exception"})," - or if ",(0,s.jsx)(t.code,{children:"what()"})," does not return a suitable string - use ",(0,s.jsx)(t.code,{children:"REGISTER_EXCEPTION_TRANSLATOR"}),". This defines a function that takes the exception type and returns a ",(0,s.jsx)(t.code,{children:"doctest::String"}),". It can appear anywhere in the code - it does not have to be in the same translation unit. For example:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c++",children:"REGISTER_EXCEPTION_TRANSLATOR(MyType& ex) {\n    return doctest::String(ex.message());\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"Note that exceptions can be accepted without a reference, but this is considered bad practice in C++."}),"\n",(0,s.jsx)(t.p,{children:"Another way to register an exception translator is to do the following in some function before any tests are executed:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c++",children:"    // adding a lambda - the signature required is `doctest::String(exception_type)`\n    doctest::registerExceptionTranslator<int>([](int in){ return doctest::toString(in); });\n"})}),"\n",(0,s.jsx)(t.p,{children:"The order in which exception translators are registered can be controlled - simply call the explicit functions in the desired order, or list the exception translators with macros in a top-to-bottom fashion in a single translation unit - everything that is auto-registered in doctest works in a top-to-bottom fashion for a single translation unit (source file)."}),"\n",(0,s.jsxs)(t.p,{children:["You can also ",(0,s.jsx)(t.a,{href:"https://github.com/catchorg/Catch2/issues/539#issuecomment-454549904",children:"override the translation mechanism"})," for exceptions deriving from ``std::exception```."]}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Check out the ",(0,s.jsx)(t.a,{href:"https://github.com/doctest/doctest/blob/master/examples/all_features/stringification.cpp",children:(0,s.jsx)(t.strong,{children:"example"})})," which shows how to stringify ",(0,s.jsx)(t.code,{children:"std::vector<T>"})," and other types/exceptions."]}),"\n",(0,s.jsxs)(t.li,{children:["Note that when specialising ",(0,s.jsx)(t.code,{children:"StringMaker<T>"})," or overloading ",(0,s.jsx)(t.code,{children:"toString()"}),", the type ",(0,s.jsx)(t.code,{children:"String"})," is used - this is the string type ",(0,s.jsx)(t.strong,{children:"doctest"})," uses. ",(0,s.jsx)(t.code,{children:"std::string"})," is not an option because doctest would have to include the ",(0,s.jsx)(t.code,{children:"<string>"})," header."]}),"\n",(0,s.jsxs)(t.li,{children:["To support ",(0,s.jsx)(t.code,{children:"operator<<(std::ostream&..."})," stringification, the library has to provide a forward declaration of ",(0,s.jsx)(t.code,{children:"std::ostream"}),", which is what the library does - however it currently works on all tested compilers, but if the user wants 100%\nstandard compliance, then the ",(0,s.jsx)(t.a,{href:"/cppdev/docs/foundamentals/testing/doct/configuration#doctest_config_use_std_headers",children:(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.code,{children:"DOCTEST_CONFIG_USE_STD_HEADERS"})})})," identifier\ncan be used to force inclusion of the ",(0,s.jsx)(t.code,{children:"<iosfwd>"})," header. The reason the header is not included by default is that on MSVC (for\nexample) it drags in a whole lot of stuff - and after that header the translation unit has grown to 42k lines of C++ code - whereas\nClang and libc++ implement it very well and including ",(0,s.jsx)(t.code,{children:"<iosfwd>"})," results in 400 lines of code."]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var o=n(6540);const s={},i=o.createContext(s);function r(e){const t=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(i.Provider,{value:t},e.children)}}}]);