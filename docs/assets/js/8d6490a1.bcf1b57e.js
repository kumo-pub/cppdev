"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[6664],{7576:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"foundamentals/testing/doct/assertions","title":"Assertions","description":"Assertion Macros","source":"@site/docs/foundamentals/testing/doct/assertions.mdx","sourceDirName":"foundamentals/testing/doct","slug":"/foundamentals/testing/doct/assertions","permalink":"/cppdev/docs/foundamentals/testing/doct/assertions","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Quick Start","permalink":"/cppdev/docs/foundamentals/testing/doct/tutorial"},"next":{"title":"Test Cases","permalink":"/cppdev/docs/foundamentals/testing/doct/testcases"}}');var i=n(4848),o=n(8453);const r={},c="Assertions",a={},d=[{value:"Assertion Macros",id:"assertion-macros",level:2},{value:"Expression-Decomposing Asserts",id:"expression-decompositing-asserts",level:2},{value:"Binary and Unary Asserts",id:"binary-and-unary-asserts",level:2},{value:"Exceptions",id:"exceptions",level:2},{value:"Using Asserts Outside of a Testing Context",id:"using-asserts-out-of-a-testing-context",level:2},{value:"String Containment",id:"string-containment",level:2},{value:"Floating-Point Comparisons",id:"floating-point-comparisons",level:2},{value:"NaN Checking",id:"nan-checking",level:2}];function l(e){const s={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"assertions",children:"Assertions"})}),"\n",(0,i.jsx)(s.h2,{id:"assertion-macros",children:"Assertion Macros"}),"\n",(0,i.jsxs)(s.p,{children:["Most testing frameworks feature a large number of assertion macros to capture all possible forms of conditions (",(0,i.jsx)(s.code,{children:"_EQUALS"}),", ",(0,i.jsx)(s.code,{children:"_NOTEQUALS"}),", ",(0,i.jsx)(s.code,{children:"_GREATER_THAN"}),", etc.)."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"doctest"})," is different (though in this regard it is like ",(0,i.jsx)(s.a,{href:"https://github.com/catchorg/Catch2",children:(0,i.jsx)(s.strong,{children:"Catch"})}),"). Because it decomposes comparison expressions, most of these forms are simplified to one or two forms that you will use consistently. That said, there is still a rich set of helper macros available."]}),"\n",(0,i.jsx)(s.p,{children:"All assertion macros have 3 assertion severity levels:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"REQUIRE"})," - If the assertion fails, this level immediately exits the test case and marks the test case as failed."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"CHECK"})," - If the assertion fails, this level marks the test case as failed but continues executing the test case."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"WARN"})," - This level only prints a message when the assertion fails but does not mark the test case as failed."]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"CHECK"})," level is useful if you have a series of essentially orthogonal assertions and want to see all results instead of stopping at the first failure."]}),"\n",(0,i.jsxs)(s.p,{children:["All assertions evaluate the expression only once, and if they fail - the values are correctly ",(0,i.jsx)(s.a,{href:"/cppdev/docs/foundamentals/testing/doct/stringification",children:(0,i.jsx)(s.strong,{children:"stringified"})}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["Note that the ",(0,i.jsx)(s.code,{children:"REQUIRE"})," level of assertions uses exceptions to end the current test case. Using assertions of this level in destructors of user-defined classes can be dangerous - if the destructor is called during stack unwinding due to an exception and a ",(0,i.jsx)(s.code,{children:"REQUIRE"})," assertion fails, the program will terminate. Additionally, starting from C++11, all destructors are ",(0,i.jsx)(s.code,{children:"noexcept(true)"})," by default unless specified otherwise, so such an assertion will cause ",(0,i.jsx)(s.code,{children:"std::terminate()"})," to be called."]}),"\n",(0,i.jsx)(s.h2,{id:"expression-decompositing-asserts",children:"Expression-Decomposing Asserts"}),"\n",(0,i.jsxs)(s.p,{children:["They take the form of ",(0,i.jsx)(s.code,{children:"CHECK(expression)"})," (the same applies to ",(0,i.jsx)(s.code,{children:"REQUIRE"})," and ",(0,i.jsx)(s.code,{children:"WARN"}),")."]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"expression"})," can be a binary comparison such as ",(0,i.jsx)(s.code,{children:"a == b"}),", or a single-condition check such as ",(0,i.jsx)(s.code,{children:"vec.isEmpty()"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["If an exception is thrown, it is caught, reported, and counted as a failure (unless the assertion level is ",(0,i.jsx)(s.code,{children:"WARN"}),")."]}),"\n",(0,i.jsx)(s.p,{children:"Examples:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-c++",children:"CHECK(flags == state::alive | state::moving);\nCHECK(thisReturnsTrue());\nREQUIRE(i < 42);\n"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Negative assertions - ",(0,i.jsx)(s.code,{children:"<LEVEL>_FALSE(expression)"})," - Evaluates the expression and records the ",(0,i.jsx)(s.em,{children:"logical NOT"})," of the result."]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["These forms exist to solve the problem where ",(0,i.jsx)(s.code,{children:"!"}),"-prefixed expressions cannot be decomposed correctly."]}),"\n",(0,i.jsx)(s.p,{children:"Example:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-c++",children:"REQUIRE_FALSE(thisReturnsFalse());\n"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Using the ",(0,i.jsx)(s.a,{href:"/cppdev/docs/foundamentals/testing/doct/configuration#doctest_config_super_fast_asserts",children:(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"DOCTEST_CONFIG_SUPER_FAST_ASSERTS"})})})," configuration option can make assertions compile up to ",(0,i.jsx)(s.a,{href:"/cppdev/docs/foundamentals/testing/doct/benchmarks#cost-of-an-assertion-macro",children:(0,i.jsx)(s.strong,{children:"31-63%"})})," faster!"]}),"\n",(0,i.jsxs)(s.li,{children:["These assertions also have a ",(0,i.jsx)(s.code,{children:"_MESSAGE"})," form - such as ",(0,i.jsx)(s.code,{children:"CHECK_MESSAGE(expression, message)"}),", which is essentially a scoped ",(0,i.jsx)(s.a,{href:"/cppdev/docs/foundamentals/testing/doct/logging#info",children:(0,i.jsx)(s.strong,{children:"INFO()"})})," logging macro paired with a ",(0,i.jsx)(s.code,{children:"CHECK"})," macro - meaning the message will only be relevant to that assertion. Binary/unary assertions do not have this variant yet."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"Example:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-c++",children:'INFO("this is relevant to all asserts, and here is some var: ", local);\n\nCHECK_MESSAGE(a < b, "relevant only to this assert ", other_local, " more text!");\n\nCHECK(b < c); // here only the first INFO() will be relevant\n'})}),"\n",(0,i.jsxs)(s.p,{children:["For more information about the ",(0,i.jsx)(s.code,{children:"INFO()"})," macro, visit the ",(0,i.jsx)(s.a,{href:"/cppdev/docs/foundamentals/testing/doct/logging",children:"Logging page"}),"."]}),"\n",(0,i.jsx)(s.h2,{id:"binary-and-unary-asserts",children:"Binary and Unary Asserts"}),"\n",(0,i.jsx)(s.p,{children:"These assertions do not use templates to decompose comparison expressions into left and right parts."}),"\n",(0,i.jsxs)(s.p,{children:["They have the same guarantees as expression-decomposing assertions but compile ",(0,i.jsx)(s.a,{href:"/cppdev/docs/foundamentals/testing/doct/benchmarks#cost-of-an-assertion-macro",children:(0,i.jsx)(s.strong,{children:"57-68%"})})," faster."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"<LEVEL>"})," is one of three possible values: ",(0,i.jsx)(s.code,{children:"REQUIRE"}),"/",(0,i.jsx)(s.code,{children:"CHECK"}),"/",(0,i.jsx)(s.code,{children:"WARN"}),"."]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"<LEVEL>_EQ(left, right)"})," - ",(0,i.jsx)(s.code,{children:"<LEVEL>(left == right)"})]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"<LEVEL>_NE(left, right)"})," - ",(0,i.jsx)(s.code,{children:"<LEVEL>(left != right)"})]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"<LEVEL>_GT(left, right)"})," - ",(0,i.jsx)(s.code,{children:"<LEVEL>(left >  right)"})]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"<LEVEL>_LT(left, right)"})," - ",(0,i.jsx)(s.code,{children:"<LEVEL>(left <  right)"})]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"<LEVEL>_GE(left, right)"})," - ",(0,i.jsx)(s.code,{children:"<LEVEL>(left >= right)"})]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"<LEVEL>_LE(left, right)"})," - ",(0,i.jsx)(s.code,{children:"<LEVEL>(left <= right)"})]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"<LEVEL>_UNARY(expr)"})," - ",(0,i.jsx)(s.code,{children:"<LEVEL>(expr)"})]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"<LEVEL>_UNARY_FALSE(expr)"})," - ",(0,i.jsx)(s.code,{children:"<LEVEL>_FALSE(expr)"})]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["Using the ",(0,i.jsx)(s.a,{href:"/cppdev/docs/foundamentals/testing/doct/configuration#doctest_config_super_fast_asserts",children:(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"DOCTEST_CONFIG_SUPER_FAST_ASSERTS"})})})," configuration option can make binary assertions compile up to ",(0,i.jsx)(s.a,{href:"/cppdev/docs/foundamentals/testing/doct/benchmarks#cost-of-an-assertion-macro",children:(0,i.jsx)(s.strong,{children:"84-91%"})})," faster!"]}),"\n",(0,i.jsx)(s.h2,{id:"exceptions",children:"Exceptions"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"<LEVEL>"})," is one of three possible values: ",(0,i.jsx)(s.code,{children:"REQUIRE"}),"/",(0,i.jsx)(s.code,{children:"CHECK"}),"/",(0,i.jsx)(s.code,{children:"WARN"}),"."]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"<LEVEL>_THROWS(expression)"})}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"Expects an exception (of any type) to be thrown during the evaluation of the expression."}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"<LEVEL>_THROWS_AS(expression, exception_type)"})}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["Expects an exception of the ",(0,i.jsx)(s.em,{children:"specified type"})," to be thrown during the evaluation of the expression."]}),"\n",(0,i.jsxs)(s.p,{children:["Note that ",(0,i.jsx)(s.code,{children:"const"})," and ",(0,i.jsx)(s.code,{children:"&"})," are added to the exception type if missing (users should not care about this) - the standard practice for exceptions in C++ is to ",(0,i.jsx)(s.code,{children:"throw by value, catch by (const) reference"}),"."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-c++",children:"CHECK_THROWS_AS(func(), const std::exception&);\nCHECK_THROWS_AS(func(), std::exception); // same as above\n"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"<LEVEL>_THROWS_WITH(expression, c_string)"})}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["Expects an exception to be thrown during the evaluation of the expression, which successfully converts to the ",(0,i.jsx)(s.em,{children:"specified c-string"})," (see ",(0,i.jsx)(s.a,{href:"/cppdev/docs/foundamentals/testing/doct/stringification#translated-exceptions",children:(0,i.jsx)(s.strong,{children:"Translated Exceptions"})}),")."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-c++",children:'CHECK_THROWS_WITH(func(), "invalid operation!");\n'})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"<LEVEL>_THROWS_WITH_AS(expression, c_string, exception_type)"})}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["This is a combination of ",(0,i.jsx)(s.code,{children:"<LEVEL>_THROWS_WITH"})," and ",(0,i.jsx)(s.code,{children:"<LEVEL>_THROWS_AS"}),"."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-c++",children:'CHECK_THROWS_WITH_AS(func(), "invalid operation!", std::runtime_error);\n'})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"<LEVEL>_NOTHROW(expression)"})}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"Expects no exception to be thrown during the evaluation of the expression."}),"\n",(0,i.jsxs)(s.p,{children:["Note that these assertions also have a ",(0,i.jsx)(s.code,{children:"_MESSAGE"})," form - such as ",(0,i.jsx)(s.code,{children:"CHECK_THROWS_MESSAGE(expression, message)"})," - these work the same way as the ",(0,i.jsx)(s.code,{children:"_MESSAGE"})," forms of the regular macros (",(0,i.jsx)(s.code,{children:'CHECK_MESSAGE(a < b, "this should not fail")'}),") as described earlier."]}),"\n",(0,i.jsxs)(s.p,{children:["Also note that a singular expression is required, meaning a function call, an IIFE (immediately invoked function expression) like ",(0,i.jsx)(s.code,{children:"[&]() { throw 1; }()"})," (note the ",(0,i.jsx)(s.code,{children:"()"})," at the end), or similar. Passing a function or lambda alone will ",(0,i.jsx)(s.strong,{children:"not work"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["One can use the ",(0,i.jsx)(s.a,{href:"/cppdev/docs/foundamentals/testing/doct/configuration#doctest_config_void_cast_expressions",children:(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"DOCTEST_CONFIG_VOID_CAST_EXPRESSIONS"})})}),' configuration identifier to cast expressions in these assertions to void to avoid warnings or other issues - for example, "nodiscard statements whose results are checked". However, this will limit the ability to write entire ',(0,i.jsx)(s.code,{children:"{}"})," code blocks as expressions (or multiple statements), but a simple lambda can be used in such cases. This should have been the default behavior from day one of the framework..."]}),"\n",(0,i.jsx)(s.h2,{id:"using-asserts-out-of-a-testing-context",children:"Using Asserts Outside of a Testing Context"}),"\n",(0,i.jsxs)(s.p,{children:["Assertions can be used outside of a testing context (in code not called from ",(0,i.jsx)(s.code,{children:"TEST_CASE()"}),") instead of ",(0,i.jsx)(s.a,{href:"https://en.cppreference.com/w/cpp/error/assert",children:(0,i.jsx)(s.code,{children:"assert()"})}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["It is still necessary to create a ",(0,i.jsx)(s.code,{children:"doctest::Context"})," object somewhere and set it as the default using the ",(0,i.jsx)(s.code,{children:"setAsDefaultForAssertsOutOfTestCases()"})," method before the assertions can work. A handler can be registered by calling the ",(0,i.jsx)(s.code,{children:"setAssertHandler()"})," method on the context object. If no handler is set, ",(0,i.jsx)(s.code,{children:"std::abort()"})," is called on failure."]}),"\n",(0,i.jsxs)(s.p,{children:["Results are best when using the ",(0,i.jsx)(s.a,{href:"/cppdev/docs/foundamentals/testing/doct/configuration#doctest_config_super_fast_asserts",children:(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"DOCTEST_CONFIG_SUPER_FAST_ASSERTS"})})})," configuration identifier."]}),"\n",(0,i.jsxs)(s.p,{children:["Check out the ",(0,i.jsx)(s.a,{href:"https://github.com/doctest/doctest/blob/master/examples/all_features/asserts_used_outside_of_tests.cpp",children:(0,i.jsx)(s.strong,{children:"example"})})," showing how this is done.\nFor more information, see the ",(0,i.jsx)(s.a,{href:"https://github.com/doctest/doctest/issues/114",children:(0,i.jsx)(s.strong,{children:"feature request issue"})}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["Currently, ",(0,i.jsx)(s.a,{href:"/cppdev/docs/foundamentals/testing/doct/logging",children:(0,i.jsx)(s.strong,{children:"logging macros"})})," cannot be used for additional context with asserts outside of test runs. This means the ``_MESSAGE```` variants of assertions are also unavailable - since they are just a packaged ",(0,i.jsx)(s.code,{children:"INFO()"})," followed by an assertion."]}),"\n",(0,i.jsx)(s.h2,{id:"string-containment",children:"String Containment"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"doctest::Contains"})," can be used to check if the string passed to its constructor is contained within the string it is compared against. Here is a simple example:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-c++",children:'REQUIRE("foobar" == doctest::Contains("foo"));\n'})}),"\n",(0,i.jsxs)(s.p,{children:["It can also be used with the ",(0,i.jsx)(s.code,{children:"THROWS_WITH"})," family of assertion macros to check if the thrown exception (when ",(0,i.jsx)(s.a,{href:"/cppdev/docs/foundamentals/testing/doct/stringification#translated-exceptions",children:"converted to a string"}),") contains the provided string. Here is another example:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-c++",children:'REQUIRE_THROWS_WITH(func(), doctest::Contains("Oopsie"));\n'})}),"\n",(0,i.jsx)(s.h2,{id:"floating-point-comparisons",children:"Floating-Point Comparisons"}),"\n",(0,i.jsx)(s.p,{children:"When comparing floating-point numbers - especially if at least one of them has been computed - great care must be taken to allow for rounding errors and imprecise representations."}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"doctest"})," provides a way to perform tolerant comparisons of floating-point values by using a wrapper class called ",(0,i.jsx)(s.code,{children:"doctest::Approx"}),".\n",(0,i.jsx)(s.code,{children:"doctest::Approx"})," can be used on either side of a comparison expression. It overloads the comparison operators to take relative tolerance into account. Here is a simple example:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-c++",children:"REQUIRE(performComputation() == doctest::Approx(2.1));\n"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"doctest"})," provides a way to perform tolerant comparisons of floating-point values by using a wrapper class called ",(0,i.jsx)(s.code,{children:"doctest::Approx"}),". ",(0,i.jsx)(s.code,{children:"doctest::Approx"})," can be used on either side of a comparison expression. Here is a simple example:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-c++",children:"REQUIRE(22.0/7 == doctest::Approx(3.141).epsilon(0.01)); // allow for a 1% error\n"})}),"\n",(0,i.jsxs)(s.p,{children:["When working with very large or very small numbers, it can be useful to specify a scale, which can be done by calling the ",(0,i.jsx)(s.code,{children:"scale()"})," method on an instance of ",(0,i.jsx)(s.code,{children:"doctest::Approx"}),"."]}),"\n",(0,i.jsx)(s.h2,{id:"nan-checking",children:"NaN Checking"}),"\n",(0,i.jsx)(s.p,{children:"Two NaN floating-point numbers do not compare equal. This makes checking for NaN when capturing values very inconvenient."}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-c++",children:"CHECK(std::isnan(performComputation())); // does not capture the result of the call\n"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"doctest"})," provides ",(0,i.jsx)(s.code,{children:"doctest::IsNaN"}),", which can be used in assertions to check if a floating-point (or any other floating-point primitive type) is indeed NaN, outputting the actual value if it is not."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-c++",children:"CHECK(doctest::IsNaN(performComputation())); // captures the result!\n"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"IsNaN"})," is able to capture the value even when negated with ",(0,i.jsx)(s.code,{children:"!"}),"."]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Check out the ",(0,i.jsx)(s.a,{href:"https://github.com/doctest/doctest/blob/master/examples/all_features/alternative_macros.cpp",children:(0,i.jsx)(s.strong,{children:"example"})})," showing many of these macros"]}),"\n",(0,i.jsxs)(s.li,{children:["Do not wrap assertion macros in ",(0,i.jsx)(s.code,{children:"try"}),"/",(0,i.jsx)(s.code,{children:"catch"})," blocks - the REQUIRE macro throws an exception to end test case execution!"]}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>r,x:()=>c});var t=n(6540);const i={},o=t.createContext(i);function r(e){const s=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(o.Provider,{value:s},e.children)}}}]);