"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[4725],{6109:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"retrieve/bitmap/roaring","title":"CRoaring","description":"CRoaring, also known as Roaring Bitmaps, is a compressed, dynamic, SIMD-optimized bitmap library widely used in production systems such as ClickHouse, Druid, Lucene, and Pinot. Its core strength lies in efficiently handling sparse and mixed-density datasets while providing dynamic operations (set / unset) and fast logical operations (AND / OR / XOR / NOT).","source":"@site/docs/retrieve/bitmap/roaring.mdx","sourceDirName":"retrieve/bitmap","slug":"/retrieve/bitmap/roaring","permalink":"/cppdev/docs/retrieve/bitmap/roaring","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Industrial Bitmap Solutions in C++","permalink":"/cppdev/docs/retrieve/bitmap/"},"next":{"title":"Library Selection","permalink":"/cppdev/docs/retrieve/vector/"}}');var r=i(4848),t=i(8453);const a={},o="CRoaring",d={},l=[{value:"Key Features",id:"key-features",level:3},{value:"Typical Use Cases",id:"typical-use-cases",level:3},{value:"C++ Example",id:"c-example",level:3}];function c(e){const n={code:"code",h1:"h1",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"croaring",children:"CRoaring"})}),"\n",(0,r.jsxs)(n.p,{children:["CRoaring, also known as Roaring Bitmaps, is a ",(0,r.jsx)(n.strong,{children:"compressed, dynamic, SIMD-optimized bitmap library"})," widely used in production systems such as ClickHouse, Druid, Lucene, and Pinot. Its core strength lies in efficiently handling ",(0,r.jsx)(n.strong,{children:"sparse and mixed-density datasets"})," while providing ",(0,r.jsx)(n.strong,{children:"dynamic operations"})," (",(0,r.jsx)(n.code,{children:"set"})," / ",(0,r.jsx)(n.code,{children:"unset"}),") and fast logical operations (AND / OR / XOR / NOT)."]}),"\n",(0,r.jsxs)(n.p,{children:["The library supports ",(0,r.jsx)(n.strong,{children:"serialization"}),", enabling cross-platform storage, fast cold-start initialization, and network transmission. Its block-based container structure allows hybrid density handling and ",(0,r.jsx)(n.strong,{children:"extendable rank/select operations"}),", making it suitable for large-scale analytical and real-time systems."]}),"\n",(0,r.jsx)(n.h3,{id:"key-features",children:"Key Features"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Compressed storage"}),": Efficiently handles sparse and dense regions within the same bitmap."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Dynamic operations"}),": Supports ",(0,r.jsx)(n.code,{children:"set"}),", ",(0,r.jsx)(n.code,{children:"unset"}),", ",(0,r.jsx)(n.code,{children:"flip"}),", and bulk operations."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"SIMD acceleration"}),": Optimized for modern CPUs for high-performance bitwise operations."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Serialization"}),": Portable binary format for storage and transmission."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Rank/Select support"}),": Partial via extensions, useful for counting and positional queries."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Hybrid density handling"}),": Automatically adapts internal containers based on density."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"typical-use-cases",children:"Typical Use Cases"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["High-performance filtering and analytics in ",(0,r.jsx)(n.strong,{children:"OLAP systems"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Large-scale event tracking"})," or exposure logging"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sparse indexing"})," in search engines or database engines"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Bitset-based set operations"})," in recommendation or CTR systems"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"c-example",children:"C++ Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'#include <roaring/roaring.hh>\n#include <iostream>\n\nint main() {\n    // Create a Roaring bitmap\n    Roaring r1;\n    r1.add(1);\n    r1.add(2);\n    r1.add(1000);\n\n    // Create another bitmap\n    Roaring r2;\n    r2.add(2);\n    r2.add(3);\n    r2.add(1000);\n\n    // Union of two bitmaps\n    Roaring r_union = r1 | r2;\n\n    // Intersection\n    Roaring r_intersection = r1 & r2;\n\n    // Serialize to a buffer\n    size_t serialized_size = r_union.getSizeInBytes();\n    char* buffer = new char[serialized_size];\n    r_union.write(buffer);\n\n    // Deserialize from buffer\n    Roaring r_loaded = Roaring::read(buffer);\n    delete[] buffer;\n\n    // Iterate over set bits\n    std::cout << "Bits in union: ";\n    for (uint32_t value : r_loaded) {\n        std::cout << value << " ";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Explanation:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Roaring::add"})," sets individual bits."]}),"\n",(0,r.jsxs)(n.li,{children:["Bitwise operations like ",(0,r.jsx)(n.code,{children:"|"})," (union) and ",(0,r.jsx)(n.code,{children:"&"})," (intersection) are provided."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"write"})," and ",(0,r.jsx)(n.code,{children:"read"})," enable ",(0,r.jsx)(n.strong,{children:"serialization"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["The bitmap supports ",(0,r.jsx)(n.strong,{children:"range-based iteration"})," over set bits."]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var s=i(6540);const r={},t=s.createContext(r);function a(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);