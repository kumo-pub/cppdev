"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[7955],{2599:(e,r,s)=>{s.r(r),s.d(r,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"store/format/avro","title":"Apache Avro","description":"Type: Row-based, schema-driven serialization format","source":"@site/docs/store/format/avro.mdx","sourceDirName":"store/format","slug":"/store/format/avro","permalink":"/cppdev/docs/store/format/avro","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Apache Avro"},"sidebar":"tutorialSidebar","previous":{"title":"Apache Arrow / Feather","permalink":"/cppdev/docs/store/format/arrow"},"next":{"title":"Substrait","permalink":"/cppdev/docs/store/format/substrait"}}');var i=s(4848),t=s(8453);const o={title:"Apache Avro"},a="Apache Avro",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Key Features",id:"key-features",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Example Benchmarks",id:"example-benchmarks",level:3},{value:"Integration &amp; Use Cases",id:"integration--use-cases",level:2},{value:"Operational Notes",id:"operational-notes",level:2},{value:"References",id:"references",level:2}];function d(e){const r={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.header,{children:(0,i.jsx)(r.h1,{id:"apache-avro",children:"Apache Avro"})}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Type"}),": Row-based, schema-driven serialization format"]}),"\n",(0,i.jsx)(r.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(r.p,{children:["Apache Avro is a ",(0,i.jsx)(r.strong,{children:"row-oriented serialization system"})," designed for efficient data serialization, RPC, and streaming. Unlike columnar formats like Parquet or Arrow, Avro stores records row by row, making it optimal for write-heavy workloads, streaming ingestion, and row-level operations."]}),"\n",(0,i.jsxs)(r.p,{children:["Avro relies on ",(0,i.jsx)(r.strong,{children:"schemas"})," to define the structure of the data. The schema is stored ",(0,i.jsx)(r.strong,{children:"alongside the data"}),", allowing self-describing files and facilitating schema evolution without breaking compatibility."]}),"\n",(0,i.jsx)(r.h2,{id:"key-features",children:"Key Features"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Row-oriented storage"}),": Each record is written contiguously, enabling fast writes and row-level access."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Schema-based"}),": All Avro data must adhere to a JSON-based schema. Readers can automatically handle missing fields or evolving schemas."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Dynamic schema evolution"}),": Supports adding, removing, or changing fields with backward/forward compatibility."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Data Types"}),": Supports primitive types (int, long, float, double, string, bytes), complex types (records, arrays, maps, unions, enums, fixed)."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Serialization / RPC"}),": Native support for binary encoding, JSON encoding, and integration with RPC frameworks."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Compression"}),": Supports built-in codecs like ",(0,i.jsx)(r.code,{children:"deflate"})," and ",(0,i.jsx)(r.code,{children:"snappy"})," for on-disk storage."]}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Write throughput"}),": Optimized for sequential writes in append-only or streaming contexts."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Read performance"}),": Efficient for row-level access; less cache-friendly for analytical workloads compared to columnar formats."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Compression"}),": Binary encoding reduces file size; ",(0,i.jsx)(r.code,{children:"snappy"})," provides good speed/compression trade-off."]}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"example-benchmarks",children:"Example Benchmarks"}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Operation"}),(0,i.jsx)(r.th,{children:"Avro (binary)"}),(0,i.jsx)(r.th,{children:"JSON"}),(0,i.jsx)(r.th,{children:"Notes"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"10M rows \xd7 10 columns write"}),(0,i.jsx)(r.td,{children:"~1.2 s"}),(0,i.jsx)(r.td,{children:"~15 s"}),(0,i.jsx)(r.td,{children:"Binary encoding greatly improves throughput"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"10M rows \xd7 10 columns read"}),(0,i.jsx)(r.td,{children:"~0.9 s"}),(0,i.jsx)(r.td,{children:"~12 s"}),(0,i.jsx)(r.td,{children:"Row-oriented access favors streaming"})]})]})]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"Benchmarks vary based on JVM/Python/C++ implementation and compression codec."}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"integration--use-cases",children:"Integration & Use Cases"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Streaming ingestion"}),": Kafka, Flink, and other stream processing systems commonly use Avro for message serialization."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Data pipelines"}),": Ideal for write-heavy ETL tasks where row-level atomicity matters."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"RPC communication"}),": Schema evolution makes Avro suitable for long-lived services with changing message structures."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Storage"}),": Used for compact, self-describing binary files, especially when frequent schema evolution is expected."]}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"operational-notes",children:"Operational Notes"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Schema management"}),": Ensure schema registry (e.g., Confluent Schema Registry) for production pipelines."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"File splitting"}),": Avro files are splittable, which is important for parallel processing frameworks like Hadoop or Spark."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Compression trade-offs"}),": ",(0,i.jsx)(r.code,{children:"snappy"})," is fast, ",(0,i.jsx)(r.code,{children:"deflate"})," reduces size more but uses more CPU."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Streaming vs batch"}),": Avro excels in streaming; for analytical queries on large datasets, columnar formats like Parquet are preferred."]}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"references",children:"References"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://avro.apache.org/",children:"Apache Avro Official"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://avro.apache.org/docs/current/spec.html#Binary_encoding",children:"Avro Binary Encoding Specification"})}),"\n"]})]})}function h(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,r,s)=>{s.d(r,{R:()=>o,x:()=>a});var n=s(6540);const i={},t=n.createContext(i);function o(e){const r=n.useContext(t);return n.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(t.Provider,{value:r},e.children)}}}]);