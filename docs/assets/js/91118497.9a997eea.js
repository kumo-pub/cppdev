"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[7939],{8364:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>m,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"foundamentals/json/stream","title":"Streams","description":"In Merak, merak::Stream is a concept (referring to C++ concepts) used for reading and writing JSON. Here we first introduce how to use the various streams provided by Merak, then explain how to define custom streams yourself.","source":"@site/docs/foundamentals/json/stream.mdx","sourceDirName":"foundamentals/json","slug":"/foundamentals/json/stream","permalink":"/cppdev/docs/foundamentals/json/stream","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/foundamentals/json/stream.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Pointer","permalink":"/cppdev/docs/foundamentals/json/pointer"},"next":{"title":"Encoding","permalink":"/cppdev/docs/foundamentals/json/encoding"}}');var s=r(4848),a=r(8453);const i={},d="Streams",o={},c=[{value:"StringStream (Input)",id:"StringStream",level:2},{value:"StringBuffer (Output)",id:"StringBuffer",level:2},{value:"FileReadStream (Input)",id:"FileReadStream",level:2},{value:"FileWriteStream (Output)",id:"FileWriteStream",level:2},{value:"IStreamWrapper",id:"IStreamWrapper",level:2},{value:"OStreamWrapper",id:"OStreamWrapper",level:2},{value:"EncodedInputStream",id:"EncodedInputStream",level:2},{value:"EncodedOutputStream",id:"EncodedOutputStream",level:2},{value:"AutoUTFInputStream",id:"AutoUTFInputStream",level:2},{value:"AutoUTFOutputStream",id:"AutoUTFOutputStream",level:2},{value:"Example: istream Wrapper",id:"ExampleIStreamWrapper",level:2},{value:"Example: ostream Wrapper",id:"ExampleOStreamWrapper",level:2}];function l(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"streams",children:"Streams"})}),"\n",(0,s.jsxs)(n.p,{children:["In Merak, ",(0,s.jsx)(n.code,{children:"merak::json::Stream"})," is a concept (referring to C++ concepts) used for reading and writing JSON. Here we first introduce how to use the various streams provided by Merak, then explain how to define custom streams yourself."]}),"\n",(0,s.jsx)(n.p,{children:"[TOC]"}),"\n",(0,s.jsx)(n.h1,{id:"MemoryStreams",children:"Memory Streams"}),"\n",(0,s.jsx)(n.p,{children:"Memory streams store JSON in memory."}),"\n",(0,s.jsx)(n.h2,{id:"StringStream",children:"StringStream (Input)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"StringStream"})," is the most basic input stream, representing a complete, read-only JSON stored in memory. It is defined in ",(0,s.jsx)(n.code,{children:"merak/json.h"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include "merak/json/document.h" // Includes "merak/json.h"\n\nusing namespace merak::json;\n\n// ...\nconst char json[] = "[1, 2, 3, 4]";\nStringStream s(json);\n\nDocument d;\nd.ParseStream(s);\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Since this is a very common usage pattern, RapidJSON provides ",(0,s.jsx)(n.code,{children:"Document::Parse(const char*)"})," to do exactly the same thing:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'// ...\nconst char json[] = "[1, 2, 3, 4]";\nDocument d;\nd.Parse(json);\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Note that ",(0,s.jsx)(n.code,{children:"StringStream"})," is a typedef of ",(0,s.jsx)(n.code,{children:"GenericStringStream<UTF8<> >"}),"; users can use other encoding classes to represent the character set used by the stream."]}),"\n",(0,s.jsx)(n.h2,{id:"StringBuffer",children:"StringBuffer (Output)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"StringBuffer"})," is a simple output stream. It allocates a memory buffer for writing the entire JSON. You can retrieve this buffer using ",(0,s.jsx)(n.code,{children:"GetString()"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include "merak/json/stringbuffer.h"\n#include <merak/json/writer.h>\n\nStringBuffer buffer;\nWriter<StringBuffer> writer(buffer);\nd.Accept(writer);\n\nconst char* output = buffer.GetString();\n'})}),"\n",(0,s.jsx)(n.p,{children:"When the buffer overflows, it will automatically increase its capacity. The default capacity is 256 characters (256 bytes for UTF8, 512 bytes for UTF16, etc.). Users can provide a custom allocator and initial capacity:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"StringBuffer buffer1(0, 1024); // Use its own allocator, initial size = 1024\nStringBuffer buffer2(allocator, 1024);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If no allocator is specified, ",(0,s.jsx)(n.code,{children:"StringBuffer"})," will instantiate an internal allocator on its own."]}),"\n",(0,s.jsxs)(n.p,{children:["Similarly, ",(0,s.jsx)(n.code,{children:"StringBuffer"})," is a typedef of ",(0,s.jsx)(n.code,{children:"GenericStringBuffer<UTF8<> >"}),"."]}),"\n",(0,s.jsx)(n.h1,{id:"FileStreams",children:"File Streams"}),"\n",(0,s.jsxs)(n.p,{children:["When parsing a JSON from a file, you can read the entire JSON into memory and use the ",(0,s.jsx)(n.code,{children:"StringStream"})," described above."]}),"\n",(0,s.jsxs)(n.p,{children:["However, if the JSON is large or memory is limited, you can use ",(0,s.jsx)(n.code,{children:"FileReadStream"})," instead. It only reads a portion of the file into a buffer and parses that portion. When all characters in the buffer are consumed, it reads the next portion from the file."]}),"\n",(0,s.jsx)(n.h2,{id:"FileReadStream",children:"FileReadStream (Input)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"FileReadStream"})," reads a file via a ",(0,s.jsx)(n.code,{children:"FILE"})," pointer. Users need to provide a buffer:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include "merak/json/filereadstream.h"\n#include <cstdio>\n\nusing namespace merak::json;\n\nFILE* fp = fopen("big.json", "rb"); // Use "r" on non-Windows platforms\n\nchar readBuffer[65536];\nFileReadStream is(fp, readBuffer, sizeof(readBuffer));\n\nDocument d;\nd.ParseStream(is);\n\nfclose(fp);\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Unlike ",(0,s.jsx)(n.code,{children:"StringStreams"}),", ",(0,s.jsx)(n.code,{children:"FileReadStream"})," is a byte stream and does not handle encoding. If the file is not encoded in UTF-8, you can wrap the byte stream with ",(0,s.jsx)(n.code,{children:"EncodedInputStream"})," (discussed shortly)."]}),"\n",(0,s.jsxs)(n.p,{children:["In addition to reading files, users can use ",(0,s.jsx)(n.code,{children:"FileReadStream"})," to read from ",(0,s.jsx)(n.code,{children:"stdin"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"FileWriteStream",children:"FileWriteStream (Output)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"FileWriteStream"})," is a buffered output stream with usage very similar to ",(0,s.jsx)(n.code,{children:"FileReadStream"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include "merak/json/filewritestream.h"\n#include <merak/json/writer.h>\n#include <cstdio>\n\nusing namespace merak::json;\n\nDocument d;\nd.Parse(json);\n// ...\n\nFILE* fp = fopen("output.json", "wb"); // Use "w" on non-Windows platforms\n\nchar writeBuffer[65536];\nFileWriteStream os(fp, writeBuffer, sizeof(writeBuffer));\n\nWriter<FileWriteStream> writer(os);\nd.Accept(writer);\n\nfclose(fp);\n'})}),"\n",(0,s.jsxs)(n.p,{children:["It can also direct output to ",(0,s.jsx)(n.code,{children:"stdout"}),"."]}),"\n",(0,s.jsx)(n.h1,{id:"iostreamWrapper",children:"iostream Wrappers"}),"\n",(0,s.jsxs)(n.p,{children:["Based on user requests, RapidJSON provides official wrapper classes for ",(0,s.jsx)(n.code,{children:"std::basic_istream"})," and ",(0,s.jsx)(n.code,{children:"std::basic_ostream"}),". However, note that their performance is significantly lower than the other streams mentioned above."]}),"\n",(0,s.jsx)(n.h2,{id:"IStreamWrapper",children:"IStreamWrapper"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"IStreamWrapper"})," wraps any class inherited from ",(0,s.jsx)(n.code,{children:"std::istream"})," (e.g., ",(0,s.jsx)(n.code,{children:"std::istringstream"}),", ",(0,s.jsx)(n.code,{children:"std::stringstream"}),", ",(0,s.jsx)(n.code,{children:"std::ifstream"}),", ",(0,s.jsx)(n.code,{children:"std::fstream"}),") into a Merak input stream:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include <merak/json/document.h>\n#include <merak/json/istreamwrapper.h>\n#include <fstream>\n\nusing namespace merak::json;\nusing namespace std;\n\nifstream ifs("test.json");\nIStreamWrapper isw(ifs);\n\nDocument d;\nd.ParseStream(isw);\n'})}),"\n",(0,s.jsxs)(n.p,{children:["For classes inherited from ",(0,s.jsx)(n.code,{children:"std::wistream"}),", use ",(0,s.jsx)(n.code,{children:"WIStreamWrapper"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"OStreamWrapper",children:"OStreamWrapper"}),"\n",(0,s.jsxs)(n.p,{children:["Similarly, ",(0,s.jsx)(n.code,{children:"OStreamWrapper"})," wraps any class inherited from ",(0,s.jsx)(n.code,{children:"std::ostream"})," (e.g., ",(0,s.jsx)(n.code,{children:"std::ostringstream"}),", ",(0,s.jsx)(n.code,{children:"std::stringstream"}),", ",(0,s.jsx)(n.code,{children:"std::ofstream"}),", ",(0,s.jsx)(n.code,{children:"std::fstream"}),") into a Merak output stream:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include <merak/json/document.h>\n#include <merak/json/ostreamwrapper.h>\n#include <merak/json/writer.h>\n#include <fstream>\n\nusing namespace merak::json;\nusing namespace std;\n\nDocument d;\nd.Parse(json);\n\n// ...\n\nofstream ofs("output.json");\nOStreamWrapper osw(ofs);\n\nWriter<OStreamWrapper> writer(osw);\nd.Accept(writer);\n'})}),"\n",(0,s.jsxs)(n.p,{children:["For classes inherited from ",(0,s.jsx)(n.code,{children:"std::wostream"}),", use ",(0,s.jsx)(n.code,{children:"WOStreamWrapper"}),"."]}),"\n",(0,s.jsx)(n.h1,{id:"EncodedStreams",children:"Encoded Streams"}),"\n",(0,s.jsx)(n.p,{children:"Encoded streams do not store JSON themselves; they provide basic encoding/decoding functionality by wrapping byte streams."}),"\n",(0,s.jsxs)(n.p,{children:["As mentioned earlier, we can directly read UTF-8 byte streams. However, UTF-16 and UTF-32 have endianness issues. To handle endianness correctly, bytes need to be converted to characters (e.g., ",(0,s.jsx)(n.code,{children:"wchar_t"})," for UTF-16) when reading, and characters converted to bytes when writing."]}),"\n",(0,s.jsxs)(n.p,{children:["Additionally, we need to handle ",(0,s.jsx)(n.a,{href:"http://en.wikipedia.org/wiki/Byte_order_mark",children:"byte order marks (BOM)"}),". When reading from a byte stream, we need to detect the BOM or simply skip it if present. When writing JSON to a byte stream, we can optionally write a BOM."]}),"\n",(0,s.jsxs)(n.p,{children:["If the stream's encoding is known at compile time, you can use ",(0,s.jsx)(n.code,{children:"EncodedInputStream"})," and ",(0,s.jsx)(n.code,{children:"EncodedOutputStream"}),". If the stream may contain JSON encoded in UTF-8, UTF-16LE, UTF-16BE, UTF-32LE, or UTF-32BE (with encoding only known at runtime), you can use ",(0,s.jsx)(n.code,{children:"AutoUTFInputStream"})," and ",(0,s.jsx)(n.code,{children:"AutoUTFOutputStream"}),". These streams are defined in ",(0,s.jsx)(n.code,{children:"merak/json/encodedstream.h"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Note that these encoded streams can be applied to streams other than files\u2014for example, you can wrap in-memory buffers or custom byte streams with encoded streams."}),"\n",(0,s.jsx)(n.h2,{id:"EncodedInputStream",children:"EncodedInputStream"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"EncodedInputStream"})," has two template parameters:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"Encoding"})," type (e.g., ",(0,s.jsx)(n.code,{children:"UTF8"}),", ",(0,s.jsx)(n.code,{children:"UTF16LE"})," defined in ",(0,s.jsx)(n.code,{children:"merak/json/encodings.h"}),")"]}),"\n",(0,s.jsx)(n.li,{children:"The type of the wrapped stream"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include "merak/json/document.h"\n#include "merak/json/filereadstream.h"   // FileReadStream\n#include "merak/json/encodedstream.h"    // EncodedInputStream\n#include <cstdio>\n\nusing namespace merak::json;\n\nFILE* fp = fopen("utf16le.json", "rb"); // Use "r" on non-Windows platforms\n\nchar readBuffer[256];\nFileReadStream bis(fp, readBuffer, sizeof(readBuffer));\n\nEncodedInputStream<UTF16LE<>, FileReadStream> eis(bis);  // Wrap bis with eis\n\nDocument d; // Document is GenericDocument<UTF8<> > \nd.ParseStream<0, UTF16LE<> >(eis);  // Parse UTF-16LE file to UTF-8 in memory\n\nfclose(fp);\n'})}),"\n",(0,s.jsx)(n.h2,{id:"EncodedOutputStream",children:"EncodedOutputStream"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"EncodedOutputStream"})," is similar, but its constructor has a ",(0,s.jsx)(n.code,{children:"bool putBOM"})," parameter to control whether to write a BOM to the output byte stream:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include "merak/json/filewritestream.h"  // FileWriteStream\n#include "merak/json/encodedstream.h"    // EncodedOutputStream\n#include <merak/json/writer.h>\n#include <cstdio>\n\nDocument d;         // Document is GenericDocument<UTF8<> > \n// ...\n\nFILE* fp = fopen("output_utf32le.json", "wb"); // Use "w" on non-Windows platforms\n\nchar writeBuffer[256];\nFileWriteStream bos(fp, writeBuffer, sizeof(writeBuffer));\n\ntypedef EncodedOutputStream<UTF32LE<>, FileWriteStream> OutputStream;\nOutputStream eos(bos, true);   // Write BOM\n\nWriter<OutputStream, UTF8<>, UTF32LE<>> writer(eos);\nd.Accept(writer);   // Generate UTF32-LE file from UTF-8 in memory\n\nfclose(fp);\n'})}),"\n",(0,s.jsx)(n.h2,{id:"AutoUTFInputStream",children:"AutoUTFInputStream"}),"\n",(0,s.jsxs)(n.p,{children:["Sometimes applications need to handle all supported JSON encodings. ",(0,s.jsx)(n.code,{children:"AutoUTFInputStream"})," first detects the encoding using the BOM. If no BOM exists, it uses characteristics of valid JSON to detect the encoding. If both methods fail, it falls back to the UTF type provided in the constructor."]}),"\n",(0,s.jsxs)(n.p,{children:["Since characters (code units) can be 8-bit, 16-bit, or 32-bit, ",(0,s.jsx)(n.code,{children:"AutoUTFInputStream"})," requires a character type that can store at least 32 bits. We can use ",(0,s.jsx)(n.code,{children:"unsigned"})," as the template parameter:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include "merak/json/document.h"\n#include "merak/json/filereadstream.h"   // FileReadStream\n#include "merak/json/encodedstream.h"    // AutoUTFInputStream\n#include <cstdio>\n\nusing namespace merak::json;\n\nFILE* fp = fopen("any.json", "rb"); // Use "r" on non-Windows platforms\n\nchar readBuffer[256];\nFileReadStream bis(fp, readBuffer, sizeof(readBuffer));\n\nAutoUTFInputStream<unsigned, FileReadStream> eis(bis);  // Wrap bis with eis\n\nDocument d;         // Document is GenericDocument<UTF8<> > \nd.ParseStream<0, AutoUTF<unsigned> >(eis); // Parse any UTF-encoded file to UTF-8 in memory\n\nfclose(fp);\n'})}),"\n",(0,s.jsxs)(n.p,{children:["To specify the stream's encoding, use ",(0,s.jsx)(n.code,{children:"AutoUTF<CharType>"})," as the parameter for ",(0,s.jsx)(n.code,{children:"ParseStream()"})," (as shown in the example above)."]}),"\n",(0,s.jsxs)(n.p,{children:["You can use ",(0,s.jsx)(n.code,{children:"UTFType GetType()"})," to retrieve the detected UTF type and ",(0,s.jsx)(n.code,{children:"HasBOM()"})," to check if the input stream contains a BOM."]}),"\n",(0,s.jsx)(n.h2,{id:"AutoUTFOutputStream",children:"AutoUTFOutputStream"}),"\n",(0,s.jsxs)(n.p,{children:["Similarly, to select the output encoding at runtime, use ",(0,s.jsx)(n.code,{children:"AutoUTFOutputStream"}),'. This class itself is not "auto"\u2014you need to specify the UTF type and whether to write a BOM at runtime:']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using namespace merak::json;\n\nvoid WriteJSONFile(FILE* fp, UTFType type, bool putBOM, const Document& d) {\n    char writeBuffer[256];\n    FileWriteStream bos(fp, writeBuffer, sizeof(writeBuffer));\n\n    typedef AutoUTFOutputStream<unsigned, FileWriteStream> OutputStream;\n    OutputStream eos(bos, type, putBOM);\n    \n    Writer<OutputStream, UTF8<>, AutoUTF<> > writer(eos);\n    d.Accept(writer);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"AutoUTFInputStream"}),"/",(0,s.jsx)(n.code,{children:"AutoUTFOutputStream"})," are more convenient than ",(0,s.jsx)(n.code,{children:"EncodedInputStream"}),"/",(0,s.jsx)(n.code,{children:"EncodedOutputStream"})," but incur a small runtime overhead."]}),"\n",(0,s.jsx)(n.h1,{id:"CustomStream",children:"Custom Streams"}),"\n",(0,s.jsx)(n.p,{children:"In addition to memory/file streams, users can create custom stream classes that adapt to the Merak API\u2014for example, network streams or streams reading from compressed files."}),"\n",(0,s.jsxs)(n.p,{children:["Merak uses templates to combine different types. A class can act as a stream as long as it implements all required interfaces. The stream concept is defined in the comments of ",(0,s.jsx)(n.code,{children:"merak/json.h"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"concept Stream {\n    typename Ch;    //!< Character type of the stream\n\n    //! Read the current character from the stream without moving the read cursor\n    Ch Peek() const;\n\n    //! Read the current character from the stream and move the read cursor to the next character.\n    Ch Take();\n\n    //! Get the read cursor position.\n    //! \\return Number of characters read since the start.\n    size_t Tell();\n\n    //! Start writing operation from the current read cursor.\n    //! \\return Pointer to the start of the writing buffer.\n    Ch* PutBegin();\n\n    //! Write a character.\n    void Put(Ch c);\n\n    //! Flush the buffer.\n    void Flush();\n\n    //! Finish the writing operation.\n    //! \\param begin Pointer returned by PutBegin().\n    //! \\return Number of characters written.\n    size_t PutEnd(Ch* begin);\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Input streams ",(0,s.jsx)(n.strong,{children:"must"})," implement ",(0,s.jsx)(n.code,{children:"Peek()"}),", ",(0,s.jsx)(n.code,{children:"Take()"}),", and ",(0,s.jsx)(n.code,{children:"Tell()"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Output streams ",(0,s.jsx)(n.strong,{children:"must"})," implement ",(0,s.jsx)(n.code,{children:"Put()"})," and ",(0,s.jsx)(n.code,{children:"Flush()"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"PutBegin()"})," and ",(0,s.jsx)(n.code,{children:"PutEnd()"})," are special interfaces used only for ",(0,s.jsx)(n.em,{children:"in situ"})," parsing. Regular streams do not need to implement them, but empty implementations must still be provided to avoid compilation errors."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"ExampleIStreamWrapper",children:"Example: istream Wrapper"}),"\n",(0,s.jsxs)(n.p,{children:["The following simple example is a wrapper for ",(0,s.jsx)(n.code,{children:"std::istream"}),", implementing only 3 required functions:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class MyIStreamWrapper {\npublic:\n    typedef char Ch;\n\n    MyIStreamWrapper(std::istream& is) : is_(is) {\n    }\n\n    Ch Peek() const { // 1\n        int c = is_.peek();\n        return c == std::char_traits<char>::eof() ? '\\0' : (Ch)c;\n    }\n\n    Ch Take() { // 2\n        int c = is_.get();\n        return c == std::char_traits<char>::eof() ? '\\0' : (Ch)c;\n    }\n\n    size_t Tell() const { return (size_t)is_.tellg(); } // 3\n\n    Ch* PutBegin() { assert(false); return 0; }\n    void Put(Ch) { assert(false); }\n    void Flush() { assert(false); }\n    size_t PutEnd(Ch*) { assert(false); return 0; }\n\nprivate:\n    MyIStreamWrapper(const MyIStreamWrapper&);\n    MyIStreamWrapper& operator=(const MyIStreamWrapper&);\n\n    std::istream& is_;\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Users can use it to wrap instances of ",(0,s.jsx)(n.code,{children:"std::stringstream"}),", ",(0,s.jsx)(n.code,{children:"std::ifstream"}),", etc.:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'const char* json = "[1,2,3,4]";\nstd::stringstream ss(json);\nMyIStreamWrapper is(ss);\n\nDocument d;\nd.ParseStream(is);\n'})}),"\n",(0,s.jsx)(n.p,{children:"Note that due to internal overhead in the standard library, this implementation may have lower performance than Merak's memory/file streams."}),"\n",(0,s.jsx)(n.h2,{id:"ExampleOStreamWrapper",children:"Example: ostream Wrapper"}),"\n",(0,s.jsxs)(n.p,{children:["The following example is a wrapper for ",(0,s.jsx)(n.code,{children:"std::ostream"}),", implementing only 2 required functions:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class MyOStreamWrapper {\npublic:\n    typedef char Ch;\n\n    MyOStreamWrapper(std::ostream& os) : os_(os) {\n    }\n\n    Ch Peek() const { assert(false); return '\\0'; }\n    Ch Take() { assert(false); return '\\0'; }\n    size_t Tell() const { assert(false); return 0; }\n\n    Ch* PutBegin() { assert(false); return 0; }\n    void Put(Ch c) { os_.put(c); }                  // 1\n    void Flush() { os_.flush(); }                   // 2\n    size_t PutEnd(Ch*) { assert(false); return 0; }\n\nprivate:\n    MyOStreamWrapper(const MyOStreamWrapper&);\n    MyOStreamWrapper& operator=(const MyOStreamWrapper&);\n\n    std::ostream& os_;\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Users can use it to wrap instances of ",(0,s.jsx)(n.code,{children:"std::stringstream"}),", ",(0,s.jsx)(n.code,{children:"std::ofstream"}),", etc.:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"Document d;\n// ...\n\nstd::stringstream ss;\nMyOStreamWrapper os(ss);\n\nWriter<MyOStreamWrapper> writer(os);\nd.Accept(writer);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Note that due to internal overhead in the standard library, this implementation may have lower performance than Merak's memory/file streams."}),"\n",(0,s.jsx)(n.h1,{id:"Summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"This section describes the various stream classes provided by Merak:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Memory streams are simple and straightforward."}),"\n",(0,s.jsx)(n.li,{children:"For JSON stored in files, file streams reduce the memory required for parsing and generation."}),"\n",(0,s.jsx)(n.li,{children:"Encoded streams convert between byte streams and character streams, handling endianness and BOMs."}),"\n",(0,s.jsx)(n.li,{children:"Finally, users can create custom streams using a simple interface to support specialized I/O scenarios."}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>d});var t=r(6540);const s={},a=t.createContext(s);function i(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);