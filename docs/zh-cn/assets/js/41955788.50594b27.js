"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[7600],{6191:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"foundamentals/filesystem/fs","title":"Turbo File System Library (turbo::files) - Usage Guide & Function Details","description":"The Turbo File System Library (turbo/files) is designed based on the C++17 std::Result, CamelCase class names + snake_case function names). It provides cross-platform file system operation capabilities, focusing on core scenarios such as path handling, directory traversal, file attribute management, and file/directory operations.","source":"@site/docs/foundamentals/filesystem/fs.mdx","sourceDirName":"foundamentals/filesystem","slug":"/foundamentals/filesystem/fs","permalink":"/cppdev/zh-cn/docs/foundamentals/filesystem/fs","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/foundamentals/filesystem/fs.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Overview","permalink":"/cppdev/zh-cn/docs/foundamentals/filesystem/"},"next":{"title":"Overview","permalink":"/cppdev/zh-cn/docs/foundamentals/json/"}}');var i=s(4848),n=s(8453);const o={},l="Turbo File System Library (turbo::files) - Usage Guide & Function Details",d={},c=[{value:"I. Overview of Core Classes and Functions",id:"i-overview-of-core-classes-and-functions",level:2},{value:"II. Core Functions and Usage Examples",id:"ii-core-functions-and-usage-examples",level:2},{value:"1. Path Operations (turbo::FilePath)",id:"1-path-operations-turbofilepath",level:3},{value:"Core Functions",id:"core-functions",level:4},{value:"Example Code",id:"example-code",level:4},{value:"2. Directory Traversal (DirectoryIterator/RecursiveDirectoryIterator)",id:"2-directory-traversal-directoryiteratorrecursivedirectoryiterator",level:3},{value:"Core Functions/Interfaces",id:"core-functionsinterfaces",level:4},{value:"Example Code",id:"example-code-1",level:4},{value:"3. File Status &amp; Attributes (FileStatus/FileType/Perms)",id:"3-file-status--attributes-filestatusfiletypeperms",level:3},{value:"Core Functions",id:"core-functions-1",level:4},{value:"Example Code",id:"example-code-2",level:4},{value:"4. Disk Space Query (SpaceInfo)",id:"4-disk-space-query-spaceinfo",level:3},{value:"Core Functions",id:"core-functions-2",level:4},{value:"Example Code",id:"example-code-3",level:4},{value:"5. File/Directory Operations (Create, Delete, Copy, Move)",id:"5-filedirectory-operations-create-delete-copy-move",level:3},{value:"Core Functions",id:"core-functions-3",level:4},{value:"Example Code",id:"example-code-4",level:4},{value:"III. Key Notes",id:"iii-key-notes",level:2}];function a(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,n.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"turbo-file-system-library-turbofiles---usage-guide--function-details",children:"Turbo File System Library (turbo::files) - Usage Guide & Function Details"})}),"\n",(0,i.jsxs)(t.p,{children:["The Turbo File System Library (",(0,i.jsx)(t.code,{children:"turbo/files"}),") is designed based on the C++17 ",(0,i.jsx)(t.code,{children:"std::filesystem"})," interface, adapted to Turbo ecosystem specifications (no exceptions thrown, returns ",(0,i.jsx)(t.code,{children:"turbo::Status"}),"/",(0,i.jsx)(t.code,{children:"turbo::Result<T>"}),", CamelCase class names + snake_case function names). It provides cross-platform file system operation capabilities, focusing on core scenarios such as path handling, directory traversal, file attribute management, and file/directory operations."]}),"\n",(0,i.jsx)(t.h2,{id:"i-overview-of-core-classes-and-functions",children:"I. Overview of Core Classes and Functions"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Class/Enum"}),(0,i.jsx)(t.th,{children:"Core Function"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"turbo::FilePath"})}),(0,i.jsx)(t.td,{children:"Syntax processing of paths (construction, concatenation, parsing, normalization, etc.), no validation of path existence"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"turbo::DirectoryEntry"})}),(0,i.jsx)(t.td,{children:"Encapsulates the path and status of a directory entry (file/directory), used with iterators"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"turbo::DirectoryIterator"})}),(0,i.jsx)(t.td,{children:"Non-recursive traversal of all entries (files/subdirectories) in a directory"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"turbo::RecursiveDirectoryIterator"})}),(0,i.jsx)(t.td,{children:"Recursive traversal of all entries (including nested subdirectories) in a directory"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"turbo::FileStatus"})}),(0,i.jsx)(t.td,{children:"Encapsulates the status of a file/directory (type, permissions, size, modification time, etc.)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"turbo::SpaceInfo"})}),(0,i.jsx)(t.td,{children:"Disk space information (total space, available space, used space)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"turbo::FileType"})}),(0,i.jsx)(t.td,{children:"Enumerates file types (directory, regular file, symbolic link, block device, character device, etc.)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"turbo::Perms"})}),(0,i.jsx)(t.td,{children:"Enumerates file permissions (read/write/execute, owner/group/other users)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"turbo::CopyOptions"})}),(0,i.jsx)(t.td,{children:"Options for copying files/directories (overwrite, recursive, preserve permissions, etc.)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"turbo::DirectoryOptions"})}),(0,i.jsx)(t.td,{children:"Options for directory traversal/creation (follow symbolic links, skip empty directories, etc.)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"turbo::FileTimeType"})}),(0,i.jsx)(t.td,{children:"Enumerates file time types (creation time, last access time, last modification time)"})]})]})]}),"\n",(0,i.jsx)(t.h2,{id:"ii-core-functions-and-usage-examples",children:"II. Core Functions and Usage Examples"}),"\n",(0,i.jsx)(t.h3,{id:"1-path-operations-turbofilepath",children:"1. Path Operations (turbo::FilePath)"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"FilePath"}),' is the core of path operations, handling only the "syntax" of paths (e.g., concatenation, parsing) without validating path existence. It supports all path forms including absolute paths, relative paths, and canonical paths.']}),"\n",(0,i.jsx)(t.h4,{id:"core-functions",children:"Core Functions"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Function Name"}),(0,i.jsx)(t.th,{children:"Function"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"FilePath(std::string_view path)"})}),(0,i.jsxs)(t.td,{children:["Constructs a path object (supports native path formats, e.g., ",(0,i.jsx)(t.code,{children:"C:\\a.txt"})," on Windows, ",(0,i.jsx)(t.code,{children:"/a.txt"})," on Linux)"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"append(std::string_view component)"})}),(0,i.jsxs)(t.td,{children:["Concatenates a subpath (automatically handles separators, e.g., ",(0,i.jsx)(t.code,{children:'"/a"'})," + ",(0,i.jsx)(t.code,{children:'"b"'})," \u2192 ",(0,i.jsx)(t.code,{children:'"/a/b"'}),")"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"parent_path()"})}),(0,i.jsxs)(t.td,{children:["Gets the parent directory path (e.g., ",(0,i.jsx)(t.code,{children:'"/a/b.txt"'})," \u2192 ",(0,i.jsx)(t.code,{children:'"/a"'}),")"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"filename()"})}),(0,i.jsxs)(t.td,{children:["Gets the file name (including extension, e.g., ",(0,i.jsx)(t.code,{children:'"/a/b.txt"'})," \u2192 ",(0,i.jsx)(t.code,{children:'"b.txt"'}),")"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"stem()"})}),(0,i.jsxs)(t.td,{children:["Gets the file name (excluding extension, e.g., ",(0,i.jsx)(t.code,{children:'"/a/b.txt"'})," \u2192 ",(0,i.jsx)(t.code,{children:'"b"'}),")"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"extension()"})}),(0,i.jsxs)(t.td,{children:["Gets the file extension (e.g., ",(0,i.jsx)(t.code,{children:'"/a/b.txt"'})," \u2192 ",(0,i.jsx)(t.code,{children:'".txt"'}),")"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"is_absolute()"})}),(0,i.jsx)(t.td,{children:"Checks if the path is absolute"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"is_relative()"})}),(0,i.jsx)(t.td,{children:"Checks if the path is relative"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"lexically_normal()"})}),(0,i.jsxs)(t.td,{children:["Normalizes the path (removes ",(0,i.jsx)(t.code,{children:"."}),"/",(0,i.jsx)(t.code,{children:".."}),", e.g., ",(0,i.jsx)(t.code,{children:'"/a/./b/../c"'})," \u2192 ",(0,i.jsx)(t.code,{children:'"/a/c"'}),")"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"lexically_absolute()"})}),(0,i.jsx)(t.td,{children:"Converts to an absolute path (based on the current working directory)"})]})]})]}),"\n",(0,i.jsx)(t.h4,{id:"example-code",children:"Example Code"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:'#include <turbo/files/filesystem.h>\n#include <iostream>\n#include <turbo/status/status.h>\n\nint main() {\n    // 1. Construct paths\n    turbo::FilePath base_path("/home/user/docs");\n    turbo::FilePath file_path(base_path);\n    // Concatenate subpath: /home/user/docs/report.pdf\n    file_path.append("report.pdf");\n\n    // 2. Path parsing\n    std::cout << "Full path: " << file_path.string() << std::endl;\n    std::cout << "Parent directory: " << file_path.parent_path().string() << std::endl;\n    std::cout << "File name: " << file_path.filename().string() << std::endl;\n    std::cout << "File name (without extension): " << file_path.stem().string() << std::endl;\n    std::cout << "Extension: " << file_path.extension().string() << std::endl;\n\n    // 3. Path normalization\n    turbo::FilePath messy_path("/home/user/./docs/../downloads/./photo.jpg");\n    turbo::FilePath normal_path = messy_path.lexically_normal();\n    std::cout << "Normalized path: " << normal_path.string() << std::endl; // /home/user/downloads/photo.jpg\n\n    // 4. Absolute/relative path check\n    turbo::FilePath rel_path("test.txt");\n    std::cout << "Is rel_path relative: " << (rel_path.is_relative() ? "Yes" : "No") << std::endl;\n    // Convert to absolute path\n    turbo::Result<turbo::FilePath> abs_result = rel_path.lexically_absolute();\n    if (abs_result.ok()) {\n        std::cout << "Absolute path of rel_path: " << abs_result.value().string() << std::endl;\n    } else {\n        std::cout << "Failed to convert to absolute path: " << abs_result.status().message() << std::endl;\n    }\n\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(t.h3,{id:"2-directory-traversal-directoryiteratorrecursivedirectoryiterator",children:"2. Directory Traversal (DirectoryIterator/RecursiveDirectoryIterator)"}),"\n",(0,i.jsxs)(t.p,{children:["Used to traverse files/subdirectories in a directory: ",(0,i.jsx)(t.code,{children:"DirectoryIterator"})," for non-recursive traversal, ",(0,i.jsx)(t.code,{children:"RecursiveDirectoryIterator"})," for recursive traversal of nested subdirectories. Traversal results are encapsulated as ",(0,i.jsx)(t.code,{children:"DirectoryEntry"}),", which can retrieve entry paths, status, etc."]}),"\n",(0,i.jsx)(t.h4,{id:"core-functionsinterfaces",children:"Core Functions/Interfaces"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Function/Interface"}),(0,i.jsx)(t.th,{children:"Function"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"DirectoryIterator(FilePath path, DirectoryOptions opts = {})"})}),(0,i.jsx)(t.td,{children:"Constructs a directory iterator (opts specifies whether to follow symbolic links)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"RecursiveDirectoryIterator(FilePath path, DirectoryOptions opts = {})"})}),(0,i.jsx)(t.td,{children:"Constructs a recursive directory iterator"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"DirectoryEntry::path()"})}),(0,i.jsx)(t.td,{children:"Gets the path of the traversed entry"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"DirectoryEntry::status()"})}),(0,i.jsxs)(t.td,{children:["Gets the file status of the traversed entry (returns ",(0,i.jsx)(t.code,{children:"Result<FileStatus>"}),")"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsxs)(t.td,{children:[(0,i.jsx)(t.code,{children:"begin()"}),"/",(0,i.jsx)(t.code,{children:"end()"})]}),(0,i.jsx)(t.td,{children:"Iterator interface (supports range-based for loops)"})]})]})]}),"\n",(0,i.jsx)(t.h4,{id:"example-code-1",children:"Example Code"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:'#include <turbo/files/filesystem.h>\n#include <iostream>\n#include <turbo/status/status.h>\n\n// Non-recursive directory traversal\nvoid traverse_directory(const turbo::FilePath& dir_path) {\n    turbo::Result<turbo::DirectoryIterator> iter_result = turbo::DirectoryIterator::open(dir_path);\n    if (!iter_result.ok()) {\n        std::cout << "Failed to open directory: " << iter_result.status().message() << std::endl;\n        return;\n    }\n\n    turbo::DirectoryIterator iter = iter_result.value();\n    for (const auto& entry : iter) { // Range-based for traversal\n        if (!entry.ok()) {\n            std::cout << "Failed to traverse entry: " << entry.status().message() << std::endl;\n            continue;\n        }\n        turbo::DirectoryEntry dir_entry = entry.value();\n        // Get entry path\n        turbo::FilePath entry_path = dir_entry.path();\n        // Get entry status\n        turbo::Result<turbo::FileStatus> status_result = dir_entry.status();\n        if (status_result.ok()) {\n            turbo::FileStatus status = status_result.value();\n            // Determine file type\n            std::string file_type;\n            if (status.type() == turbo::FileType::directory) {\n                file_type = "Directory";\n            } else if (status.type() == turbo::FileType::regular) {\n                file_type = "Regular file";\n            } else if (status.type() == turbo::FileType::symlink) {\n                file_type = "Symbolic link";\n            } else {\n                file_type = "Other type";\n            }\n            std::cout << "Entry: " << entry_path.string() << " Type: " << file_type << std::endl;\n        }\n    }\n}\n\n// Recursive directory traversal\nvoid traverse_directory_recursive(const turbo::FilePath& dir_path) {\n    turbo::Result<turbo::RecursiveDirectoryIterator> iter_result = turbo::RecursiveDirectoryIterator::open(dir_path);\n    if (!iter_result.ok()) {\n        std::cout << "Failed to open recursive directory: " << iter_result.status().message() << std::endl;\n        return;\n    }\n\n    turbo::RecursiveDirectoryIterator iter = iter_result.value();\n    for (const auto& entry : iter) {\n        if (!entry.ok()) {\n            std::cout << "Failed to recursively traverse entry: " << entry.status().message() << std::endl;\n            continue;\n        }\n        turbo::DirectoryEntry dir_entry = entry.value();\n        std::cout << "Recursive entry: " << dir_entry.path().string() << std::endl;\n    }\n}\n\nint main() {\n    turbo::FilePath test_dir("/home/user/docs");\n    std::cout << "===== Non-recursive Traversal =====" << std::endl;\n    traverse_directory(test_dir);\n\n    std::cout << "\\n===== Recursive Traversal =====" << std::endl;\n    traverse_directory_recursive(test_dir);\n\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(t.h3,{id:"3-file-status--attributes-filestatusfiletypeperms",children:"3. File Status & Attributes (FileStatus/FileType/Perms)"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"FileStatus"})," encapsulates core attributes of files/directories, enabling retrieval of file type, permissions, size, modification time, etc. ",(0,i.jsx)(t.code,{children:"FileType"})," enumerates file types, and ",(0,i.jsx)(t.code,{children:"Perms"})," enumerates file permissions."]}),"\n",(0,i.jsx)(t.h4,{id:"core-functions-1",children:"Core Functions"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Function Name"}),(0,i.jsx)(t.th,{children:"Function"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"turbo::status(FilePath path)"})}),(0,i.jsxs)(t.td,{children:["Gets file status (returns ",(0,i.jsx)(t.code,{children:"Result<FileStatus>"}),")"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"FileStatus::type()"})}),(0,i.jsxs)(t.td,{children:["Gets file type (returns ",(0,i.jsx)(t.code,{children:"FileType"}),")"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"FileStatus::permissions()"})}),(0,i.jsxs)(t.td,{children:["Gets file permissions (returns ",(0,i.jsx)(t.code,{children:"Perms"}),")"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"FileStatus::file_size()"})}),(0,i.jsxs)(t.td,{children:["Gets file size (in bytes, returns ",(0,i.jsx)(t.code,{children:"uint64_t"}),")"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"FileStatus::last_write_time()"})}),(0,i.jsxs)(t.td,{children:["Gets last modification time (returns timestamp corresponding to ",(0,i.jsx)(t.code,{children:"FileTimeType"}),")"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"turbo::is_regular_file(FilePath path)"})}),(0,i.jsxs)(t.td,{children:["Checks if it is a regular file (returns ",(0,i.jsx)(t.code,{children:"Result<bool>"}),")"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"turbo::is_directory(FilePath path)"})}),(0,i.jsxs)(t.td,{children:["Checks if it is a directory (returns ",(0,i.jsx)(t.code,{children:"Result<bool>"}),")"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"turbo::is_symlink(FilePath path)"})}),(0,i.jsxs)(t.td,{children:["Checks if it is a symbolic link (returns ",(0,i.jsx)(t.code,{children:"Result<bool>"}),")"]})]})]})]}),"\n",(0,i.jsx)(t.h4,{id:"example-code-2",children:"Example Code"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:'#include <turbo/files/filesystem.h>\n#include <iostream>\n#include <turbo/status/status.h>\n\nvoid get_file_info(const turbo::FilePath& file_path) {\n    // Get file status\n    turbo::Result<turbo::FileStatus> status_result = turbo::status(file_path);\n    if (!status_result.ok()) {\n        std::cout << "Failed to get file status: " << status_result.status().message() << std::endl;\n        return;\n    }\n    turbo::FileStatus fs = status_result.value();\n\n    // 1. File type\n    std::cout << "File type: ";\n    switch (fs.type()) {\n        case turbo::FileType::none: std::cout << "Unknown"; break;\n        case turbo::FileType::directory: std::cout << "Directory"; break;\n        case turbo::FileType::regular: std::cout << "Regular file"; break;\n        case turbo::FileType::symlink: std::cout << "Symbolic link"; break;\n        case turbo::FileType::block: std::cout << "Block device"; break;\n        case turbo::FileType::character: std::cout << "Character device"; break;\n        case turbo::FileType::fifo: std::cout << "FIFO"; break;\n        case turbo::FileType::socket: std::cout << "Socket"; break;\n        default: std::cout << "Other";\n    }\n    std::cout << std::endl;\n\n    // 2. File size (valid only for regular files)\n    if (fs.type() == turbo::FileType::regular) {\n        std::cout << "File size: " << fs.file_size() << " bytes" << std::endl;\n    }\n\n    // 3. File permissions\n    turbo::Perms perms = fs.permissions();\n    std::cout << "File permissions: ";\n    // Check owner read permission\n    if ((perms & turbo::Perms::owner_read) != turbo::Perms::none) {\n        std::cout << "Owner readable ";\n    }\n    // Check owner write permission\n    if ((perms & turbo::Perms::owner_write) != turbo::Perms::none) {\n        std::cout << "Owner writable ";\n    }\n    // Check owner execute permission\n    if ((perms & turbo::Perms::owner_exec) != turbo::Perms::none) {\n        std::cout << "Owner executable ";\n    }\n    std::cout << std::endl;\n\n    // 4. Quick file type check\n    turbo::Result<bool> is_regular = turbo::is_regular_file(file_path);\n    if (is_regular.ok()) {\n        std::cout << "Is regular file: " << (is_regular.value() ? "Yes" : "No") << std::endl;\n    }\n}\n\nint main() {\n    turbo::FilePath file_path("/home/user/docs/report.pdf");\n    get_file_info(file_path);\n\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(t.h3,{id:"4-disk-space-query-spaceinfo",children:"4. Disk Space Query (SpaceInfo)"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"SpaceInfo"})," encapsulates disk partition space information. Use the ",(0,i.jsx)(t.code,{children:"turbo::space"})," function to get space data of the partition where the specified path resides."]}),"\n",(0,i.jsx)(t.h4,{id:"core-functions-2",children:"Core Functions"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Function Name"}),(0,i.jsx)(t.th,{children:"Function"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"turbo::space(FilePath path)"})}),(0,i.jsxs)(t.td,{children:["Gets disk space info of the partition containing the path (returns ",(0,i.jsx)(t.code,{children:"Result<SpaceInfo>"}),")"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"SpaceInfo::capacity"})}),(0,i.jsx)(t.td,{children:"Total partition space (in bytes)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"SpaceInfo::free"})}),(0,i.jsx)(t.td,{children:"Free partition space (in bytes, including space unavailable to non-privileged users)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"SpaceInfo::available"})}),(0,i.jsx)(t.td,{children:"Available partition space (in bytes, usable by non-privileged users)"})]})]})]}),"\n",(0,i.jsx)(t.h4,{id:"example-code-3",children:"Example Code"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:'#include <turbo/files/filesystem.h>\n#include <iostream>\n#include <turbo/status/status.h>\n\nvoid get_disk_space(const turbo::FilePath& path) {\n    turbo::Result<turbo::SpaceInfo> space_result = turbo::space(path);\n    if (!space_result.ok()) {\n        std::cout << "Failed to get disk space: " << space_result.status().message() << std::endl;\n        return;\n    }\n    turbo::SpaceInfo si = space_result.value();\n\n    // Convert to GB (1GB = 1024*1024*1024 bytes)\n    const uint64_t GB = 1024 * 1024 * 1024;\n    std::cout << "Total partition space: " << static_cast<double>(si.capacity) / GB << " GB" << std::endl;\n    std::cout << "Free partition space: " << static_cast<double>(si.free) / GB << " GB" << std::endl;\n    std::cout << "Available partition space: " << static_cast<double>(si.available) / GB << " GB" << std::endl;\n}\n\nint main() {\n    // Query space of the partition containing the root directory (Linux)\n    turbo::FilePath root_path("/");\n    get_disk_space(root_path);\n\n    // Windows example: Query C drive space\n    // turbo::FilePath c_path("C:\\\\");\n    // get_disk_space(c_path);\n\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(t.h3,{id:"5-filedirectory-operations-create-delete-copy-move",children:"5. File/Directory Operations (Create, Delete, Copy, Move)"}),"\n",(0,i.jsxs)(t.p,{children:["Turbo provides a series of file/directory operation functions, all returning ",(0,i.jsx)(t.code,{children:"turbo::Status"})," (no return value) or ",(0,i.jsx)(t.code,{children:"turbo::Result<T>"})," (with return value) without throwing exceptions. Operation behavior can be controlled via ",(0,i.jsx)(t.code,{children:"CopyOptions"}),"/",(0,i.jsx)(t.code,{children:"DirectoryOptions"}),"."]}),"\n",(0,i.jsx)(t.h4,{id:"core-functions-3",children:"Core Functions"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Function Name"}),(0,i.jsx)(t.th,{children:"Function"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"turbo::create_directory(FilePath path)"})}),(0,i.jsxs)(t.td,{children:["Creates a single directory (returns ",(0,i.jsx)(t.code,{children:"Status"}),")"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"turbo::create_directories(FilePath path)"})}),(0,i.jsxs)(t.td,{children:["Recursively creates multi-level directories (returns ",(0,i.jsx)(t.code,{children:"Status"}),")"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"turbo::remove(FilePath path)"})}),(0,i.jsxs)(t.td,{children:["Deletes a file/empty directory (returns ",(0,i.jsx)(t.code,{children:"Status"}),")"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"turbo::remove_all(FilePath path)"})}),(0,i.jsxs)(t.td,{children:["Recursively deletes a directory (including all contents), returns the number of deleted files ( ",(0,i.jsx)(t.code,{children:"Result<uint64_t>"}),")"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"turbo::copy(FilePath src, FilePath dst, CopyOptions opts = {})"})}),(0,i.jsxs)(t.td,{children:["Copies a file/directory (returns ",(0,i.jsx)(t.code,{children:"Status"}),")"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"turbo::rename(FilePath src, FilePath dst)"})}),(0,i.jsxs)(t.td,{children:["Renames/moves a file/directory (returns ",(0,i.jsx)(t.code,{children:"Status"}),")"]})]})]})]}),"\n",(0,i.jsx)(t.h4,{id:"example-code-4",children:"Example Code"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:'#include <turbo/files/filesystem.h>\n#include <iostream>\n#include <turbo/status/status.h>\n\nvoid file_operations_demo() {\n    // 1. Create multi-level directories\n    turbo::FilePath new_dir("/home/user/test/dir1/dir2");\n    turbo::Status create_status = turbo::create_directories(new_dir);\n    if (create_status.ok()) {\n        std::cout << "Successfully created multi-level directory: " << new_dir.string() << std::endl;\n    } else {\n        std::cout << "Failed to create multi-level directory: " << create_status.message() << std::endl;\n        return;\n    }\n\n    // 2. Copy file\n    turbo::FilePath src_file("/home/user/docs/report.pdf");\n    turbo::FilePath dst_file("/home/user/test/report_copy.pdf");\n    // Copy options: overwrite existing files\n    turbo::CopyOptions copy_opts;\n    copy_opts.overwrite_existing = true;\n    turbo::Status copy_status = turbo::copy(src_file, dst_file, copy_opts);\n    if (copy_status.ok()) {\n        std::cout << "Successfully copied file: " << dst_file.string() << std::endl;\n    } else {\n        std::cout << "Failed to copy file: " << copy_status.message() << std::endl;\n    }\n\n    // 3. Rename file\n    turbo::FilePath rename_dst("/home/user/test/report_renamed.pdf");\n    turbo::Status rename_status = turbo::rename(dst_file, rename_dst);\n    if (rename_status.ok()) {\n        std::cout << "Successfully renamed file: " << rename_dst.string() << std::endl;\n    } else {\n        std::cout << "Failed to rename file: " << rename_status.message() << std::endl;\n    }\n\n    // 4. Delete file\n    turbo::Status remove_file_status = turbo::remove(rename_dst);\n    if (remove_file_status.ok()) {\n        std::cout << "Successfully deleted file: " << rename_dst.string() << std::endl;\n    } else {\n        std::cout << "Failed to delete file: " << remove_file_status.message() << std::endl;\n    }\n\n    // 5. Recursively delete directory\n    turbo::Result<uint64_t> remove_result = turbo::remove_all(new_dir.parent_path()); // Delete /home/user/test\n    if (remove_result.ok()) {\n        std::cout << "Successfully deleted directory recursively, " << remove_result.value() << " files/directories deleted" << std::endl;\n    } else {\n        std::cout << "Failed to delete directory recursively: " << remove_result.status().message() << std::endl;\n    }\n}\n\nint main() {\n    file_operations_demo();\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"iii-key-notes",children:"III. Key Notes"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Cross-Platform Compatibility"}),": ",(0,i.jsx)(t.code,{children:"turbo::FilePath"})," automatically adapts to path formats on Windows/Linux/macOS (e.g., Windows drive letters, Linux root directories) \u2014 no manual separator handling required;"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Error Handling"}),": All operations return ",(0,i.jsx)(t.code,{children:"turbo::Status"}),"/",(0,i.jsx)(t.code,{children:"turbo::Result<T>"})," \u2014 use ",(0,i.jsx)(t.code,{children:"ok()"})," to check operation success, avoiding reliance on exceptions;"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Path Validity"}),": ",(0,i.jsx)(t.code,{children:"FilePath"})," only handles syntax \u2014 validate path existence using ",(0,i.jsx)(t.code,{children:"turbo::exists(FilePath path)"})," (returns ",(0,i.jsx)(t.code,{children:"Result<bool>"}),");"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Permissions & Special Files"}),": When operating on symbolic links or device files, specify whether to follow symbolic links via ",(0,i.jsx)(t.code,{children:"DirectoryOptions"})," to avoid unintended operations;"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Performance Tips"}),": For recursive traversal of large directories, prefer ",(0,i.jsx)(t.code,{children:"RecursiveDirectoryIterator"})," (optimized traversal logic internally) to avoid performance loss from manual recursion."]}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>o,x:()=>l});var r=s(6540);const i={},n=r.createContext(i);function o(e){const t=r.useContext(n);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(n.Provider,{value:t},e.children)}}}]);