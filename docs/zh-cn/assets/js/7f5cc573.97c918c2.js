"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[5382],{6245:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"foundamentals/fibers/kthread_or_not","title":"Thread Model Selection","description":"krpc provides asynchronous interfaces, so a common question arises: Should I use asynchronous interfaces or kthread?","source":"@site/docs/foundamentals/fibers/kthread_or_not.mdx","sourceDirName":"foundamentals/fibers","slug":"/foundamentals/fibers/kthread_or_not","permalink":"/cppdev/zh-cn/docs/foundamentals/fibers/kthread_or_not","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/foundamentals/fibers/kthread_or_not.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"kthread Scheduling and Execution Flow","permalink":"/cppdev/zh-cn/docs/foundamentals/fibers/kthread_schedule"},"next":{"title":"FAQ","permalink":"/cppdev/zh-cn/docs/foundamentals/fibers/faq"}}');var o=s(4848),t=s(8453);const a={},i="Thread Model Selection",c={},l=[{value:"Synchronous or Asynchronous",id:"synchronous-or-asynchronous",level:2},{value:"How to Choose Between Synchronous and Asynchronous",id:"how-to-choose-between-synchronous-and-asynchronous",level:3},{value:"Asynchronous or kthread",id:"asynchronous-or-kthread",level:2},{value:"When to Use Taskflow",id:"when-to-use-taskflow",level:2}];function h(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"thread-model-selection",children:"Thread Model Selection"})}),"\n",(0,o.jsxs)(n.p,{children:["krpc provides ",(0,o.jsx)(n.a,{href:"/cppdev/zh-cn/docs/rpc/krpc/client#asynchronous-access",children:"asynchronous interfaces"}),", so a common question arises: Should I use asynchronous interfaces or kthread?"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Short answer"}),": For low-latency scenarios, start with simple and easy-to-understand synchronous interfaces. If they don\u2019t meet requirements, use asynchronous interfaces. Only use kthread when multi-core parallel computing is needed."]}),"\n",(0,o.jsx)(n.h2,{id:"synchronous-or-asynchronous",children:"Synchronous or Asynchronous"}),"\n",(0,o.jsxs)(n.p,{children:["Asynchrony replaces blocking with callbacks\u2014where there is blocking, there are callbacks. While callbacks work well and are widely accepted in languages like JavaScript, anyone who has used them in multi-threaded environments will find they are entirely different from what we need. This difference is not about ",(0,o.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Anonymous_function",children:"lambda"})," or ",(0,o.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Futures_and_promises",children:"future"}),", but that JavaScript is ",(0,o.jsx)(n.strong,{children:"single-threaded"}),". JavaScript-style callbacks are unlikely to work in multi-threaded environments due to excessive race conditions\u2014synchronous methods in single-threaded vs. multi-threaded contexts are fundamentally different."]}),"\n",(0,o.jsxs)(n.p,{children:["Could we design services in a similar fashion (multiple threads, each with an independent event loop)? Yes\u2014",(0,o.jsx)(n.strong,{children:"ub"}),"a",(0,o.jsx)(n.strong,{children:"server"}),' (note the letter "a") is an example, but its real-world performance was poor. Converting blocking code to callback-based code is non-trivial: blocking within loops, conditional branches, or deep nested subfunctions is extremely hard to refactor. Furthermore, legacy code and third-party libraries are often impossible to modify. Inevitably, blocking code remains, causing delays to other callbacks in the same thread, leading to request timeouts and subpar server performance.']}),"\n",(0,o.jsx)(n.p,{children:'If you claim, "I want to refactor existing synchronous code into a mass of callbacks that no one else can understand, with potentially worse performance," most developers would disagree. Don\u2019t be misled by advocates of asynchrony\u2014they write end-to-end, bottom-up fully asynchronous code that ignores multi-threading, which is entirely different from what you need to implement.'}),"\n",(0,o.jsxs)(n.p,{children:["Asynchrony in krpc is completely different from single-threaded asynchrony: asynchronous callbacks run in a different thread from the caller. You gain multi-core scalability but must account for multi-threading issues. You can block within callbacks\u2014provided sufficient threads are available, there will be no significant impact on overall server performance. However, asynchronous code remains difficult to write. To simplify this, we provide ",(0,o.jsx)(n.a,{href:"/cppdev/zh-cn/docs/rpc/krpc/combo_channel",children:"Combo Access"}),": by composing different channels, you can declaratively execute complex access patterns without worrying about low-level details."]}),"\n",(0,o.jsx)(n.p,{children:"Of course, for scenarios with low latency and low QPS, we strongly recommend synchronous interfaces. This was a key motivation for creating kthread: to improve interaction performance while retaining the simplicity of synchronous code."}),"\n",(0,o.jsx)(n.h3,{id:"how-to-choose-between-synchronous-and-asynchronous",children:"How to Choose Between Synchronous and Asynchronous"}),"\n",(0,o.jsxs)(n.p,{children:["Calculate ",(0,o.jsx)(n.code,{children:"QPS * latency (in seconds)"}),". If the result is on the same order of magnitude as the number of CPU cores, use synchronous; otherwise, use asynchronous."]}),"\n",(0,o.jsx)(n.p,{children:"Examples:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"QPS = 2000, Latency = 10ms \u2192 2000 * 0.01s = 20. This matches the order of a typical 32-core CPU \u2192 use synchronous."}),"\n",(0,o.jsx)(n.li,{children:"QPS = 100, Latency = 5s \u2192 100 * 5s = 500. This is far larger than the number of CPU cores \u2192 use asynchronous."}),"\n",(0,o.jsx)(n.li,{children:"QPS = 500, Latency = 100ms \u2192 500 * 0.1s = 50. Roughly on the same order as CPU cores \u2192 synchronous is acceptable. Consider asynchronous if latency increases in the future."}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["This formula calculates the ",(0,o.jsx)(n.strong,{children:"average number of concurrent requests"})," (you can verify this yourself), which is comparable to the number of threads/CPU cores. When this value is much larger than the number of CPU cores, most operations do not consume CPU but block a large number of threads\u2014using asynchrony significantly saves thread resources (memory occupied by stacks). When the value is smaller than or similar to the number of CPU cores, the thread resources saved by asynchrony are negligible, and simple, readable synchronous code becomes more important."]}),"\n",(0,o.jsx)(n.h2,{id:"asynchronous-or-kthread",children:"Asynchronous or kthread"}),"\n",(0,o.jsx)(n.p,{children:'With kthread, users can even implement asynchrony themselves. Take "semi-synchronous" as an example\u2014krpc offers multiple options:'}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["Initiate multiple asynchronous RPCs and call ",(0,o.jsx)(n.code,{children:"Join"})," on each (blocks until the RPC completes).",(0,o.jsx)(n.br,{}),"\n","(For comparison with kthread only\u2014we recommend using ",(0,o.jsx)(n.a,{href:"/cppdev/zh-cn/docs/rpc/krpc/combo_channel#ParallelChannel",children:"ParallelChannel"})," in practice instead of manual ",(0,o.jsx)(n.code,{children:"Join"}),".)"]}),"\n",(0,o.jsx)(n.li,{children:"Start multiple kthreads to execute synchronous RPCs individually, then join the kthreads one by one."}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Which is more efficient? Clearly the former. The latter incurs the cost of kthread creation, and kthreads remain blocked during RPC execution (unavailable for other tasks)."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Do NOT use kthread if you only need concurrent RPC calls."})}),"\n",(0,o.jsx)(n.p,{children:"However, the situation changes when parallel computing is required. kthread enables simple construction of tree-structured parallel computation to fully utilize multi-core resources. For example, if a retrieval process has three parallelizable stages: create two kthreads to run two stages, run the third stage in the current thread, then join the two kthreads. A rough implementation is as follows:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-c++",children:'bool search() {\n  // ... (initialization logic)\n  kthread th1, th2;\n  if (kthread_start_background(&th1, NULL, part1, part1_args) != 0) {\n    LOG(ERROR) << "Fail to create kthread for part1";\n    return false;\n  }\n  if (kthread_start_background(&th2, NULL, part2, part2_args) != 0) {\n    LOG(ERROR) << "Fail to create kthread for part2";\n    return false;\n  }\n  part3(part3_args); // Run in current thread\n  kthread_join(th1);\n  kthread_join(th2);\n  return true;\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"Key points about this implementation:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"You could create three kthreads (one for each stage) and join them all, but this consumes one additional thread resource compared to the above approach."}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"There is a scheduling delay from kthread creation to execution. On lightly loaded machines:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Median delay: ~3 microseconds"}),"\n",(0,o.jsx)(n.li,{children:"90th percentile: within 10 microseconds"}),"\n",(0,o.jsx)(n.li,{children:"99.99th percentile: within 30 microseconds"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"This implies two things:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"The benefit of kthread is significant only when computation time exceeds 1ms. For trivial computations (completing in a few microseconds), kthread is meaningless."}),"\n",(0,o.jsx)(n.li,{children:"Try to run the slowest stage in the current thread. Even if the kthread stages are delayed by a few microseconds, they will likely finish first\u2014eliminating the impact of scheduling delay. Additionally, joining an already completed kthread returns immediately with no context switch overhead."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["kthread can also replace thread pools for executing a class of jobs. If job execution order is required, use ",(0,o.jsx)(n.a,{href:"/cppdev/zh-cn/docs/foundamentals/fibers/execution_queue",children:"ExecutionQueue"})," (built on kthread)."]}),"\n",(0,o.jsx)(n.h2,{id:"when-to-use-taskflow",children:"When to Use Taskflow"}),"\n",(0,o.jsxs)(n.p,{children:["Taskflow is designed for ",(0,o.jsx)(n.strong,{children:"continuous high-density computation"})," and ",(0,o.jsx)(n.strong,{children:"complex task dependencies"}),". The underlying implementation of ",(0,o.jsx)(n.code,{children:"Taskflow"})," runs on..."]})]})}function d(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>i});var r=s(6540);const o={},t=r.createContext(o);function a(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);