"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[3434],{1727:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>h,contentTitle:()=>l,default:()=>a,frontMatter:()=>i,metadata:()=>c,toc:()=>o});const c=JSON.parse('{"id":"testing/gt/reference/assertions","title":"Assertions Reference","description":"This page lists the assertion macros provided by GoogleTest for verifying code","source":"@site/docs/testing/gt/reference/assertions.md","sourceDirName":"testing/gt/reference","slug":"/testing/gt/reference/assertions","permalink":"/cppdev/zh-cn/docs/testing/gt/reference/assertions","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/testing/gt/reference/assertions.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Mocking Reference","permalink":"/cppdev/zh-cn/docs/testing/gt/reference/mocking"},"next":{"title":"Matchers Reference","permalink":"/cppdev/zh-cn/docs/testing/gt/reference/matchers"}}');var d=s(4848),r=s(8453);const i={},l="Assertions Reference",h={},o=[{value:"Explicit Success and Failure",id:"success-failure",level:2},{value:"SUCCEED",id:"SUCCEED",level:3},{value:"FAIL",id:"FAIL",level:3},{value:"ADD_FAILURE",id:"ADD_FAILURE",level:3},{value:"ADD_FAILURE_AT",id:"ADD_FAILURE_AT",level:3},{value:"Generalized Assertion",id:"generalized",level:2},{value:"EXPECT_THAT",id:"EXPECT_THAT",level:3},{value:"Boolean Conditions",id:"boolean",level:2},{value:"EXPECT_TRUE",id:"EXPECT_TRUE",level:3},{value:"EXPECT_FALSE",id:"EXPECT_FALSE",level:3},{value:"Binary Comparison",id:"binary-comparison",level:2},{value:"EXPECT_EQ",id:"EXPECT_EQ",level:3},{value:"EXPECT_NE",id:"EXPECT_NE",level:3},{value:"EXPECT_LT",id:"EXPECT_LT",level:3},{value:"EXPECT_LE",id:"EXPECT_LE",level:3},{value:"EXPECT_GT",id:"EXPECT_GT",level:3},{value:"EXPECT_GE",id:"EXPECT_GE",level:3},{value:"String Comparison",id:"c-strings",level:2},{value:"EXPECT_STREQ",id:"EXPECT_STREQ",level:3},{value:"EXPECT_STRNE",id:"EXPECT_STRNE",level:3},{value:"EXPECT_STRCASEEQ",id:"EXPECT_STRCASEEQ",level:3},{value:"EXPECT_STRCASENE",id:"EXPECT_STRCASENE",level:3},{value:"Floating-Point Comparison",id:"floating-point",level:2},{value:"EXPECT_FLOAT_EQ",id:"EXPECT_FLOAT_EQ",level:3},{value:"EXPECT_DOUBLE_EQ",id:"EXPECT_DOUBLE_EQ",level:3},{value:"EXPECT_NEAR",id:"EXPECT_NEAR",level:3},{value:"Exception Assertions",id:"exceptions",level:2},{value:"EXPECT_THROW",id:"EXPECT_THROW",level:3},{value:"EXPECT_ANY_THROW",id:"EXPECT_ANY_THROW",level:3},{value:"EXPECT_NO_THROW",id:"EXPECT_NO_THROW",level:3},{value:"Predicate Assertions",id:"predicates",level:2},{value:"EXPECT_PRED*",id:"EXPECT_PRED",level:3},{value:"EXPECT_PRED_FORMAT*",id:"EXPECT_PRED_FORMAT",level:3},{value:"Windows HRESULT Assertions",id:"HRESULT",level:2},{value:"EXPECT_HRESULT_SUCCEEDED",id:"EXPECT_HRESULT_SUCCEEDED",level:3},{value:"EXPECT_HRESULT_FAILED",id:"EXPECT_HRESULT_FAILED",level:3},{value:"Death Assertions",id:"death",level:2},{value:"EXPECT_DEATH",id:"EXPECT_DEATH",level:3},{value:"EXPECT_DEATH_IF_SUPPORTED",id:"EXPECT_DEATH_IF_SUPPORTED",level:3},{value:"EXPECT_DEBUG_DEATH",id:"EXPECT_DEBUG_DEATH",level:3},{value:"EXPECT_EXIT",id:"EXPECT_EXIT",level:3}];function t(e){const n={a:"a",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(n.header,{children:(0,d.jsx)(n.h1,{id:"assertions-reference",children:"Assertions Reference"})}),"\n",(0,d.jsxs)(n.p,{children:["This page lists the assertion macros provided by GoogleTest for verifying code\nbehavior. To use them, add ",(0,d.jsx)(n.code,{children:"#include <gtest/gtest.h>"}),"."]}),"\n",(0,d.jsxs)(n.p,{children:["The majority of the macros listed below come as a pair with an ",(0,d.jsx)(n.code,{children:"EXPECT_"})," variant\nand an ",(0,d.jsx)(n.code,{children:"ASSERT_"})," variant. Upon failure, ",(0,d.jsx)(n.code,{children:"EXPECT_"})," macros generate nonfatal\nfailures and allow the current function to continue running, while ",(0,d.jsx)(n.code,{children:"ASSERT_"}),"\nmacros generate fatal failures and abort the current function."]}),"\n",(0,d.jsxs)(n.p,{children:["All assertion macros support streaming a custom failure message into them with\nthe ",(0,d.jsx)(n.code,{children:"<<"})," operator, for example:"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",children:'EXPECT_TRUE(my_condition) << "My condition is not true";\n'})}),"\n",(0,d.jsxs)(n.p,{children:["Anything that can be streamed to an ",(0,d.jsx)(n.code,{children:"ostream"})," can be streamed to an assertion\nmacro\u2014in particular, C strings and string objects. If a wide string (",(0,d.jsx)(n.code,{children:"wchar_t*"}),",\n",(0,d.jsx)(n.code,{children:"TCHAR*"})," in ",(0,d.jsx)(n.code,{children:"UNICODE"})," mode on Windows, or ",(0,d.jsx)(n.code,{children:"std::wstring"}),") is streamed to an\nassertion, it will be translated to UTF-8 when printed."]}),"\n",(0,d.jsx)(n.h2,{id:"success-failure",children:"Explicit Success and Failure"}),"\n",(0,d.jsx)(n.p,{children:"The assertions in this section generate a success or failure directly instead of\ntesting a value or expression. These are useful when control flow, rather than a\nBoolean expression, determines the test's success or failure, as shown by the\nfollowing example:"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-c++",children:'switch(expression) {\n  case 1:\n    ... some checks ...\n  case 2:\n    ... some other checks ...\n  default:\n    FAIL() << "We shouldn\'t get here.";\n}\n'})}),"\n",(0,d.jsx)(n.h3,{id:"SUCCEED",children:"SUCCEED"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.code,{children:"SUCCEED()"})}),"\n",(0,d.jsxs)(n.p,{children:["Generates a success. This ",(0,d.jsx)(n.em,{children:"does not"})," make the overall test succeed. A test is\nconsidered successful only if none of its assertions fail during its execution."]}),"\n",(0,d.jsxs)(n.p,{children:["The ",(0,d.jsx)(n.code,{children:"SUCCEED"})," assertion is purely documentary and currently doesn't generate any\nuser-visible output. However, we may add ",(0,d.jsx)(n.code,{children:"SUCCEED"})," messages to GoogleTest output\nin the future."]}),"\n",(0,d.jsx)(n.h3,{id:"FAIL",children:"FAIL"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.code,{children:"FAIL()"})}),"\n",(0,d.jsx)(n.p,{children:"Generates a fatal failure, which returns from the current function."}),"\n",(0,d.jsxs)(n.p,{children:["Can only be used in functions that return ",(0,d.jsx)(n.code,{children:"void"}),". See\n",(0,d.jsx)(n.a,{href:"/cppdev/zh-cn/docs/testing/gt/advanced#assertion-placement",children:"Assertion Placement"})," for more information."]}),"\n",(0,d.jsx)(n.h3,{id:"ADD_FAILURE",children:"ADD_FAILURE"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.code,{children:"ADD_FAILURE()"})}),"\n",(0,d.jsx)(n.p,{children:"Generates a nonfatal failure, which allows the current function to continue\nrunning."}),"\n",(0,d.jsx)(n.h3,{id:"ADD_FAILURE_AT",children:"ADD_FAILURE_AT"}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"ADD_FAILURE_AT("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"file_path"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"line_number"})}),(0,d.jsx)(n.code,{children:")"})]}),"\n",(0,d.jsx)(n.p,{children:"Generates a nonfatal failure at the file and line number specified."}),"\n",(0,d.jsx)(n.h2,{id:"generalized",children:"Generalized Assertion"}),"\n",(0,d.jsxs)(n.p,{children:["The following assertion allows ",(0,d.jsx)(n.a,{href:"/cppdev/zh-cn/docs/testing/gt/reference/matchers",children:"matchers"})," to be used to verify\nvalues."]}),"\n",(0,d.jsx)(n.h3,{id:"EXPECT_THAT",children:"EXPECT_THAT"}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"EXPECT_THAT("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"value"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"matcher"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"ASSERT_THAT("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"value"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"matcher"})}),(0,d.jsx)(n.code,{children:")"})]}),"\n",(0,d.jsxs)(n.p,{children:["Verifies that ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"value"})})," matches the ",(0,d.jsx)(n.a,{href:"/cppdev/zh-cn/docs/testing/gt/reference/matchers",children:"matcher"})," ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"matcher"})}),"."]}),"\n",(0,d.jsxs)(n.p,{children:["For example, the following code verifies that the string ",(0,d.jsx)(n.code,{children:"value1"})," starts with\n",(0,d.jsx)(n.code,{children:'"Hello"'}),", ",(0,d.jsx)(n.code,{children:"value2"})," matches a regular expression, and ",(0,d.jsx)(n.code,{children:"value3"})," is between 5 and\n10:"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",children:'#include <gmock/gmock.h>\n\nusing ::testing::AllOf;\nusing ::testing::Gt;\nusing ::testing::Lt;\nusing ::testing::MatchesRegex;\nusing ::testing::StartsWith;\n\n...\nEXPECT_THAT(value1, StartsWith("Hello"));\nEXPECT_THAT(value2, MatchesRegex("Line \\\\d+"));\nASSERT_THAT(value3, AllOf(Gt(5), Lt(10)));\n'})}),"\n",(0,d.jsxs)(n.p,{children:["Matchers enable assertions of this form to read like English and generate\ninformative failure messages. For example, if the above assertion on ",(0,d.jsx)(n.code,{children:"value1"}),"\nfails, the resulting message will be similar to the following:"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:'Value of: value1\n  Actual: "Hi, world!"\nExpected: starts with "Hello"\n'})}),"\n",(0,d.jsxs)(n.p,{children:["GoogleTest provides a built-in library of matchers\u2014see the\n",(0,d.jsx)(n.a,{href:"/cppdev/zh-cn/docs/testing/gt/reference/matchers",children:"Matchers Reference"}),". It is also possible to write your own\nmatchers\u2014see ",(0,d.jsx)(n.a,{href:"/cppdev/zh-cn/docs/testing/gt/gmock_cook_book#NewMatchers",children:"Writing New Matchers Quickly"}),".\nThe use of matchers makes ",(0,d.jsx)(n.code,{children:"EXPECT_THAT"})," a powerful, extensible assertion."]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsxs)(n.em,{children:["The idea for this assertion was borrowed from Joe Walnes' Hamcrest project,\nwhich adds ",(0,d.jsx)(n.code,{children:"assertThat()"})," to JUnit."]})}),"\n",(0,d.jsx)(n.h2,{id:"boolean",children:"Boolean Conditions"}),"\n",(0,d.jsx)(n.p,{children:"The following assertions test Boolean conditions."}),"\n",(0,d.jsx)(n.h3,{id:"EXPECT_TRUE",children:"EXPECT_TRUE"}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"EXPECT_TRUE("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"condition"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"ASSERT_TRUE("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"condition"})}),(0,d.jsx)(n.code,{children:")"})]}),"\n",(0,d.jsxs)(n.p,{children:["Verifies that ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"condition"})})," is true."]}),"\n",(0,d.jsx)(n.h3,{id:"EXPECT_FALSE",children:"EXPECT_FALSE"}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"EXPECT_FALSE("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"condition"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"ASSERT_FALSE("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"condition"})}),(0,d.jsx)(n.code,{children:")"})]}),"\n",(0,d.jsxs)(n.p,{children:["Verifies that ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"condition"})})," is false."]}),"\n",(0,d.jsx)(n.h2,{id:"binary-comparison",children:"Binary Comparison"}),"\n",(0,d.jsx)(n.p,{children:"The following assertions compare two values. The value arguments must be\ncomparable by the assertion's comparison operator, otherwise a compiler error\nwill result."}),"\n",(0,d.jsxs)(n.p,{children:["If an argument supports the ",(0,d.jsx)(n.code,{children:"<<"})," operator, it will be called to print the\nargument when the assertion fails. Otherwise, GoogleTest will attempt to print\nthem in the best way it can\u2014see\n",(0,d.jsx)(n.a,{href:"/cppdev/zh-cn/docs/testing/gt/advanced#teaching-googletest-how-to-print-your-values",children:"Teaching GoogleTest How to Print Your Values"}),"."]}),"\n",(0,d.jsx)(n.p,{children:"Arguments are always evaluated exactly once, so it's OK for the arguments to\nhave side effects. However, the argument evaluation order is undefined and\nprograms should not depend on any particular argument evaluation order."}),"\n",(0,d.jsxs)(n.p,{children:["These assertions work with both narrow and wide string objects (",(0,d.jsx)(n.code,{children:"string"})," and\n",(0,d.jsx)(n.code,{children:"wstring"}),")."]}),"\n",(0,d.jsxs)(n.p,{children:["See also the ",(0,d.jsx)(n.a,{href:"#floating-point",children:"Floating-Point Comparison"})," assertions to compare\nfloating-point numbers and avoid problems caused by rounding."]}),"\n",(0,d.jsx)(n.h3,{id:"EXPECT_EQ",children:"EXPECT_EQ"}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"EXPECT_EQ("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"ASSERT_EQ("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),(0,d.jsx)(n.code,{children:")"})]}),"\n",(0,d.jsxs)(n.p,{children:["Verifies that ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:"=="}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),"."]}),"\n",(0,d.jsxs)(n.p,{children:["Does pointer equality on pointers. If used on two C strings, it tests if they\nare in the same memory location, not if they have the same value. Use\n",(0,d.jsx)(n.a,{href:"#EXPECT_STREQ",children:(0,d.jsx)(n.code,{children:"EXPECT_STREQ"})})," to compare C strings (e.g. ",(0,d.jsx)(n.code,{children:"const char*"}),") by\nvalue."]}),"\n",(0,d.jsxs)(n.p,{children:["When comparing a pointer to ",(0,d.jsx)(n.code,{children:"NULL"}),", use ",(0,d.jsx)(n.code,{children:"EXPECT_EQ("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"ptr"})}),(0,d.jsx)(n.code,{children:", nullptr)"})," instead\nof ",(0,d.jsx)(n.code,{children:"EXPECT_EQ("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"ptr"})}),(0,d.jsx)(n.code,{children:", NULL)"}),"."]}),"\n",(0,d.jsx)(n.h3,{id:"EXPECT_NE",children:"EXPECT_NE"}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"EXPECT_NE("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"ASSERT_NE("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),(0,d.jsx)(n.code,{children:")"})]}),"\n",(0,d.jsxs)(n.p,{children:["Verifies that ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:"!="}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),"."]}),"\n",(0,d.jsxs)(n.p,{children:["Does pointer equality on pointers. If used on two C strings, it tests if they\nare in different memory locations, not if they have different values. Use\n",(0,d.jsx)(n.a,{href:"#EXPECT_STRNE",children:(0,d.jsx)(n.code,{children:"EXPECT_STRNE"})})," to compare C strings (e.g. ",(0,d.jsx)(n.code,{children:"const char*"}),") by\nvalue."]}),"\n",(0,d.jsxs)(n.p,{children:["When comparing a pointer to ",(0,d.jsx)(n.code,{children:"NULL"}),", use ",(0,d.jsx)(n.code,{children:"EXPECT_NE("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"ptr"})}),(0,d.jsx)(n.code,{children:", nullptr)"})," instead\nof ",(0,d.jsx)(n.code,{children:"EXPECT_NE("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"ptr"})}),(0,d.jsx)(n.code,{children:", NULL)"}),"."]}),"\n",(0,d.jsx)(n.h3,{id:"EXPECT_LT",children:"EXPECT_LT"}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"EXPECT_LT("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"ASSERT_LT("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),(0,d.jsx)(n.code,{children:")"})]}),"\n",(0,d.jsxs)(n.p,{children:["Verifies that ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:"<"}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),"."]}),"\n",(0,d.jsx)(n.h3,{id:"EXPECT_LE",children:"EXPECT_LE"}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"EXPECT_LE("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"ASSERT_LE("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),(0,d.jsx)(n.code,{children:")"})]}),"\n",(0,d.jsxs)(n.p,{children:["Verifies that ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:"<="}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),"."]}),"\n",(0,d.jsx)(n.h3,{id:"EXPECT_GT",children:"EXPECT_GT"}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"EXPECT_GT("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"ASSERT_GT("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),(0,d.jsx)(n.code,{children:")"})]}),"\n",(0,d.jsxs)(n.p,{children:["Verifies that ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:">"}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),"."]}),"\n",(0,d.jsx)(n.h3,{id:"EXPECT_GE",children:"EXPECT_GE"}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"EXPECT_GE("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"ASSERT_GE("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),(0,d.jsx)(n.code,{children:")"})]}),"\n",(0,d.jsxs)(n.p,{children:["Verifies that ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:">="}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),"."]}),"\n",(0,d.jsx)(n.h2,{id:"c-strings",children:"String Comparison"}),"\n",(0,d.jsxs)(n.p,{children:["The following assertions compare two ",(0,d.jsx)(n.strong,{children:"C strings"}),". To compare two ",(0,d.jsx)(n.code,{children:"string"}),"\nobjects, use ",(0,d.jsx)(n.a,{href:"#EXPECT_EQ",children:(0,d.jsx)(n.code,{children:"EXPECT_EQ"})})," or ",(0,d.jsx)(n.a,{href:"#EXPECT_NE",children:(0,d.jsx)(n.code,{children:"EXPECT_NE"})})," instead."]}),"\n",(0,d.jsxs)(n.p,{children:["These assertions also accept wide C strings (",(0,d.jsx)(n.code,{children:"wchar_t*"}),"). If a comparison of two\nwide strings fails, their values will be printed as UTF-8 narrow strings."]}),"\n",(0,d.jsxs)(n.p,{children:["To compare a C string with ",(0,d.jsx)(n.code,{children:"NULL"}),", use ",(0,d.jsx)(n.code,{children:"EXPECT_EQ("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"c_string"})}),(0,d.jsx)(n.code,{children:", nullptr)"})," or\n",(0,d.jsx)(n.code,{children:"EXPECT_NE("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"c_string"})}),(0,d.jsx)(n.code,{children:", nullptr)"}),"."]}),"\n",(0,d.jsx)(n.h3,{id:"EXPECT_STREQ",children:"EXPECT_STREQ"}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"EXPECT_STREQ("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"str1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"str2"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"ASSERT_STREQ("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"str1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"str2"})}),(0,d.jsx)(n.code,{children:")"})]}),"\n",(0,d.jsxs)(n.p,{children:["Verifies that the two C strings ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"str1"})})," and ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"str2"})})," have the same contents."]}),"\n",(0,d.jsx)(n.h3,{id:"EXPECT_STRNE",children:"EXPECT_STRNE"}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"EXPECT_STRNE("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"str1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"str2"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"ASSERT_STRNE("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"str1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"str2"})}),(0,d.jsx)(n.code,{children:")"})]}),"\n",(0,d.jsxs)(n.p,{children:["Verifies that the two C strings ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"str1"})})," and ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"str2"})})," have different contents."]}),"\n",(0,d.jsx)(n.h3,{id:"EXPECT_STRCASEEQ",children:"EXPECT_STRCASEEQ"}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"EXPECT_STRCASEEQ("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"str1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"str2"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"ASSERT_STRCASEEQ("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"str1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"str2"})}),(0,d.jsx)(n.code,{children:")"})]}),"\n",(0,d.jsxs)(n.p,{children:["Verifies that the two C strings ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"str1"})})," and ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"str2"})})," have the same contents,\nignoring case."]}),"\n",(0,d.jsx)(n.h3,{id:"EXPECT_STRCASENE",children:"EXPECT_STRCASENE"}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"EXPECT_STRCASENE("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"str1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"str2"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"ASSERT_STRCASENE("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"str1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"str2"})}),(0,d.jsx)(n.code,{children:")"})]}),"\n",(0,d.jsxs)(n.p,{children:["Verifies that the two C strings ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"str1"})})," and ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"str2"})})," have different contents,\nignoring case."]}),"\n",(0,d.jsx)(n.h2,{id:"floating-point",children:"Floating-Point Comparison"}),"\n",(0,d.jsx)(n.p,{children:"The following assertions compare two floating-point values."}),"\n",(0,d.jsxs)(n.p,{children:["Due to rounding errors, it is very unlikely that two floating-point values will\nmatch exactly, so ",(0,d.jsx)(n.code,{children:"EXPECT_EQ"})," is not suitable. In general, for floating-point\ncomparison to make sense, the user needs to carefully choose the error bound."]}),"\n",(0,d.jsxs)(n.p,{children:["GoogleTest also provides assertions that use a default error bound based on\nUnits in the Last Place (ULPs). To learn more about ULPs, see the article\n",(0,d.jsx)(n.a,{href:"https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/",children:"Comparing Floating Point Numbers"}),"."]}),"\n",(0,d.jsx)(n.h3,{id:"EXPECT_FLOAT_EQ",children:"EXPECT_FLOAT_EQ"}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"EXPECT_FLOAT_EQ("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"ASSERT_FLOAT_EQ("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),(0,d.jsx)(n.code,{children:")"})]}),"\n",(0,d.jsxs)(n.p,{children:["Verifies that the two ",(0,d.jsx)(n.code,{children:"float"})," values ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})})," and ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})})," are approximately\nequal, to within 4 ULPs from each other. Infinity and the largest finite float\nvalue are considered to be one ULP apart."]}),"\n",(0,d.jsx)(n.h3,{id:"EXPECT_DOUBLE_EQ",children:"EXPECT_DOUBLE_EQ"}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"EXPECT_DOUBLE_EQ("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"ASSERT_DOUBLE_EQ("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),(0,d.jsx)(n.code,{children:")"})]}),"\n",(0,d.jsxs)(n.p,{children:["Verifies that the two ",(0,d.jsx)(n.code,{children:"double"})," values ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})})," and ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})})," are approximately\nequal, to within 4 ULPs from each other. Infinity and the largest finite double\nvalue are considered to be one ULP apart."]}),"\n",(0,d.jsx)(n.h3,{id:"EXPECT_NEAR",children:"EXPECT_NEAR"}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"EXPECT_NEAR("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"abs_error"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"ASSERT_NEAR("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"abs_error"})}),(0,d.jsx)(n.code,{children:")"})]}),"\n",(0,d.jsxs)(n.p,{children:["Verifies that the difference between ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})})," and ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})})," does not exceed the\nabsolute error bound ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"abs_error"})}),"."]}),"\n",(0,d.jsxs)(n.p,{children:["If ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val"})})," and ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})})," are both infinity of the same sign, the difference is\nconsidered to be 0. Otherwise, if either value is infinity, the difference is\nconsidered to be infinity. All non-NaN values (including infinity) are\nconsidered to not exceed an ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"abs_error"})})," of infinity."]}),"\n",(0,d.jsx)(n.h2,{id:"exceptions",children:"Exception Assertions"}),"\n",(0,d.jsx)(n.p,{children:"The following assertions verify that a piece of code throws, or does not throw,\nan exception. Usage requires exceptions to be enabled in the build environment."}),"\n",(0,d.jsx)(n.p,{children:"Note that the piece of code under test can be a compound statement, for example:"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",children:"EXPECT_NO_THROW({\n  int n = 5;\n  DoSomething(&n);\n});\n"})}),"\n",(0,d.jsx)(n.h3,{id:"EXPECT_THROW",children:"EXPECT_THROW"}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"EXPECT_THROW("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"statement"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"exception_type"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"ASSERT_THROW("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"statement"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"exception_type"})}),(0,d.jsx)(n.code,{children:")"})]}),"\n",(0,d.jsxs)(n.p,{children:["Verifies that ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"statement"})})," throws an exception of type ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"exception_type"})}),"."]}),"\n",(0,d.jsx)(n.h3,{id:"EXPECT_ANY_THROW",children:"EXPECT_ANY_THROW"}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"EXPECT_ANY_THROW("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"statement"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"ASSERT_ANY_THROW("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"statement"})}),(0,d.jsx)(n.code,{children:")"})]}),"\n",(0,d.jsxs)(n.p,{children:["Verifies that ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"statement"})})," throws an exception of any type."]}),"\n",(0,d.jsx)(n.h3,{id:"EXPECT_NO_THROW",children:"EXPECT_NO_THROW"}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"EXPECT_NO_THROW("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"statement"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"ASSERT_NO_THROW("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"statement"})}),(0,d.jsx)(n.code,{children:")"})]}),"\n",(0,d.jsxs)(n.p,{children:["Verifies that ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"statement"})})," does not throw any exception."]}),"\n",(0,d.jsx)(n.h2,{id:"predicates",children:"Predicate Assertions"}),"\n",(0,d.jsxs)(n.p,{children:["The following assertions enable more complex predicates to be verified while\nprinting a more clear failure message than if ",(0,d.jsx)(n.code,{children:"EXPECT_TRUE"})," were used alone."]}),"\n",(0,d.jsx)(n.h3,{id:"EXPECT_PRED",children:"EXPECT_PRED*"}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"EXPECT_PRED1("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"pred"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"EXPECT_PRED2("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"pred"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"EXPECT_PRED3("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"pred"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val3"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"EXPECT_PRED4("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"pred"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val3"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val4"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"EXPECT_PRED5("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"pred"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val3"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val4"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val5"})}),(0,d.jsx)(n.code,{children:")"})]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"ASSERT_PRED1("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"pred"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"ASSERT_PRED2("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"pred"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"ASSERT_PRED3("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"pred"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val3"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"ASSERT_PRED4("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"pred"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val3"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val4"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"ASSERT_PRED5("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"pred"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val3"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val4"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val5"})}),(0,d.jsx)(n.code,{children:")"})]}),"\n",(0,d.jsxs)(n.p,{children:["Verifies that the predicate ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"pred"})})," returns ",(0,d.jsx)(n.code,{children:"true"})," when passed the given values\nas arguments."]}),"\n",(0,d.jsxs)(n.p,{children:["The parameter ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"pred"})})," is a function or functor that accepts as many arguments\nas the corresponding macro accepts values. If ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"pred"})})," returns ",(0,d.jsx)(n.code,{children:"true"})," for the\ngiven arguments, the assertion succeeds, otherwise the assertion fails."]}),"\n",(0,d.jsx)(n.p,{children:"When the assertion fails, it prints the value of each argument. Arguments are\nalways evaluated exactly once."}),"\n",(0,d.jsx)(n.p,{children:"As an example, see the following code:"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",children:"// Returns true if m and n have no common divisors except 1.\nbool MutuallyPrime(int m, int n) { ... }\n...\nconst int a = 3;\nconst int b = 4;\nconst int c = 10;\n...\nEXPECT_PRED2(MutuallyPrime, a, b);  // Succeeds\nEXPECT_PRED2(MutuallyPrime, b, c);  // Fails\n"})}),"\n",(0,d.jsx)(n.p,{children:"In the above example, the first assertion succeeds, and the second fails with\nthe following message:"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"MutuallyPrime(b, c) is false, where\nb is 4\nc is 10\n"})}),"\n",(0,d.jsxs)(n.p,{children:["Note that if the given predicate is an overloaded function or a function\ntemplate, the assertion macro might not be able to determine which version to\nuse, and it might be necessary to explicitly specify the type of the function.\nFor example, for a Boolean function ",(0,d.jsx)(n.code,{children:"IsPositive()"})," overloaded to take either a\nsingle ",(0,d.jsx)(n.code,{children:"int"})," or ",(0,d.jsx)(n.code,{children:"double"})," argument, it would be necessary to write one of the\nfollowing:"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",children:"EXPECT_PRED1(static_cast<bool (*)(int)>(IsPositive), 5);\nEXPECT_PRED1(static_cast<bool (*)(double)>(IsPositive), 3.14);\n"})}),"\n",(0,d.jsxs)(n.p,{children:["Writing simply ",(0,d.jsx)(n.code,{children:"EXPECT_PRED1(IsPositive, 5);"})," would result in a compiler error.\nSimilarly, to use a template function, specify the template arguments:"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",children:"template <typename T>\nbool IsNegative(T x) {\n  return x < 0;\n}\n...\nEXPECT_PRED1(IsNegative<int>, -5);  // Must specify type for IsNegative\n"})}),"\n",(0,d.jsx)(n.p,{children:"If a template has multiple parameters, wrap the predicate in parentheses so the\nmacro arguments are parsed correctly:"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",children:"ASSERT_PRED2((MyPredicate<int, int>), 5, 0);\n"})}),"\n",(0,d.jsx)(n.h3,{id:"EXPECT_PRED_FORMAT",children:"EXPECT_PRED_FORMAT*"}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"EXPECT_PRED_FORMAT1("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"pred_formatter"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"EXPECT_PRED_FORMAT2("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"pred_formatter"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"EXPECT_PRED_FORMAT3("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"pred_formatter"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val3"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"EXPECT_PRED_FORMAT4("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"pred_formatter"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val3"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val4"})}),(0,d.jsx)(n.code,{children:")"}),"\n",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"EXPECT_PRED_FORMAT5("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"pred_formatter"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val3"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val4"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val5"})}),(0,d.jsx)(n.code,{children:")"})]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"ASSERT_PRED_FORMAT1("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"pred_formatter"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"ASSERT_PRED_FORMAT2("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"pred_formatter"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"ASSERT_PRED_FORMAT3("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"pred_formatter"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val3"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"ASSERT_PRED_FORMAT4("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"pred_formatter"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val3"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val4"})}),(0,d.jsx)(n.code,{children:")"}),"\n",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"ASSERT_PRED_FORMAT5("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"pred_formatter"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val3"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val4"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val5"})}),(0,d.jsx)(n.code,{children:")"})]}),"\n",(0,d.jsxs)(n.p,{children:["Verifies that the predicate ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"pred_formatter"})})," succeeds when passed the given\nvalues as arguments."]}),"\n",(0,d.jsxs)(n.p,{children:["The parameter ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"pred_formatter"})})," is a ",(0,d.jsx)(n.em,{children:"predicate-formatter"}),", which is a function\nor functor with the signature:"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",children:"testing::AssertionResult PredicateFormatter(const char* expr1,\n                                            const char* expr2,\n                                            ...\n                                            const char* exprn,\n                                            T1 val1,\n                                            T2 val2,\n                                            ...\n                                            Tn valn);\n"})}),"\n",(0,d.jsxs)(n.p,{children:["where ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val1"})}),", ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"val2"})}),", ..., ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"valn"})})," are the values of the predicate\narguments, and ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"expr1"})}),", ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"expr2"})}),", ..., ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"exprn"})})," are the corresponding\nexpressions as they appear in the source code. The types ",(0,d.jsx)(n.code,{children:"T1"}),", ",(0,d.jsx)(n.code,{children:"T2"}),", ..., ",(0,d.jsx)(n.code,{children:"Tn"}),"\ncan be either value types or reference types; if an argument has type ",(0,d.jsx)(n.code,{children:"T"}),", it\ncan be declared as either ",(0,d.jsx)(n.code,{children:"T"})," or ",(0,d.jsx)(n.code,{children:"const T&"}),", whichever is appropriate. For more\nabout the return type ",(0,d.jsx)(n.code,{children:"testing::AssertionResult"}),", see\n",(0,d.jsx)(n.a,{href:"/cppdev/zh-cn/docs/testing/gt/advanced#using-a-function-that-returns-an-assertionresult",children:"Using a Function That Returns an AssertionResult"}),"."]}),"\n",(0,d.jsx)(n.p,{children:"As an example, see the following code:"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",children:'// Returns the smallest prime common divisor of m and n,\n// or 1 when m and n are mutually prime.\nint SmallestPrimeCommonDivisor(int m, int n) { ... }\n\n// Returns true if m and n have no common divisors except 1.\nbool MutuallyPrime(int m, int n) { ... }\n\n// A predicate-formatter for asserting that two integers are mutually prime.\ntesting::AssertionResult AssertMutuallyPrime(const char* m_expr,\n                                             const char* n_expr,\n                                             int m,\n                                             int n) {\n  if (MutuallyPrime(m, n)) return testing::AssertionSuccess();\n\n  return testing::AssertionFailure() << m_expr << " and " << n_expr\n      << " (" << m << " and " << n << ") are not mutually prime, "\n      << "as they have a common divisor " << SmallestPrimeCommonDivisor(m, n);\n}\n\n...\nconst int a = 3;\nconst int b = 4;\nconst int c = 10;\n...\nEXPECT_PRED_FORMAT2(AssertMutuallyPrime, a, b);  // Succeeds\nEXPECT_PRED_FORMAT2(AssertMutuallyPrime, b, c);  // Fails\n'})}),"\n",(0,d.jsx)(n.p,{children:"In the above example, the final assertion fails and the predicate-formatter\nproduces the following failure message:"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"b and c (4 and 10) are not mutually prime, as they have a common divisor 2\n"})}),"\n",(0,d.jsx)(n.h2,{id:"HRESULT",children:"Windows HRESULT Assertions"}),"\n",(0,d.jsxs)(n.p,{children:["The following assertions test for ",(0,d.jsx)(n.code,{children:"HRESULT"})," success or failure. For example:"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",children:'CComPtr<IShellDispatch2> shell;\nASSERT_HRESULT_SUCCEEDED(shell.CoCreateInstance(L"Shell.Application"));\nCComVariant empty;\nASSERT_HRESULT_SUCCEEDED(shell->ShellExecute(CComBSTR(url), empty, empty, empty, empty));\n'})}),"\n",(0,d.jsxs)(n.p,{children:["The generated output contains the human-readable error message associated with\nthe returned ",(0,d.jsx)(n.code,{children:"HRESULT"})," code."]}),"\n",(0,d.jsx)(n.h3,{id:"EXPECT_HRESULT_SUCCEEDED",children:"EXPECT_HRESULT_SUCCEEDED"}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"EXPECT_HRESULT_SUCCEEDED("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"expression"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"ASSERT_HRESULT_SUCCEEDED("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"expression"})}),(0,d.jsx)(n.code,{children:")"})]}),"\n",(0,d.jsxs)(n.p,{children:["Verifies that ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"expression"})})," is a success ",(0,d.jsx)(n.code,{children:"HRESULT"}),"."]}),"\n",(0,d.jsx)(n.h3,{id:"EXPECT_HRESULT_FAILED",children:"EXPECT_HRESULT_FAILED"}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"EXPECT_HRESULT_FAILED("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"expression"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"ASSERT_HRESULT_FAILED("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"expression"})}),(0,d.jsx)(n.code,{children:")"})]}),"\n",(0,d.jsxs)(n.p,{children:["Verifies that ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"expression"})})," is a failure ",(0,d.jsx)(n.code,{children:"HRESULT"}),"."]}),"\n",(0,d.jsx)(n.h2,{id:"death",children:"Death Assertions"}),"\n",(0,d.jsxs)(n.p,{children:["The following assertions verify that a piece of code causes the process to\nterminate. For context, see ",(0,d.jsx)(n.a,{href:"/cppdev/zh-cn/docs/testing/gt/advanced#death-tests",children:"Death Tests"}),"."]}),"\n",(0,d.jsxs)(n.p,{children:["These assertions spawn a new process and execute the code under test in that\nprocess. How that happens depends on the platform and the variable\n",(0,d.jsx)(n.code,{children:"::testing::GTEST_FLAG(death_test_style)"}),", which is initialized from the\ncommand-line flag ",(0,d.jsx)(n.code,{children:"--gtest_death_test_style"}),"."]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:["On POSIX systems, ",(0,d.jsx)(n.code,{children:"fork()"})," (or ",(0,d.jsx)(n.code,{children:"clone()"})," on Linux) is used to spawn the\nchild, after which:","\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:["If the variable's value is ",(0,d.jsx)(n.code,{children:'"fast"'}),", the death test statement is\nimmediately executed."]}),"\n",(0,d.jsxs)(n.li,{children:["If the variable's value is ",(0,d.jsx)(n.code,{children:'"threadsafe"'}),", the child process re-executes\nthe unit test binary just as it was originally invoked, but with some\nextra flags to cause just the single death test under consideration to\nbe run."]}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(n.li,{children:["On Windows, the child is spawned using the ",(0,d.jsx)(n.code,{children:"CreateProcess()"})," API, and\nre-executes the binary to cause just the single death test under\nconsideration to be run - much like the ",(0,d.jsx)(n.code,{children:'"threadsafe"'})," mode on POSIX."]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["Other values for the variable are illegal and will cause the death test to fail.\nCurrently, the flag's default value is\n",(0,d.jsx)(n.strong,{children:(0,d.jsx)(n.code,{children:'"fast"'})}),"."]}),"\n",(0,d.jsx)(n.p,{children:"If the death test statement runs to completion without dying, the child process\nwill nonetheless terminate, and the assertion fails."}),"\n",(0,d.jsx)(n.p,{children:"Note that the piece of code under test can be a compound statement, for example:"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",children:'EXPECT_DEATH({\n  int n = 5;\n  DoSomething(&n);\n}, "Error on line .* of DoSomething()");\n'})}),"\n",(0,d.jsx)(n.h3,{id:"EXPECT_DEATH",children:"EXPECT_DEATH"}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"EXPECT_DEATH("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"statement"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"matcher"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"ASSERT_DEATH("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"statement"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"matcher"})}),(0,d.jsx)(n.code,{children:")"})]}),"\n",(0,d.jsxs)(n.p,{children:["Verifies that ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"statement"})})," causes the process to terminate with a nonzero exit\nstatus and produces ",(0,d.jsx)(n.code,{children:"stderr"})," output that matches ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"matcher"})}),"."]}),"\n",(0,d.jsxs)(n.p,{children:["The parameter ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"matcher"})})," is either a ",(0,d.jsx)(n.a,{href:"/cppdev/zh-cn/docs/testing/gt/reference/matchers",children:"matcher"})," for a ",(0,d.jsx)(n.code,{children:"const std::string&"}),", or a regular expression (see\n",(0,d.jsx)(n.a,{href:"/cppdev/zh-cn/docs/testing/gt/advanced#regular-expression-syntax",children:"Regular Expression Syntax"}),")\u2014a bare\nstring ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"s"})})," (with no matcher) is treated as\n",(0,d.jsx)(n.a,{href:"/cppdev/zh-cn/docs/testing/gt/reference/matchers#string-matchers",children:(0,d.jsx)(n.code,{children:"ContainsRegex(s)"})}),", ",(0,d.jsx)(n.strong,{children:"not"}),"\n",(0,d.jsx)(n.a,{href:"/cppdev/zh-cn/docs/testing/gt/reference/matchers#generic-comparison",children:(0,d.jsx)(n.code,{children:"Eq(s)"})}),"."]}),"\n",(0,d.jsxs)(n.p,{children:["For example, the following code verifies that calling ",(0,d.jsx)(n.code,{children:"DoSomething(42)"})," causes\nthe process to die with an error message that contains the text ",(0,d.jsx)(n.code,{children:"My error"}),":"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",children:'EXPECT_DEATH(DoSomething(42), "My error");\n'})}),"\n",(0,d.jsx)(n.h3,{id:"EXPECT_DEATH_IF_SUPPORTED",children:"EXPECT_DEATH_IF_SUPPORTED"}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"EXPECT_DEATH_IF_SUPPORTED("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"statement"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"matcher"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"ASSERT_DEATH_IF_SUPPORTED("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"statement"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"matcher"})}),(0,d.jsx)(n.code,{children:")"})]}),"\n",(0,d.jsxs)(n.p,{children:["If death tests are supported, behaves the same as\n",(0,d.jsx)(n.a,{href:"#EXPECT_DEATH",children:(0,d.jsx)(n.code,{children:"EXPECT_DEATH"})}),". Otherwise, verifies nothing."]}),"\n",(0,d.jsx)(n.h3,{id:"EXPECT_DEBUG_DEATH",children:"EXPECT_DEBUG_DEATH"}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"EXPECT_DEBUG_DEATH("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"statement"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"matcher"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"ASSERT_DEBUG_DEATH("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"statement"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"matcher"})}),(0,d.jsx)(n.code,{children:")"})]}),"\n",(0,d.jsxs)(n.p,{children:["In debug mode, behaves the same as ",(0,d.jsx)(n.a,{href:"#EXPECT_DEATH",children:(0,d.jsx)(n.code,{children:"EXPECT_DEATH"})}),". When not in\ndebug mode (i.e. ",(0,d.jsx)(n.code,{children:"NDEBUG"})," is defined), just executes ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"statement"})}),"."]}),"\n",(0,d.jsx)(n.h3,{id:"EXPECT_EXIT",children:"EXPECT_EXIT"}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"EXPECT_EXIT("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"statement"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"predicate"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"matcher"})}),(0,d.jsx)(n.code,{children:")"})," ",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"ASSERT_EXIT("}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"statement"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"predicate"})}),(0,d.jsx)(n.code,{children:","}),(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"matcher"})}),(0,d.jsx)(n.code,{children:")"})]}),"\n",(0,d.jsxs)(n.p,{children:["Verifies that ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"statement"})})," causes the process to terminate with an exit status\nthat satisfies ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"predicate"})}),", and produces ",(0,d.jsx)(n.code,{children:"stderr"})," output that matches\n",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"matcher"})}),"."]}),"\n",(0,d.jsxs)(n.p,{children:["The parameter ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"predicate"})})," is a function or functor that accepts an ",(0,d.jsx)(n.code,{children:"int"})," exit\nstatus and returns a ",(0,d.jsx)(n.code,{children:"bool"}),". GoogleTest provides two predicates to handle common\ncases:"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",children:"// Returns true if the program exited normally with the given exit status code.\n::testing::ExitedWithCode(exit_code);\n\n// Returns true if the program was killed by the given signal.\n// Not available on Windows.\n::testing::KilledBySignal(signal_number);\n"})}),"\n",(0,d.jsxs)(n.p,{children:["The parameter ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"matcher"})})," is either a ",(0,d.jsx)(n.a,{href:"/cppdev/zh-cn/docs/testing/gt/reference/matchers",children:"matcher"})," for a ",(0,d.jsx)(n.code,{children:"const std::string&"}),", or a regular expression (see\n",(0,d.jsx)(n.a,{href:"/cppdev/zh-cn/docs/testing/gt/advanced#regular-expression-syntax",children:"Regular Expression Syntax"}),")\u2014a bare\nstring ",(0,d.jsx)(n.em,{children:(0,d.jsx)(n.code,{children:"s"})})," (with no matcher) is treated as\n",(0,d.jsx)(n.a,{href:"/cppdev/zh-cn/docs/testing/gt/reference/matchers#string-matchers",children:(0,d.jsx)(n.code,{children:"ContainsRegex(s)"})}),", ",(0,d.jsx)(n.strong,{children:"not"}),"\n",(0,d.jsx)(n.a,{href:"/cppdev/zh-cn/docs/testing/gt/reference/matchers#generic-comparison",children:(0,d.jsx)(n.code,{children:"Eq(s)"})}),"."]}),"\n",(0,d.jsxs)(n.p,{children:["For example, the following code verifies that calling ",(0,d.jsx)(n.code,{children:"NormalExit()"})," causes the\nprocess to print a message containing the text ",(0,d.jsx)(n.code,{children:"Success"})," to ",(0,d.jsx)(n.code,{children:"stderr"})," and exit\nwith exit status code 0:"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",children:'EXPECT_EXIT(NormalExit(), testing::ExitedWithCode(0), "Success");\n'})})]})}function a(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(t,{...e})}):t(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>l});var c=s(6540);const d={},r=c.createContext(d);function i(e){const n=c.useContext(r);return c.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:i(e.components),c.createElement(r.Provider,{value:n},e.children)}}}]);