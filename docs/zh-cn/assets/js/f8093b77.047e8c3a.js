"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[9069],{8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>c});var r=t(6540);const s={},i=r.createContext(s);function o(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(i.Provider,{value:n},e.children)}},8461:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"foundamentals/json/encoding","title":"Encoding","description":"According to ECMA-404:","source":"@site/docs/foundamentals/json/encoding.mdx","sourceDirName":"foundamentals/json","slug":"/foundamentals/json/encoding","permalink":"/cppdev/zh-cn/docs/foundamentals/json/encoding","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/foundamentals/json/encoding.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Streams","permalink":"/cppdev/zh-cn/docs/foundamentals/json/stream"},"next":{"title":"DOM","permalink":"/cppdev/zh-cn/docs/foundamentals/json/dom"}}');var s=t(4848),i=t(8453);const o={},c="Encoding",a={},d=[{value:"Unicode Transformation Formats (UTF)",id:"UTF",level:2},{value:"Character Type",id:"CharacterType",level:2},{value:"AutoUTF",id:"AutoUTF",level:2},{value:"ASCII",id:"ASCII",level:2},{value:"Transcoder",id:"Transcoder",level:2}];function l(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"encoding",children:"Encoding"})}),"\n",(0,s.jsxs)(n.p,{children:["According to ",(0,s.jsx)(n.a,{href:"http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf",children:"ECMA-404"}),":"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"(in Introduction) JSON text is a sequence of Unicode code points."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Earlier, ",(0,s.jsx)(n.a,{href:"http://www.ietf.org/rfc/rfc4627.txt",children:"RFC4627"})," states:"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"(in \xa73) JSON text SHALL be encoded in Unicode.  The default encoding is UTF-8.\n(in \xa76) JSON may be represented using UTF-8, UTF-16, or UTF-32. When JSON is written in UTF-8, JSON is 8-bit compatible.  When JSON is written in UTF-16 or UTF-32, the binary content-transfer-encoding must be used."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Merak supports multiple encodings. It can also validate the encoding of JSON and perform transcoding between different encodings. All these features are implemented internally, without relying on external libraries (e.g., ",(0,s.jsx)(n.a,{href:"http://site.icu-project.org/",children:"ICU"}),")."]}),"\n",(0,s.jsx)(n.p,{children:"[TOC]"}),"\n",(0,s.jsx)(n.h1,{id:"Unicode",children:"Unicode"}),"\n",(0,s.jsxs)(n.p,{children:["According to the ",(0,s.jsx)(n.a,{href:"http://www.unicode.org/standard/translations/t-chinese.html",children:"official Unicode website"}),":"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Unicode provides a unique number for every character,\nno matter what platform,\nno matter what program,\nno matter what language."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["These unique numbers are called ",(0,s.jsx)(n.strong,{children:"code points"}),", ranging from ",(0,s.jsx)(n.code,{children:"0x0"})," to ",(0,s.jsx)(n.code,{children:"0x10FFFF"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"UTF",children:"Unicode Transformation Formats (UTF)"}),"\n",(0,s.jsx)(n.p,{children:"There are multiple ways to encode Unicode code points for storage, known as Unicode Transformation Formats (UTF). Merak supports the most commonly used UTF variants:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"UTF-8: An 8-bit variable-length encoding that maps a single code point to 1 to 4 bytes."}),"\n",(0,s.jsx)(n.li,{children:"UTF-16: A 16-bit variable-length encoding that maps a single code point to 1 to 2 16-bit code units (i.e., 2 to 4 bytes)."}),"\n",(0,s.jsx)(n.li,{children:"UTF-32: A 32-bit fixed-length encoding that directly maps a single code point to one 32-bit code unit (i.e., 4 bytes)."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For UTF-16 and UTF-32, ",(0,s.jsx)(n.strong,{children:"endianness"})," is a critical factor. In memory, they are typically stored using the host machine\u2019s native endianness. However, when stored in files or transmitted over networks, the endianness of the byte sequence (little-endian/LE or big-endian/BE) must be explicitly specified."]}),"\n",(0,s.jsxs)(n.p,{children:["Merak provides various encodings via structs in ",(0,s.jsx)(n.code,{children:"merak/json/encodings.h"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"namespace merak::json {\n\ntemplate<typename CharType = char>\nstruct UTF8;\n\ntemplate<typename CharType = wchar_t>\nstruct UTF16;\n\ntemplate<typename CharType = wchar_t>\nstruct UTF16LE;\n\ntemplate<typename CharType = wchar_t>\nstruct UTF16BE;\n\ntemplate<typename CharType = unsigned>\nstruct UTF32;\n\ntemplate<typename CharType = unsigned>\nstruct UTF32LE;\n\ntemplate<typename CharType = unsigned>\nstruct UTF32BE;\n\n} // namespace merak::json\n"})}),"\n",(0,s.jsxs)(n.p,{children:["For in-memory text, we typically use ",(0,s.jsx)(n.code,{children:"UTF8"}),", ",(0,s.jsx)(n.code,{children:"UTF16"}),", or ",(0,s.jsx)(n.code,{children:"UTF32"}),". For text processed through I/O operations, ",(0,s.jsx)(n.code,{children:"UTF8"}),", ",(0,s.jsx)(n.code,{children:"UTF16LE"}),", ",(0,s.jsx)(n.code,{children:"UTF16BE"}),", ",(0,s.jsx)(n.code,{children:"UTF32LE"}),", or ",(0,s.jsx)(n.code,{children:"UTF32BE"})," are applicable."]}),"\n",(0,s.jsxs)(n.p,{children:["When using DOM-style APIs, the ",(0,s.jsx)(n.code,{children:"Encoding"})," template parameter in ",(0,s.jsx)(n.code,{children:"GenericValue<Encoding>"})," and ",(0,s.jsx)(n.code,{children:"GenericDocument<Encoding>"})," specifies the encoding of JSON strings stored in memory. Thus, ",(0,s.jsx)(n.code,{children:"UTF8"}),", ",(0,s.jsx)(n.code,{children:"UTF16"}),", or ",(0,s.jsx)(n.code,{children:"UTF32"})," are commonly used here\u2014 the choice depends on the operating system and other libraries used by the application. For example, the Windows API uses UTF-16 for Unicode characters, while most Linux distributions and applications prefer UTF-8."]}),"\n",(0,s.jsx)(n.p,{children:"Example of declaring a DOM with UTF-16:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"typedef GenericDocument<UTF16<> > WDocument;\ntypedef GenericValue<UTF16<> > WValue;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["A more detailed usage example is available in the ",(0,s.jsx)(n.a,{href:"/cppdev/zh-cn/docs/foundamentals/json/stream",children:"DOM's Encoding"})," section."]}),"\n",(0,s.jsx)(n.h2,{id:"CharacterType",children:"Character Type"}),"\n",(0,s.jsxs)(n.p,{children:["As shown in the declarations above, each encoding has a ",(0,s.jsx)(n.code,{children:"CharType"})," template parameter. This can be misleading: in practice, each ",(0,s.jsx)(n.code,{children:"CharType"})," stores a ",(0,s.jsx)(n.strong,{children:"code unit"}),", not a single character (code point). As mentioned earlier, one code point in UTF-8 may be encoded into 1 to 4 code units."]}),"\n",(0,s.jsxs)(n.p,{children:["For ",(0,s.jsx)(n.code,{children:"UTF16(LE|BE)"})," and ",(0,s.jsx)(n.code,{children:"UTF32(LE|BE)"}),", ",(0,s.jsx)(n.code,{children:"CharType"})," must be an integer type of at least 2 and 4 bytes, respectively."]}),"\n",(0,s.jsxs)(n.p,{children:["Note that C++11 introduced ",(0,s.jsx)(n.code,{children:"char16_t"})," and ",(0,s.jsx)(n.code,{children:"char32_t"}),", which can be used for ",(0,s.jsx)(n.code,{children:"UTF16"})," and ",(0,s.jsx)(n.code,{children:"UTF32"})," respectively."]}),"\n",(0,s.jsx)(n.h2,{id:"AutoUTF",children:"AutoUTF"}),"\n",(0,s.jsx)(n.p,{children:"The encodings described above are statically bound at compile time\u2014in other words, the user must know the encoding used in memory or streams in advance. However, there are scenarios where we need to read/write files with different encodings that can only be determined at runtime."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"AutoUTF"})," is an encoding designed for this purpose. It selects the appropriate encoding based on the input or output stream. Currently, it should be used with ",(0,s.jsx)(n.code,{children:"EncodedInputStream"})," and ",(0,s.jsx)(n.code,{children:"EncodedOutputStream"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"ASCII",children:"ASCII"}),"\n",(0,s.jsxs)(n.p,{children:["Although the JSON standard does not reference ",(0,s.jsx)(n.a,{href:"http://en.wikipedia.org/wiki/ASCII",children:"ASCII"}),", there are cases where we need to write 7-bit ASCII JSON for applications that cannot handle UTF-8. Since any Unicode character in JSON can be represented as a ",(0,s.jsx)(n.code,{children:"\\uXXXX"})," escape sequence, JSON can always be encoded in ASCII."]}),"\n",(0,s.jsx)(n.p,{children:"Example of writing a UTF-8 DOM to ASCII JSON:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"using namespace merak::json;\nDocument d; // UTF8<>\n// ...\nStringBuffer buffer;\nWriter<StringBuffer, Document::EncodingType, ASCII<> > writer(buffer);\nd.Accept(writer);\nstd::cout << buffer.GetString();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["ASCII can be used for input streams. If the input stream contains bytes greater than 127, a ",(0,s.jsx)(n.code,{children:"kParseErrorStringInvalidEncoding"})," error will be thrown."]}),"\n",(0,s.jsxs)(n.p,{children:["ASCII ",(0,s.jsx)(n.em,{children:"cannot"})," be used for memory (the encoding of ",(0,s.jsx)(n.code,{children:"Document"})," or the target encoding of ",(0,s.jsx)(n.code,{children:"Reader"}),"), as it cannot represent Unicode code points."]}),"\n",(0,s.jsx)(n.h1,{id:"ValidationTranscoding",children:"Validation and Transcoding"}),"\n",(0,s.jsxs)(n.p,{children:["When Merak parses JSON, it can validate whether the input JSON is a valid sequence of the specified encoding. To enable this feature, add ",(0,s.jsx)(n.code,{children:"kParseValidateEncodingFlag"})," to the ",(0,s.jsx)(n.code,{children:"parseFlags"})," template parameter."]}),"\n",(0,s.jsxs)(n.p,{children:["If the input encoding differs from the output encoding, ",(0,s.jsx)(n.code,{children:"Reader"})," and ",(0,s.jsx)(n.code,{children:"Writer"})," will automatically transcode the text. In this case, ",(0,s.jsx)(n.code,{children:"kParseValidateEncodingFlag"})," is unnecessary\u2014decoding the input sequence is mandatory, and invalid sequences will fail to decode by default."]}),"\n",(0,s.jsx)(n.h2,{id:"Transcoder",children:"Transcoder"}),"\n",(0,s.jsx)(n.p,{children:'Although Merak\u2019s encoding features are designed for JSON parsing/generation, users can also "repurpose" them to transcode non-JSON strings.'}),"\n",(0,s.jsx)(n.p,{children:"Example of transcoding a UTF-8 string to UTF-16:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include "merak/json/encodings.h"\n\nusing namespace merak::json;\n\nconst char* s = "..."; // UTF-8 string\nStringStream source(s);\nGenericStringBuffer<UTF16<> > target;\n\nbool hasError = false;\nwhile (source.Peek() != \'\\0\')\n    if (!Transcoder<UTF8<>, UTF16<> >::Transcode(source, target)) {\n        hasError = true;\n        break;\n    }\n\nif (!hasError) {\n    const wchar_t* t = target.GetString();\n    // ...\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["You can also use ",(0,s.jsx)(n.code,{children:"AutoUTF"})," and corresponding streams to dynamically set the source/target encodings at runtime."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);