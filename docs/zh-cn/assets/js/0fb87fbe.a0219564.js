"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[9695],{6213:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>g,frontMatter:()=>r,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"log/sinks","title":"Custom Log Sinks","description":"turbo:","source":"@site/docs/log/sinks.mdx","sourceDirName":"log","slug":"/log/sinks","permalink":"/cppdev/zh-cn/docs/log/sinks","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/log/sinks.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Logging","permalink":"/cppdev/zh-cn/docs/log/logging"},"next":{"title":"Built-in LogSink Receivers","permalink":"/cppdev/zh-cn/docs/log/builtin_sinks"}}');var s=t(4848),i=t(8453);const r={},c="Custom Log Sinks",a={},d=[{value:"Basic Interface",id:"basic-interface",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"custom-log-sinks",children:"Custom Log Sinks"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"turbo::LogSink"})," is an extension point for processing logged messages (e.g., by writing them to disk files). A message can be directed to it using the ",(0,s.jsx)(n.code,{children:".ToSinkOnly()"})," or ",(0,s.jsx)(n.code,{children:".ToSinkAlso()"})," ",(0,s.jsx)(n.a,{href:"/cppdev/zh-cn/docs/log/logging#mutators",children:"mutator methods"}),", or a sink can be registered to observe all logged messages (except those using ",(0,s.jsx)(n.code,{children:".ToSinkOnly()"}),") with ",(0,s.jsx)(n.code,{children:"turbo::add_log_sink()"})," and unregistered with ",(0,s.jsx)(n.code,{children:"turbo::remove_log_sink"}),". For example:"]}),"\n",(0,s.jsx)(n.h2,{id:"basic-interface",children:"Basic Interface"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c++",children:'class LinePrinterLogSink : public turbo::LogSink {\n public:\n  LinePrinterLogSink() : fp_(fopen("/dev/lp0", "a")) {\n    PKCHECK(fp_ != nullptr) << "Failed to open /dev/lp0";\n  }\n  ~LinePrinterLogSink() {\n    fputc(\'\\f\', fp_);\n    PKCHECK(fclose(fp_) == 0) << "Failed to close /dev/lp0";\n  }\n  void Send(const turbo::LogEntry& entry) override {\n    for (std::string_view line :\n         turbo::sr_split(entry.text_message_with_prefix(), turbo::ByChar(\'\\n\'))) {\n      // Overprint severe entries for emphasis:\n      for (int i = static_cast<int>(turbo::LogSeverity::kInfo);\n           i <= static_cast<int>(entry.log_severity()); i++) {\n        turbo::FPrintF(fp_, "%s\\r", line);\n      }\n      fputc(\'\\n\', fp_);\n    }\n  }\n\n private:\n  FILE* const fp_;\n};\n'})}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.code,{children:"LogSink"})," receives two copies of each ",(0,s.jsx)(n.code,{children:"FATAL"})," message: one without a ",(0,s.jsx)(n.code,{children:"stacktrace"}),", followed by one with it. This quirk ensures that some diagnostic data can be observed even if stack trace collection fails or takes too long. The process will terminate immediately after the ",(0,s.jsx)(n.code,{children:"LogSink"})," returns\u2014meaning the sink does not need to call ",(0,s.jsx)(n.code,{children:"abort()"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Any logging that occurs within a registered ",(0,s.jsx)(n.code,{children:"LogSink"})," (or functions called by a registered ",(0,s.jsx)(n.code,{children:"LogSink"}),") is sent only to ",(0,s.jsx)(n.code,{children:"stderr"}),", not to any registered LogSinks, to avoid infinite recursion."]})]})}function g(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var o=t(6540);const s={},i=o.createContext(s);function r(e){const n=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);