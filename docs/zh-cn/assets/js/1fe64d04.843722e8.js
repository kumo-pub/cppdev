"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[4627],{2993:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>d,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"foundamentals/fibers/std-future","title":"std-future","description":"\u975e\u5e38\u62b1\u6b49\uff0c\u4e4b\u524d\u7684\u5e8f\u53f7\u6392\u7248\u4e0d\u7b26\u5408\u4f60\u7684\u8981\u6c42\u3002\u4ee5\u4e0b\u662f\u8c03\u6574\u540e\u65e0\u5e8f\u53f7\u3001\u7b80\u6d01\u4e13\u4e1a\u7684 std::future \u8be6\u89e3\u6587\u6863\uff0c\u5b8c\u5168\u9075\u5faa\u4f60\u5bf9\u6280\u672f\u6587\u6863\u7684\u683c\u5f0f\u89c4\u8303\uff1a","source":"@site/docs/foundamentals/fibers/std-future.md","sourceDirName":"foundamentals/fibers","slug":"/foundamentals/fibers/std-future","permalink":"/cppdev/zh-cn/docs/foundamentals/fibers/std-future","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/foundamentals/fibers/std-future.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Futures","permalink":"/cppdev/zh-cn/docs/foundamentals/fibers/futures"},"next":{"title":"Execution Queue","permalink":"/cppdev/zh-cn/docs/foundamentals/fibers/execution_queue"}}');var r=s(4848),i=s(8453);const d={},a="Detailed Explanation of std::future",o={},c=[{value:"Core Functionality",id:"core-functionality",level:2},{value:"Primary Use Cases",id:"primary-use-cases",level:2},{value:"Asynchronous Result Retrieval",id:"asynchronous-result-retrieval",level:3},{value:"Non-blocking Task Status Query",id:"non-blocking-task-status-query",level:3},{value:"Thread Synchronization in Producer-Consumer Models",id:"thread-synchronization-in-producer-consumer-models",level:3},{value:"State Management",id:"state-management",level:2},{value:"State Transition Rules",id:"state-transition-rules",level:3},{value:"Comprehensive Usage Examples",id:"comprehensive-usage-examples",level:2},{value:"Basic Usage with <code>std::async</code>",id:"basic-usage-with-stdasync",level:3},{value:"Producer-Consumer Model with <code>std::promise</code> and <code>std::future</code>",id:"producer-consumer-model-with-stdpromise-and-stdfuture",level:3},{value:"Shared Result Access with <code>std::shared_future</code>",id:"shared-result-access-with-stdshared_future",level:3},{value:"Key Features",id:"key-features",level:2},{value:"Exclusive Ownership of <code>std::future</code>",id:"exclusive-ownership-of-stdfuture",level:3},{value:"Exception Propagation Mechanism",id:"exception-propagation-mechanism",level:3},{value:"Compatibility with Other Async Utilities",id:"compatibility-with-other-async-utilities",level:3},{value:"Critical Notes",id:"critical-notes",level:2},{value:"Blocking Behavior Control",id:"blocking-behavior-control",level:3},{value:"Deferred Task Execution Caveat",id:"deferred-task-execution-caveat",level:3},{value:"Thread Safety Considerations",id:"thread-safety-considerations",level:3},{value:"Resource Management Best Practices",id:"resource-management-best-practices",level:3},{value:"Summary",id:"summary",level:2}];function l(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:["\u975e\u5e38\u62b1\u6b49\uff0c\u4e4b\u524d\u7684\u5e8f\u53f7\u6392\u7248\u4e0d\u7b26\u5408\u4f60\u7684\u8981\u6c42\u3002\u4ee5\u4e0b\u662f\u8c03\u6574\u540e",(0,r.jsx)(t.strong,{children:"\u65e0\u5e8f\u53f7\u3001\u7b80\u6d01\u4e13\u4e1a"}),"\u7684 ",(0,r.jsx)(t.code,{children:"std::future"})," \u8be6\u89e3\u6587\u6863\uff0c\u5b8c\u5168\u9075\u5faa\u4f60\u5bf9\u6280\u672f\u6587\u6863\u7684\u683c\u5f0f\u89c4\u8303\uff1a"]}),"\n",(0,r.jsx)(t.header,{children:(0,r.jsxs)(t.h1,{id:"detailed-explanation-of-stdfuture",children:["Detailed Explanation of ",(0,r.jsx)(t.code,{children:"std::future"})]})}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"std::future"})," is a core component of C++ asynchronous programming (introduced in C++11, defined in the ",(0,r.jsx)(t.code,{children:"<future>"})," header). This document provides a comprehensive, practice-oriented explanation of its functionality, usage scenarios, and best practices, with enhanced code examples for production environments."]}),"\n",(0,r.jsx)(t.h2,{id:"core-functionality",children:"Core Functionality"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"std::future"})," is a class template in the C++ Standard Library designed for ",(0,r.jsx)(t.strong,{children:"safe access to the results of asynchronous operations"}),". It acts as a lightweight handle that bridges the creator of an asynchronous task (e.g., via ",(0,r.jsx)(t.code,{children:"std::async"}),", ",(0,r.jsx)(t.code,{children:"std::packaged_task"}),", or ",(0,r.jsx)(t.code,{children:"std::promise"}),") and the task's outcome\u2014either a return value or an exception thrown during execution."]}),"\n",(0,r.jsx)(t.p,{children:"Its core design goals are:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Decouple task execution flow from result retrieval flow"}),"\n",(0,r.jsx)(t.li,{children:"Ensure thread-safe transmission of results and exceptions across threads"}),"\n",(0,r.jsx)(t.li,{children:"Provide flexible mechanisms to wait for task completion without indefinite blocking"}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"primary-use-cases",children:"Primary Use Cases"}),"\n",(0,r.jsx)(t.h3,{id:"asynchronous-result-retrieval",children:"Asynchronous Result Retrieval"}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"get()"})," method blocks the calling thread until the asynchronous task finishes, then returns the task's result. If the task throws an exception, ",(0,r.jsx)(t.code,{children:"get()"})," rethrows the same exception in the calling thread, enabling consistent cross-thread error handling."]}),"\n",(0,r.jsx)(t.h3,{id:"non-blocking-task-status-query",children:"Non-blocking Task Status Query"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"wait()"})," blocks until the task is ready, while ",(0,r.jsx)(t.code,{children:"wait_for()"})," and ",(0,r.jsx)(t.code,{children:"wait_until()"})," implement timeout-aware waiting. These methods return a ",(0,r.jsx)(t.code,{children:"std::future_status"})," enum to indicate the task state, allowing the calling thread to perform other work while waiting."]}),"\n",(0,r.jsx)(t.h3,{id:"thread-synchronization-in-producer-consumer-models",children:"Thread Synchronization in Producer-Consumer Models"}),"\n",(0,r.jsxs)(t.p,{children:["Paired with ",(0,r.jsx)(t.code,{children:"std::promise"}),", ",(0,r.jsx)(t.code,{children:"std::future"})," enables explicit synchronization between producer threads (which generate data or results) and consumer threads (which process the results). This is particularly useful in high-performance scenarios where manual thread control is required."]}),"\n",(0,r.jsx)(t.h2,{id:"state-management",children:"State Management"}),"\n",(0,r.jsxs)(t.p,{children:["A ",(0,r.jsx)(t.code,{children:"std::future"})," object manages an internal shared state, which has three possible states:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Not Ready"}),": The asynchronous task is still running; no result or exception is available."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Ready"}),": The task has completed successfully; the result can be retrieved via ",(0,r.jsx)(t.code,{children:"get()"}),"."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Exceptional"}),": The task threw an exception during execution; calling ",(0,r.jsx)(t.code,{children:"get()"})," will rethrow the exception."]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"state-transition-rules",children:"State Transition Rules"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["The initial state of a ",(0,r.jsx)(t.code,{children:"std::future"})," is ",(0,r.jsx)(t.strong,{children:"Not Ready"}),"."]}),"\n",(0,r.jsxs)(t.li,{children:["Once the task finishes (successfully or with an exception), the state transitions to ",(0,r.jsx)(t.strong,{children:"Ready"})," or ",(0,r.jsx)(t.strong,{children:"Exceptional"})," and becomes immutable."]}),"\n",(0,r.jsxs)(t.li,{children:["After a call to ",(0,r.jsx)(t.code,{children:"get()"}),", the shared state is destroyed, and the ",(0,r.jsx)(t.code,{children:"std::future"})," becomes invalid. Subsequent calls to ",(0,r.jsx)(t.code,{children:"get()"})," or ",(0,r.jsx)(t.code,{children:"wait()"})," will throw a ",(0,r.jsx)(t.code,{children:"std::future_error"})," with the error code ",(0,r.jsx)(t.code,{children:"std::future_errc::no_state"}),"."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"comprehensive-usage-examples",children:"Comprehensive Usage Examples"}),"\n",(0,r.jsxs)(t.h3,{id:"basic-usage-with-stdasync",children:["Basic Usage with ",(0,r.jsx)(t.code,{children:"std::async"})]}),"\n",(0,r.jsx)(t.p,{children:"This example demonstrates forced asynchronous execution, timeout status checks, and exception handling\u2014critical for high-performance applications where thread resource utilization matters."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cpp",children:'#include <iostream>\n#include <future>\n#include <thread>\n#include <chrono>\n#include <stdexcept>\n\nint factorial(int n) {\n    if (n < 0) {\n        throw std::invalid_argument("n must be non-negative");\n    }\n    int result = 1;\n    for (int i = 2; i <= n; ++i) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(100));\n        result *= i;\n    }\n    return result;\n}\n\nint main() {\n    std::future<int> fut = std::async(std::launch::async, factorial, 5);\n\n    std::cout << "Main thread: Executing other tasks..." << std::endl;\n    std::this_thread::sleep_for(std::chrono::milliseconds(200));\n\n    std::future_status status = fut.wait_for(std::chrono::milliseconds(100));\n    switch (status) {\n        case std::future_status::ready:\n            std::cout << "Task completed early!" << std::endl;\n            break;\n        case std::future_status::timeout:\n            std::cout << "Task still running (timeout)!" << std::endl;\n            break;\n        case std::future_status::deferred:\n            std::cout << "Task is deferred (runs on get())!" << std::endl;\n            break;\n    }\n\n    try {\n        int fact_result = fut.get();\n        std::cout << "Factorial of 5: " << fact_result << std::endl;\n    } catch (const std::invalid_argument& e) {\n        std::cerr << "Error: " << e.what() << std::endl;\n    }\n\n    return 0;\n}\n'})}),"\n",(0,r.jsxs)(t.h3,{id:"producer-consumer-model-with-stdpromise-and-stdfuture",children:["Producer-Consumer Model with ",(0,r.jsx)(t.code,{children:"std::promise"})," and ",(0,r.jsx)(t.code,{children:"std::future"})]}),"\n",(0,r.jsx)(t.p,{children:"This example is suitable for scenarios where you need manual control over thread lifecycle and result delivery\u2014common in high-performance systems like real-time data processing pipelines."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cpp",children:'#include <iostream>\n#include <future>\n#include <thread>\n#include <stdexcept>\n#include <chrono>\n\nvoid produce_data(std::promise<int>& prom) {\n    try {\n        std::cout << "Producer: Working on data..." << std::endl;\n        std::this_thread::sleep_for(std::chrono::seconds(1));\n        \n        int data = 42;\n        prom.set_value(data);\n\n        // Uncomment to test exception propagation\n        // throw std::runtime_error("Data generation failed");\n        // prom.set_exception(std::current_exception());\n    } catch (...) {\n        prom.set_exception(std::current_exception());\n    }\n}\n\nint main() {\n    std::promise<int> data_promise;\n    std::future<int> data_future = data_promise.get_future();\n\n    std::thread producer(produce_data, std::ref(data_promise));\n\n    std::cout << "Consumer: Waiting for data..." << std::endl;\n    try {\n        int result = data_future.get();\n        std::cout << "Consumer: Received data: " << result << std::endl;\n    } catch (const std::runtime_error& e) {\n        std::cerr << "Consumer: Error - " << e.what() << std::endl;\n    }\n\n    if (producer.joinable()) {\n        producer.join();\n    }\n\n    return 0;\n}\n'})}),"\n",(0,r.jsxs)(t.h3,{id:"shared-result-access-with-stdshared_future",children:["Shared Result Access with ",(0,r.jsx)(t.code,{children:"std::shared_future"})]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"std::future"})," is move-only (exclusive ownership), so ",(0,r.jsx)(t.code,{children:"std::shared_future"})," is required when multiple threads need to access the same asynchronous result\u2014this avoids redundant task execution and reduces overhead in multi-consumer scenarios."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cpp",children:'#include <iostream>\n#include <future>\n#include <thread>\n#include <vector>\n\nvoid process_result(std::shared_future<int> shared_fut, int thread_id) {\n    try {\n        int result = shared_fut.get();\n        std::cout << "Thread " << thread_id << ": Result = " << result << std::endl;\n    } catch (const std::exception& e) {\n        std::cerr << "Thread " << thread_id << ": Error - " << e.what() << std::endl;\n    }\n}\n\nint main() {\n    std::promise<int> prom;\n    std::shared_future<int> shared_fut = prom.get_future();\n\n    std::vector<std::thread> workers;\n    for (int i = 0; i < 3; ++i) {\n        workers.emplace_back(process_result, shared_fut, i);\n    }\n\n    prom.set_value(99);\n\n    for (auto& t : workers) {\n        if (t.joinable()) {\n            t.join();\n        }\n    }\n\n    return 0;\n}\n'})}),"\n",(0,r.jsx)(t.h2,{id:"key-features",children:"Key Features"}),"\n",(0,r.jsxs)(t.h3,{id:"exclusive-ownership-of-stdfuture",children:["Exclusive Ownership of ",(0,r.jsx)(t.code,{children:"std::future"})]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"std::future"})," is ",(0,r.jsx)(t.strong,{children:"move-only"}),"\u2014its copy constructor and copy assignment operator are deleted. This enforces exclusive ownership of the shared state, ensuring that only one thread can retrieve the result, which avoids race conditions and redundant result processing."]}),"\n",(0,r.jsxs)(t.p,{children:["Ownership can be transferred via ",(0,r.jsx)(t.code,{children:"std::move"}),", which is useful for passing ",(0,r.jsx)(t.code,{children:"std::future"})," objects between functions or threads without copying overhead."]}),"\n",(0,r.jsx)(t.h3,{id:"exception-propagation-mechanism",children:"Exception Propagation Mechanism"}),"\n",(0,r.jsxs)(t.p,{children:["Exceptions thrown in asynchronous tasks are stored in the shared state, rather than being thrown directly in the task thread. When ",(0,r.jsx)(t.code,{children:"get()"})," is called, the stored exception is rethrown in the calling thread, allowing developers to handle errors using the same try-catch mechanism as synchronous code."]}),"\n",(0,r.jsx)(t.h3,{id:"compatibility-with-other-async-utilities",children:"Compatibility with Other Async Utilities"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Utility"}),(0,r.jsx)(t.th,{children:"Role"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"std::async"})}),(0,r.jsxs)(t.td,{children:["Launches asynchronous tasks with automatic thread management; returns a ",(0,r.jsx)(t.code,{children:"std::future"})," directly"]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"std::packaged_task"})}),(0,r.jsxs)(t.td,{children:["Wraps a callable object into a task that can be executed asynchronously; its ",(0,r.jsx)(t.code,{children:"get_future"})," method returns a ",(0,r.jsx)(t.code,{children:"std::future"})," for result retrieval"]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"std::promise"})}),(0,r.jsxs)(t.td,{children:["Manually sets the result or exception of an asynchronous operation; paired with ",(0,r.jsx)(t.code,{children:"std::future"})," for explicit producer-consumer synchronization"]})]})]})]}),"\n",(0,r.jsx)(t.h2,{id:"critical-notes",children:"Critical Notes"}),"\n",(0,r.jsx)(t.h3,{id:"blocking-behavior-control",children:"Blocking Behavior Control"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"get()"})," blocks indefinitely, which can lead to thread starvation in high-performance applications. To avoid this, always use ",(0,r.jsx)(t.code,{children:"wait_for()"})," or ",(0,r.jsx)(t.code,{children:"wait_until()"})," with a reasonable timeout before calling ",(0,r.jsx)(t.code,{children:"get()"}),", allowing the calling thread to handle timeouts gracefully."]}),"\n",(0,r.jsx)(t.h3,{id:"deferred-task-execution-caveat",children:"Deferred Task Execution Caveat"}),"\n",(0,r.jsxs)(t.p,{children:["When ",(0,r.jsx)(t.code,{children:"std::async"})," is called without an explicit launch policy, the implementation may choose ",(0,r.jsx)(t.code,{children:"std::launch::deferred"}),", which executes the task synchronously when ",(0,r.jsx)(t.code,{children:"get()"})," or ",(0,r.jsx)(t.code,{children:"wait()"})," is called\u2014no new thread is created. This can cause unexpected performance bottlenecks, so always specify ",(0,r.jsx)(t.code,{children:"std::launch::async"})," if you need forced asynchronous execution."]}),"\n",(0,r.jsx)(t.h3,{id:"thread-safety-considerations",children:"Thread Safety Considerations"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["The ",(0,r.jsx)(t.strong,{children:"shared state"})," managed by ",(0,r.jsx)(t.code,{children:"std::future"})," is thread-safe; concurrent calls to ",(0,r.jsx)(t.code,{children:"wait()"})," from multiple threads are allowed."]}),"\n",(0,r.jsxs)(t.li,{children:["The ",(0,r.jsx)(t.code,{children:"std::future"})," object itself is ",(0,r.jsx)(t.strong,{children:"not thread-safe"}),"; concurrent calls to ",(0,r.jsx)(t.code,{children:"get()"})," or ",(0,r.jsx)(t.code,{children:"move()"})," on the same ",(0,r.jsx)(t.code,{children:"std::future"})," object will result in undefined behavior. Use ",(0,r.jsx)(t.code,{children:"std::shared_future"})," for multi-threaded access."]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"resource-management-best-practices",children:"Resource Management Best Practices"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Always join or detach threads associated with ",(0,r.jsx)(t.code,{children:"std::promise"})," to avoid resource leaks."]}),"\n",(0,r.jsxs)(t.li,{children:["Avoid storing ",(0,r.jsx)(t.code,{children:"std::future"})," objects in containers for extended periods\u2014once ",(0,r.jsx)(t.code,{children:"get()"})," is called, the object becomes invalid and should be discarded."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"std::future"})," is a foundational tool for C++ asynchronous programming, enabling safe, efficient result retrieval and thread synchronization. Its key advantages are strict ownership semantics, seamless exception propagation, and compatibility with a range of async utilities."]}),"\n",(0,r.jsx)(t.p,{children:"In high-performance applications, the best practices are:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Use explicit launch policies with ",(0,r.jsx)(t.code,{children:"std::async"})," to avoid deferred execution surprises"]}),"\n",(0,r.jsxs)(t.li,{children:["Prefer ",(0,r.jsx)(t.code,{children:"wait_for()"}),"/",(0,r.jsx)(t.code,{children:"wait_until()"})," over direct ",(0,r.jsx)(t.code,{children:"get()"})," calls to control blocking behavior"]}),"\n",(0,r.jsxs)(t.li,{children:["Adopt ",(0,r.jsx)(t.code,{children:"std::shared_future"})," for multi-consumer scenarios to reduce overhead"]}),"\n",(0,r.jsx)(t.li,{children:"Always handle exceptions propagated from asynchronous tasks"}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>d,x:()=>a});var n=s(6540);const r={},i=n.createContext(r);function d(e){const t=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);