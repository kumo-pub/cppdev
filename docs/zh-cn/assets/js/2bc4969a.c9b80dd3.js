"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[1325],{8453:(e,i,s)=>{s.d(i,{R:()=>d,x:()=>c});var t=s(6540);const r={},n=t.createContext(r);function d(e){const i=t.useContext(n);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function c(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),t.createElement(n.Provider,{value:i},e.children)}},9440:(e,i,s)=>{s.r(i),s.d(i,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>d,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"retrieve/vector/diskann","title":"DiskANN (Disk-based Approximate Nearest Neighbor) Overview","description":"- Repository//github.com/microsoft/DiskANN","source":"@site/i18n/zh-cn/docusaurus-plugin-content-docs/current/retrieve/vector/diskann.mdx","sourceDirName":"retrieve/vector","slug":"/retrieve/vector/diskann","permalink":"/cppdev/zh-cn/docs/retrieve/vector/diskann","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"NGT (Neighborhood Graph and Tree) Overview","permalink":"/cppdev/zh-cn/docs/retrieve/vector/ngt"},"next":{"title":"SPTAG (Space Partition Tree And Graph) Overview","permalink":"/cppdev/zh-cn/docs/retrieve/vector/sptag"}}');var r=s(4848),n=s(8453);const d={},c="DiskANN (Disk-based Approximate Nearest Neighbor) Overview",l={},a=[{value:"Purpose &amp; Use Cases",id:"purpose--use-cases",level:2},{value:"Algorithms Supported",id:"algorithms-supported",level:2},{value:"Core Technical Specifications",id:"core-technical-specifications",level:2},{value:"1. Supported Metric Spaces",id:"1-supported-metric-spaces",level:3},{value:"2. Supported Data Types",id:"2-supported-data-types",level:3},{value:"3. Dynamic Data Operations (Insert/Delete/Modify)",id:"3-dynamic-data-operations-insertdeletemodify",level:3},{value:"Characteristics",id:"characteristics",level:2},{value:"Notes",id:"notes",level:2}];function o(e){const i={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,n.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"diskann-disk-based-approximate-nearest-neighbor-overview",children:"DiskANN (Disk-based Approximate Nearest Neighbor) Overview"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Repository:"})," ",(0,r.jsx)(i.a,{href:"https://github.com/microsoft/DiskANN",children:"https://github.com/microsoft/DiskANN"})]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Language:"})," C++ (Python bindings available)"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"purpose--use-cases",children:"Purpose & Use Cases"}),"\n",(0,r.jsxs)(i.p,{children:["DiskANN is a ",(0,r.jsx)(i.strong,{children:"CPU-only, disk-optimized vector similarity search library"})," designed for ultra-large-scale (billion/trillion-level) high-dimensional vector datasets where in-memory storage is infeasible. Its core advantage is minimal RAM usage (1\u20135% of total vector size) via disk-backed graph indexing, focusing on read-heavy, static/low-churn scenarios rather than real-time dynamic updates or high-speed query performance. It is suitable for:"]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Approximate nearest neighbor (ANN) search over 1B+ high-dimensional vectors (100\u201310000 dimensions)."}),"\n",(0,r.jsx)(i.li,{children:"Scenarios with strict RAM constraints (e.g., trillion-scale embedding libraries that cannot fit in memory)."}),"\n",(0,r.jsx)(i.li,{children:"Offline batch indexing and online disk-backed query (no need to load full datasets into RAM)."}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"Typical applications include:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Web-scale semantic search (text/image embedding retrieval with petabyte-scale datasets)."}),"\n",(0,r.jsx)(i.li,{children:"Enterprise recommendation systems (cold user/item embedding libraries with 1B+ entries)."}),"\n",(0,r.jsx)(i.li,{children:"Scientific computing (high-dimensional astronomical/genomic data similarity search)."}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"algorithms-supported",children:"Algorithms Supported"}),"\n",(0,r.jsx)(i.p,{children:"DiskANN exclusively implements disk-aware graph-based indexes optimized for CPU/disk I/O, with no hybrid or accelerated variants:"}),"\n",(0,r.jsxs)(i.table,{children:[(0,r.jsx)(i.thead,{children:(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.th,{children:"Algorithm"}),(0,r.jsx)(i.th,{children:"Key Characteristics"}),(0,r.jsx)(i.th,{children:"Use Case"})]})}),(0,r.jsxs)(i.tbody,{children:[(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"StaticDiskANN"})}),(0,r.jsx)(i.td,{children:"Disk-backed HNSW variant for static datasets \u2013 minimal RAM usage, read-optimized."}),(0,r.jsx)(i.td,{children:"1B+ static vectors (no updates) \u2013 DiskANN\u2019s core scenario."})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"DynamicDiskANN"})}),(0,r.jsx)(i.td,{children:"Incremental disk-backed index supporting low-frequency batch insertion/deletion."}),(0,r.jsx)(i.td,{children:"Large-scale datasets with hourly/daily batch updates."})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"PQ-DiskANN"})}),(0,r.jsx)(i.td,{children:"Product Quantization + DiskANN \u2013 further reduces disk/RAM usage (minor recall loss)."}),(0,r.jsx)(i.td,{children:"Trillion-scale vectors with extreme memory constraints."})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:"Brute-force"}),(0,r.jsx)(i.td,{children:"Exact disk-based search (baseline) \u2013 no approximation, slow but high recall."}),(0,r.jsx)(i.td,{children:"Small disk-resident datasets (\u2264100M vectors)."})]})]})]}),"\n",(0,r.jsx)(i.h2,{id:"core-technical-specifications",children:"Core Technical Specifications"}),"\n",(0,r.jsx)(i.h3,{id:"1-supported-metric-spaces",children:"1. Supported Metric Spaces"}),"\n",(0,r.jsx)(i.p,{children:"DiskANN supports a narrow set of metric spaces for numerical vectors (no native non-metric support):"}),"\n",(0,r.jsxs)(i.table,{children:[(0,r.jsx)(i.thead,{children:(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.th,{children:"Metric Type"}),(0,r.jsx)(i.th,{children:"Full Name"}),(0,r.jsx)(i.th,{children:"Supported Indexes"}),(0,r.jsx)(i.th,{children:"Use Case"})]})}),(0,r.jsxs)(i.tbody,{children:[(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:"L2"}),(0,r.jsx)(i.td,{children:"Euclidean Distance"}),(0,r.jsx)(i.td,{children:"All indexes"}),(0,r.jsx)(i.td,{children:"General numerical vectors (image/video embeddings)."})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:"Cosine"}),(0,r.jsx)(i.td,{children:"Cosine Similarity (normalized L2)"}),(0,r.jsx)(i.td,{children:"All indexes (via pre-normalization)"}),(0,r.jsx)(i.td,{children:"Text embeddings (BERT/LLM embeddings)."})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:"Inner Product (IP)"}),(0,r.jsx)(i.td,{children:"Dot Product"}),(0,r.jsx)(i.td,{children:"All indexes (via normalization)"}),(0,r.jsx)(i.td,{children:"Normalized vector similarity (equivalent to cosine)."})]})]})]}),"\n",(0,r.jsxs)(i.blockquote,{children:["\n",(0,r.jsx)(i.p,{children:"Note: Non-metric spaces (Jaccard/Hamming/L1/L\u221e) are not supported, and custom preprocessing for these spaces is unmaintained and not production-grade."}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"2-supported-data-types",children:"2. Supported Data Types"}),"\n",(0,r.jsx)(i.p,{children:"DiskANN is optimized for 32-bit floating-point vectors, with limited support for low-precision integer types via quantization:"}),"\n",(0,r.jsxs)(i.table,{children:[(0,r.jsx)(i.thead,{children:(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.th,{children:"Data Type"}),(0,r.jsx)(i.th,{children:"Precision"}),(0,r.jsx)(i.th,{children:"C++ Type"}),(0,r.jsx)(i.th,{children:"Python Binding Mapping"}),(0,r.jsx)(i.th,{children:"Support Status"}),(0,r.jsx)(i.th,{children:"Use Case"})]})}),(0,r.jsxs)(i.tbody,{children:[(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:"Float32"}),(0,r.jsx)(i.td,{children:"32-bit"}),(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"float"})}),(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"numpy.float32"})}),(0,r.jsx)(i.td,{children:"Fully supported (optimal performance)"}),(0,r.jsx)(i.td,{children:"Default \u2013 DiskANN\u2019s core optimized type."})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:"Float64 (Double)"}),(0,r.jsx)(i.td,{children:"64-bit"}),(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"double"})}),(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"numpy.float64"})}),(0,r.jsx)(i.td,{children:"Partial (CPU-only, 2\u20133x slower)"}),(0,r.jsx)(i.td,{children:"High-precision scientific computing only."})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:"Int8/UInt8"}),(0,r.jsx)(i.td,{children:"8-bit"}),(0,r.jsxs)(i.td,{children:[(0,r.jsx)(i.code,{children:"int8_t"}),"/",(0,r.jsx)(i.code,{children:"uint8_t"})]}),(0,r.jsxs)(i.td,{children:[(0,r.jsx)(i.code,{children:"numpy.int8"}),"/",(0,r.jsx)(i.code,{children:"numpy.uint8"})]}),(0,r.jsx)(i.td,{children:"Partial (via scalar quantization)"}),(0,r.jsx)(i.td,{children:"Edge/disk-constrained environments (4x memory reduction)."})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:"Float16 (FP16)"}),(0,r.jsx)(i.td,{children:"16-bit"}),(0,r.jsx)(i.td,{children:"-"}),(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"numpy.float16"})}),(0,r.jsx)(i.td,{children:"Not supported"}),(0,r.jsx)(i.td,{children:"Manual conversion to Float32 provides no memory/performance benefits."})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:"Binary"}),(0,r.jsx)(i.td,{children:"Bit-level"}),(0,r.jsxs)(i.td,{children:[(0,r.jsx)(i.code,{children:"uint8_t"})," (packed)"]}),(0,r.jsxs)(i.td,{children:[(0,r.jsx)(i.code,{children:"numpy.uint8"})," (bitpacked)"]}),(0,r.jsx)(i.td,{children:"Not supported"}),(0,r.jsx)(i.td,{children:"No native handling for Hamming distance."})]})]})]}),"\n",(0,r.jsx)(i.h3,{id:"3-dynamic-data-operations-insertdeletemodify",children:"3. Dynamic Data Operations (Insert/Delete/Modify)"}),"\n",(0,r.jsx)(i.p,{children:"DiskANN\u2019s dynamic capabilities are batch-oriented and non-real-time, with no support for high-frequency updates:"}),"\n",(0,r.jsxs)(i.table,{children:[(0,r.jsx)(i.thead,{children:(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.th,{children:"Operation"}),(0,r.jsx)(i.th,{children:"Support Level"}),(0,r.jsx)(i.th,{children:"Constraints"})]})}),(0,r.jsxs)(i.tbody,{children:[(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:"Incremental Insertion"}),(0,r.jsx)(i.td,{children:"Partial (batch-only, DynamicDiskANN)"}),(0,r.jsxs)(i.td,{children:["- Batch insertion only (10k+ vectors per batch, latency ~100ms/batch);",(0,r.jsx)("br",{}),"- Single-vector insertion latency: ~10ms/vector (too slow for real-time);",(0,r.jsx)("br",{}),"- Max sustainable QPS: ~100 (CPU-only)."]})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:"Real-Time Deletion"}),(0,r.jsx)(i.td,{children:"Minimal (soft delete only)"}),(0,r.jsxs)(i.td,{children:['- "Soft delete" (mark IDs as invalid, filter post-query);',(0,r.jsx)("br",{}),"- Physical deletion requires partial index rebuild (hourly/daily batch);",(0,r.jsx)("br",{}),"- No memory bloat for up to 30% deleted vectors."]})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:"Vector Modification"}),(0,r.jsx)(i.td,{children:"Indirect (delete + reinsert)"}),(0,r.jsx)(i.td,{children:"Inherits deletion/insertion latency (batch-only, no real-time support)."})]})]})]}),"\n",(0,r.jsx)(i.h2,{id:"characteristics",children:"Characteristics"}),"\n",(0,r.jsxs)(i.table,{children:[(0,r.jsx)(i.thead,{children:(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.th,{children:"Feature"}),(0,r.jsx)(i.th,{children:"Description"})]})}),(0,r.jsxs)(i.tbody,{children:[(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:"Incremental Updates"}),(0,r.jsx)(i.td,{children:"Batch-only insertion (DynamicDiskANN); soft deletion only; no real-time single-vector support."})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:"Query Speed"}),(0,r.jsx)(i.td,{children:"CPU/disk-backed: 3\u201315ms/query (1B 768-dim vectors) \u2013 2\u20134x faster than disk-based FAISS IVF-PQ."})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:"Index Type"}),(0,r.jsx)(i.td,{children:"Disk-backed graph-based HNSW (static/dynamic); quantization-enhanced variants (PQ-DiskANN)."})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:"Scalability"}),(0,r.jsx)(i.td,{children:"Handles trillion-scale vectors (disk-backed); RAM usage = 0.5\u20135% of total vector size (core advantage)."})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:"Language Bindings"}),(0,r.jsx)(i.td,{children:"C++ (full feature set), Python (core features only \u2013 no DynamicDiskANN full support)."})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:"Non-Metric Support"}),(0,r.jsx)(i.td,{children:"No native support (requires custom preprocessing)."})]})]})]}),"\n",(0,r.jsx)(i.h2,{id:"notes",children:"Notes"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["DiskANN\u2019s core value is ultra-low RAM usage for billion/trillion-scale static vectors \u2013 it is not optimized for speed (FAISS HNSW/GPU is faster for in-memory datasets ",(0,r.jsx)(i.code,{children:"<1B"})," vectors)."]}),"\n",(0,r.jsx)(i.li,{children:"DynamicDiskANN is designed for low-frequency batch updates (hourly/daily) \u2013 avoid using it for real-time use cases (e.g., sub-second user behavior embedding insertion)."}),"\n",(0,r.jsx)(i.li,{children:"Limitations: No distributed multi-node support (single-node disk-backed only); Python bindings lack full DynamicDiskANN functionality; no non-metric space support."}),"\n",(0,r.jsxs)(i.li,{children:["Best Practices: Use StaticDiskANN for 1B+ static vectors (low RAM footprint); pair with in-memory FAISS HNSW for hot data (",(0,r.jsx)(i.code,{children:"<100M"})," vectors) to balance scale and query speed."]}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,n.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}}}]);