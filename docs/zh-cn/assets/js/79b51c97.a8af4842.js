"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[2100],{7628:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"testing/benchmark/AssemblyTests","title":"Assembly Tests","description":"The Benchmark library provides a number of functions whose primary","source":"@site/docs/testing/benchmark/AssemblyTests.md","sourceDirName":"testing/benchmark","slug":"/testing/benchmark/AssemblyTests","permalink":"/zh-cn/docs/testing/benchmark/AssemblyTests","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/testing/benchmark/AssemblyTests.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Benchmark","permalink":"/zh-cn/docs/testing/benchmark/"},"next":{"title":"Build tool dependency policy","permalink":"/zh-cn/docs/testing/benchmark/dependencies"}}');var i=t(4848),r=t(8453);const o={},l="Assembly Tests",a={},c=[{value:"Anatomy of a Test",id:"anatomy-of-a-test",level:2},{value:"LLVM Filecheck",id:"llvm-filecheck",level:4},{value:"Tips and Tricks:",id:"tips-and-tricks",level:4},{value:"Problems Writing Portable Tests",id:"problems-writing-portable-tests",level:2},{value:"Capturing Variables",id:"capturing-variables",level:4},{value:"Using Regular Expressions to Match Differing Output",id:"using-regular-expressions-to-match-differing-output",level:4},{value:"Current Requirements and Limitations",id:"current-requirements-and-limitations",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"assembly-tests",children:"Assembly Tests"})}),"\n",(0,i.jsxs)(n.p,{children:["The Benchmark library provides a number of functions whose primary\npurpose in to affect assembly generation, including ",(0,i.jsx)(n.code,{children:"DoNotOptimize"}),"\nand ",(0,i.jsx)(n.code,{children:"ClobberMemory"}),". In addition there are other functions,\nsuch as ",(0,i.jsx)(n.code,{children:"KeepRunning"}),", for which generating good assembly is paramount."]}),"\n",(0,i.jsx)(n.p,{children:"For these functions it's important to have tests that verify the\ncorrectness and quality of the implementation. This requires testing\nthe code generated by the compiler."}),"\n",(0,i.jsx)(n.p,{children:"This document describes how the Benchmark library tests compiler output,\nas well as how to properly write new tests."}),"\n",(0,i.jsx)(n.h2,{id:"anatomy-of-a-test",children:"Anatomy of a Test"}),"\n",(0,i.jsx)(n.p,{children:"Writing a test has two steps:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Write the code you want to generate assembly for."}),"\n",(0,i.jsxs)(n.li,{children:["Add ",(0,i.jsx)(n.code,{children:"// CHECK"})," lines to match against the verified assembly."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c++",children:'\n// CHECK-LABEL: test_add:\nextern "C" int test_add() {\n    extern int ExternInt;\n    return ExternInt + 1;\n\n    // CHECK: movl ExternInt(%rip), %eax\n    // CHECK: addl %eax\n    // CHECK: ret\n}\n\n'})}),"\n",(0,i.jsx)(n.h4,{id:"llvm-filecheck",children:"LLVM Filecheck"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://llvm.org/docs/CommandGuide/FileCheck.html",children:"LLVM's Filecheck"}),"\nis used to test the generated assembly against the ",(0,i.jsx)(n.code,{children:"// CHECK"})," lines\nspecified in the tests source file. Please see the documentation\nlinked above for information on how to write ",(0,i.jsx)(n.code,{children:"CHECK"})," directives."]}),"\n",(0,i.jsx)(n.h4,{id:"tips-and-tricks",children:"Tips and Tricks:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Tests should match the minimal amount of output required to establish\ncorrectness. ",(0,i.jsx)(n.code,{children:"CHECK"})," directives don't have to match on the exact next line\nafter the previous match, so tests should omit checks for unimportant\nbits of assembly. (",(0,i.jsx)(n.a,{href:"https://llvm.org/docs/CommandGuide/FileCheck.html#the-check-next-directive",children:(0,i.jsx)(n.code,{children:"CHECK-NEXT"})}),"\ncan be used to ensure a match occurs exactly after the previous match)."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["The tests are compiled with ",(0,i.jsx)(n.code,{children:"-O3 -g0"}),". So we're only testing the\noptimized output."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["The assembly output is further cleaned up using ",(0,i.jsx)(n.code,{children:"tools/strip_asm.py"}),".\nThis removes comments, assembler directives, and unused labels before\nthe test is run."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["The generated and stripped assembly file for a test is output under\n",(0,i.jsx)(n.code,{children:"<build-directory>/test/<test-name>.s"})]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Filecheck supports using ",(0,i.jsxs)(n.a,{href:"https://llvm.org/docs/CommandGuide/FileCheck.html#cmdoption-check-prefixes",children:[(0,i.jsx)(n.code,{children:"CHECK"})," prefixes"]}),"\nto specify lines that should only match in certain situations.\nThe Benchmark tests use ",(0,i.jsx)(n.code,{children:"CHECK-CLANG"})," and ",(0,i.jsx)(n.code,{children:"CHECK-GNU"})," for lines that\nare only expected to match Clang or GCC's output respectively. Normal\n",(0,i.jsx)(n.code,{children:"CHECK"})," lines match against all compilers. (Note: ",(0,i.jsx)(n.code,{children:"CHECK-NOT"})," and\n",(0,i.jsx)(n.code,{children:"CHECK-LABEL"})," are NOT prefixes. They are versions of non-prefixed\n",(0,i.jsx)(n.code,{children:"CHECK"})," lines)"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Use ",(0,i.jsx)(n.code,{children:'extern "C"'})," to disable name mangling for specific functions. This\nmakes them easier to name in the ",(0,i.jsx)(n.code,{children:"CHECK"})," lines."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"problems-writing-portable-tests",children:"Problems Writing Portable Tests"}),"\n",(0,i.jsx)(n.p,{children:"Writing tests which check the code generated by a compiler are\ninherently non-portable. Different compilers and even different compiler\nversions may generate entirely different code. The Benchmark tests\nmust tolerate this."}),"\n",(0,i.jsxs)(n.p,{children:['LLVM Filecheck provides a number of mechanisms to help write\n"more portable" tests; including ',(0,i.jsx)(n.a,{href:"https://llvm.org/docs/CommandGuide/FileCheck.html#filecheck-pattern-matching-syntax",children:"matching using regular expressions"}),",\nallowing the creation of ",(0,i.jsx)(n.a,{href:"https://llvm.org/docs/CommandGuide/FileCheck.html#filecheck-variables",children:"named variables"}),"\nfor later matching, and ",(0,i.jsx)(n.a,{href:"https://llvm.org/docs/CommandGuide/FileCheck.html#the-check-dag-directive",children:"checking non-sequential matches"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"capturing-variables",children:"Capturing Variables"}),"\n",(0,i.jsx)(n.p,{children:'For example, say GCC stores a variable in a register but Clang stores\nit in memory. To write a test that tolerates both cases we "capture"\nthe destination of the store, and then use the captured expression\nto write the remainder of the test.'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c++",children:'// CHECK-LABEL: test_div_no_op_into_shr:\nextern "C" void test_div_no_op_into_shr(int value) {\n    int divisor = 2;\n    benchmark::DoNotOptimize(divisor); // hide the value from the optimizer\n    return value / divisor;\n\n    // CHECK: movl $2, [[DEST:.*]]\n    // CHECK: idivl [[DEST]]\n    // CHECK: ret\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"using-regular-expressions-to-match-differing-output",children:"Using Regular Expressions to Match Differing Output"}),"\n",(0,i.jsx)(n.p,{children:"Often tests require testing assembly lines which may subtly differ\nbetween compilers or compiler versions. A common example of this\nis matching stack frame addresses. In this case regular expressions\ncan be used to match the differing bits of output. For example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c++",children:'int ExternInt;\nstruct Point { int x, y, z; };\n\n// CHECK-LABEL: test_store_point:\nextern "C" void test_store_point() {\n    Point p{ExternInt, ExternInt, ExternInt};\n    benchmark::DoNotOptimize(p);\n\n    // CHECK: movl ExternInt(%rip), %eax\n    // CHECK: movl %eax, -{{[0-9]+}}(%rsp)\n    // CHECK: movl %eax, -{{[0-9]+}}(%rsp)\n    // CHECK: movl %eax, -{{[0-9]+}}(%rsp)\n    // CHECK: ret\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"current-requirements-and-limitations",children:"Current Requirements and Limitations"}),"\n",(0,i.jsxs)(n.p,{children:["The tests require Filecheck to be installed along the ",(0,i.jsx)(n.code,{children:"PATH"})," of the\nbuild machine. Otherwise the tests will be disabled."]}),"\n",(0,i.jsx)(n.p,{children:"Additionally, as mentioned in the previous section, codegen tests are\ninherently non-portable. Currently the tests are limited to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"x86_64 targets."}),"\n",(0,i.jsx)(n.li,{children:"Compiled with GCC or Clang"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Further work could be done, at least on a limited basis, to extend the\ntests to other architectures and compilers (using ",(0,i.jsx)(n.code,{children:"CHECK"})," prefixes)."]}),"\n",(0,i.jsxs)(n.p,{children:["Furthermore, the tests fail for builds which specify additional flags\nthat modify code generation, including ",(0,i.jsx)(n.code,{children:"--coverage"})," or ",(0,i.jsx)(n.code,{children:"-fsanitize="}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>l});var s=t(6540);const i={},r=s.createContext(i);function o(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);