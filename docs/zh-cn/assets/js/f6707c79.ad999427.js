"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[4216],{8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var a=t(6540);const r={},s=a.createContext(r);function i(e){const n=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),a.createElement(s.Provider,{value:n},e.children)}},9634:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"testing/benchmark/user_guide","title":"User Guide","description":"Command Line","source":"@site/docs/testing/benchmark/user_guide.md","sourceDirName":"testing/benchmark","slug":"/testing/benchmark/user_guide","permalink":"/cppdev/zh-cn/docs/testing/benchmark/user_guide","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/testing/benchmark/user_guide.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Benchmark Tools","permalink":"/cppdev/zh-cn/docs/testing/benchmark/tools"},"next":{"title":"index","permalink":"/cppdev/zh-cn/docs/log/"}}');var r=t(4848),s=t(8453);const i={},o="User Guide",c={},l=[{value:"Command Line",id:"command-line",level:2},{value:"Library",id:"library",level:2},{value:"Benchmarking Tips",id:"benchmarking-tips",level:2},{value:"Output Formats",id:"output-formats",level:2},{value:"Output Files",id:"output-files",level:2},{value:"Running Benchmarks",id:"running-benchmarks",level:2},{value:"Dry runs",id:"dry-runs",level:3},{value:"Running a Subset of Benchmarks",id:"running-a-subset-of-benchmarks",level:2},{value:"Disabling Benchmarks",id:"disabling-benchmarks",level:2},{value:"Result comparison",id:"result-comparison",level:2},{value:"Extra Context",id:"extra-context",level:2},{value:"Runtime and Reporting Considerations",id:"runtime-and-reporting-considerations",level:2},{value:"Setup/Teardown",id:"setupteardown",level:2},{value:"Passing Arguments",id:"passing-arguments",level:2},{value:"Passing Arbitrary Arguments to a Benchmark",id:"passing-arbitrary-arguments-to-a-benchmark",level:3},{value:"Calculating Asymptotic Complexity (Big O)",id:"calculating-asymptotic-complexity-big-o",level:2},{value:"Custom Benchmark Name",id:"custom-benchmark-name",level:2},{value:"Templated Benchmarks",id:"templated-benchmarks",level:2},{value:"Templated Benchmarks that take arguments",id:"templated-benchmarks-that-take-arguments",level:2},{value:"Fixtures",id:"fixtures",level:2},{value:"Templated Fixtures",id:"templated-fixtures",level:3},{value:"Custom Counters",id:"custom-counters",level:2},{value:"Counter Reporting",id:"counter-reporting",level:3},{value:"Multithreaded Benchmarks",id:"multithreaded-benchmarks",level:2},{value:"Manual Multithreaded Benchmarks",id:"manual-multithreaded-benchmarks",level:3},{value:"CPU Timers",id:"cpu-timers",level:2},{value:"Controlling Timers",id:"controlling-timers",level:3},{value:"Manual Timing",id:"manual-timing",level:2},{value:"Setting the Time Unit",id:"setting-the-time-unit",level:2},{value:"Preventing Optimization",id:"preventing-optimization",level:2},{value:"Statistics: Reporting the Mean, Median and Standard Deviation / Coefficient of variation of Repeated Benchmarks",id:"statistics-reporting-the-mean-median-and-standard-deviation--coefficient-of-variation-of-repeated-benchmarks",level:2},{value:"Custom Statistics",id:"custom-statistics",level:2},{value:"Memory Usage",id:"memory-usage",level:2},{value:"Profiling",id:"profiling",level:2},{value:"Using RegisterBenchmark(name, fn, args...)",id:"using-registerbenchmarkname-fn-args",level:2},{value:"Exiting with an Error",id:"exiting-with-an-error",level:2},{value:"A Faster KeepRunning Loop",id:"a-faster-keeprunning-loop",level:2},{value:"Disabling CPU Frequency Scaling",id:"disabling-cpu-frequency-scaling",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"user-guide",children:"User Guide"})}),"\n",(0,r.jsx)(n.h2,{id:"command-line",children:"Command Line"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#output-formats",children:"Output Formats"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#output-files",children:"Output Files"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#running-benchmarks",children:"Running Benchmarks"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#running-a-subset-of-benchmarks",children:"Running a Subset of Benchmarks"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#result-comparison",children:"Result Comparison"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#extra-context",children:"Extra Context"})}),"\n",(0,r.jsx)(n.h2,{id:"library",children:"Library"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#runtime-and-reporting-considerations",children:"Runtime and Reporting Considerations"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#setupteardown",children:"Setup/Teardown"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#passing-arguments",children:"Passing Arguments"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#custom-benchmark-name",children:"Custom Benchmark Name"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#asymptotic-complexity",children:"Calculating Asymptotic Complexity"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#templated-benchmarks",children:"Templated Benchmarks"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#templated-benchmarks-with-arguments",children:"Templated Benchmarks that take arguments"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#fixtures",children:"Fixtures"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#custom-counters",children:"Custom Counters"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#multithreaded-benchmarks",children:"Multithreaded Benchmarks"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#cpu-timers",children:"CPU Timers"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#manual-timing",children:"Manual Timing"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#setting-the-time-unit",children:"Setting the Time Unit"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"/cppdev/zh-cn/docs/testing/benchmark/random_interleaving",children:"Random Interleaving"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"/cppdev/zh-cn/docs/testing/benchmark/perf_counters",children:"User-Requested Performance Counters"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#preventing-optimization",children:"Preventing Optimization"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#reporting-statistics",children:"Reporting Statistics"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#custom-statistics",children:"Custom Statistics"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#memory-usage",children:"Memory Usage"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#using-register-benchmark",children:"Using RegisterBenchmark"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#exiting-with-an-error",children:"Exiting with an Error"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.a,{href:"#a-faster-keep-running-loop",children:["A Faster ",(0,r.jsx)(n.code,{children:"KeepRunning"})," Loop"]})}),"\n",(0,r.jsx)(n.h2,{id:"benchmarking-tips",children:"Benchmarking Tips"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#disabling-cpu-frequency-scaling",children:"Disabling CPU Frequency Scaling"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"/cppdev/zh-cn/docs/testing/benchmark/reducing_variance",children:"Reducing Variance in Benchmarks"})}),"\n",(0,r.jsx)("a",{name:"output-formats"}),"\n",(0,r.jsx)(n.h2,{id:"output-formats",children:"Output Formats"}),"\n",(0,r.jsxs)(n.p,{children:["The library supports multiple output formats. Use the\n",(0,r.jsx)(n.code,{children:"--benchmark_format=<console|json|csv>"})," flag (or set the\n",(0,r.jsx)(n.code,{children:"BENCHMARK_FORMAT=<console|json|csv>"})," environment variable) to set\nthe format type. ",(0,r.jsx)(n.code,{children:"console"})," is the default format."]}),"\n",(0,r.jsx)(n.p,{children:"The Console format is intended to be a human readable format. By default\nthe format generates color output. Context is output on stderr and the\ntabular data on stdout. Example tabular output looks like:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Benchmark                               Time(ns)    CPU(ns) Iterations\n----------------------------------------------------------------------\nBM_SetInsert/1024/1                        28928      29349      23853  133.097kiB/s   33.2742k items/s\nBM_SetInsert/1024/8                        32065      32913      21375  949.487kiB/s   237.372k items/s\nBM_SetInsert/1024/10                       33157      33648      21431  1.13369MiB/s   290.225k items/s\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The JSON format outputs human readable json split into two top level attributes.\nThe ",(0,r.jsx)(n.code,{children:"context"})," attribute contains information about the run in general, including\ninformation about the CPU and the date.\nThe ",(0,r.jsx)(n.code,{children:"benchmarks"})," attribute contains a list of every benchmark run. Example json\noutput looks like:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "context": {\n    "date": "2015/03/17-18:40:25",\n    "num_cpus": 40,\n    "mhz_per_cpu": 2801,\n    "cpu_scaling_enabled": false,\n    "build_type": "debug"\n  },\n  "benchmarks": [\n    {\n      "name": "BM_SetInsert/1024/1",\n      "iterations": 94877,\n      "real_time": 29275,\n      "cpu_time": 29836,\n      "bytes_per_second": 134066,\n      "items_per_second": 33516\n    },\n    {\n      "name": "BM_SetInsert/1024/8",\n      "iterations": 21609,\n      "real_time": 32317,\n      "cpu_time": 32429,\n      "bytes_per_second": 986770,\n      "items_per_second": 246693\n    },\n    {\n      "name": "BM_SetInsert/1024/10",\n      "iterations": 21393,\n      "real_time": 32724,\n      "cpu_time": 33355,\n      "bytes_per_second": 1199226,\n      "items_per_second": 299807\n    }\n  ]\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The CSV format outputs comma-separated values. The ",(0,r.jsx)(n.code,{children:"context"})," is output on stderr\nand the CSV itself on stdout. Example CSV output looks like:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'name,iterations,real_time,cpu_time,bytes_per_second,items_per_second,label\n"BM_SetInsert/1024/1",65465,17890.7,8407.45,475768,118942,\n"BM_SetInsert/1024/8",116606,18810.1,9766.64,3.27646e+06,819115,\n"BM_SetInsert/1024/10",106365,17238.4,8421.53,4.74973e+06,1.18743e+06,\n'})}),"\n",(0,r.jsx)("a",{name:"output-files"}),"\n",(0,r.jsx)(n.h2,{id:"output-files",children:"Output Files"}),"\n",(0,r.jsxs)(n.p,{children:["Write benchmark results to a file with the ",(0,r.jsx)(n.code,{children:"--benchmark_out=<filename>"})," option\n(or set ",(0,r.jsx)(n.code,{children:"BENCHMARK_OUT"}),"). Specify the output format with\n",(0,r.jsx)(n.code,{children:"--benchmark_out_format={json|console|csv}"})," (or set\n",(0,r.jsx)(n.code,{children:"BENCHMARK_OUT_FORMAT={json|console|csv}"}),"). Note that the 'csv' reporter is\ndeprecated and the saved ",(0,r.jsx)(n.code,{children:".csv"})," file\n",(0,r.jsx)(n.a,{href:"https://github.com/google/benchmark/issues/794",children:"is not parsable"})," by csv\nparsers."]}),"\n",(0,r.jsxs)(n.p,{children:["Specifying ",(0,r.jsx)(n.code,{children:"--benchmark_out"})," does not suppress the console output."]}),"\n",(0,r.jsx)("a",{name:"running-benchmarks"}),"\n",(0,r.jsx)(n.h2,{id:"running-benchmarks",children:"Running Benchmarks"}),"\n",(0,r.jsxs)(n.p,{children:["Benchmarks are executed by running the produced binaries. Benchmarks binaries,\nby default, accept options that may be specified either through their command\nline interface or by setting environment variables before execution. For every\n",(0,r.jsx)(n.code,{children:"--option_flag=<value>"})," CLI switch, a corresponding environment variable\n",(0,r.jsx)(n.code,{children:"OPTION_FLAG=<value>"})," exist and is used as default if set (CLI switches always\nprevails). A complete list of CLI options is available running benchmarks\nwith the ",(0,r.jsx)(n.code,{children:"--help"})," switch."]}),"\n",(0,r.jsx)(n.h3,{id:"dry-runs",children:"Dry runs"}),"\n",(0,r.jsxs)(n.p,{children:["To confirm that benchmarks can run successfully without needing to wait for\nmultiple repetitions and iterations, the ",(0,r.jsx)(n.code,{children:"--benchmark_dry_run"})," flag can be\nused.  This will run the benchmarks as normal, but for 1 iteration and 1\nrepetition only."]}),"\n",(0,r.jsx)("a",{name:"running-a-subset-of-benchmarks"}),"\n",(0,r.jsx)(n.h2,{id:"running-a-subset-of-benchmarks",children:"Running a Subset of Benchmarks"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"--benchmark_filter=<regex>"})," option (or ",(0,r.jsx)(n.code,{children:"BENCHMARK_FILTER=<regex>"}),"\nenvironment variable) can be used to only run the benchmarks that match\nthe specified ",(0,r.jsx)(n.code,{children:"<regex>"}),". For example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"$ ./run_benchmarks.x --benchmark_filter=BM_memcpy/32\nRun on (1 X 2300 MHz CPU )\n2016-06-25 19:34:24\nBenchmark              Time           CPU Iterations\n----------------------------------------------------\nBM_memcpy/32          11 ns         11 ns   79545455\nBM_memcpy/32k       2181 ns       2185 ns     324074\nBM_memcpy/32          12 ns         12 ns   54687500\nBM_memcpy/32k       1834 ns       1837 ns     357143\n"})}),"\n",(0,r.jsx)(n.h2,{id:"disabling-benchmarks",children:"Disabling Benchmarks"}),"\n",(0,r.jsx)(n.p,{children:'It is possible to temporarily disable benchmarks by renaming the benchmark\nfunction to have the prefix "DISABLED_". This will cause the benchmark to\nbe skipped at runtime.'}),"\n",(0,r.jsx)("a",{name:"result-comparison"}),"\n",(0,r.jsx)(n.h2,{id:"result-comparison",children:"Result comparison"}),"\n",(0,r.jsxs)(n.p,{children:["It is possible to compare the benchmarking results.\nSee ",(0,r.jsx)(n.a,{href:"/cppdev/zh-cn/docs/testing/benchmark/tools",children:"Additional Tooling Documentation"})]}),"\n",(0,r.jsx)("a",{name:"extra-context"}),"\n",(0,r.jsx)(n.h2,{id:"extra-context",children:"Extra Context"}),"\n",(0,r.jsxs)(n.p,{children:["Sometimes it's useful to add extra context to the content printed before the\nresults. By default this section includes information about the CPU on which\nthe benchmarks are running. If you do want to add more context, you can use\nthe ",(0,r.jsx)(n.code,{children:"benchmark_context"})," command line flag:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"$ ./run_benchmarks --benchmark_context=pwd=`pwd`\nRun on (1 x 2300 MHz CPU)\npwd: /home/user/benchmark/\nBenchmark              Time           CPU Iterations\n----------------------------------------------------\nBM_memcpy/32          11 ns         11 ns   79545455\nBM_memcpy/32k       2181 ns       2185 ns     324074\n"})}),"\n",(0,r.jsx)(n.p,{children:"You can get the same effect with the API:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:'  benchmark::AddCustomContext("foo", "bar");\n'})}),"\n",(0,r.jsx)(n.p,{children:"Note that attempts to add a second value with the same key will fail with an\nerror message."}),"\n",(0,r.jsx)("a",{name:"runtime-and-reporting-considerations"}),"\n",(0,r.jsx)(n.h2,{id:"runtime-and-reporting-considerations",children:"Runtime and Reporting Considerations"}),"\n",(0,r.jsx)(n.p,{children:"When the benchmark binary is executed, each benchmark function is run serially.\nThe number of iterations to run is determined dynamically by running the\nbenchmark a few times and measuring the time taken and ensuring that the\nultimate result will be statistically stable. As such, faster benchmark\nfunctions will be run for more iterations than slower benchmark functions, and\nthe number of iterations is thus reported."}),"\n",(0,r.jsxs)(n.p,{children:["In all cases, the number of iterations for which the benchmark is run is\ngoverned by the amount of time the benchmark takes. Concretely, the number of\niterations is at least one, not more than 1e9, until CPU time is greater than\nthe minimum time, or the wallclock time is 5x minimum time. The minimum time is\nset per benchmark by calling ",(0,r.jsx)(n.code,{children:"MinTime"})," on the registered benchmark object."]}),"\n",(0,r.jsxs)(n.p,{children:["Furthermore warming up a benchmark might be necessary in order to get\nstable results because of e.g caching effects of the code under benchmark.\nWarming up means running the benchmark a given amount of time, before\nresults are actually taken into account. The amount of time for which\nthe warmup should be run can be set per benchmark by calling\n",(0,r.jsx)(n.code,{children:"MinWarmUpTime"})," on the registered benchmark object or for all benchmarks\nusing the ",(0,r.jsx)(n.code,{children:"--benchmark_min_warmup_time"})," command-line option. Note that\n",(0,r.jsx)(n.code,{children:"MinWarmUpTime"})," will overwrite the value of ",(0,r.jsx)(n.code,{children:"--benchmark_min_warmup_time"}),"\nfor the single benchmark. How many iterations the warmup run of each\nbenchmark takes is determined the same way as described in the paragraph\nabove. Per default the warmup phase is set to 0 seconds and is therefore\ndisabled."]}),"\n",(0,r.jsxs)(n.p,{children:["Average timings are then reported over the iterations run. If multiple\nrepetitions are requested using the ",(0,r.jsx)(n.code,{children:"--benchmark_repetitions"})," command-line\noption, or at registration time, the benchmark function will be run several\ntimes and statistical results across these repetitions will also be reported."]}),"\n",(0,r.jsx)(n.p,{children:"As well as the per-benchmark entries, a preamble in the report will include\ninformation about the machine on which the benchmarks are run."}),"\n",(0,r.jsx)("a",{name:"setup-teardown"}),"\n",(0,r.jsx)(n.h2,{id:"setupteardown",children:"Setup/Teardown"}),"\n",(0,r.jsx)(n.p,{children:"Global setup/teardown specific to each benchmark can be done by\npassing a callback to Setup/Teardown:"}),"\n",(0,r.jsx)(n.p,{children:"The setup/teardown callbacks will be invoked once for each benchmark. If the\nbenchmark is multi-threaded (will run in k threads), they will be invoked\nexactly once before each run with k threads."}),"\n",(0,r.jsx)(n.p,{children:"If the benchmark uses different size groups of threads, the above will be true\nfor each size group."}),"\n",(0,r.jsx)(n.p,{children:"Eg.,"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:"static void DoSetup(const benchmark::State& state) {\n}\n\nstatic void DoTeardown(const benchmark::State& state) {\n}\n\nstatic void BM_func(benchmark::State& state) {...}\n\nBENCHMARK(BM_func)->Arg(1)->Arg(3)->Threads(16)->Threads(32)->Setup(DoSetup)->Teardown(DoTeardown);\n\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In this example, ",(0,r.jsx)(n.code,{children:"DoSetup"})," and ",(0,r.jsx)(n.code,{children:"DoTearDown"})," will be invoked 4 times each,\nspecifically, once for each of this family:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"BM_func_Arg_1_Threads_16, BM_func_Arg_1_Threads_32"}),"\n",(0,r.jsx)(n.li,{children:"BM_func_Arg_3_Threads_16, BM_func_Arg_3_Threads_32"}),"\n"]}),"\n",(0,r.jsx)("a",{name:"passing-arguments"}),"\n",(0,r.jsx)(n.h2,{id:"passing-arguments",children:"Passing Arguments"}),"\n",(0,r.jsxs)(n.p,{children:["Sometimes a family of benchmarks can be implemented with just one routine that\ntakes an extra argument to specify which one of the family of benchmarks to\nrun. For example, the following code defines a family of benchmarks for\nmeasuring the speed of ",(0,r.jsx)(n.code,{children:"memcpy()"})," calls of different lengths:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:"static void BM_memcpy(benchmark::State& state) {\n  char* src = new char[state.range(0)];\n  char* dst = new char[state.range(0)];\n  memset(src, 'x', state.range(0));\n  for (auto _ : state)\n    memcpy(dst, src, state.range(0));\n  state.SetBytesProcessed(int64_t(state.iterations()) *\n                          int64_t(state.range(0)));\n  delete[] src;\n  delete[] dst;\n}\nBENCHMARK(BM_memcpy)->Arg(8)->Arg(64)->Arg(512)->Arg(4<<10)->Arg(8<<10);\n"})}),"\n",(0,r.jsx)(n.p,{children:"The preceding code is quite repetitive, and can be replaced with the following\nshort-hand. The following invocation will pick a few appropriate arguments in\nthe specified range and will generate a benchmark for each such argument."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:"BENCHMARK(BM_memcpy)->Range(8, 8<<10);\n"})}),"\n",(0,r.jsx)(n.p,{children:"By default the arguments in the range are generated in multiples of eight and\nthe command above selects [ 8, 64, 512, 4k, 8k ]. In the following code the\nrange multiplier is changed to multiples of two."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:"BENCHMARK(BM_memcpy)->RangeMultiplier(2)->Range(8, 8<<10);\n"})}),"\n",(0,r.jsx)(n.p,{children:"Now arguments generated are [ 8, 16, 32, 64, 128, 256, 512, 1024, 2k, 4k, 8k ]."}),"\n",(0,r.jsxs)(n.p,{children:["The preceding code shows a method of defining a sparse range.  The following\nexample shows a method of defining a dense range. It is then used to benchmark\nthe performance of ",(0,r.jsx)(n.code,{children:"std::vector"})," initialization for uniformly increasing sizes."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:"static void BM_DenseRange(benchmark::State& state) {\n  for(auto _ : state) {\n    std::vector<int> v(state.range(0), state.range(0));\n    auto data = v.data();\n    benchmark::DoNotOptimize(data);\n    benchmark::ClobberMemory();\n  }\n}\nBENCHMARK(BM_DenseRange)->DenseRange(0, 1024, 128);\n"})}),"\n",(0,r.jsx)(n.p,{children:"Now arguments generated are [ 0, 128, 256, 384, 512, 640, 768, 896, 1024 ]."}),"\n",(0,r.jsx)(n.p,{children:"You might have a benchmark that depends on two or more inputs. For example, the\nfollowing code defines a family of benchmarks for measuring the speed of set\ninsertion."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:"static void BM_SetInsert(benchmark::State& state) {\n  std::set<int> data;\n  for (auto _ : state) {\n    state.PauseTiming();\n    data = ConstructRandomSet(state.range(0));\n    state.ResumeTiming();\n    for (int j = 0; j < state.range(1); ++j)\n      data.insert(RandomNumber());\n  }\n}\nBENCHMARK(BM_SetInsert)\n    ->Args({1<<10, 128})\n    ->Args({2<<10, 128})\n    ->Args({4<<10, 128})\n    ->Args({8<<10, 128})\n    ->Args({1<<10, 512})\n    ->Args({2<<10, 512})\n    ->Args({4<<10, 512})\n    ->Args({8<<10, 512});\n"})}),"\n",(0,r.jsx)(n.p,{children:"The preceding code is quite repetitive, and can be replaced with the following\nshort-hand. The following macro will pick a few appropriate arguments in the\nproduct of the two specified ranges and will generate a benchmark for each such\npair."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:"BENCHMARK(BM_SetInsert)->Ranges({{1<<10, 8<<10}, {128, 512}});\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Some benchmarks may require specific argument values that cannot be expressed\nwith ",(0,r.jsx)(n.code,{children:"Ranges"}),". In this case, ",(0,r.jsx)(n.code,{children:"ArgsProduct"})," offers the ability to generate a\nbenchmark input for each combination in the product of the supplied vectors."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:"BENCHMARK(BM_SetInsert)\n    ->ArgsProduct({{1<<10, 3<<10, 8<<10}, {20, 40, 60, 80}})\n// would generate the same benchmark arguments as\nBENCHMARK(BM_SetInsert)\n    ->Args({1<<10, 20})\n    ->Args({3<<10, 20})\n    ->Args({8<<10, 20})\n    ->Args({3<<10, 40})\n    ->Args({8<<10, 40})\n    ->Args({1<<10, 40})\n    ->Args({1<<10, 60})\n    ->Args({3<<10, 60})\n    ->Args({8<<10, 60})\n    ->Args({1<<10, 80})\n    ->Args({3<<10, 80})\n    ->Args({8<<10, 80});\n"})}),"\n",(0,r.jsx)(n.p,{children:"For the most common scenarios, helper methods for creating a list of\nintegers for a given sparse or dense range are provided."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:"BENCHMARK(BM_SetInsert)\n    ->ArgsProduct({\n      benchmark::CreateRange(8, 128, /*multi=*/2),\n      benchmark::CreateDenseRange(1, 4, /*step=*/1)\n    })\n// would generate the same benchmark arguments as\nBENCHMARK(BM_SetInsert)\n    ->ArgsProduct({\n      {8, 16, 32, 64, 128},\n      {1, 2, 3, 4}\n    });\n"})}),"\n",(0,r.jsxs)(n.p,{children:["For more complex patterns of inputs, passing a custom function to ",(0,r.jsx)(n.code,{children:"Apply"})," allows\nprogrammatic specification of an arbitrary set of arguments on which to run the\nbenchmark. The following example enumerates a dense range on one parameter,\nand a sparse range on the second."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:"static void CustomArguments(benchmark::internal::Benchmark* b) {\n  for (int i = 0; i <= 10; ++i)\n    for (int j = 32; j <= 1024*1024; j *= 8)\n      b->Args({i, j});\n}\nBENCHMARK(BM_SetInsert)->Apply(CustomArguments);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"passing-arbitrary-arguments-to-a-benchmark",children:"Passing Arbitrary Arguments to a Benchmark"}),"\n",(0,r.jsxs)(n.p,{children:["It is possible to define a benchmark that takes an arbitrary number\nof extra arguments. The ",(0,r.jsx)(n.code,{children:"BENCHMARK_CAPTURE(func, test_case_name, ...args)"}),"\nmacro creates a benchmark that invokes ",(0,r.jsx)(n.code,{children:"func"}),"  with the ",(0,r.jsx)(n.code,{children:"benchmark::State"})," as\nthe first argument followed by the specified ",(0,r.jsx)(n.code,{children:"args..."}),".\nThe ",(0,r.jsx)(n.code,{children:"test_case_name"})," is appended to the name of the benchmark and\nshould describe the values passed."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:'template <class ...Args>\nvoid BM_takes_args(benchmark::State& state, Args&&... args) {\n  auto args_tuple = std::make_tuple(std::move(args)...);\n  for (auto _ : state) {\n    std::cout << std::get<0>(args_tuple) << ": " << std::get<1>(args_tuple)\n              << \'\\n\';\n    [...]\n  }\n}\n// Registers a benchmark named "BM_takes_args/int_string_test" that passes\n// the specified values to `args`.\nBENCHMARK_CAPTURE(BM_takes_args, int_string_test, 42, std::string("abc"));\n\n// Registers the same benchmark "BM_takes_args/int_test" that passes\n// the specified values to `args`.\nBENCHMARK_CAPTURE(BM_takes_args, int_test, 42, 43);\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Note that elements of ",(0,r.jsx)(n.code,{children:"...args"})," may refer to global variables. Users should\navoid modifying global state inside of a benchmark."]}),"\n",(0,r.jsx)("a",{name:"asymptotic-complexity"}),"\n",(0,r.jsx)(n.h2,{id:"calculating-asymptotic-complexity-big-o",children:"Calculating Asymptotic Complexity (Big O)"}),"\n",(0,r.jsx)(n.p,{children:"Asymptotic complexity might be calculated for a family of benchmarks. The\nfollowing code will calculate the coefficient for the high-order term in the\nrunning time and the normalized root-mean square error of string comparison."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:"static void BM_StringCompare(benchmark::State& state) {\n  std::string s1(state.range(0), '-');\n  std::string s2(state.range(0), '-');\n  for (auto _ : state) {\n    auto comparison_result = s1.compare(s2);\n    benchmark::DoNotOptimize(comparison_result);\n  }\n  state.SetComplexityN(state.range(0));\n}\nBENCHMARK(BM_StringCompare)\n    ->RangeMultiplier(2)->Range(1<<10, 1<<18)->Complexity(benchmark::oN);\n"})}),"\n",(0,r.jsx)(n.p,{children:"As shown in the following invocation, asymptotic complexity might also be\ncalculated automatically."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:"BENCHMARK(BM_StringCompare)\n    ->RangeMultiplier(2)->Range(1<<10, 1<<18)->Complexity();\n"})}),"\n",(0,r.jsx)(n.p,{children:"The following code will specify asymptotic complexity with a lambda function,\nthat might be used to customize high-order term calculation."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:"BENCHMARK(BM_StringCompare)->RangeMultiplier(2)\n    ->Range(1<<10, 1<<18)->Complexity([](benchmark::IterationCount n)->double{return n; });\n"})}),"\n",(0,r.jsx)("a",{name:"custom-benchmark-name"}),"\n",(0,r.jsx)(n.h2,{id:"custom-benchmark-name",children:"Custom Benchmark Name"}),"\n",(0,r.jsx)(n.p,{children:"You can change the benchmark's name as follows:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:'BENCHMARK(BM_memcpy)->Name("memcpy")->RangeMultiplier(2)->Range(8, 8<<10);\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The invocation will execute the benchmark as before using ",(0,r.jsx)(n.code,{children:"BM_memcpy"})," but changes\nthe prefix in the report to ",(0,r.jsx)(n.code,{children:"memcpy"}),"."]}),"\n",(0,r.jsx)("a",{name:"templated-benchmarks"}),"\n",(0,r.jsx)(n.h2,{id:"templated-benchmarks",children:"Templated Benchmarks"}),"\n",(0,r.jsxs)(n.p,{children:["This example produces and consumes messages of size ",(0,r.jsx)(n.code,{children:"sizeof(v)"})," ",(0,r.jsx)(n.code,{children:"range_x"}),"\ntimes. It also outputs throughput in the absence of multiprogramming."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:"template <class Q> void BM_Sequential(benchmark::State& state) {\n  Q q;\n  typename Q::value_type v;\n  for (auto _ : state) {\n    for (int i = state.range(0); i--; )\n      q.push(v);\n    for (int e = state.range(0); e--; )\n      q.Wait(&v);\n  }\n  // actually messages, not bytes:\n  state.SetBytesProcessed(\n      static_cast<int64_t>(state.iterations())*state.range(0));\n}\n\n// You can use the BENCHMARK macro with template parameters:\nBENCHMARK(BM_Sequential<WaitQueue<int>>)->Range(1<<0, 1<<10);\n\n// Old, legacy verbose C++03 syntax:\nBENCHMARK_TEMPLATE(BM_Sequential, WaitQueue<int>)->Range(1<<0, 1<<10);\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"Three macros are provided for adding benchmark templates."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:"#define BENCHMARK(func<...>) // Takes any number of parameters.\n#define BENCHMARK_TEMPLATE1(func, arg1)\n#define BENCHMARK_TEMPLATE2(func, arg1, arg2)\n"})}),"\n",(0,r.jsx)("a",{name:"templated-benchmarks-with-arguments"}),"\n",(0,r.jsx)(n.h2,{id:"templated-benchmarks-that-take-arguments",children:"Templated Benchmarks that take arguments"}),"\n",(0,r.jsx)(n.p,{children:"Sometimes there is a need to template benchmarks, and provide arguments to them."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:"template <class Q> void BM_Sequential_With_Step(benchmark::State& state, int step) {\n  Q q;\n  typename Q::value_type v;\n  for (auto _ : state) {\n    for (int i = state.range(0); i-=step; )\n      q.push(v);\n    for (int e = state.range(0); e-=step; )\n      q.Wait(&v);\n  }\n  // actually messages, not bytes:\n  state.SetBytesProcessed(\n      static_cast<int64_t>(state.iterations())*state.range(0));\n}\n\nBENCHMARK_TEMPLATE1_CAPTURE(BM_Sequential, WaitQueue<int>, Step1, 1)->Range(1<<0, 1<<10);\n"})}),"\n",(0,r.jsx)("a",{name:"fixtures"}),"\n",(0,r.jsx)(n.h2,{id:"fixtures",children:"Fixtures"}),"\n",(0,r.jsxs)(n.p,{children:["Fixture tests are created by first defining a type that derives from\n",(0,r.jsx)(n.code,{children:"::benchmark::Fixture"})," and then creating/registering the tests using the\nfollowing macros:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"BENCHMARK_F(ClassName, Method)"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"BENCHMARK_DEFINE_F(ClassName, Method)"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"BENCHMARK_REGISTER_F(ClassName, Method)"})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"For Example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:"class MyFixture : public benchmark::Fixture {\npublic:\n  void SetUp(::benchmark::State& state) {\n  }\n\n  void TearDown(::benchmark::State& state) {\n  }\n};\n\n// Defines and registers `FooTest` using the class `MyFixture`.\nBENCHMARK_F(MyFixture, FooTest)(benchmark::State& st) {\n   for (auto _ : st) {\n     ...\n  }\n}\n\n// Only defines `BarTest` using the class `MyFixture`.\nBENCHMARK_DEFINE_F(MyFixture, BarTest)(benchmark::State& st) {\n   for (auto _ : st) {\n     ...\n  }\n}\n// `BarTest` is NOT registered.\nBENCHMARK_REGISTER_F(MyFixture, BarTest)->Threads(2);\n// `BarTest` is now registered.\n"})}),"\n",(0,r.jsx)(n.h3,{id:"templated-fixtures",children:"Templated Fixtures"}),"\n",(0,r.jsx)(n.p,{children:"Also you can create templated fixture by using the following macros:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"BENCHMARK_TEMPLATE_F(ClassName, Method, ...)"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"BENCHMARK_TEMPLATE_DEFINE_F(ClassName, Method, ...)"})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"For example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:"template<typename T>\nclass MyFixture : public benchmark::Fixture {};\n\n// Defines and registers `IntTest` using the class template `MyFixture<int>`.\nBENCHMARK_TEMPLATE_F(MyFixture, IntTest, int)(benchmark::State& st) {\n   for (auto _ : st) {\n     ...\n  }\n}\n\n// Only defines `DoubleTest` using the class template `MyFixture<double>`.\nBENCHMARK_TEMPLATE_DEFINE_F(MyFixture, DoubleTest, double)(benchmark::State& st) {\n   for (auto _ : st) {\n     ...\n  }\n}\n// `DoubleTest` is NOT registered.\nBENCHMARK_REGISTER_F(MyFixture, DoubleTest)->Threads(2);\n// `DoubleTest` is now registered.\n"})}),"\n",(0,r.jsx)(n.p,{children:"If you want to use a method template for your fixtures,\nwhich you instantiate afterward, use the following macros:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"BENCHMARK_TEMPLATE_METHOD_F(ClassName, Method)"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"BENCHMARK_TEMPLATE_INSTANTIATE_F(ClassName, Method, ...)"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["With these macros you can define one method for several instantiations.\nExample (using ",(0,r.jsx)(n.code,{children:"MyFixture"})," from above):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:"// Defines `Test` using the class template `MyFixture`.\nBENCHMARK_TEMPLATE_METHOD_F(MyFixture, Test)(benchmark::State& st) {\n   for (auto _ : st) {\n     ...\n  }\n}\n\n// Instantiates and registers the benchmark `MyFixture<int>::Test`.\nBENCHMARK_TEMPLATE_INSTANTIATE_F(MyFixture, Test, int)->Threads(2);\n// Instantiates and registers the benchmark `MyFixture<double>::Test`.\nBENCHMARK_TEMPLATE_INSTANTIATE_F(MyFixture, Test, double)->Threads(4);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Inside the method definition of ",(0,r.jsx)(n.code,{children:"BENCHMARK_TEMPLATE_METHOD_F"})," the type ",(0,r.jsx)(n.code,{children:"Base"})," refers\nto the type of the instantiated fixture.\nAccesses to members of the fixture must be prefixed by ",(0,r.jsx)(n.code,{children:"this->"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"BENCHMARK_TEMPLATE_METHOD_F"}),"and ",(0,r.jsx)(n.code,{children:"BENCHMARK_TEMPLATE_INSTANTIATE_F"})," can only be used,\nif the fixture does not use non-type template parameters.\nIf you want to pass values as template parameters, use e.g. ",(0,r.jsx)(n.code,{children:"std::integral_constant"}),".\nFor example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:"template<typename Sz>\nclass SizedFixture : public benchmark::Fixture {\n  static constexpr auto Size = Sz::value;\n  int myValue;\n};\n\nBENCHMARK_TEMPLATE_METHOD_F(SizedFixture, Test)(benchmark::State& st) {\n   for (auto _ : st) {\n     this->myValue = Base::Size;\n  }\n}\n\nBENCHMARK_TEMPLATE_INSTANTIATE_F(SizedFixture, Test, std::integral_constant<5>)->Threads(2);\n"})}),"\n",(0,r.jsx)("a",{name:"custom-counters"}),"\n",(0,r.jsx)(n.h2,{id:"custom-counters",children:"Custom Counters"}),"\n",(0,r.jsx)(n.p,{children:'You can add your own counters with user-defined names. The example below\nwill add columns "Foo", "Bar" and "Baz" in its output:'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:'static void UserCountersExample1(benchmark::State& state) {\n  double numFoos = 0, numBars = 0, numBazs = 0;\n  for (auto _ : state) {\n    // ... count Foo,Bar,Baz events\n  }\n  state.counters["Foo"] = numFoos;\n  state.counters["Bar"] = numBars;\n  state.counters["Baz"] = numBazs;\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"state.counters"})," object is a ",(0,r.jsx)(n.code,{children:"std::map"})," with ",(0,r.jsx)(n.code,{children:"std::string"})," keys\nand ",(0,r.jsx)(n.code,{children:"Counter"})," values. The latter is a ",(0,r.jsx)(n.code,{children:"double"}),"-like class, via an implicit\nconversion to ",(0,r.jsx)(n.code,{children:"double&"}),". Thus you can use all of the standard arithmetic\nassignment operators (",(0,r.jsx)(n.code,{children:"=,+=,-=,*=,/="}),") to change the value of each counter."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"Counter"})," constructor accepts three parameters: the value as a ",(0,r.jsx)(n.code,{children:"double"}),"\n; a bit flag which allows you to show counters as rates, and/or as per-thread\niteration, and/or as per-thread averages, and/or iteration invariants,\nand/or finally inverting the result; and a flag specifying the 'unit' - i.e.\nis 1k a 1000 (default, ",(0,r.jsx)(n.code,{children:"benchmark::Counter::OneK::kIs1000"}),"), or 1024\n(",(0,r.jsx)(n.code,{children:"benchmark::Counter::OneK::kIs1024"}),")?"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:'  // sets a simple counter\n  state.counters["Foo"] = numFoos;\n\n  // Set the counter as a rate. It will be presented divided\n  // by the duration of the benchmark.\n  // Meaning: per one second, how many \'foo\'s are processed?\n  state.counters["FooRate"] = Counter(numFoos, benchmark::Counter::kIsRate);\n\n  // Set the counter as a rate. It will be presented divided\n  // by the duration of the benchmark, and the result inverted.\n  // Meaning: how many seconds it takes to process one \'foo\'?\n  state.counters["FooInvRate"] = Counter(numFoos, benchmark::Counter::kIsRate | benchmark::Counter::kInvert);\n\n  // Set the counter as a thread-average quantity. It will\n  // be presented divided by the number of threads.\n  state.counters["FooAvg"] = Counter(numFoos, benchmark::Counter::kAvgThreads);\n\n  // There\'s also a combined flag:\n  state.counters["FooAvgRate"] = Counter(numFoos,benchmark::Counter::kAvgThreadsRate);\n\n  // This says that we process with the rate of state.range(0) bytes every iteration:\n  state.counters["BytesProcessed"] = Counter(state.range(0), benchmark::Counter::kIsIterationInvariantRate, benchmark::Counter::OneK::kIs1024);\n'})}),"\n",(0,r.jsxs)(n.p,{children:["You can use ",(0,r.jsx)(n.code,{children:"insert()"})," with ",(0,r.jsx)(n.code,{children:"std::initializer_list"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:'  state.counters.insert({{"Foo", numFoos}, {"Bar", numBars}, {"Baz", numBazs}});\n  // ... instead of:\n  state.counters["Foo"] = numFoos;\n  state.counters["Bar"] = numBars;\n  state.counters["Baz"] = numBazs;\n'})}),"\n",(0,r.jsxs)(n.p,{children:["In multithreaded benchmarks, each counter is set on the calling thread only.\nWhen the benchmark finishes, the counters from each thread will be summed.\nCounters that are configured with ",(0,r.jsx)(n.code,{children:"kIsRate"}),", will report the average rate across all threads, while ",(0,r.jsx)(n.code,{children:"kAvgThreadsRate"})," counters will report the average rate per thread."]}),"\n",(0,r.jsx)(n.h3,{id:"counter-reporting",children:"Counter Reporting"}),"\n",(0,r.jsxs)(n.p,{children:["When using the console reporter, by default, user counters are printed at\nthe end after the table, the same way as ",(0,r.jsx)(n.code,{children:"bytes_processed"})," and\n",(0,r.jsx)(n.code,{children:"items_processed"}),". This is best for cases in which there are few counters,\nor where there are only a couple of lines per benchmark. Here's an example of\nthe default output:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"------------------------------------------------------------------------------\nBenchmark                        Time           CPU Iterations UserCounters...\n------------------------------------------------------------------------------\nBM_UserCounter/threads:8      2248 ns      10277 ns      68808 Bar=16 Bat=40 Baz=24 Foo=8\nBM_UserCounter/threads:1      9797 ns       9788 ns      71523 Bar=2 Bat=5 Baz=3 Foo=1024m\nBM_UserCounter/threads:2      4924 ns       9842 ns      71036 Bar=4 Bat=10 Baz=6 Foo=2\nBM_UserCounter/threads:4      2589 ns      10284 ns      68012 Bar=8 Bat=20 Baz=12 Foo=4\nBM_UserCounter/threads:8      2212 ns      10287 ns      68040 Bar=16 Bat=40 Baz=24 Foo=8\nBM_UserCounter/threads:16     1782 ns      10278 ns      68144 Bar=32 Bat=80 Baz=48 Foo=16\nBM_UserCounter/threads:32     1291 ns      10296 ns      68256 Bar=64 Bat=160 Baz=96 Foo=32\nBM_UserCounter/threads:4      2615 ns      10307 ns      68040 Bar=8 Bat=20 Baz=12 Foo=4\nBM_Factorial                    26 ns         26 ns   26608979 40320\nBM_Factorial/real_time          26 ns         26 ns   26587936 40320\nBM_CalculatePiRange/1           16 ns         16 ns   45704255 0\nBM_CalculatePiRange/8           73 ns         73 ns    9520927 3.28374\nBM_CalculatePiRange/64         609 ns        609 ns    1140647 3.15746\nBM_CalculatePiRange/512       4900 ns       4901 ns     142696 3.14355\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If this doesn't suit you, you can print each counter as a table column by\npassing the flag ",(0,r.jsx)(n.code,{children:"--benchmark_counters_tabular=true"})," to the benchmark\napplication. This is best for cases in which there are a lot of counters, or\na lot of lines per individual benchmark. Note that this will trigger a\nreprinting of the table header any time the counter set changes between\nindividual benchmarks. Here's an example of corresponding output when\n",(0,r.jsx)(n.code,{children:"--benchmark_counters_tabular=true"})," is passed:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"---------------------------------------------------------------------------------------\nBenchmark                        Time           CPU Iterations    Bar   Bat   Baz   Foo\n---------------------------------------------------------------------------------------\nBM_UserCounter/threads:8      2198 ns       9953 ns      70688     16    40    24     8\nBM_UserCounter/threads:1      9504 ns       9504 ns      73787      2     5     3     1\nBM_UserCounter/threads:2      4775 ns       9550 ns      72606      4    10     6     2\nBM_UserCounter/threads:4      2508 ns       9951 ns      70332      8    20    12     4\nBM_UserCounter/threads:8      2055 ns       9933 ns      70344     16    40    24     8\nBM_UserCounter/threads:16     1610 ns       9946 ns      70720     32    80    48    16\nBM_UserCounter/threads:32     1192 ns       9948 ns      70496     64   160    96    32\nBM_UserCounter/threads:4      2506 ns       9949 ns      70332      8    20    12     4\n--------------------------------------------------------------\nBenchmark                        Time           CPU Iterations\n--------------------------------------------------------------\nBM_Factorial                    26 ns         26 ns   26392245 40320\nBM_Factorial/real_time          26 ns         26 ns   26494107 40320\nBM_CalculatePiRange/1           15 ns         15 ns   45571597 0\nBM_CalculatePiRange/8           74 ns         74 ns    9450212 3.28374\nBM_CalculatePiRange/64         595 ns        595 ns    1173901 3.15746\nBM_CalculatePiRange/512       4752 ns       4752 ns     147380 3.14355\nBM_CalculatePiRange/4k       37970 ns      37972 ns      18453 3.14184\nBM_CalculatePiRange/32k     303733 ns     303744 ns       2305 3.14162\nBM_CalculatePiRange/256k   2434095 ns    2434186 ns        288 3.1416\nBM_CalculatePiRange/1024k  9721140 ns    9721413 ns         71 3.14159\nBM_CalculatePi/threads:8      2255 ns       9943 ns      70936\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Note above the additional header printed when the benchmark changes from\n",(0,r.jsx)(n.code,{children:"BM_UserCounter"})," to ",(0,r.jsx)(n.code,{children:"BM_Factorial"}),". This is because ",(0,r.jsx)(n.code,{children:"BM_Factorial"})," does\nnot have the same counter set as ",(0,r.jsx)(n.code,{children:"BM_UserCounter"}),"."]}),"\n",(0,r.jsx)("a",{name:"multithreaded-benchmarks"}),"\n",(0,r.jsx)(n.h2,{id:"multithreaded-benchmarks",children:"Multithreaded Benchmarks"}),"\n",(0,r.jsxs)(n.p,{children:["In a multithreaded test (benchmark invoked by multiple threads simultaneously),\nit is guaranteed that none of the threads will start until all have reached\nthe start of the benchmark loop, and all will have finished before any thread\nexits the benchmark loop. (This behavior is also provided by the ",(0,r.jsx)(n.code,{children:"KeepRunning()"}),"\nAPI) As such, any global setup or teardown can be wrapped in a check against the thread\nindex:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:"static void BM_MultiThreaded(benchmark::State& state) {\n  if (state.thread_index() == 0) {\n    // Setup code here.\n  }\n  for (auto _ : state) {\n    // Run the test as normal.\n  }\n  if (state.thread_index() == 0) {\n    // Teardown code here.\n  }\n}\nBENCHMARK(BM_MultiThreaded)->Threads(2);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["To run the benchmark across a range of thread counts, instead of ",(0,r.jsx)(n.code,{children:"Threads"}),", use\n",(0,r.jsx)(n.code,{children:"ThreadRange"}),". This takes two parameters (",(0,r.jsx)(n.code,{children:"min_threads"})," and ",(0,r.jsx)(n.code,{children:"max_threads"}),") and\nruns the benchmark once for values in the inclusive range. For example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:"BENCHMARK(BM_MultiThreaded)->ThreadRange(1, 8);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["will run ",(0,r.jsx)(n.code,{children:"BM_MultiThreaded"})," with thread counts 1, 2, 4, and 8."]}),"\n",(0,r.jsx)(n.p,{children:'If the benchmarked code itself uses threads and you want to compare it to\nsingle-threaded code, you may want to use real-time ("wallclock") measurements\nfor latency comparisons:'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:"BENCHMARK(BM_test)->Range(8, 8<<10)->UseRealTime();\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Without ",(0,r.jsx)(n.code,{children:"UseRealTime"}),", CPU time is used by default."]}),"\n",(0,r.jsx)(n.h3,{id:"manual-multithreaded-benchmarks",children:"Manual Multithreaded Benchmarks"}),"\n",(0,r.jsxs)(n.p,{children:["Google/benchmark uses ",(0,r.jsx)(n.code,{children:"std::thread"})," as multithreading environment per default.\nIf you want to use another multithreading environment (e.g. OpenMP), you can provide\na factory function to your benchmark using the ",(0,r.jsx)(n.code,{children:"ThreadRunner"})," function.\nThe factory function takes the number of threads as argument and creates a custom class\nderived from ",(0,r.jsx)(n.code,{children:"benchmark::ThreadRunnerBase"}),".\nThis custom class must override the function\n",(0,r.jsx)(n.code,{children:"void RunThreads(const std::function<void(int)>& fn)"}),".\n",(0,r.jsx)(n.code,{children:"RunThreads"})," is called by the main thread and spawns the requested number of threads.\nEach spawned thread must call ",(0,r.jsx)(n.code,{children:"fn(thread_index)"}),", where ",(0,r.jsx)(n.code,{children:"thread_index"})," is its own\nthread index. Before ",(0,r.jsx)(n.code,{children:"RunThreads"})," returns, all spawned threads must be joined."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:"class OpenMPThreadRunner : public benchmark::ThreadRunnerBase\n{\n  OpenMPThreadRunner(int num_threads)\n  : num_threads_(num_threads)\n  {}\n\n  void RunThreads(const std::function<void(int)>& fn) final\n  {\n#pragma omp parallel num_threads(num_threads_)\n    fn(omp_get_thread_num());\n  }\n\nprivate:\n  int num_threads_;\n};\n\nBENCHMARK(BM_MultiThreaded)\n  ->ThreadRunner([](int num_threads) {\n    return std::make_unique<OpenMPThreadRunner>(num_threads);\n  })\n  ->Threads(1)->Threads(2)->Threads(4);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The above example creates a parallel OpenMP region before it enters ",(0,r.jsx)(n.code,{children:"BM_MultiThreaded"}),".\nThe actual benchmark code can remain the same and is therefore not tied to a specific\nthread runner. The measurement does not include the time for creating and joining the\nthreads."]}),"\n",(0,r.jsx)("a",{name:"cpu-timers"}),"\n",(0,r.jsx)(n.h2,{id:"cpu-timers",children:"CPU Timers"}),"\n",(0,r.jsx)(n.p,{children:"By default, the CPU timer only measures the time spent by the main thread.\nIf the benchmark itself uses threads internally, this measurement may not\nbe what you are looking for. Instead, there is a way to measure the total\nCPU usage of the process, by all the threads."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:"void callee(int i);\n\nstatic void MyMain(int size) {\n#pragma omp parallel for\n  for(int i = 0; i < size; i++)\n    callee(i);\n}\n\nstatic void BM_OpenMP(benchmark::State& state) {\n  for (auto _ : state)\n    MyMain(state.range(0));\n}\n\n// Measure the time spent by the main thread, use it to decide for how long to\n// run the benchmark loop. Depending on the internal implementation detail may\n// measure to anywhere from near-zero (the overhead spent before/after work\n// handoff to worker thread[s]) to the whole single-thread time.\nBENCHMARK(BM_OpenMP)->Range(8, 8<<10);\n\n// Measure the user-visible time, the wall clock (literally, the time that\n// has passed on the clock on the wall), use it to decide for how long to\n// run the benchmark loop. This will always be meaningful, and will match the\n// time spent by the main thread in single-threaded case, in general decreasing\n// with the number of internal threads doing the work.\nBENCHMARK(BM_OpenMP)->Range(8, 8<<10)->UseRealTime();\n\n// Measure the total CPU consumption, use it to decide for how long to\n// run the benchmark loop. This will always measure to no less than the\n// time spent by the main thread in single-threaded case.\nBENCHMARK(BM_OpenMP)->Range(8, 8<<10)->MeasureProcessCPUTime();\n\n// A mixture of the last two. Measure the total CPU consumption, but use the\n// wall clock to decide for how long to run the benchmark loop.\nBENCHMARK(BM_OpenMP)->Range(8, 8<<10)->MeasureProcessCPUTime()->UseRealTime();\n"})}),"\n",(0,r.jsx)(n.h3,{id:"controlling-timers",children:"Controlling Timers"}),"\n",(0,r.jsxs)(n.p,{children:["Normally, the entire duration of the work loop (",(0,r.jsx)(n.code,{children:"for (auto _ : state) {}"}),")\nis measured. But sometimes, it is necessary to do some work inside of\nthat loop, every iteration, but without counting that time to the benchmark time.\nThat is possible, although it is not recommended, since it has high overhead."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:"static void BM_SetInsert_With_Timer_Control(benchmark::State& state) {\n  std::set<int> data;\n  for (auto _ : state) {\n    state.PauseTiming(); // Stop timers. They will not count until they are resumed.\n    data = ConstructRandomSet(state.range(0)); // Do something that should not be measured\n    state.ResumeTiming(); // And resume timers. They are now counting again.\n    // The rest will be measured.\n    for (int j = 0; j < state.range(1); ++j)\n      data.insert(RandomNumber());\n  }\n}\nBENCHMARK(BM_SetInsert_With_Timer_Control)->Ranges({{1<<10, 8<<10}, {128, 512}});\n"})}),"\n",(0,r.jsx)("a",{name:"manual-timing"}),"\n",(0,r.jsx)(n.h2,{id:"manual-timing",children:"Manual Timing"}),"\n",(0,r.jsxs)(n.p,{children:["For benchmarking something for which neither CPU time nor real-time are\ncorrect or accurate enough, completely manual timing is supported using\nthe ",(0,r.jsx)(n.code,{children:"UseManualTime"})," function."]}),"\n",(0,r.jsxs)(n.p,{children:["When ",(0,r.jsx)(n.code,{children:"UseManualTime"})," is used, the benchmarked code must call\n",(0,r.jsx)(n.code,{children:"SetIterationTime"})," once per iteration of the benchmark loop to\nreport the manually measured time."]}),"\n",(0,r.jsxs)(n.p,{children:["An example use case for this is benchmarking GPU execution (e.g. OpenCL\nor CUDA kernels, OpenGL or Vulkan or Direct3D draw calls), which cannot\nbe accurately measured using CPU time or real-time. Instead, they can be\nmeasured accurately using a dedicated API, and these measurement results\ncan be reported back with ",(0,r.jsx)(n.code,{children:"SetIterationTime"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:"static void BM_ManualTiming(benchmark::State& state) {\n  int microseconds = state.range(0);\n  std::chrono::duration<double, std::micro> sleep_duration {\n    static_cast<double>(microseconds)\n  };\n\n  for (auto _ : state) {\n    auto start = std::chrono::high_resolution_clock::now();\n    // Simulate some useful workload with a sleep\n    std::this_thread::sleep_for(sleep_duration);\n    auto end = std::chrono::high_resolution_clock::now();\n\n    auto elapsed_seconds =\n      std::chrono::duration_cast<std::chrono::duration<double>>(\n        end - start);\n\n    state.SetIterationTime(elapsed_seconds.count());\n  }\n}\nBENCHMARK(BM_ManualTiming)->Range(1, 1<<17)->UseManualTime();\n"})}),"\n",(0,r.jsx)("a",{name:"setting-the-time-unit"}),"\n",(0,r.jsx)(n.h2,{id:"setting-the-time-unit",children:"Setting the Time Unit"}),"\n",(0,r.jsx)(n.p,{children:"If a benchmark runs a few milliseconds it may be hard to visually compare the\nmeasured times, since the output data is given in nanoseconds per default. In\norder to manually set the time unit, you can specify it manually:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:"BENCHMARK(BM_test)->Unit(benchmark::kMillisecond);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Additionally the default time unit can be set globally with the\n",(0,r.jsx)(n.code,{children:"--benchmark_time_unit={ns|us|ms|s}"})," command line argument. The argument only\naffects benchmarks where the time unit is not set explicitly."]}),"\n",(0,r.jsx)("a",{name:"preventing-optimization"}),"\n",(0,r.jsx)(n.h2,{id:"preventing-optimization",children:"Preventing Optimization"}),"\n",(0,r.jsxs)(n.p,{children:["To prevent a value or expression from being optimized away by the compiler\nthe ",(0,r.jsx)(n.code,{children:"benchmark::DoNotOptimize(...)"})," and ",(0,r.jsx)(n.code,{children:"benchmark::ClobberMemory()"}),"\nfunctions can be used."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:"static void BM_test(benchmark::State& state) {\n  for (auto _ : state) {\n      int x = 0;\n      for (int i=0; i < 64; ++i) {\n        benchmark::DoNotOptimize(x += i);\n      }\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"DoNotOptimize(<expr>)"})," forces the  ",(0,r.jsx)(n.em,{children:"result"})," of ",(0,r.jsx)(n.code,{children:"<expr>"})," to be stored in either\nmemory or a register. For GNU based compilers it acts as read/write barrier\nfor global memory. More specifically it forces the compiler to flush pending\nwrites to memory and reload any other values as necessary."]}),"\n",(0,r.jsxs)(n.p,{children:["Note that ",(0,r.jsx)(n.code,{children:"DoNotOptimize(<expr>)"})," does not prevent optimizations on ",(0,r.jsx)(n.code,{children:"<expr>"}),"\nin any way. ",(0,r.jsx)(n.code,{children:"<expr>"})," may even be removed entirely when the result is already\nknown. For example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:"  // Example 1: `<expr>` is removed entirely.\n  int foo(int x) { return x + 42; }\n  while (...) DoNotOptimize(foo(0)); // Optimized to DoNotOptimize(42);\n\n  // Example 2: Result of '<expr>' is only reused.\n  int bar(int) __attribute__((const));\n  while (...) DoNotOptimize(bar(0)); // Optimized to:\n  // int __result__ = bar(0);\n  // while (...) DoNotOptimize(__result__);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The second tool for preventing optimizations is ",(0,r.jsx)(n.code,{children:"ClobberMemory()"}),". In essence\n",(0,r.jsx)(n.code,{children:"ClobberMemory()"}),' forces the compiler to perform all pending writes to global\nmemory. Memory managed by block scope objects must be "escaped" using\n',(0,r.jsx)(n.code,{children:"DoNotOptimize(...)"})," before it can be clobbered. In the below example\n",(0,r.jsx)(n.code,{children:"ClobberMemory()"})," prevents the call to ",(0,r.jsx)(n.code,{children:"v.push_back(42)"})," from being optimized\naway."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:"static void BM_vector_push_back(benchmark::State& state) {\n  for (auto _ : state) {\n    std::vector<int> v;\n    v.reserve(1);\n    auto data = v.data();           // Allow v.data() to be clobbered. Pass as non-const\n    benchmark::DoNotOptimize(data); // lvalue to avoid undesired compiler optimizations\n    v.push_back(42);\n    benchmark::ClobberMemory(); // Force 42 to be written to memory.\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Note that ",(0,r.jsx)(n.code,{children:"ClobberMemory()"})," is only available for GNU or MSVC based compilers."]}),"\n",(0,r.jsx)("a",{name:"reporting-statistics"}),"\n",(0,r.jsx)(n.h2,{id:"statistics-reporting-the-mean-median-and-standard-deviation--coefficient-of-variation-of-repeated-benchmarks",children:"Statistics: Reporting the Mean, Median and Standard Deviation / Coefficient of variation of Repeated Benchmarks"}),"\n",(0,r.jsx)(n.p,{children:"By default each benchmark is run once and that single result is reported.\nHowever benchmarks are often noisy and a single result may not be representative\nof the overall behavior. For this reason it's possible to repeatedly rerun the\nbenchmark."}),"\n",(0,r.jsxs)(n.p,{children:["The number of runs of each benchmark is specified globally by the\n",(0,r.jsx)(n.code,{children:"--benchmark_repetitions"})," flag or on a per benchmark basis by calling\n",(0,r.jsx)(n.code,{children:"Repetitions"})," on the registered benchmark object. When a benchmark is run more\nthan once the mean, median, standard deviation and coefficient of variation\nof the runs will be reported."]}),"\n",(0,r.jsxs)(n.p,{children:["Additionally the ",(0,r.jsx)(n.code,{children:"--benchmark_report_aggregates_only={true|false}"}),",\n",(0,r.jsx)(n.code,{children:"--benchmark_display_aggregates_only={true|false}"})," flags or\n",(0,r.jsx)(n.code,{children:"ReportAggregatesOnly(bool)"}),", ",(0,r.jsx)(n.code,{children:"DisplayAggregatesOnly(bool)"})," functions can be\nused to change how repeated tests are reported. By default the result of each\nrepeated run is reported. When ",(0,r.jsx)(n.code,{children:"report aggregates only"})," option is ",(0,r.jsx)(n.code,{children:"true"}),",\nonly the aggregates (i.e. mean, median, standard deviation and coefficient\nof variation, maybe complexity measurements if they were requested) of the runs\nis reported, to both the reporters - standard output (console), and the file.\nHowever when only the ",(0,r.jsx)(n.code,{children:"display aggregates only"})," option is ",(0,r.jsx)(n.code,{children:"true"}),",\nonly the aggregates are displayed in the standard output, while the file\noutput still contains everything.\nCalling ",(0,r.jsx)(n.code,{children:"ReportAggregatesOnly(bool)"})," / ",(0,r.jsx)(n.code,{children:"DisplayAggregatesOnly(bool)"})," on a\nregistered benchmark object overrides the value of the appropriate flag for that\nbenchmark."]}),"\n",(0,r.jsx)("a",{name:"custom-statistics"}),"\n",(0,r.jsx)(n.h2,{id:"custom-statistics",children:"Custom Statistics"}),"\n",(0,r.jsx)(n.p,{children:"While having these aggregates is nice, this may not be enough for everyone.\nFor example you may want to know what the largest observation is, e.g. because\nyou have some real-time constraints. This is easy. The following code will\nspecify a custom statistic to be calculated, defined by a lambda function."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:'void BM_spin_empty(benchmark::State& state) {\n  for (auto _ : state) {\n    for (int x = 0; x < state.range(0); ++x) {\n      benchmark::DoNotOptimize(x);\n    }\n  }\n}\n\nBENCHMARK(BM_spin_empty)\n  ->Repetitions(3) // or add option --benchmark_repetitions=3\n  ->ComputeStatistics("max", [](const std::vector<double>& v) -> double {\n    return *(std::max_element(std::begin(v), std::end(v)));\n  })\n  ->Arg(512);\n'})}),"\n",(0,r.jsx)(n.p,{children:"While usually the statistics produce values in time units,\nyou can also produce percentages:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:'void BM_spin_empty(benchmark::State& state) {\n  for (auto _ : state) {\n    for (int x = 0; x < state.range(0); ++x) {\n      benchmark::DoNotOptimize(x);\n    }\n  }\n}\n\nBENCHMARK(BM_spin_empty)\n  ->Repetitions(3) // or add option --benchmark_repetitions=3\n  ->ComputeStatistics("ratio", [](const std::vector<double>& v) -> double {\n    return v.front() / v.back();\n  }, benchmark::StatisticUnit::kPercentage)\n  ->Arg(512);\n'})}),"\n",(0,r.jsx)("a",{name:"memory-usage"}),"\n",(0,r.jsx)(n.h2,{id:"memory-usage",children:"Memory Usage"}),"\n",(0,r.jsxs)(n.p,{children:["It's often useful to also track memory usage for benchmarks, alongside CPU\nperformance. For this reason, benchmark offers the ",(0,r.jsx)(n.code,{children:"RegisterMemoryManager"}),"\nmethod that allows a custom ",(0,r.jsx)(n.code,{children:"MemoryManager"})," to be injected."]}),"\n",(0,r.jsxs)(n.p,{children:["If set, the ",(0,r.jsx)(n.code,{children:"MemoryManager::Start"})," and ",(0,r.jsx)(n.code,{children:"MemoryManager::Stop"})," methods will be\ncalled at the start and end of benchmark runs to allow user code to fill out\na report on the number of allocations, bytes used, etc."]}),"\n",(0,r.jsx)(n.p,{children:"This data will then be reported alongside other performance data, currently\nonly when using JSON output."}),"\n",(0,r.jsx)("a",{name:"profiling"}),"\n",(0,r.jsx)(n.h2,{id:"profiling",children:"Profiling"}),"\n",(0,r.jsxs)(n.p,{children:["It's often useful to also profile benchmarks in particular ways, in addition to\nCPU performance. For this reason, benchmark offers the ",(0,r.jsx)(n.code,{children:"RegisterProfilerManager"}),"\nmethod that allows a custom ",(0,r.jsx)(n.code,{children:"ProfilerManager"})," to be injected."]}),"\n",(0,r.jsxs)(n.p,{children:["If set, the ",(0,r.jsx)(n.code,{children:"ProfilerManager::AfterSetupStart"})," and\n",(0,r.jsx)(n.code,{children:"ProfilerManager::BeforeTeardownStop"})," methods will be called at the start and\nend of a separate benchmark run to allow user code to collect and report\nuser-provided profile metrics."]}),"\n",(0,r.jsx)(n.p,{children:"Output collected from this profiling run must be reported separately."}),"\n",(0,r.jsx)("a",{name:"using-register-benchmark"}),"\n",(0,r.jsx)(n.h2,{id:"using-registerbenchmarkname-fn-args",children:"Using RegisterBenchmark(name, fn, args...)"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"RegisterBenchmark(name, func, args...)"})," function provides an alternative\nway to create and register benchmarks.\n",(0,r.jsx)(n.code,{children:"RegisterBenchmark(name, func, args...)"})," creates, registers, and returns a\npointer to a new benchmark with the specified ",(0,r.jsx)(n.code,{children:"name"})," that invokes\n",(0,r.jsx)(n.code,{children:"func(st, args...)"})," where ",(0,r.jsx)(n.code,{children:"st"})," is a ",(0,r.jsx)(n.code,{children:"benchmark::State"})," object."]}),"\n",(0,r.jsxs)(n.p,{children:["Unlike the ",(0,r.jsx)(n.code,{children:"BENCHMARK"})," registration macros, which can only be used at the global\nscope, the ",(0,r.jsx)(n.code,{children:"RegisterBenchmark"})," can be called anywhere. This allows for\nbenchmark tests to be registered programmatically."]}),"\n",(0,r.jsxs)(n.p,{children:["Additionally ",(0,r.jsx)(n.code,{children:"RegisterBenchmark"})," allows any callable object to be registered\nas a benchmark. Including capturing lambdas and function objects."]}),"\n",(0,r.jsx)(n.p,{children:"For Example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:"auto BM_test = [](benchmark::State& st, auto Inputs) { /* ... */ };\n\nint main(int argc, char** argv) {\n  benchmark::MaybeReenterWithoutASLR(argc, argv);\n  for (auto& test_input : { /* ... */ })\n      benchmark::RegisterBenchmark(test_input.name(), BM_test, test_input);\n  benchmark::Initialize(&argc, argv);\n  benchmark::RunSpecifiedBenchmarks();\n  benchmark::Shutdown();\n}\n"})}),"\n",(0,r.jsx)("a",{name:"exiting-with-an-error"}),"\n",(0,r.jsx)(n.h2,{id:"exiting-with-an-error",children:"Exiting with an Error"}),"\n",(0,r.jsxs)(n.p,{children:["When errors caused by external influences, such as file I/O and network\ncommunication, occur within a benchmark the\n",(0,r.jsx)(n.code,{children:"State::SkipWithError(const std::string& msg)"})," function can be used to skip that run\nof benchmark and report the error. Note that only future iterations of the\n",(0,r.jsx)(n.code,{children:"KeepRunning()"})," are skipped. For the ranged-for version of the benchmark loop\nUsers must explicitly exit the loop, otherwise all iterations will be performed.\nUsers may explicitly return to exit the benchmark immediately."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"SkipWithError(...)"})," function may be used at any point within the benchmark,\nincluding before and after the benchmark loop. Moreover, if ",(0,r.jsx)(n.code,{children:"SkipWithError(...)"}),"\nhas been used, it is not required to reach the benchmark loop and one may return\nfrom the benchmark function early."]}),"\n",(0,r.jsx)(n.p,{children:"For example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:'static void BM_test(benchmark::State& state) {\n  auto resource = GetResource();\n  if (!resource.good()) {\n    state.SkipWithError("Resource is not good!");\n    // KeepRunning() loop will not be entered.\n  }\n  while (state.KeepRunning()) {\n    auto data = resource.read_data();\n    if (!resource.good()) {\n      state.SkipWithError("Failed to read data!");\n      break; // Needed to skip the rest of the iteration.\n    }\n    do_stuff(data);\n  }\n}\n\nstatic void BM_test_ranged_fo(benchmark::State & state) {\n  auto resource = GetResource();\n  if (!resource.good()) {\n    state.SkipWithError("Resource is not good!");\n    return; // Early return is allowed when SkipWithError() has been used.\n  }\n  for (auto _ : state) {\n    auto data = resource.read_data();\n    if (!resource.good()) {\n      state.SkipWithError("Failed to read data!");\n      break; // REQUIRED to prevent all further iterations.\n    }\n    do_stuff(data);\n  }\n}\n'})}),"\n",(0,r.jsx)("a",{name:"a-faster-keep-running-loop"}),"\n",(0,r.jsx)(n.h2,{id:"a-faster-keeprunning-loop",children:"A Faster KeepRunning Loop"}),"\n",(0,r.jsxs)(n.p,{children:["A ranged-based for loop should be used in preference to\nthe ",(0,r.jsx)(n.code,{children:"KeepRunning"})," loop for running the benchmarks. For example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c++",children:"static void BM_Fast(benchmark::State &state) {\n  for (auto _ : state) {\n    FastOperation();\n  }\n}\nBENCHMARK(BM_Fast);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The reason the ranged-for loop is faster than using ",(0,r.jsx)(n.code,{children:"KeepRunning"}),", is\nbecause ",(0,r.jsx)(n.code,{children:"KeepRunning"})," requires a memory load and store of the iteration count\never iteration, whereas the ranged-for variant is able to keep the iteration count\nin a register."]}),"\n",(0,r.jsx)(n.p,{children:"For example, an empty inner loop of using the ranged-based for method looks like:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-asm",children:"# Loop Init\n  mov rbx, qword ptr [r14 + 104]\n  call benchmark::State::StartKeepRunning()\n  test rbx, rbx\n  je .LoopEnd\n.LoopHeader: # =>This Inner Loop Header: Depth=1\n  add rbx, -1\n  jne .LoopHeader\n.LoopEnd:\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Compared to an empty ",(0,r.jsx)(n.code,{children:"KeepRunning"})," loop, which looks like:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-asm",children:".LoopHeader: # in Loop: Header=BB0_3 Depth=1\n  cmp byte ptr [rbx], 1\n  jne .LoopInit\n.LoopBody: # =>This Inner Loop Header: Depth=1\n  mov rax, qword ptr [rbx + 8]\n  lea rcx, [rax + 1]\n  mov qword ptr [rbx + 8], rcx\n  cmp rax, qword ptr [rbx + 104]\n  jb .LoopHeader\n  jmp .LoopEnd\n.LoopInit:\n  mov rdi, rbx\n  call benchmark::State::StartKeepRunning()\n  jmp .LoopBody\n.LoopEnd:\n"})}),"\n",(0,r.jsx)(n.p,{children:"Unless C++03 compatibility is required, the ranged-for variant of writing\nthe benchmark loop should be preferred."}),"\n",(0,r.jsx)("a",{name:"disabling-cpu-frequency-scaling"}),"\n",(0,r.jsx)(n.h2,{id:"disabling-cpu-frequency-scaling",children:"Disabling CPU Frequency Scaling"}),"\n",(0,r.jsx)(n.p,{children:"If you see this error:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"***WARNING*** CPU scaling is enabled, the benchmark real time measurements may\nbe noisy and will incur extra overhead.\n"})}),"\n",(0,r.jsx)(n.p,{children:"you might want to disable the CPU frequency scaling while running the\nbenchmark, as well as consider other ways to stabilize the performance of\nyour system while benchmarking."}),"\n",(0,r.jsxs)(n.p,{children:["See ",(0,r.jsx)(n.a,{href:"/cppdev/zh-cn/docs/testing/benchmark/reducing_variance",children:"Reducing Variance"})," for more information."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);