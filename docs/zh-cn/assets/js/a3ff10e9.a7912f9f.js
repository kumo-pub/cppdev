"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[7226],{2996:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"retrieve/trie/index","title":"index","description":"Trie Implementations Overview","source":"@site/i18n/zh-cn/docusaurus-plugin-content-docs/current/retrieve/trie/index.mdx","sourceDirName":"retrieve/trie","slug":"/retrieve/trie/","permalink":"/cppdev/zh-cn/docs/retrieve/trie/","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"SCANN (Scalable Nearest Neighbor) Overview","permalink":"/cppdev/zh-cn/docs/retrieve/vector/scann"},"next":{"title":"darts","permalink":"/cppdev/zh-cn/docs/retrieve/trie/darts"}}');var s=r(4848),t=r(8453);const l={},d=void 0,c={},a=[{value:"Trie Implementations Overview",id:"trie-implementations-overview",level:2},{value:"1. MARISA Trie",id:"1-marisa-trie",level:3},{value:"2. DARTS Trie",id:"2-darts-trie",level:3},{value:"3. TSL Trie (Ternary Search Tree)",id:"3-tsl-trie-ternary-search-tree",level:3},{value:"4. Cedar Trie",id:"4-cedar-trie",level:3},{value:"Comparison Table",id:"comparison-table",level:3},{value:"Scene Selection Guidelines",id:"scene-selection-guidelines",level:3},{value:"Conclusion",id:"conclusion",level:3}];function o(e){const n={h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"trie-implementations-overview",children:"Trie Implementations Overview"}),"\n",(0,s.jsxs)(n.p,{children:["Tries are specialized data structures primarily used for ",(0,s.jsx)(n.strong,{children:"SUG (suggestion / autocomplete) systems and fast prefix matching"}),". They enable extremely low-latency lookup of prefixes in large English dictionaries or query sets. Depending on requirements such as ",(0,s.jsx)(n.strong,{children:"dynamic updates, memory efficiency, and query performance"}),", different trie implementations are suitable."]}),"\n",(0,s.jsxs)(n.p,{children:["This section summarizes four widely used trie implementations in industrial English dictionary workloads: ",(0,s.jsx)(n.strong,{children:"MARISA"}),", ",(0,s.jsx)(n.strong,{children:"DARTS"}),", ",(0,s.jsx)(n.strong,{children:"TSL"}),", and ",(0,s.jsx)(n.strong,{children:"Cedar"}),"."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"1-marisa-trie",children:"1. MARISA Trie"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type:"})," Static, memory-efficient trie"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Primary Use Case:"})," High-performance ",(0,s.jsx)(n.strong,{children:"prefix matching / autocomplete"})," in read-only English dictionaries"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Strengths:"})," Compact memory footprint, fast exact and prefix search, memory-mapped support"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Limitations:"})," Read-only after build; no dynamic insert/delete"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"2-darts-trie",children:"2. DARTS Trie"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type:"})," Static double-array trie"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Primary Use Case:"})," ",(0,s.jsx)(n.strong,{children:"Autocomplete / SUG systems"})," with very large static key sets"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Strengths:"})," Fast exact match and prefix search, compact double-array representation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Limitations:"})," Read-only; no dynamic payload attachment"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"3-tsl-trie-ternary-search-tree",children:"3. TSL Trie (Ternary Search Tree)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type:"})," Dynamic trie (ternary search tree)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Primary Use Case:"})," ",(0,s.jsx)(n.strong,{children:"Dynamic autocomplete or evolving dictionary scenarios"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Strengths:"})," Supports online insertions and deletions, prefix search, memory-efficient for sparse sets"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Limitations:"})," Slightly slower than double-array tries for large static datasets"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"4-cedar-trie",children:"4. Cedar Trie"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type:"})," Fully dynamic updatable double-array trie"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Primary Use Case:"})," ",(0,s.jsx)(n.strong,{children:"High-performance SUG systems with online updates"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Strengths:"})," Online insert/delete supported, exact match and prefix search, serializable and mmap-able"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Limitations:"})," Slightly larger memory footprint than static double-array; payload support limited"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"comparison-table",children:"Comparison Table"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Trie"}),(0,s.jsx)(n.th,{children:"Dynamic Insert/Delete"}),(0,s.jsx)(n.th,{children:"Static Read-Only"}),(0,s.jsx)(n.th,{children:"Prefix Search"}),(0,s.jsx)(n.th,{children:"Exact Match"}),(0,s.jsx)(n.th,{children:"Memory-Mapped"}),(0,s.jsx)(n.th,{children:"Notes"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"MARISA"}),(0,s.jsx)(n.td,{children:"\u274c"}),(0,s.jsx)(n.td,{children:"\u2714\ufe0f"}),(0,s.jsx)(n.td,{children:"\u2714\ufe0f"}),(0,s.jsx)(n.td,{children:"\u2714\ufe0f"}),(0,s.jsx)(n.td,{children:"\u2714\ufe0f"}),(0,s.jsx)(n.td,{children:"Best for static SUG / autocomplete"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"DARTS"}),(0,s.jsx)(n.td,{children:"\u274c"}),(0,s.jsx)(n.td,{children:"\u2714\ufe0f"}),(0,s.jsx)(n.td,{children:"\u2714\ufe0f"}),(0,s.jsx)(n.td,{children:"\u2714\ufe0f"}),(0,s.jsx)(n.td,{children:"\u2714\ufe0f"}),(0,s.jsx)(n.td,{children:"High-performance static SUG"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"TSL"}),(0,s.jsx)(n.td,{children:"\u2714\ufe0f"}),(0,s.jsx)(n.td,{children:"\u274c"}),(0,s.jsx)(n.td,{children:"\u2714\ufe0f"}),(0,s.jsx)(n.td,{children:"\u2714\ufe0f"}),(0,s.jsx)(n.td,{children:"\u274c"}),(0,s.jsx)(n.td,{children:"Dynamic SUG / evolving dictionary"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Cedar"}),(0,s.jsx)(n.td,{children:"\u2714\ufe0f"}),(0,s.jsx)(n.td,{children:"Partial"}),(0,s.jsx)(n.td,{children:"\u2714\ufe0f"}),(0,s.jsx)(n.td,{children:"\u2714\ufe0f"}),(0,s.jsx)(n.td,{children:"\u2714\ufe0f"}),(0,s.jsx)(n.td,{children:"Fully dynamic SUG / autocomplete"})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"scene-selection-guidelines",children:"Scene Selection Guidelines"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Static, large English SUG / autocomplete dictionaries:"})}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Choose ",(0,s.jsx)(n.strong,{children:"MARISA"})," or ",(0,s.jsx)(n.strong,{children:"DARTS"})]}),"\n",(0,s.jsx)(n.li,{children:"Build once, deploy many times; memory-mapped for fast cold start"}),"\n"]}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Dynamic autocomplete / evolving query dictionaries:"})}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Choose ",(0,s.jsx)(n.strong,{children:"TSL"})," or ",(0,s.jsx)(n.strong,{children:"Cedar"})]}),"\n",(0,s.jsxs)(n.li,{children:["TSL if simpler dynamic operations suffice; Cedar if ",(0,s.jsx)(n.strong,{children:"high-performance online updates"})," are required"]}),"\n"]}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Prefix-heavy SUG workloads:"})}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"All four support prefix search"}),"\n",(0,s.jsx)(n.li,{children:"Memory efficiency: MARISA > DARTS > Cedar \u2248 TSL"}),"\n",(0,s.jsx)(n.li,{children:"Dynamic prefix queries: Cedar or TSL"}),"\n"]}),"\n",(0,s.jsxs)(n.ol,{start:"4",children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Persistent SUG dictionary for production:"})}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"MARISA"})," and ",(0,s.jsx)(n.strong,{children:"Cedar"})," offer serialization / mmap"]}),"\n",(0,s.jsx)(n.li,{children:"DARTS can be serialized but updates require rebuild"}),"\n",(0,s.jsx)(n.li,{children:"TSL usually in-memory for dynamic operations"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Primary scenario:"})," Tries excel in ",(0,s.jsx)(n.strong,{children:"SUG / autocomplete and fast prefix matching"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Static vs Dynamic:"})," MARISA & DARTS \u2192 static, TSL & Cedar \u2192 dynamic"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Scene fit:"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"MARISA / DARTS \u2192 read-only autocomplete dictionaries"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"TSL \u2192 dynamic autocomplete / evolving dictionary"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Cedar \u2192 dynamic, high-performance autocomplete with serialization"}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>d});var i=r(6540);const s={},t=i.createContext(s);function l(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);