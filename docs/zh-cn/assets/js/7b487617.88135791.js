"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[4295],{1591:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"foundamentals/testing/doct/reporters","title":"Test Reporters","description":"Reporters","source":"@site/i18n/zh-cn/docusaurus-plugin-content-docs/current/foundamentals/testing/doct/reporters.mdx","sourceDirName":"foundamentals/testing/doct","slug":"/foundamentals/testing/doct/reporters","permalink":"/cppdev/zh-cn/docs/foundamentals/testing/doct/reporters","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Stringification","permalink":"/cppdev/zh-cn/docs/foundamentals/testing/doct/stringification"},"next":{"title":"Extensions","permalink":"/cppdev/zh-cn/docs/foundamentals/testing/doct/extensions"}}');var r=n(4848),o=n(8453);const i={},a="Test Reporters",c={},d=[{value:"Reporters",id:"reporters",level:2}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"test-reporters",children:"Test Reporters"})}),"\n",(0,r.jsx)(t.h2,{id:"reporters",children:"Reporters"}),"\n",(0,r.jsx)(t.p,{children:'Doctest features a modular reporter/listener system that allows users to write and register their own reporters. The reporter interface can also be used to "listen" to events.'}),"\n",(0,r.jsxs)(t.p,{children:["You can use ",(0,r.jsx)(t.code,{children:"--list-reporters"})," to list all registered reporters/listeners. Several reporters are implemented in the framework:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"console"})," - Streaming - Writes normal text lines with color if a capable terminal is detected"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"xml"})," - Streaming - Writes in an xml format customized for doctest"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"junit"})," - Buffered - Writes in JUnit-compatible xml - For more information, check ",(0,r.jsx)(t.a,{href:"https://github.com/doctest/doctest/issues/318",children:"here"})," and ",(0,r.jsx)(t.a,{href:"https://github.com/doctest/doctest/issues/376",children:"here"}),"."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Streaming means results are delivered incrementally, rather than at the end of the test run."}),"\n",(0,r.jsxs)(t.p,{children:["Output is written to ",(0,r.jsx)(t.code,{children:"stdout"})," by default, but can be redirected using the ",(0,r.jsx)(t.code,{children:"--out=<filename>"})," ",(0,r.jsx)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/doct/commandline",children:(0,r.jsx)(t.strong,{children:"command line option"})}),"."]}),"\n",(0,r.jsx)(t.p,{children:"Example of how to define your own reporter:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-c++",children:'#include <doctest/doctest.h>\n\n#include <mutex>\n\nusing namespace doctest;\n\nstruct MyXmlReporter : public IReporter\n{\n    // caching pointers/references to objects of these types - safe to do\n    std::ostream&         stdout_stream;\n    const ContextOptions& opt;\n    const TestCaseData*   tc;\n    std::mutex            mutex;\n\n    // constructor has to accept the ContextOptions by ref as a single argument\n    MyXmlReporter(const ContextOptions& in)\n            : stdout_stream(*in.cout)\n            , opt(in) {}\n\n    void report_query(const QueryData& /*in*/) override {}\n\n    void test_run_start() override {}\n\n    void test_run_end(const TestRunStats& /*in*/) override {}\n\n    void test_case_start(const TestCaseData& in) override { tc = &in; }\n\n    // called when a test case is reentered because of unfinished subcases\n    void test_case_reenter(const TestCaseData& /*in*/) override {}\n\n    void test_case_end(const CurrentTestCaseStats& /*in*/) override {}\n\n    void test_case_exception(const TestCaseException& /*in*/) override {}\n\n    void subcase_start(const SubcaseSignature& /*in*/) override {\n        std::lock_guard<std::mutex> lock(mutex);\n    }\n\n    void subcase_end() override {\n        std::lock_guard<std::mutex> lock(mutex);\n    }\n\n    void log_assert(const AssertData& in) override {\n        // don\'t include successful asserts by default - this is done here\n        // instead of in the framework itself because doctest doesn\'t know\n        // if/when a reporter/listener cares about successful results\n        if(!in.m_failed && !opt.success)\n            return;\n\n        // make sure there are no races - this is done here instead of in the\n        // framework itself because doctest doesn\'t know if reporters/listeners\n        // care about successful asserts and thus doesn\'t lock a mutex unnecessarily\n        std::lock_guard<std::mutex> lock(mutex);\n\n        // ...\n    }\n\n    void log_message(const MessageData& /*in*/) override {\n        // messages too can be used in a multi-threaded context - like asserts\n        std::lock_guard<std::mutex> lock(mutex);\n\n        // ...\n    }\n\n    void test_case_skipped(const TestCaseData& /*in*/) override {}\n};\n\n// "1" is the priority - used for ordering when multiple reporters are used\nREGISTER_REPORTER("my_xml", 1, MyXmlReporter);\n\n// registering the same class as a reporter and as a listener is nonsense but it\'s possible\nREGISTER_LISTENER("my_listener", 1, MyXmlReporter);\n'})}),"\n",(0,r.jsxs)(t.p,{children:["Custom ",(0,r.jsx)(t.code,{children:"IReporter"})," implementations must be registered with one of the following:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"REGISTER_REPORTER"}),", when the new reporter is an option that users can select at runtime."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"REGISTER_LISTENER"}),", when the reporter is actually a listener and must always execute, regardless of which reporter is selected at runtime."]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["Multiple reporters can be used simultaneously - simply specify them via the ",(0,r.jsx)(t.code,{children:"--reporters=..."})," ",(0,r.jsx)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/doct/commandline",children:(0,r.jsx)(t.strong,{children:"command line filter option"})}),", separated by commas like this: ",(0,r.jsx)(t.code,{children:"--reporters=myReporter,xml"}),". Their execution order will be based on their priority - in the case of the example reporter above, that is the number ",(0,r.jsx)(t.code,{children:"1"})," (lower values mean earlier execution - the default console/xml reporters in the framework have a priority of 0, and negative values are also accepted)."]}),"\n",(0,r.jsxs)(t.p,{children:["All registered listeners (",(0,r.jsx)(t.code,{children:"REGISTER_LISTENER"}),") will execute before any reporters - they do not need to be specified and cannot be filtered via the command line."]}),"\n",(0,r.jsxs)(t.p,{children:["When implementing a reporter, it is recommended that users follow the comments in the example above and review the small number of reporters implemented in the framework itself. Also check out the ",(0,r.jsx)(t.a,{href:"https://github.com/doctest/doctest/blob/master/examples/all_features/reporters_and_listeners.cpp",children:(0,r.jsx)(t.strong,{children:"example"})}),"."]})]})}function u(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>a});var s=n(6540);const r={},o=s.createContext(r);function i(e){const t=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);