"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[3750],{8453:(e,i,r)=>{r.d(i,{R:()=>d,x:()=>c});var t=r(6540);const s={},n=t.createContext(s);function d(e){const i=t.useContext(n);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function c(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),t.createElement(n.Provider,{value:i},e.children)}},9866:(e,i,r)=>{r.r(i),r.d(i,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>d,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"retrieve/vector/sptag","title":"SPTAG (Space Partition Tree And Graph) Overview","description":"- Repository//github.com/microsoft/SPTAG","source":"@site/i18n/zh-cn/docusaurus-plugin-content-docs/current/retrieve/vector/sptag.mdx","sourceDirName":"retrieve/vector","slug":"/retrieve/vector/sptag","permalink":"/cppdev/zh-cn/docs/retrieve/vector/sptag","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"DiskANN (Disk-based Approximate Nearest Neighbor) Overview","permalink":"/cppdev/zh-cn/docs/retrieve/vector/diskann"},"next":{"title":"SCANN (Scalable Nearest Neighbor) Overview","permalink":"/cppdev/zh-cn/docs/retrieve/vector/scann"}}');var s=r(4848),n=r(8453);const d={},c="SPTAG (Space Partition Tree And Graph) Overview",l={},a=[{value:"Purpose &amp; Use Cases",id:"purpose--use-cases",level:2},{value:"Algorithms Supported",id:"algorithms-supported",level:2},{value:"Core Technical Specifications",id:"core-technical-specifications",level:2},{value:"1. Supported Metric Spaces",id:"1-supported-metric-spaces",level:3},{value:"2. Supported Data Types",id:"2-supported-data-types",level:3},{value:"3. Dynamic Data Operations (Insert/Delete/Modify)",id:"3-dynamic-data-operations-insertdeletemodify",level:3},{value:"Characteristics",id:"characteristics",level:2},{value:"Notes",id:"notes",level:2}];function o(e){const i={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"sptag-space-partition-tree-and-graph-overview",children:"SPTAG (Space Partition Tree And Graph) Overview"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Repository:"})," ",(0,s.jsx)(i.a,{href:"https://github.com/microsoft/SPTAG",children:"https://github.com/microsoft/SPTAG"})]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Language:"})," C++ (Python/RESTful API bindings available)"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"purpose--use-cases",children:"Purpose & Use Cases"}),"\n",(0,s.jsxs)(i.p,{children:["SPTAG is an open-source vector similarity search library developed by Microsoft, focused on ",(0,s.jsx)(i.strong,{children:"balanced performance between recall rate and query speed"})," for high-dimensional vector datasets (10s to 1000s of dimensions). It integrates multiple index structures to adapt to different data scales and query requirements, and is oriented to offline batch indexing + semi-real-time query scenarios (limited dynamic update capabilities). It is suitable for:"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Medium-to-large scale (10M\u20131B) high-dimensional vector approximate nearest neighbor (ANN) search."}),"\n",(0,s.jsx)(i.li,{children:"Scenarios requiring adjustable recall-speed tradeoffs (e.g., semantic search with flexible precision requirements)."}),"\n",(0,s.jsx)(i.li,{children:"Enterprise-level AI applications (text/image embedding retrieval, recommendation system feature matching)."}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"Typical applications include:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"NLP (semantic search, text embedding similarity matching)."}),"\n",(0,s.jsx)(i.li,{children:"Computer vision (image feature retrieval, small-scale face recognition)."}),"\n",(0,s.jsx)(i.li,{children:"Recommendation systems (user/item embedding matching for cold start scenarios)."}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"algorithms-supported",children:"Algorithms Supported"}),"\n",(0,s.jsx)(i.p,{children:"SPTAG provides a variety of index algorithms with different architectural designs, covering tree-based, graph-based and hybrid types:"}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Algorithm"}),(0,s.jsx)(i.th,{children:"Key Characteristics"}),(0,s.jsx)(i.th,{children:"Use Case"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"KDTree"})}),(0,s.jsxs)(i.td,{children:["Space-partitioning tree index \u2013 fast build speed, suitable for low-dimensional vectors (",(0,s.jsx)(i.code,{children:"<50"})," dims)."]}),(0,s.jsx)(i.td,{children:"Low-dimensional vector search (e.g., simple feature vectors)."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsxs)(i.td,{children:[(0,s.jsx)(i.code,{children:"BKT"})," (Balanced K-D Tree)"]}),(0,s.jsx)(i.td,{children:"Optimized KDTree variant \u2013 better balance of build/query speed for medium dimensions (50\u2013200 dims)."}),(0,s.jsx)(i.td,{children:"Medium-dimensional static vector datasets."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"Annoy"})}),(0,s.jsx)(i.td,{children:"Tree-based index (inspired by Spotify Annoy) \u2013 high query speed, moderate memory usage."}),(0,s.jsx)(i.td,{children:"Real-time query scenarios with medium recall requirements."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsxs)(i.td,{children:[(0,s.jsx)(i.code,{children:"HNSW"})," (Hierarchical Navigable Small Worlds)"]}),(0,s.jsx)(i.td,{children:"Graph-based index \u2013 high recall rate, optimal for high-dimensional vectors (>200 dims)."}),(0,s.jsx)(i.td,{children:"High-dimensional vector search (e.g., BERT embeddings, image deep features)."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"BruteForce"})}),(0,s.jsx)(i.td,{children:"Exact nearest neighbor search \u2013 no approximation, baseline for recall comparison."}),(0,s.jsxs)(i.td,{children:["Small datasets (",(0,s.jsx)(i.code,{children:"<10M"})," vectors) with strict recall requirements."]})]})]})]}),"\n",(0,s.jsx)(i.h2,{id:"core-technical-specifications",children:"Core Technical Specifications"}),"\n",(0,s.jsx)(i.h3,{id:"1-supported-metric-spaces",children:"1. Supported Metric Spaces"}),"\n",(0,s.jsx)(i.p,{children:"SPTAG supports mainstream metric spaces for numerical vectors, with no native non-metric space support:"}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Metric Type"}),(0,s.jsx)(i.th,{children:"Full Name"}),(0,s.jsx)(i.th,{children:"Supported Indexes"}),(0,s.jsx)(i.th,{children:"Use Case"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"L2"}),(0,s.jsx)(i.td,{children:"Euclidean Distance"}),(0,s.jsx)(i.td,{children:"All indexes"}),(0,s.jsx)(i.td,{children:"General numerical vectors (image/video embeddings, low-dimensional features)."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Cosine"}),(0,s.jsx)(i.td,{children:"Cosine Similarity/Distance"}),(0,s.jsx)(i.td,{children:"All indexes"}),(0,s.jsx)(i.td,{children:"Text embeddings (direction-based similarity, e.g., BERT/LLM outputs)."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Inner Product (IP)"}),(0,s.jsx)(i.td,{children:"Dot Product"}),(0,s.jsx)(i.td,{children:"All indexes (via normalization)"}),(0,s.jsx)(i.td,{children:"Normalized vector similarity (equivalent to cosine)."})]})]})]}),"\n",(0,s.jsxs)(i.blockquote,{children:["\n",(0,s.jsx)(i.p,{children:"Note: Non-metric spaces (Jaccard/Hamming/L1/L\u221e) are not supported; custom preprocessing for these spaces is unmaintained and not recommended for production."}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"2-supported-data-types",children:"2. Supported Data Types"}),"\n",(0,s.jsx)(i.p,{children:"SPTAG is optimized for 32-bit floating-point vectors, with limited support for other numerical types:"}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Data Type"}),(0,s.jsx)(i.th,{children:"Precision"}),(0,s.jsx)(i.th,{children:"C++ Type"}),(0,s.jsx)(i.th,{children:"Python Binding Mapping"}),(0,s.jsx)(i.th,{children:"Support Status"}),(0,s.jsx)(i.th,{children:"Use Case"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Float32"}),(0,s.jsx)(i.td,{children:"32-bit"}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"float"})}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"numpy.float32"})}),(0,s.jsx)(i.td,{children:"Fully supported (optimal performance)"}),(0,s.jsx)(i.td,{children:"Default \u2013 core optimized type for all indexes."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Float64 (Double)"}),(0,s.jsx)(i.td,{children:"64-bit"}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"double"})}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"numpy.float64"})}),(0,s.jsx)(i.td,{children:"Partial (2\u20133x slower)"}),(0,s.jsx)(i.td,{children:"High-precision scientific computing scenarios only."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Int32"}),(0,s.jsx)(i.td,{children:"32-bit"}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"int32_t"})}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"numpy.int32"})}),(0,s.jsx)(i.td,{children:"Partial (only L2 distance)"}),(0,s.jsx)(i.td,{children:"Discrete feature vectors (e.g., count-based features)."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Float16 (FP16)/Int8/Binary"}),(0,s.jsx)(i.td,{children:"-"}),(0,s.jsx)(i.td,{children:"-"}),(0,s.jsx)(i.td,{children:"-"}),(0,s.jsx)(i.td,{children:"Not supported"}),(0,s.jsx)(i.td,{children:"No native handling; manual conversion to Float32 has no performance/memory benefits."})]})]})]}),"\n",(0,s.jsx)(i.h3,{id:"3-dynamic-data-operations-insertdeletemodify",children:"3. Dynamic Data Operations (Insert/Delete/Modify)"}),"\n",(0,s.jsx)(i.p,{children:"SPTAG\u2019s dynamic update capabilities are limited and non-real-time optimized:"}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Operation"}),(0,s.jsx)(i.th,{children:"Support Level"}),(0,s.jsx)(i.th,{children:"Constraints"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Incremental Insertion"}),(0,s.jsx)(i.td,{children:"Partial support (HNSW/Annoy only)"}),(0,s.jsxs)(i.td,{children:["- Batch insertion recommended (single-vector insertion latency: ~1ms/vector);",(0,s.jsx)("br",{}),"- Max sustainable QPS: ~500;",(0,s.jsx)("br",{}),"- Index build time increases significantly after frequent inserts."]})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Real-Time Deletion"}),(0,s.jsx)(i.td,{children:"Not supported"}),(0,s.jsx)(i.td,{children:'No native deletion API; "soft delete" (filter results by ID post-query) leads to index bloat and query performance degradation.'})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Vector Modification"}),(0,s.jsx)(i.td,{children:"Not supported"}),(0,s.jsx)(i.td,{children:"Must re-insert updated vectors (no in-place modification), inheriting insertion latency constraints."})]})]})]}),"\n",(0,s.jsx)(i.h2,{id:"characteristics",children:"Characteristics"}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Feature"}),(0,s.jsx)(i.th,{children:"Description"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Incremental Updates"}),(0,s.jsx)(i.td,{children:"Partial batch insertion (HNSW/Annoy); no deletion/modification; non-real-time optimized."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Query Speed"}),(0,s.jsx)(i.td,{children:"HNSW > Annoy > BKT/KDTree; 5\u201320ms/query (100M 768-dim vectors), 0.5\u20135ms/query (10M vectors)."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Index Type"}),(0,s.jsx)(i.td,{children:"Hybrid (tree-based: KDTree/BKT/Annoy; graph-based: HNSW; brute-force)."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Scalability"}),(0,s.jsx)(i.td,{children:"Handles up to 1B vectors (single-node); no distributed multi-node support."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Language Bindings"}),(0,s.jsx)(i.td,{children:"C++ (full feature set), Python (core features), RESTful API (deployment-oriented)."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Non-Metric Support"}),(0,s.jsx)(i.td,{children:"No native support (requires custom preprocessing)."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"GPU Support"}),(0,s.jsx)(i.td,{children:"Not supported"})]})]})]}),"\n",(0,s.jsx)(i.h2,{id:"notes",children:"Notes"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["SPTAG\u2019s core advantage is ",(0,s.jsx)(i.strong,{children:"rich index types"})," \u2013 select KDTree for low dimensions, HNSW for high dimensions to balance recall and speed."]}),"\n",(0,s.jsxs)(i.li,{children:["For high-speed query scenarios (",(0,s.jsx)(i.code,{children:"<100M"})," vectors) requiring sub-millisecond latency, FAISS HNSW/GPU is more recommended."]}),"\n",(0,s.jsx)(i.li,{children:"Dynamic updates are only suitable for low-frequency batch insertion (hourly/daily); avoid using it for real-time single-vector write scenarios (e.g., real-time user behavior embedding)."}),"\n",(0,s.jsx)(i.li,{children:"Limitations: No distributed support; Python bindings lack partial HNSW tuning parameters; no non-metric space support; community maintenance is slow (last major update in 2023)."}),"\n",(0,s.jsx)(i.li,{children:"Best Practices: Use HNSW index for high-dimensional static vectors (10M\u20131B); pair with Redis for hot data caching to improve query speed; use batch insertion for incremental updates."}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,n.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}}}]);