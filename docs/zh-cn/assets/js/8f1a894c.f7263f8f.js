"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[1553],{509:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"foundamentals/strings/fmt","title":"Formatted Output","description":"kumo integrates two custom formatting libraries:str_format().","source":"@site/i18n/zh-cn/docusaurus-plugin-content-docs/current/foundamentals/strings/fmt.mdx","sourceDirName":"foundamentals/strings","slug":"/foundamentals/strings/fmt","permalink":"/cppdev/zh-cn/docs/foundamentals/strings/fmt","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"stings","permalink":"/cppdev/zh-cn/docs/foundamentals/strings/"},"next":{"title":"String Splitting","permalink":"/cppdev/zh-cn/docs/foundamentals/strings/split"}}');var s=r(4848),i=r(8453);const o={},d="Formatted Output",c={},a=[{value:"<code>fmt</code> Formatted Output",id:"fmt-formatted-output",level:2},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Conversion Specifiers",id:"conversion-specifiers",level:3},{value:"Type Support",id:"type-support",level:3},{value:"Advanced Formatting",id:"advanced",level:2},{value:"PrintF Alternatives",id:"printf-alternatives",level:2},{value:"Appending to Strings",id:"appending-to-strings",level:2},{value:"Writing to Streams",id:"writing-to-streams",level:2},{value:"User-Defined Formats",id:"user-defined-formats",level:2},{value:"<code>turbo_stringify()</code>",id:"turbo_stringify",level:3},{value:"<code>turbo_format_convert()</code>",id:"turbo_format_convert",level:3},{value:"Defining Acceptors",id:"defining-acceptors",level:2}];function l(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"formatted-output",children:"Formatted Output"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"kumo"})," integrates two custom formatting libraries: ",(0,s.jsx)(n.code,{children:"fmt"})," and ",(0,s.jsx)(n.code,{children:"turbo::str_format()"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"str_format"})," library is a type-safe alternative to the ",(0,s.jsx)(n.code,{children:"printf()"})," family of string formatting routines in the ",(0,s.jsx)(n.code,{children:"<cstdio>"})," standard library header. This ",(0,s.jsx)(n.code,{children:"str_format"})," library provides most of the functionality of ",(0,s.jsx)(n.code,{children:"printf()"}),"-style string formatting along with many additional benefits:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Type safety, including native support for ",(0,s.jsx)(n.code,{children:"std::string"})," and ",(0,s.jsx)(n.code,{children:"std::string_view"})]}),"\n",(0,s.jsx)(n.li,{children:"Reliable behavior independent of the standard library"}),"\n",(0,s.jsx)(n.li,{children:"Support for POSIX positional extensions"}),"\n",(0,s.jsxs)(n.li,{children:["Native support for Turbo types such as ",(0,s.jsx)(n.code,{children:"turbo::Cord"})," and extensibility to support other types"]}),"\n",(0,s.jsxs)(n.li,{children:["Significantly faster than native ",(0,s.jsx)(n.code,{children:"printf"})," functions (typically 2 to 3 times faster)"]}),"\n",(0,s.jsx)(n.li,{children:"Streamable to various existing sinks"}),"\n",(0,s.jsx)(n.li,{children:"Extensible to custom sinks"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["In addition, the library includes drop-in replacements for ",(0,s.jsx)(n.code,{children:"printf()"}),", ",(0,s.jsx)(n.code,{children:"fprintf()"}),", and ",(0,s.jsx)(n.code,{children:"snprintf()"}),"."]}),"\n",(0,s.jsxs)(n.h2,{id:"fmt-formatted-output",children:[(0,s.jsx)(n.code,{children:"fmt"})," Formatted Output"]}),"\n",(0,s.jsx)(n.p,{children:"Installation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"kmpkg install fmt\n"})}),"\n",(0,s.jsxs)(n.p,{children:["For usage, refer to the ",(0,s.jsx)(n.a,{href:"https://fmt.dev/11.0/",children:"fmt official documentation"}),", ",(0,s.jsx)(n.a,{href:"https://github.com/fmtlib/fmt",children:"GitHub repository"}),", and ",(0,s.jsx)(n.a,{href:"https://gitee.com/kumo-hub/fmt",children:"Gitee mirror"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,s.jsxs)(n.p,{children:["The primary ",(0,s.jsx)(n.code,{children:"str_format()"})," function is a variadic template that returns a string given a ",(0,s.jsx)(n.code,{children:"printf()"}),"-style ",(0,s.jsx)(n.em,{children:"format string"})," and zero or more additional arguments. Use it like ",(0,s.jsx)(n.code,{children:"sprintf()"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:['A format string typically consists of ordinary character data and one or more format conversion specifiers (indicated by the "%" character). Ordinary character data is returned to the result string unchanged, while each conversion specifier performs substitutions with the other typed arguments of ',(0,s.jsx)(n.code,{children:"str_format()"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"str_format()"})," returns an empty string on error and is marked with ",(0,s.jsx)(n.code,{children:"TURBO_MUST_USE_RESULT"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include "turbo/strings/str_format.h"\n\nstd::string s = turbo::str_format("Welcome to %s, Number %d!", "The Village", 6);\nEXPECT_EQ("Welcome to The Village, Number 6!", s);\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"str_format()"})," format strings should generally be declared as ",(0,s.jsx)(n.code,{children:"constexpr"}),"*; as a result, if you need to supply it as a variable, use ",(0,s.jsx)(n.code,{children:"std::string_view"})," instead of ",(0,s.jsx)(n.code,{children:"std::string"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'// Won\'t compile, not constexpr (and the `std::string` can\'t be declared\n// constexpr).\nstd::string format_string = "Welcome to %s, Number %d!";\nstd::string s = turbo::str_format(format_string, "The Village", 6);\n\n// This will compile.\nconstexpr std::string_view kFormatString = "Welcome to %s, Number %d!";\nstd::string s = turbo::str_format(kFormatString, "The Village", 6);\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Requiring the format string to be ",(0,s.jsx)(n.code,{children:"constexpr"})," allows compile-time checking of the format string."]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["Format strings must either be declared as ",(0,s.jsx)(n.code,{children:"constexpr"})," or dynamically formatted using the ",(0,s.jsx)(n.code,{children:"turbo::parsed_format"})," type. See ",(0,s.jsx)(n.a,{href:"#advanced",children:"Advanced Formatting"})," below."]})}),"\n",(0,s.jsx)(n.h3,{id:"conversion-specifiers",children:"Conversion Specifiers"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"str_format"})," library primarily follows the POSIX syntax as specified in the ",(0,s.jsxs)(n.a,{href:"http://pubs.opengroup.org/onlinepubs/9699919799/functions/fprintf.html",children:["POSIX ",(0,s.jsx)(n.code,{children:"printf()"})," family specifications"]}),", which defines format conversion specifiers. (Exceptions are noted below.)"]}),"\n",(0,s.jsx)(n.p,{children:"A format conversion specifier is a string of the form:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"%"})," character"]}),"\n",(0,s.jsxs)(n.li,{children:["An optional positional specifier of the form ",(0,s.jsx)(n.code,{children:"n$"}),", where ",(0,s.jsx)(n.code,{children:"n"})," is a non-negative positive value. (e.g., ",(0,s.jsx)(n.code,{children:"3$"}),", ",(0,s.jsx)(n.code,{children:"10$"}),", etc.). Note that ",(0,s.jsx)(n.code,{children:"str_format"})," fully supports positional modifiers; they are a POSIX extension and not part of standard ",(0,s.jsx)(n.code,{children:"printf"})," notation."]}),"\n",(0,s.jsxs)(n.li,{children:["A set of optional alignment and padding flags:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"-"})," Left-justifies the result. (Right-justified by default.)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"+"})," Forces a plus sign to precede positive results. (A minus sign always precedes negative results.)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:" "})," (space) Adds a space before the result of signed conversions. (",(0,s.jsx)(n.code,{children:"+"})," takes precedence over space)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"#"})," Uses an alternative conversion form for certain specifiers. (For example, using ",(0,s.jsx)(n.code,{children:"\u201c#\u201d"})," on a hexadecimal conversion will prepend ",(0,s.jsx)(n.code,{children:"\u201c0x\u201d"})," or ",(0,s.jsx)(n.code,{children:"\u201c0X\u201d"})," to the hexadecimal string result.)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"\u201c0\u201d"})," (zero) Pads integer and floating-point conversions with leading zeros. (Zero padding for integers is ignored if precision is explicitly specified.) This flag is ignored if ",(0,s.jsx)(n.code,{children:"\u201c-\u201d"})," is used."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["An optional integer value of the form ",(0,s.jsx)(n.code,{children:"n"})," specifying the minimum width of the result, or ",(0,s.jsxs)("code",{children:["*",(0,s.jsx)("i",{children:"variable"})]})," to use a variable of type ",(0,s.jsx)(n.code,{children:"int"})," to specify this value."]}),"\n",(0,s.jsxs)(n.li,{children:["An optional precision value, specified as ",(0,s.jsx)(n.code,{children:".n"})," where ",(0,s.jsx)(n.code,{children:"n"})," is an integer value, or ",(0,s.jsxs)("code",{children:[".*",(0,s.jsx)("i",{children:"variable"})]})," to use a variable of type ",(0,s.jsx)(n.code,{children:"int"})," to specify this value."]}),"\n",(0,s.jsxs)(n.li,{children:["A length modifier, used to modify the length of the data type. In ",(0,s.jsx)(n.code,{children:"str_format()"}),", these values are largely ignored (and unnecessary, as ",(0,s.jsx)(n.code,{children:"str_format()"})," is type-safe) but are allowed for backward compatibility:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"hh"}),", ",(0,s.jsx)(n.code,{children:"h"}),", ",(0,s.jsx)(n.code,{children:"l"}),", ",(0,s.jsx)(n.code,{children:"ll"}),", ",(0,s.jsx)(n.code,{children:"L"}),", ",(0,s.jsx)(n.code,{children:"j"}),", ",(0,s.jsx)(n.code,{children:"z"}),", ",(0,s.jsx)(n.code,{children:"t"}),", ",(0,s.jsx)(n.code,{children:"q"}),(0,s.jsx)(n.br,{}),"\n","There is one case where the length modifier has a visible effect: if the requested type is ",(0,s.jsx)(n.code,{children:"c"}),", the ",(0,s.jsx)(n.code,{children:"l"})," modifier causes the provided argument to be treated as ",(0,s.jsx)(n.code,{children:"wchar_t"})," instead of ",(0,s.jsx)(n.code,{children:"char"}),". (This happens automatically if the provided argument is already of type ",(0,s.jsx)(n.code,{children:"wchar_t"}),".)"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["A type specifier:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"c"})," Represents a character value. These are treated as ",(0,s.jsx)(n.code,{children:"char"})," unless the provided type is ",(0,s.jsx)(n.code,{children:"wchar_t"})," or the ",(0,s.jsx)(n.code,{children:"l"})," modifier is present, in which case they are treated as ",(0,s.jsx)(n.code,{children:"wchar_t"})," and converted to a multi-byte string encoded as UTF-8."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"s"})," Represents a string value. Wide strings (",(0,s.jsx)(n.code,{children:"std::wstring"}),", ",(0,s.jsx)(n.code,{children:"std::wstring_view"}),") are converted to multi-byte strings encoded as UTF-8."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"d"})," or ",(0,s.jsx)(n.code,{children:"i"})," Represents an integer value, including enumeration type values"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"o"})," Converts an unsigned integer (including enumeration type values) to an octal value"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"x"})," or ",(0,s.jsx)(n.code,{children:"X"})," Converts an unsigned integer (including enumeration type values) to a hexadecimal value"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"u"})," Represents an unsigned integer value"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"f"})," or ",(0,s.jsx)(n.code,{children:"F"})," Converts a floating-point value to decimal notation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"e"})," or ",(0,s.jsx)(n.code,{children:"E"})," Converts a floating-point value to exponential notation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"a"})," or ",(0,s.jsx)(n.code,{children:"A"})," Converts a floating-point value to hexadecimal exponential notation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"g"})," or ",(0,s.jsx)(n.code,{children:"G"})," Converts a floating-point value to either decimal or exponential notation based on precision"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"p"})," Represents a pointer address value"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"n"})," Represents a special case that writes the number of characters written up to this point."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"v"})," Represents a value formatted with the default format for its deduced type. These deduced types include many primitive types represented here as well as user-defined types with appropriate extensions. (See ",(0,s.jsx)(n.a,{href:"#user-defined-formats",children:"User-Defined Formats"})," below.)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["Note: The ",(0,s.jsx)(n.code,{children:"n"})," specifier in the ",(0,s.jsx)(n.code,{children:"printf"})," function family is unsafe. ",(0,s.jsx)(n.code,{children:"str_format()"})," allows the use of ",(0,s.jsx)(n.code,{children:"%n"})," only when such values are captured within a safe scope using the ",(0,s.jsx)(n.code,{children:"FormatCountCapture"})," class. See the example below."]})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["Note: The ",(0,s.jsx)(n.code,{children:"v"}),' specifier (standing for "value") is a type specifier that does not exist in the ',(0,s.jsx)(n.code,{children:"POSIX"})," specification. ",(0,s.jsx)(n.code,{children:"%v"})," will format the value according to its deduced type. ",(0,s.jsx)(n.code,{children:"v"})," uses ",(0,s.jsx)(n.code,{children:"d"})," for signed integer values, ",(0,s.jsx)(n.code,{children:"u"})," for unsigned integer values, ",(0,s.jsx)(n.code,{children:"g"}),' for floating-point values, and formats boolean values as "true"/"false" (instead of "1" or "0" for booleans formatted with ',(0,s.jsx)(n.code,{children:"d"}),"). ",(0,s.jsx)(n.code,{children:"const char*"})," is not supported; use ",(0,s.jsx)(n.code,{children:"std::string"})," and ",(0,s.jsx)(n.code,{children:"string_view"})," instead. The ",(0,s.jsx)(n.code,{children:"char"})," type is also not supported due to ambiguity. This specifier does not support modifiers."]})}),"\n",(0,s.jsx)(n.p,{children:"Examples:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'// Characters\nturbo::str_format("%c", \'a\') -> "a"\nturbo::str_format("%c", 32)  -> " "\nturbo::str_format("%c", 100) -> "d"\nturbo::str_format("%lc", 0x2002) -> (Locale-dependent)  // E.g. U+2002 as UTF-8\n\n// Strings\nturbo::str_format("%s", "Hello!") -> "Hello!"\n\n// Decimals\nturbo::str_format("%d", 1)    -> "1"\nturbo::str_format("%02d", 1)  -> "01"       // Zero-padding\nturbo::str_format("%-2d", 1)  -> "1 "       // Left justification\nturbo::str_format("%0+3d", 1) -> "+01"      // + specifier part of width\n\n// Octals\nturbo::str_format("%o", 16)   -> "20"\nturbo::str_format("%o", 016)  -> "16"       // literal octal\nturbo::str_format("%#o", 016) -> "016"      // alternative form\n\n// Hex\nturbo::str_format("%x", 16)      -> "10"\nturbo::str_format("%x", 0x16)    -> "16"\nturbo::str_format("%#x", 0x16)   -> "0x16"    // alternative form\nturbo::str_format("%X", 10)      -> "A"       // Upper-case\nturbo::str_format("%#06x", 0x16) -> "0x0016"  // "0x" counts as part of the width\n\n// Unsigned Integers\nturbo::str_format("%u", 16) -> "16"\nturbo::str_format("%u", -16) -> "4294967280"\n\n// Big Integers\n// Length modifiers are unnecessary, and are ignored\nturbo::str_format("%d", 100\'000\'000\'000\'000) -> "100000000000000"\nturbo::str_format("%lld", 100\'000\'000\'000\'000) -> "100000000000000"\n\n// Floating Point\n// Default precision of %f conversion is 6\nturbo::str_format("%f", 1.6)       -> "1.600000" // Width includes decimal pt.\nturbo::str_format("%05.2f", 1.6)   -> "01.60"\nturbo::str_format("%.1f", 1.63232) -> "1.6"      // Rounding down\nturbo::str_format("%.3f", 1.63451) -> "1.635"    // Rounding up\nturbo::str_format("%*.*f", 5, 2, 1.63451) -> " 1.63"  // Same as "%5.2f"\n\n// Exponential Notation\n// Default precision of a %e conversion is 6\n// Default precision of exponent is 2\n// Default sign of exponent is +\nturbo::str_format("%e", 1.6)    -> "1.600000e+00"\nturbo::str_format("%1.1e", 1.6) -> "1.6e+00"\n\n// Hex Exponents\nturbo::str_format("%a", 3.14159) -> "0x1.921f9f01b866ep+1"\n\n// Floating Point to Exponential Notation\nturbo::str_format("%g", 31415900000) -> "3.14159e+10"\n\n// Pointer conversion\nint* ptr = 9;\nturbo::str_format("%p", ptr) -> "0x7ffdeb6ad2a4";\n\n// Positional Modifiers\nstd::string s = turbo::str_format("%2$s, %3$s, %1$s!", "vici", "veni", "vidi");\nEXPECT_EQ(s, "veni, vidi, vici!");\n\n// Character Count Capturing\nint n = 0;\nstd::string s = turbo::str_format(\n    "%s%d%n", "hello", 123, turbo::FormatCountCapture(&n));\nEXPECT_EQ(8, n);\n\n// %v\nstd::string s = "hello";\nunsigned int x = 16;\nturbo::str_format("%v", s)    -> "hello"\nturbo::str_format("%v", 1)    -> "1"\nturbo::str_format("%v", x)    -> "16"\nturbo::str_format("%v", 1.6)  -> "1.6"\nturbo::str_format("%v", true) -> "true"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"type-support",children:"Type Support"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"str_format()"})," natively supports all of these basic C++ types:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Characters:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"char"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"signed char"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"unsigned char"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"wchar_t"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Strings:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"std::string"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"std::wstring"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"std::string_view"})," (if available)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"std::wstring_view"})," (if available)"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Integers:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"int"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"short"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"unsigned short"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"unsigned"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"long"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"unsigned long"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"long long"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"unsigned long long"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Floating-point:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"float"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"double"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"long double"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Unlike the printf family of functions, str_format() does not rely on the caller to encode the exact type of the argument into the format string. (With ",(0,s.jsx)(n.code,{children:"printf()"}),", this must be done carefully using length modifiers and conversion specifiers\u2014e.g., ",(0,s.jsx)(n.code,{children:"%llu"})," encodes the type ",(0,s.jsx)(n.code,{children:"unsigned long long"}),".) In the ",(0,s.jsx)(n.code,{children:"str_format"})," library, format conversions specify broader C++ conceptual categories rather than exact types. For example, ",(0,s.jsx)(n.code,{children:"%s"})," binds to any string-like argument, so ",(0,s.jsx)(n.code,{children:"std::string"}),", ",(0,s.jsx)(n.code,{children:"std::wstring"}),", ",(0,s.jsx)(n.code,{children:"std::string_view"}),", ",(0,s.jsx)(n.code,{children:"const char*"}),", and ",(0,s.jsx)(n.code,{children:"const wchar_t*"})," are all accepted. Similarly, ",(0,s.jsx)(n.code,{children:"%d"})," accepts any integer-like argument, and so on."]}),"\n",(0,s.jsx)(n.h2,{id:"advanced",children:"Advanced Formatting"}),"\n",(0,s.jsxs)(n.p,{children:["Strings that are formatted very frequently or are critical for performance can be specified using ",(0,s.jsx)(n.code,{children:"turbo::ParsedFormat"}),". ",(0,s.jsx)(n.code,{children:"turbo::ParsedFormat"})," represents a pre-parsed ",(0,s.jsx)(n.code,{children:"turbo::FormatSpec"}),", where template parameters specify a set of conversion specifiers."]}),"\n",(0,s.jsxs)(n.p,{children:["In C++14, these conversion specifiers are limited to single character values (e.g., ",(0,s.jsx)(n.code,{children:"d"}),"); in C++17 or later, you can also specify one or more ",(0,s.jsx)(n.code,{children:"turbo::FormatConversionCharSet"})," enums (e.g., ",(0,s.jsx)(n.code,{children:"turbo::FormatConversionCharSet::d"})," or ",(0,s.jsx)(n.code,{children:"turbo::FormatConversionCharSet::d | Turbo::FormatConversionCharSet::x"})," combined using bitwise OR)."]}),"\n",(0,s.jsx)(n.p,{children:"Several enums specify entire conversion groups:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"turbo::FormatConversionCharSet::kIntegral"})," = ",(0,s.jsx)(n.code,{children:"d | i | u | o | x | X"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"turbo::FormatConversionCharSet::kFloating"})," = ",(0,s.jsx)(n.code,{children:"a | e | f | g | A | E | F | G"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"turbo::FormatConversionCharSet::kNumeric"})," = ",(0,s.jsx)(n.code,{children:"kIntegral | kFloating"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"turbo::FormatConversionCharSet::kString"})," = ",(0,s.jsx)(n.code,{children:"s"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"turbo::FormatConversionCharSet::kPointer"})," = ",(0,s.jsx)(n.code,{children:"p"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["These type specifiers are checked at compile time. This approach is much faster than re-parsing a ",(0,s.jsx)(n.code,{children:"const char*"})," format each time it is used."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'// Verified at compile time.\nstatic const auto* const format_string =\n    new turbo::ParsedFormat<\'s\',\'d\'>("Welcome to %s, Number %d!");\nturbo::str_format(*format_string, "TheVillage", 6);\n\n// Verified at runtime.\nauto format_runtime = turbo::ParsedFormat<\'d\'>::New(format_string);\nif (format_runtime) {\n  value = turbo::str_format(*format_runtime, i);\n} else {\n  ... error case ...\n}\n\n// C++17 allows extended formats to support multiple conversion characters per\n// argument, specified via a combination of `FormatConversionCharSet` enums.\nusing MyFormat = turbo::ParsedFormat<turbo::FormatConversionCharSet::d |\n                                    turbo::FormatConversionCharSet::x>;\nMyFormat GetFormat(bool use_hex) {\n  if (use_hex) return MyFormat("foo %x bar");\n  return MyFormat("foo %d bar");\n}\n\n'})}),"\n",(0,s.jsx)(n.p,{children:"Precompiled formats can also be used as a way to pass formats across API boundaries in a type-safe manner. Format objects encode type information in their template parameters to allow compile-time checking of format functionality."}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'// Note: this example only compiles in C++17 and above.\nclass MyValue {\n public:\n  // MyValueFormat can be constructed from a %d or a %x format and can be\n  // used with any argument type that can be formatted with %d or %x.\n  using MyValueFormat = turbo::ParsedFormat<turbo::FormatConversionCharSet::d |\n                                           turbo::FormatConversionCharSet::x>;\n  const MyValueFormat& GetFormat(int radix) const {\n    return radix == RADIX_HEX ? format_x_ : format_d_;\n  }\n private:\n   const MyValueFormat format_d_{"%6d"};\n   const MyValueFormat format_x_{"%8x"};\n};\n\nstd::string PrintIt(const MyValue& foo) {\n  return turbo::StringF(foo.GetFormat(mode), my_int_value_);\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"printf-alternatives",children:"PrintF Alternatives"}),"\n",(0,s.jsxs)(n.p,{children:["In addition to the ",(0,s.jsx)(n.code,{children:"str_format()"})," function like ",(0,s.jsx)(n.code,{children:"std::sprintf()"}),", ",(0,s.jsx)(n.code,{children:"str_format.h"})," also provides direct drop-in replacements for ",(0,s.jsx)(n.code,{children:"std::printf()"}),", ",(0,s.jsx)(n.code,{children:"std::fprintf()"}),", and ",(0,s.jsx)(n.code,{children:"std::snprintf()"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"turbo::PrintF()"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"turbo::FPrintF()"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"turbo::SNPrintF()"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["These functions are all similar to the C built-in functions. In particular, they take the same arguments, return an ",(0,s.jsx)(n.code,{children:"int"})," with the same semantics, and can set ",(0,s.jsx)(n.code,{children:"errno"}),". Using these functions is just like using any printf variant."]}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'turbo::PrintF("Trying to request TITLE: %s USER: %s\\n", title, user);\n'})}),"\n",(0,s.jsx)(n.h2,{id:"appending-to-strings",children:"Appending to Strings"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"turbo::str_append_format()"})," function allows you to perform ",(0,s.jsx)(n.code,{children:"printf"}),"-like formatting into an existing ",(0,s.jsx)(n.code,{children:"&dest"})," string, appending the formatted string to it. ",(0,s.jsx)(n.code,{children:"str_append_format()"})," returns ",(0,s.jsx)(n.code,{children:"*dest"})," for convenient chaining."]}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"std::string& turbo::str_append_format(&dest, format, ...)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"writing-to-streams",children:"Writing to Streams"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"turbo::StreamFormat()"})," returns an object that can be efficiently streamed to a ",(0,s.jsx)(n.code,{children:"std::ostream"}),", such as for I/O or files."]}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsxs)(n.p,{children:["Note: The returned object must be used immediately. That is, do not retain it in an ",(0,s.jsx)(n.code,{children:"auto"})," variable."]})}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'//  Stream to standard output\nstd::cout << turbo::StreamFormat("name: %-20.4s: quota: %7.3f", name, quota);\n\n// Stream to a file\nif (FILE* file_handle = fopen("myfile.txt", "w"); file_handle != nullptr) {\n  int result =\n      turbo::FPrintF(file_handle, "%s", "C:\\\\Windows\\\\System32\\\\");\n  return result;\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"user-defined-formats",children:"User-Defined Formats"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"str_format"})," library provides custom utilities for formatting user-defined types with ",(0,s.jsx)(n.code,{children:"str_format()"}),". As with most type extensions, you should own the type you want to extend."]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Tip: For types you don't own you can use ",(0,s.jsx)(n.code,{children:"turbo::FormatStreamed()"})," to format\ntypes that have an ",(0,s.jsx)(n.code,{children:"operator<<"})," but no intrinsic type support within\n",(0,s.jsx)(n.code,{children:"str_format()"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'turbo::PrintF("My Foo: %s\\n", turbo::FormatStreamed(foo));\n'})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"There are two ways to format user-defined types:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"turbo_stringify()"})," provides a simpler user API with the ",(0,s.jsx)(n.code,{children:"v"})," type specifier and can also be used with ",(0,s.jsx)(n.code,{children:"turbo::str_cat()"}),", ",(0,s.jsx)(n.code,{children:"turbo::substitute()"}),", and logging in addition to ",(0,s.jsx)(n.code,{children:"str_format()"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"turbo_format_convert()"})," is more customizable, allowing users better control over type specifiers and additional modifiers used to format their types."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"We'll cover both of these approaches below."}),"\n",(0,s.jsx)(n.h3,{id:"turbo_stringify",children:(0,s.jsx)(n.code,{children:"turbo_stringify()"})}),"\n",(0,s.jsxs)(n.p,{children:["To enable a type to support the ",(0,s.jsx)(n.code,{children:"turbo_stringify()"})," extension point, define an appropriate ",(0,s.jsx)(n.code,{children:"turbo_stringify()"})," function template for that type as described below. For a class type, ",(0,s.jsx)(n.code,{children:"turbo_stringify()"})," should be defined as a ",(0,s.jsx)(n.code,{children:"friend"})," function template. For an enumeration type ",(0,s.jsx)(n.code,{children:"E"}),", define ",(0,s.jsx)(n.code,{children:"turbo_stringify()"})," at namespace scope in the same namespace as ",(0,s.jsx)(n.code,{children:"E"})," so that it can be found via argument-dependent lookup (ADL)."]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.code,{children:"turbo_stringify()"})," overload should have the following signature:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"template <typename Sink>\nvoid turbo_stringify(Sink& sink, const UserDefinedType& value);\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"turbo_stringify()"})," is only supported for use with the type specifier ",(0,s.jsx)(n.code,{children:"%v"}),", which uses type deduction for formatting purposes."]}),"\n",(0,s.jsx)(n.p,{children:"Example usage in a user-defined type is shown below:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'struct Point {\n\n  ...\n  // str_format support is added to the Point class through an turbo_stringify()\n  // friend declaration.\n  template <typename Sink>\n  friend void turbo_stringify(Sink& sink, const Point& p) {\n    turbo::Format(&sink, "(%d, %d)", p.x, p.y);\n  }\n\n  int x;\n  int y;\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Formatting a ",(0,s.jsx)(n.code,{children:"Point"})," can then simply use the ",(0,s.jsx)(n.code,{children:"%v"})," type specifier:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'// str_format has built-in support for types extended with turbo_stringify\nturbo::str_format("The point is %v", p);\n// turbo_stringify also automatically includes support for turbo::StrCat and\n// turbo::Substitute()\nturbo::StrCat("The point is ", p);\nturbo::Substitute("The point is $0", p);\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In addition, ",(0,s.jsx)(n.code,{children:"turbo_stringify()"})," itself can use ",(0,s.jsx)(n.code,{children:"%v"})," in its own format string to perform this type deduction. Our ",(0,s.jsx)(n.code,{children:"Point"})," above could be formatted as, for example, ",(0,s.jsx)(n.code,{children:'"(%v, %v)"'}),", with the ",(0,s.jsx)(n.code,{children:"int"})," values deduced as ",(0,s.jsx)(n.code,{children:"%d"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"turbo_format_convert",children:(0,s.jsx)(n.code,{children:"turbo_format_convert()"})}),"\n",(0,s.jsxs)(n.p,{children:["To extend formatting to your custom type using ",(0,s.jsx)(n.code,{children:"turbo_format_convert()"}),", provide a ",(0,s.jsx)(n.code,{children:"turbo_format_convert()"})," overload as a free (non-member) function in the same file and namespace as the type, typically as a ",(0,s.jsx)(n.code,{children:"friend"})," definition. The ",(0,s.jsx)(n.code,{children:"str_format"})," library will check for such overloads when formatting user-defined types with ",(0,s.jsx)(n.code,{children:"str_format()"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.code,{children:"turbo_format_convert()"})," overload should have the following signature:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"turbo::FormatConvertResult<...> turbo_format_convert(\n    const X& value,\n    const turbo::FormatConversionSpec& conversion_spec,\n    turbo::FormatSink *output_sink);\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"turbo::FormatConvertResult"})," return value holds the set of ",(0,s.jsx)(n.code,{children:"turbo::FormatConversionCharSet"})," values valid for this custom type. A return value of ",(0,s.jsx)(n.code,{children:"true"})," indicates the conversion was successful; if false is returned, str_format() will generate an empty string, and this result will propagate to FormatUntyped()."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"turbo::FormatConversionSpec"}),' holds the fields extracted from the user string during processing. For full documentation of this format, see "Conversion Specifiers" above.']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"turbo::FormatSink"})," holds the formatted string as it is being built."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"turbo::FormatConversionSpec"})," class also has a number of member functions to inspect the returned conversion character specification:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"conversion_char()"})," Returns the base conversion character for this formatting operation."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"width()"})," and ",(0,s.jsx)(n.code,{children:"precision()"})," Indicate whether the conversion operation should adjust the width or precision of the result."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"is_basic()"})," Indicates that no additional conversion flags are included in the conversion, including any flags used to modify width or precision. This method is useful for optimizing conversions via a fast path."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"has_left_flag()"}),' Indicates whether the result should be left-aligned by using the "-" character in the format string. E.g. ',(0,s.jsx)(n.code,{children:"\u201c%-s\u201d"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"has_show_pos_flag()"})," Indicates whether a sign column should be prepended to the result of this conversion character in the format string by using the ",(0,s.jsx)(n.code,{children:"+"})," character in the format string, even if the result is positive. E.g. ",(0,s.jsx)(n.code,{children:"%+d"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"has_sign_col_flag()"})," Indicates whether a forced sign column should be added to the result of this conversion character by using a space character (' ') in the format string. E.g. ",(0,s.jsx)(n.code,{children:'"%i"'})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"has_alt_flag()"})," Indicates whether the ",(0,s.jsx)(n.code,{children:"alternative"})," format should be applied to the result of this conversion character. E.g. ",(0,s.jsx)(n.code,{children:"%#h"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"has_zero_flag()"}),' Indicates whether zeros should be prepended to the result of this conversion character instead of spaces by using the "0" character in the format string. E.g. ',(0,s.jsx)(n.code,{children:"%0f"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"These member functions can be used to select how to handle conversion operations encountered in the source format string."}),"\n",(0,s.jsx)(n.p,{children:"Example usage in a user-defined type is shown below:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'struct Point {\n\n  ...\n  // str_format support is added to the Point class through an\n  // turbo_format_convert() friend declaration.\n  //\n  // FormatConvertResult indicates that this formatting extension will accept\n  // kIntegral ( d | i | u | o | x | X) or kString (s) specifiers. Successful\n  // conversions will return `true`.\n  friend turbo::FormatConvertResult<turbo::FormatConversionCharSet::kString |\n                                   turbo::FormatConversionCharSet::kIntegral>\n  turbo_format_convert(const Point& p,\n                    const turbo::FormatConversionSpec& spec,\n                    turbo::FormatSink* s) {\n    if (spec.conversion_char() == turbo::FormatConversionChar::s) {\n      // If the conversion char is %s, produce output of the form "x=1 y=2"\n      turbo::Format(s, "x=%vy=%v", p.x, p.y);\n    } else {\n      // If the conversion char is integral (%i, %d ...) , produce output of the\n      // form "1,2". Note that no padding will occur here.\n      turbo::Format(s, "%v,%v", p.x, p.y);\n    }\n    return {true};\n  }\n\n  int x;\n  int y;\n};\n'})}),"\n",(0,s.jsx)(n.h2,{id:"defining-acceptors",children:"Defining Acceptors"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"bool turbo::Format(&dest, format, ...)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Similar to ",(0,s.jsx)(n.code,{children:"turbo::str_append_format"}),", but the output is to an arbitrary destination object that supports the ",(0,s.jsx)(n.code,{children:"RawSink"})," interface. To implement this interface, provide an overload of ",(0,s.jsx)(n.code,{children:"turbo_format_flush()"})," for your sink object:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"void turbo_format_flush(MySink* dest, std::string_view part);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["where ",(0,s.jsx)(n.code,{children:"dest"})," is the pointer passed to ",(0,s.jsx)(n.code,{children:"turbo::format()"}),". This is typically done by providing a free function that can be found by ADL."]}),"\n",(0,s.jsxs)(n.p,{children:["The library already provides built-in support for sinks using types ",(0,s.jsx)(n.code,{children:"std::string"}),", ",(0,s.jsx)(n.code,{children:"std::ostream"}),", and ",(0,s.jsx)(n.code,{children:"turbo::Cord"})," with ",(0,s.jsx)(n.code,{children:"turbo::format()"}),"."]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["Remember that only the type owner should write such extensions. An overload for a type ",(0,s.jsx)(n.code,{children:"MySink"})," should be declared ",(0,s.jsx)(n.strong,{children:"only"})," in the header that declares ",(0,s.jsx)(n.code,{children:"MySink"}),", and in the same namespace as ",(0,s.jsx)(n.code,{children:"MySink"}),". If a particular type does not support this extension please ask the owner to write one, or make your own wrapper type that supports it."]})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>d});var t=r(6540);const s={},i=t.createContext(s);function o(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);