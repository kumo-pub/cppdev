"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[3850],{277:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"foundamentals/testing/gt/faq","title":"GoogleTest FAQ","description":"Why should test suite names and test names not contain underscore?","source":"@site/docs/foundamentals/testing/gt/faq.md","sourceDirName":"foundamentals/testing/gt","slug":"/foundamentals/testing/gt/faq","permalink":"/cppdev/zh-cn/docs/foundamentals/testing/gt/faq","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/foundamentals/testing/gt/faq.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Actions Reference","permalink":"/cppdev/zh-cn/docs/foundamentals/testing/gt/reference/actions"},"next":{"title":"Legacy gMock FAQ","permalink":"/cppdev/zh-cn/docs/foundamentals/testing/gt/gmock_faq"}}');var o=s(4848),i=s(8453);const a={},r="GoogleTest FAQ",c={},d=[{value:"Why should test suite names and test names not contain underscore?",id:"why-should-test-suite-names-and-test-names-not-contain-underscore",level:2},{value:"Why does GoogleTest support <code>EXPECT_EQ(NULL, ptr)</code> and <code>ASSERT_EQ(NULL, ptr)</code> but not <code>EXPECT_NE(NULL, ptr)</code> and <code>ASSERT_NE(NULL, ptr)</code>?",id:"why-does-googletest-support-expect_eqnull-ptr-and-assert_eqnull-ptr-but-not-expect_nenull-ptr-and-assert_nenull-ptr",level:2},{value:"I need to test that different implementations of an interface satisfy some common requirements. Should I use typed tests or value-parameterized tests?",id:"i-need-to-test-that-different-implementations-of-an-interface-satisfy-some-common-requirements-should-i-use-typed-tests-or-value-parameterized-tests",level:2},{value:"My death test modifies some state, but the change seems lost after the death test finishes. Why?",id:"my-death-test-modifies-some-state-but-the-change-seems-lost-after-the-death-test-finishes-why",level:2},{value:"EXPECT_EQ(htonl(blah), blah_blah) generates weird compiler errors in opt mode. Is this a GoogleTest bug?",id:"expect_eqhtonlblah-blah_blah-generates-weird-compiler-errors-in-opt-mode-is-this-a-googletest-bug",level:2},{value:"The compiler complains about &quot;undefined references&quot; to some static const member variables, but I did define them in the class body. What&#39;s wrong?",id:"the-compiler-complains-about-undefined-references-to-some-static-const-member-variables-but-i-did-define-them-in-the-class-body-whats-wrong",level:2},{value:"Can I derive a test fixture from another?",id:"can-i-derive-a-test-fixture-from-another",level:2},{value:"My compiler complains &quot;void value not ignored as it ought to be.&quot; What does this mean?",id:"my-compiler-complains-void-value-not-ignored-as-it-ought-to-be-what-does-this-mean",level:2},{value:"My death test hangs (or seg-faults). How do I fix it?",id:"my-death-test-hangs-or-seg-faults-how-do-i-fix-it",level:2},{value:"Should I use the constructor/destructor of the test fixture or SetUp()/TearDown()?",id:"CtorVsSetUp",level:2},{value:"The compiler complains &quot;no matching function to call&quot; when I use <code>ASSERT_PRED*</code>. How do I fix it?",id:"the-compiler-complains-no-matching-function-to-call-when-i-use-assert_pred-how-do-i-fix-it",level:2},{value:"My compiler complains about &quot;ignoring return value&quot; when I call RUN_ALL_TESTS(). Why?",id:"my-compiler-complains-about-ignoring-return-value-when-i-call-run_all_tests-why",level:2},{value:"My compiler complains that a constructor (or destructor) cannot return a value. What&#39;s going on?",id:"my-compiler-complains-that-a-constructor-or-destructor-cannot-return-a-value-whats-going-on",level:2},{value:"My SetUp() function is not called. Why?",id:"my-setup-function-is-not-called-why",level:2},{value:"I have several test suites which share the same test fixture logic; do I have to define a new test fixture class for each of them? This seems pretty tedious.",id:"i-have-several-test-suites-which-share-the-same-test-fixture-logic-do-i-have-to-define-a-new-test-fixture-class-for-each-of-them-this-seems-pretty-tedious",level:2},{value:"GoogleTest output is buried in a whole bunch of LOG messages. What do I do?",id:"googletest-output-is-buried-in-a-whole-bunch-of-log-messages-what-do-i-do",level:2},{value:"Why should I prefer test fixtures over global variables?",id:"why-should-i-prefer-test-fixtures-over-global-variables",level:2},{value:"What can the statement argument in ASSERT_DEATH() be?",id:"what-can-the-statement-argument-in-assert_death-be",level:2},{value:"I have a fixture class <code>FooTest</code>, but <code>TEST_F(FooTest, Bar)</code> gives me error <code>&quot;no matching function for call to `FooTest::FooTest()&#39;&quot;</code>. Why?",id:"i-have-a-fixture-class-footest-but-test_ffootest-bar-gives-me-error-no-matching-function-for-call-to-footestfootest-why",level:2},{value:"Why does GoogleTest require the entire test suite, instead of individual tests, to be named <code>*DeathTest</code> when it uses <code>ASSERT_DEATH</code>?",id:"why-does-googletest-require-the-entire-test-suite-instead-of-individual-tests-to-be-named-deathtest-when-it-uses-assert_death",level:2},{value:"But I don&#39;t like calling my entire test suite <code>*DeathTest</code> when it contains both death tests and non-death tests. What do I do?",id:"but-i-dont-like-calling-my-entire-test-suite-deathtest-when-it-contains-both-death-tests-and-non-death-tests-what-do-i-do",level:2},{value:"GoogleTest prints the LOG messages in a death test&#39;s child process only when the test fails. How can I see the LOG messages when the death test succeeds?",id:"googletest-prints-the-log-messages-in-a-death-tests-child-process-only-when-the-test-fails-how-can-i-see-the-log-messages-when-the-death-test-succeeds",level:2},{value:"The compiler complains about <code>no match for &#39;operator&lt;&lt;&#39;</code> when I use an assertion. What gives?",id:"the-compiler-complains-about-no-match-for-operator-when-i-use-an-assertion-what-gives",level:2},{value:"How do I suppress the memory leak messages on Windows?",id:"how-do-i-suppress-the-memory-leak-messages-on-windows",level:2},{value:"How can my code detect if it is running in a test?",id:"how-can-my-code-detect-if-it-is-running-in-a-test",level:2},{value:"How do I temporarily disable a test?",id:"how-do-i-temporarily-disable-a-test",level:2},{value:"Is it OK if I have two separate <code>TEST(Foo, Bar)</code> test methods defined in different namespaces?",id:"is-it-ok-if-i-have-two-separate-testfoo-bar-test-methods-defined-in-different-namespaces",level:2}];function l(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"googletest-faq",children:"GoogleTest FAQ"})}),"\n",(0,o.jsx)(t.h2,{id:"why-should-test-suite-names-and-test-names-not-contain-underscore",children:"Why should test suite names and test names not contain underscore?"}),"\n",(0,o.jsx)(t.admonition,{type:"info",children:(0,o.jsxs)(t.p,{children:["Note: GoogleTest reserves underscore (",(0,o.jsx)(t.code,{children:"_"}),") for special-purpose keywords, such as\n",(0,o.jsxs)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/gt/advanced#temporarily-disabling-tests",children:["the ",(0,o.jsx)(t.code,{children:"DISABLED_"})," prefix"]}),", in addition\nto the following rationale."]})}),"\n",(0,o.jsxs)(t.p,{children:["Underscore (",(0,o.jsx)(t.code,{children:"_"}),") is special, as C++ reserves the following to be used by the\ncompiler and the standard library:"]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["any identifier that starts with an ",(0,o.jsx)(t.code,{children:"_"})," followed by an upper-case letter, and"]}),"\n",(0,o.jsxs)(t.li,{children:["any identifier that contains two consecutive underscores (i.e. ",(0,o.jsx)(t.code,{children:"__"}),")\n",(0,o.jsx)(t.em,{children:"anywhere"})," in its name."]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["User code is ",(0,o.jsx)(t.em,{children:"prohibited"})," from using such identifiers."]}),"\n",(0,o.jsxs)(t.p,{children:["Now let's look at what this means for ",(0,o.jsx)(t.code,{children:"TEST"})," and ",(0,o.jsx)(t.code,{children:"TEST_F"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["Currently ",(0,o.jsx)(t.code,{children:"TEST(TestSuiteName, TestName)"})," generates a class named\n",(0,o.jsx)(t.code,{children:"TestSuiteName_TestName_Test"}),". What happens if ",(0,o.jsx)(t.code,{children:"TestSuiteName"})," or ",(0,o.jsx)(t.code,{children:"TestName"}),"\ncontains ",(0,o.jsx)(t.code,{children:"_"}),"?"]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["If ",(0,o.jsx)(t.code,{children:"TestSuiteName"})," starts with an ",(0,o.jsx)(t.code,{children:"_"})," followed by an upper-case letter (say,\n",(0,o.jsx)(t.code,{children:"_Foo"}),"), we end up with ",(0,o.jsx)(t.code,{children:"_Foo_TestName_Test"}),", which is reserved and thus\ninvalid."]}),"\n",(0,o.jsxs)(t.li,{children:["If ",(0,o.jsx)(t.code,{children:"TestSuiteName"})," ends with an ",(0,o.jsx)(t.code,{children:"_"})," (say, ",(0,o.jsx)(t.code,{children:"Foo_"}),"), we get\n",(0,o.jsx)(t.code,{children:"Foo__TestName_Test"}),", which is invalid."]}),"\n",(0,o.jsxs)(t.li,{children:["If ",(0,o.jsx)(t.code,{children:"TestName"})," starts with an ",(0,o.jsx)(t.code,{children:"_"})," (say, ",(0,o.jsx)(t.code,{children:"_Bar"}),"), we get\n",(0,o.jsx)(t.code,{children:"TestSuiteName__Bar_Test"}),", which is invalid."]}),"\n",(0,o.jsxs)(t.li,{children:["If ",(0,o.jsx)(t.code,{children:"TestName"})," ends with an ",(0,o.jsx)(t.code,{children:"_"})," (say, ",(0,o.jsx)(t.code,{children:"Bar_"}),"), we get\n",(0,o.jsx)(t.code,{children:"TestSuiteName_Bar__Test"}),", which is invalid."]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["So clearly ",(0,o.jsx)(t.code,{children:"TestSuiteName"})," and ",(0,o.jsx)(t.code,{children:"TestName"})," cannot start or end with ",(0,o.jsx)(t.code,{children:"_"}),"\n(Actually, ",(0,o.jsx)(t.code,{children:"TestSuiteName"})," can start with ",(0,o.jsx)(t.code,{children:"_"}),"\u2014as long as the ",(0,o.jsx)(t.code,{children:"_"})," isn't followed\nby an upper-case letter. But that's getting complicated. So for simplicity we\njust say that it cannot start with ",(0,o.jsx)(t.code,{children:"_"}),".)."]}),"\n",(0,o.jsxs)(t.p,{children:["It may seem fine for ",(0,o.jsx)(t.code,{children:"TestSuiteName"})," and ",(0,o.jsx)(t.code,{children:"TestName"})," to contain ",(0,o.jsx)(t.code,{children:"_"})," in the\nmiddle. However, consider this:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-c++",children:"TEST(Time, Flies_Like_An_Arrow) { ... }\nTEST(Time_Flies, Like_An_Arrow) { ... }\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Now, the two ",(0,o.jsx)(t.code,{children:"TEST"}),"s will both generate the same class\n(",(0,o.jsx)(t.code,{children:"Time_Flies_Like_An_Arrow_Test"}),"). That's not good."]}),"\n",(0,o.jsxs)(t.p,{children:["So for simplicity, we just ask the users to avoid ",(0,o.jsx)(t.code,{children:"_"})," in ",(0,o.jsx)(t.code,{children:"TestSuiteName"})," and\n",(0,o.jsx)(t.code,{children:"TestName"}),". The rule is more constraining than necessary, but it's simple and\neasy to remember. It also gives GoogleTest some wiggle room in case its\nimplementation needs to change in the future."]}),"\n",(0,o.jsx)(t.p,{children:"If you violate the rule, there may not be immediate consequences, but your test\nmay (just may) break with a new compiler (or a new version of the compiler you\nare using) or with a new version of GoogleTest. Therefore it's best to follow\nthe rule."}),"\n",(0,o.jsxs)(t.h2,{id:"why-does-googletest-support-expect_eqnull-ptr-and-assert_eqnull-ptr-but-not-expect_nenull-ptr-and-assert_nenull-ptr",children:["Why does GoogleTest support ",(0,o.jsx)(t.code,{children:"EXPECT_EQ(NULL, ptr)"})," and ",(0,o.jsx)(t.code,{children:"ASSERT_EQ(NULL, ptr)"})," but not ",(0,o.jsx)(t.code,{children:"EXPECT_NE(NULL, ptr)"})," and ",(0,o.jsx)(t.code,{children:"ASSERT_NE(NULL, ptr)"}),"?"]}),"\n",(0,o.jsxs)(t.p,{children:["First of all, you can use ",(0,o.jsx)(t.code,{children:"nullptr"})," with each of these macros, e.g.\n",(0,o.jsx)(t.code,{children:"EXPECT_EQ(ptr, nullptr)"}),", ",(0,o.jsx)(t.code,{children:"EXPECT_NE(ptr, nullptr)"}),", ",(0,o.jsx)(t.code,{children:"ASSERT_EQ(ptr, nullptr)"}),",\n",(0,o.jsx)(t.code,{children:"ASSERT_NE(ptr, nullptr)"}),". This is the preferred syntax in the style guide\nbecause ",(0,o.jsx)(t.code,{children:"nullptr"})," does not have the type problems that ",(0,o.jsx)(t.code,{children:"NULL"})," does."]}),"\n",(0,o.jsxs)(t.p,{children:["Due to some peculiarity of C++, it requires some non-trivial template meta\nprogramming tricks to support using ",(0,o.jsx)(t.code,{children:"NULL"})," as an argument of the ",(0,o.jsx)(t.code,{children:"EXPECT_XX()"}),"\nand ",(0,o.jsx)(t.code,{children:"ASSERT_XX()"})," macros. Therefore we only do it where it's most needed\n(otherwise we make the implementation of GoogleTest harder to maintain and more\nerror-prone than necessary)."]}),"\n",(0,o.jsxs)(t.p,{children:["Historically, the ",(0,o.jsx)(t.code,{children:"EXPECT_EQ()"})," macro took the ",(0,o.jsx)(t.em,{children:"expected"})," value as its first\nargument and the ",(0,o.jsx)(t.em,{children:"actual"})," value as the second, though this argument order is now\ndiscouraged. It was reasonable that someone wanted\nto write ",(0,o.jsx)(t.code,{children:"EXPECT_EQ(NULL, some_expression)"}),", and this indeed was requested\nseveral times. Therefore we implemented it."]}),"\n",(0,o.jsxs)(t.p,{children:["The need for ",(0,o.jsx)(t.code,{children:"EXPECT_NE(NULL, ptr)"})," wasn't nearly as strong. When the assertion\nfails, you already know that ",(0,o.jsx)(t.code,{children:"ptr"})," must be ",(0,o.jsx)(t.code,{children:"NULL"}),", so it doesn't add any\ninformation to print ",(0,o.jsx)(t.code,{children:"ptr"})," in this case. That means ",(0,o.jsx)(t.code,{children:"EXPECT_TRUE(ptr != NULL)"}),"\nworks just as well."]}),"\n",(0,o.jsxs)(t.p,{children:["If we were to support ",(0,o.jsx)(t.code,{children:"EXPECT_NE(NULL, ptr)"}),", for consistency we'd have to\nsupport ",(0,o.jsx)(t.code,{children:"EXPECT_NE(ptr, NULL)"})," as well. This means using the template meta\nprogramming tricks twice in the implementation, making it even harder to\nunderstand and maintain. We believe the benefit doesn't justify the cost."]}),"\n",(0,o.jsxs)(t.p,{children:["Finally, with the growth of the gMock matcher library, we are encouraging people\nto use the unified ",(0,o.jsx)(t.code,{children:"EXPECT_THAT(value, matcher)"})," syntax more often in tests. One\nsignificant advantage of the matcher approach is that matchers can be easily\ncombined to form new matchers, while the ",(0,o.jsx)(t.code,{children:"EXPECT_NE"}),", etc, macros cannot be\neasily combined. Therefore we want to invest more in the matchers than in the\n",(0,o.jsx)(t.code,{children:"EXPECT_XX()"})," macros."]}),"\n",(0,o.jsx)(t.h2,{id:"i-need-to-test-that-different-implementations-of-an-interface-satisfy-some-common-requirements-should-i-use-typed-tests-or-value-parameterized-tests",children:"I need to test that different implementations of an interface satisfy some common requirements. Should I use typed tests or value-parameterized tests?"}),"\n",(0,o.jsx)(t.p,{children:"For testing various implementations of the same interface, either typed tests or\nvalue-parameterized tests can get it done. It's really up to you the user to\ndecide which is more convenient for you, depending on your particular case. Some\nrough guidelines:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["Typed tests can be easier to write if instances of the different\nimplementations can be created the same way, modulo the type. For example,\nif all these implementations have a public default constructor (such that\nyou can write ",(0,o.jsx)(t.code,{children:"new TypeParam"}),"), or if their factory functions have the same\nform (e.g. ",(0,o.jsx)(t.code,{children:"CreateInstance<TypeParam>()"}),")."]}),"\n",(0,o.jsxs)(t.li,{children:["Value-parameterized tests can be easier to write if you need different code\npatterns to create different implementations' instances, e.g. ",(0,o.jsx)(t.code,{children:"new Foo"})," vs\n",(0,o.jsx)(t.code,{children:"new Bar(5)"}),". To accommodate for the differences, you can write factory\nfunction wrappers and pass these function pointers to the tests as their\nparameters."]}),"\n",(0,o.jsx)(t.li,{children:"When a typed test fails, the default output includes the name of the type,\nwhich can help you quickly identify which implementation is wrong.\nValue-parameterized tests only show the number of the failed iteration by\ndefault. You will need to define a function that returns the iteration name\nand pass it as the third parameter to INSTANTIATE_TEST_SUITE_P to have more\nuseful output."}),"\n",(0,o.jsxs)(t.li,{children:["When using typed tests, you need to make sure you are testing against the\ninterface type, not the concrete types (in other words, you want to make\nsure ",(0,o.jsx)(t.code,{children:"implicit_cast<MyInterface*>(my_concrete_impl)"})," works, not just that\n",(0,o.jsx)(t.code,{children:"my_concrete_impl"})," works). It's less likely to make mistakes in this area\nwhen using value-parameterized tests."]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"I hope I didn't confuse you more. :-) If you don't mind, I'd suggest you to give\nboth approaches a try. Practice is a much better way to grasp the subtle\ndifferences between the two tools. Once you have some concrete experience, you\ncan much more easily decide which one to use the next time."}),"\n",(0,o.jsx)(t.h2,{id:"my-death-test-modifies-some-state-but-the-change-seems-lost-after-the-death-test-finishes-why",children:"My death test modifies some state, but the change seems lost after the death test finishes. Why?"}),"\n",(0,o.jsxs)(t.p,{children:["Death tests (",(0,o.jsx)(t.code,{children:"EXPECT_DEATH"}),", etc.) are executed in a sub-process s.t. the\nexpected crash won't kill the test program (i.e. the parent process). As a\nresult, any in-memory side effects they incur are observable in their respective\nsub-processes, but not in the parent process. You can think of them as running\nin a parallel universe, more or less."]}),"\n",(0,o.jsxs)(t.p,{children:["In particular, if you use mocking and the death test statement invokes some mock\nmethods, the parent process will think the calls have never occurred. Therefore,\nyou may want to move your ",(0,o.jsx)(t.code,{children:"EXPECT_CALL"})," statements inside the ",(0,o.jsx)(t.code,{children:"EXPECT_DEATH"}),"\nmacro."]}),"\n",(0,o.jsx)(t.h2,{id:"expect_eqhtonlblah-blah_blah-generates-weird-compiler-errors-in-opt-mode-is-this-a-googletest-bug",children:"EXPECT_EQ(htonl(blah), blah_blah) generates weird compiler errors in opt mode. Is this a GoogleTest bug?"}),"\n",(0,o.jsxs)(t.p,{children:["Actually, the bug is in ",(0,o.jsx)(t.code,{children:"htonl()"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["According to ",(0,o.jsx)(t.code,{children:"'man htonl'"}),", ",(0,o.jsx)(t.code,{children:"htonl()"})," is a ",(0,o.jsx)(t.em,{children:"function"}),", which means it's valid to\nuse ",(0,o.jsx)(t.code,{children:"htonl"})," as a function pointer. However, in opt mode ",(0,o.jsx)(t.code,{children:"htonl()"})," is defined as\na ",(0,o.jsx)(t.em,{children:"macro"}),", which breaks this usage."]}),"\n",(0,o.jsxs)(t.p,{children:["Worse, the macro definition of ",(0,o.jsx)(t.code,{children:"htonl()"})," uses a ",(0,o.jsx)(t.code,{children:"gcc"})," extension and is ",(0,o.jsx)(t.em,{children:"not"}),"\nstandard C++. That hacky implementation has some ad hoc limitations. In\nparticular, it prevents you from writing ",(0,o.jsx)(t.code,{children:"Foo<sizeof(htonl(x))>()"}),", where ",(0,o.jsx)(t.code,{children:"Foo"}),"\nis a template that has an integral argument."]}),"\n",(0,o.jsxs)(t.p,{children:["The implementation of ",(0,o.jsx)(t.code,{children:"EXPECT_EQ(a, b)"})," uses ",(0,o.jsx)(t.code,{children:"sizeof(... a ...)"})," inside a\ntemplate argument, and thus doesn't compile in opt mode when ",(0,o.jsx)(t.code,{children:"a"})," contains a call\nto ",(0,o.jsx)(t.code,{children:"htonl()"}),". It is difficult to make ",(0,o.jsx)(t.code,{children:"EXPECT_EQ"})," bypass the ",(0,o.jsx)(t.code,{children:"htonl()"})," bug, as\nthe solution must work with different compilers on various platforms."]}),"\n",(0,o.jsx)(t.h2,{id:"the-compiler-complains-about-undefined-references-to-some-static-const-member-variables-but-i-did-define-them-in-the-class-body-whats-wrong",children:'The compiler complains about "undefined references" to some static const member variables, but I did define them in the class body. What\'s wrong?'}),"\n",(0,o.jsx)(t.p,{children:"If your class has a static data member:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-c++",children:"// foo.h\nclass Foo {\n  ...\n  static const int kBar = 100;\n};\n"})}),"\n",(0,o.jsxs)(t.p,{children:["you also need to define it ",(0,o.jsx)(t.em,{children:"outside"})," of the class body in ",(0,o.jsx)(t.code,{children:"foo.cc"}),":"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-c++",children:"const int Foo::kBar;  // No initializer here.\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Otherwise your code is ",(0,o.jsx)(t.strong,{children:"invalid C++"}),", and may break in unexpected ways. In\nparticular, using it in GoogleTest comparison assertions (",(0,o.jsx)(t.code,{children:"EXPECT_EQ"}),', etc.)\nwill generate an "undefined reference" linker error. The fact that "it used to\nwork" doesn\'t mean it\'s valid. It just means that you were lucky. :-)']}),"\n",(0,o.jsxs)(t.p,{children:["If the declaration of the static data member is ",(0,o.jsx)(t.code,{children:"constexpr"})," then it is\nimplicitly an ",(0,o.jsx)(t.code,{children:"inline"})," definition, and a separate definition in ",(0,o.jsx)(t.code,{children:"foo.cc"})," is not\nneeded:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-c++",children:"// foo.h\nclass Foo {\n  ...\n  static constexpr int kBar = 100;  // Defines kBar, no need to do it in foo.cc.\n};\n"})}),"\n",(0,o.jsx)(t.h2,{id:"can-i-derive-a-test-fixture-from-another",children:"Can I derive a test fixture from another?"}),"\n",(0,o.jsx)(t.p,{children:"Yes."}),"\n",(0,o.jsx)(t.p,{children:"Each test fixture has a corresponding and same named test suite. This means only\none test suite can use a particular fixture. Sometimes, however, multiple test\ncases may want to use the same or slightly different fixtures. For example, you\nmay want to make sure that all of a GUI library's test suites don't leak\nimportant system resources like fonts and brushes."}),"\n",(0,o.jsxs)(t.p,{children:["In GoogleTest, you share a fixture among test suites by putting the shared logic\nin a base test fixture, then deriving from that base a separate fixture for each\ntest suite that wants to use this common logic. You then use ",(0,o.jsx)(t.code,{children:"TEST_F()"})," to write\ntests using each derived fixture."]}),"\n",(0,o.jsx)(t.p,{children:"Typically, your code looks like this:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-c++",children:"// Defines a base test fixture.\nclass BaseTest : public ::testing::Test {\n protected:\n  ...\n};\n\n// Derives a fixture FooTest from BaseTest.\nclass FooTest : public BaseTest {\n protected:\n  void SetUp() override {\n    BaseTest::SetUp();  // Sets up the base fixture first.\n    ... additional set-up work ...\n  }\n\n  void TearDown() override {\n    ... clean-up work for FooTest ...\n    BaseTest::TearDown();  // Remember to tear down the base fixture\n                           // after cleaning up FooTest!\n  }\n\n  ... functions and variables for FooTest ...\n};\n\n// Tests that use the fixture FooTest.\nTEST_F(FooTest, Bar) { ... }\nTEST_F(FooTest, Baz) { ... }\n\n... additional fixtures derived from BaseTest ...\n"})}),"\n",(0,o.jsx)(t.p,{children:"If necessary, you can continue to derive test fixtures from a derived fixture.\nGoogleTest has no limit on how deep the hierarchy can be."}),"\n",(0,o.jsxs)(t.p,{children:["For a complete example using derived test fixtures, see\n",(0,o.jsx)(t.a,{href:"https://github.com/google/googletest/blob/main/googletest/samples/sample5_unittest.cc",children:"sample5_unittest.cc"}),"."]}),"\n",(0,o.jsx)(t.h2,{id:"my-compiler-complains-void-value-not-ignored-as-it-ought-to-be-what-does-this-mean",children:'My compiler complains "void value not ignored as it ought to be." What does this mean?'}),"\n",(0,o.jsxs)(t.p,{children:["You're probably using an ",(0,o.jsx)(t.code,{children:"ASSERT_*()"})," in a function that doesn't return ",(0,o.jsx)(t.code,{children:"void"}),".\n",(0,o.jsx)(t.code,{children:"ASSERT_*()"})," can only be used in ",(0,o.jsx)(t.code,{children:"void"})," functions, due to exceptions being\ndisabled by our build system. Please see more details\n",(0,o.jsx)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/gt/advanced#assertion-placement",children:"here"}),"."]}),"\n",(0,o.jsx)(t.h2,{id:"my-death-test-hangs-or-seg-faults-how-do-i-fix-it",children:"My death test hangs (or seg-faults). How do I fix it?"}),"\n",(0,o.jsxs)(t.p,{children:["In GoogleTest, death tests are run in a child process and the way they work is\ndelicate. To write death tests you really need to understand how they work\u2014see\nthe details at ",(0,o.jsx)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/gt/reference/assertions#death",children:"Death Assertions"})," in the\nAssertions Reference."]}),"\n",(0,o.jsxs)(t.p,{children:["In particular, death tests don't like having multiple threads in the parent\nprocess. So the first thing you can try is to eliminate creating threads outside\nof ",(0,o.jsx)(t.code,{children:"EXPECT_DEATH()"}),". For example, you may want to use mocks or fake objects\ninstead of real ones in your tests."]}),"\n",(0,o.jsxs)(t.p,{children:["Sometimes this is impossible as some library you must use may be creating\nthreads before ",(0,o.jsx)(t.code,{children:"main()"})," is even reached. In this case, you can try to minimize\nthe chance of conflicts by either moving as many activities as possible inside\n",(0,o.jsx)(t.code,{children:"EXPECT_DEATH()"})," (in the extreme case, you want to move everything inside), or\nleaving as few things as possible in it. Also, you can try to set the death test\nstyle to ",(0,o.jsx)(t.code,{children:'"threadsafe"'}),", which is safer but slower, and see if it helps."]}),"\n",(0,o.jsx)(t.p,{children:"If you go with thread-safe death tests, remember that they rerun the test\nprogram from the beginning in the child process. Therefore make sure your\nprogram can run side-by-side with itself and is deterministic."}),"\n",(0,o.jsx)(t.p,{children:"In the end, this boils down to good concurrent programming. You have to make\nsure that there are no race conditions or deadlocks in your program. No silver\nbullet - sorry!"}),"\n",(0,o.jsx)(t.h2,{id:"CtorVsSetUp",children:"Should I use the constructor/destructor of the test fixture or SetUp()/TearDown()?"}),"\n",(0,o.jsxs)(t.p,{children:["The first thing to remember is that GoogleTest does ",(0,o.jsx)(t.strong,{children:"not"})," reuse the same test\nfixture object across multiple tests. For each ",(0,o.jsx)(t.code,{children:"TEST_F"}),", GoogleTest will create\na ",(0,o.jsx)(t.strong,{children:"fresh"})," test fixture object, immediately call ",(0,o.jsx)(t.code,{children:"SetUp()"}),", run the test body,\ncall ",(0,o.jsx)(t.code,{children:"TearDown()"}),", and then delete the test fixture object."]}),"\n",(0,o.jsxs)(t.p,{children:["When you need to write per-test set-up and tear-down logic, you have the choice\nbetween using the test fixture constructor/destructor or ",(0,o.jsx)(t.code,{children:"SetUp()"}),"/",(0,o.jsx)(t.code,{children:"TearDown()"}),".\nThe former is usually preferred, as it has the following benefits:"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["By initializing a member variable in the constructor, we have the option to\nmake it ",(0,o.jsx)(t.code,{children:"const"}),", which helps prevent accidental changes to its value and\nmakes the tests more obviously correct."]}),"\n",(0,o.jsxs)(t.li,{children:["In case we need to subclass the test fixture class, the subclass'\nconstructor is guaranteed to call the base class' constructor ",(0,o.jsx)(t.em,{children:"first"}),", and\nthe subclass' destructor is guaranteed to call the base class' destructor\n",(0,o.jsx)(t.em,{children:"afterward"}),". With ",(0,o.jsx)(t.code,{children:"SetUp()/TearDown()"}),", a subclass may make the mistake of\nforgetting to call the base class' ",(0,o.jsx)(t.code,{children:"SetUp()/TearDown()"})," or call them at the\nwrong time."]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["You may still want to use ",(0,o.jsx)(t.code,{children:"SetUp()/TearDown()"})," in the following cases:"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["C++ does not allow virtual function calls in constructors and destructors.\nYou can call a method declared as virtual, but it will not use dynamic\ndispatch. It will use the definition from the class the constructor of which\nis currently executing. This is because calling a virtual method before the\nderived class constructor has a chance to run is very dangerous - the\nvirtual method might operate on uninitialized data. Therefore, if you need\nto call a method that will be overridden in a derived class, you have to use\n",(0,o.jsx)(t.code,{children:"SetUp()/TearDown()"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:["In the body of a constructor (or destructor), it's not possible to use the\n",(0,o.jsx)(t.code,{children:"ASSERT_xx"})," macros. Therefore, if the set-up operation could cause a fatal\ntest failure that should prevent the test from running, it's necessary to\nuse ",(0,o.jsx)(t.code,{children:"abort"})," and abort the whole test\nexecutable, or to use ",(0,o.jsx)(t.code,{children:"SetUp()"})," instead of a constructor."]}),"\n",(0,o.jsxs)(t.li,{children:["If the tear-down operation could throw an exception, you must use\n",(0,o.jsx)(t.code,{children:"TearDown()"})," as opposed to the destructor, as throwing in a destructor leads\nto undefined behavior and usually will kill your program right away. Note\nthat many standard libraries (like STL) may throw when exceptions are\nenabled in the compiler. Therefore you should prefer ",(0,o.jsx)(t.code,{children:"TearDown()"})," if you\nwant to write portable tests that work with or without exceptions."]}),"\n",(0,o.jsx)(t.li,{children:"The GoogleTest team is considering making the assertion macros throw on\nplatforms where exceptions are enabled (e.g. Windows, Mac OS, and Linux\nclient-side), which will eliminate the need for the user to propagate\nfailures from a subroutine to its caller. Therefore, you shouldn't use\nGoogleTest assertions in a destructor if your code could run on such a\nplatform."}),"\n"]}),"\n",(0,o.jsxs)(t.h2,{id:"the-compiler-complains-no-matching-function-to-call-when-i-use-assert_pred-how-do-i-fix-it",children:['The compiler complains "no matching function to call" when I use ',(0,o.jsx)(t.code,{children:"ASSERT_PRED*"}),". How do I fix it?"]}),"\n",(0,o.jsxs)(t.p,{children:["See details for ",(0,o.jsx)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/gt/reference/assertions#EXPECT_PRED",children:(0,o.jsx)(t.code,{children:"EXPECT_PRED*"})})," in the\nAssertions Reference."]}),"\n",(0,o.jsx)(t.h2,{id:"my-compiler-complains-about-ignoring-return-value-when-i-call-run_all_tests-why",children:'My compiler complains about "ignoring return value" when I call RUN_ALL_TESTS(). Why?'}),"\n",(0,o.jsxs)(t.p,{children:["Some people had been ignoring the return value of ",(0,o.jsx)(t.code,{children:"RUN_ALL_TESTS()"}),". That is,\ninstead of"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-c++",children:"  return RUN_ALL_TESTS();\n"})}),"\n",(0,o.jsx)(t.p,{children:"they write"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-c++",children:"  RUN_ALL_TESTS();\n"})}),"\n",(0,o.jsxs)(t.p,{children:["This is ",(0,o.jsx)(t.strong,{children:"wrong and dangerous"}),". The testing services needs to see the return\nvalue of ",(0,o.jsx)(t.code,{children:"RUN_ALL_TESTS()"})," in order to determine if a test has passed. If your\n",(0,o.jsx)(t.code,{children:"main()"})," function ignores it, your test will be considered successful even if it\nhas a GoogleTest assertion failure. Very bad."]}),"\n",(0,o.jsxs)(t.p,{children:["We have decided to fix this (thanks to Michael Chastain for the idea). Now, your\ncode will no longer be able to ignore ",(0,o.jsx)(t.code,{children:"RUN_ALL_TESTS()"})," when compiled with\n",(0,o.jsx)(t.code,{children:"gcc"}),". If you do so, you'll get a compiler error."]}),"\n",(0,o.jsxs)(t.p,{children:["If you see the compiler complaining about you ignoring the return value of\n",(0,o.jsx)(t.code,{children:"RUN_ALL_TESTS()"}),", the fix is simple: just make sure its value is used as the\nreturn value of ",(0,o.jsx)(t.code,{children:"main()"}),"."]}),"\n",(0,o.jsx)(t.p,{children:"But how could we introduce a change that breaks existing tests? Well, in this\ncase, the code was already broken in the first place, so we didn't break it. :-)"}),"\n",(0,o.jsx)(t.h2,{id:"my-compiler-complains-that-a-constructor-or-destructor-cannot-return-a-value-whats-going-on",children:"My compiler complains that a constructor (or destructor) cannot return a value. What's going on?"}),"\n",(0,o.jsxs)(t.p,{children:["Due to a peculiarity of C++, in order to support the syntax for streaming\nmessages to an ",(0,o.jsx)(t.code,{children:"ASSERT_*"}),", e.g."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-c++",children:'  ASSERT_EQ(1, Foo()) << "blah blah" << foo;\n'})}),"\n",(0,o.jsxs)(t.p,{children:["we had to give up using ",(0,o.jsx)(t.code,{children:"ASSERT*"})," and ",(0,o.jsx)(t.code,{children:"FAIL*"})," (but not ",(0,o.jsx)(t.code,{children:"EXPECT*"})," and\n",(0,o.jsx)(t.code,{children:"ADD_FAILURE*"}),") in constructors and destructors. The workaround is to move the\ncontent of your constructor/destructor to a private void member function, or\nswitch to ",(0,o.jsx)(t.code,{children:"EXPECT_*()"})," if that works. This\n",(0,o.jsx)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/gt/advanced#assertion-placement",children:"section"})," in the user's guide explains it."]}),"\n",(0,o.jsx)(t.h2,{id:"my-setup-function-is-not-called-why",children:"My SetUp() function is not called. Why?"}),"\n",(0,o.jsxs)(t.p,{children:["C++ is case-sensitive. Did you spell it as ",(0,o.jsx)(t.code,{children:"Setup()"}),"?"]}),"\n",(0,o.jsxs)(t.p,{children:["Similarly, sometimes people spell ",(0,o.jsx)(t.code,{children:"SetUpTestSuite()"})," as ",(0,o.jsx)(t.code,{children:"SetupTestSuite()"})," and\nwonder why it's never called."]}),"\n",(0,o.jsx)(t.h2,{id:"i-have-several-test-suites-which-share-the-same-test-fixture-logic-do-i-have-to-define-a-new-test-fixture-class-for-each-of-them-this-seems-pretty-tedious",children:"I have several test suites which share the same test fixture logic; do I have to define a new test fixture class for each of them? This seems pretty tedious."}),"\n",(0,o.jsx)(t.p,{children:"You don't have to. Instead of"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-c++",children:"class FooTest : public BaseTest {};\n\nTEST_F(FooTest, Abc) { ... }\nTEST_F(FooTest, Def) { ... }\n\nclass BarTest : public BaseTest {};\n\nTEST_F(BarTest, Abc) { ... }\nTEST_F(BarTest, Def) { ... }\n"})}),"\n",(0,o.jsxs)(t.p,{children:["you can simply ",(0,o.jsx)(t.code,{children:"typedef"})," the test fixtures:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-c++",children:"typedef BaseTest FooTest;\n\nTEST_F(FooTest, Abc) { ... }\nTEST_F(FooTest, Def) { ... }\n\ntypedef BaseTest BarTest;\n\nTEST_F(BarTest, Abc) { ... }\nTEST_F(BarTest, Def) { ... }\n"})}),"\n",(0,o.jsx)(t.h2,{id:"googletest-output-is-buried-in-a-whole-bunch-of-log-messages-what-do-i-do",children:"GoogleTest output is buried in a whole bunch of LOG messages. What do I do?"}),"\n",(0,o.jsx)(t.p,{children:"The GoogleTest output is meant to be a concise and human-friendly report. If\nyour test generates textual output itself, it will mix with the GoogleTest\noutput, making it hard to read. However, there is an easy solution to this\nproblem."}),"\n",(0,o.jsxs)(t.p,{children:["Since ",(0,o.jsx)(t.code,{children:"LOG"})," messages go to stderr, we decided to let GoogleTest output go to\nstdout. This way, you can easily separate the two using redirection. For\nexample:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-shell",children:"$ ./my_test > gtest_output.txt\n"})}),"\n",(0,o.jsx)(t.h2,{id:"why-should-i-prefer-test-fixtures-over-global-variables",children:"Why should I prefer test fixtures over global variables?"}),"\n",(0,o.jsx)(t.p,{children:"There are several good reasons:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"It's likely your test needs to change the states of its global variables.\nThis makes it difficult to keep side effects from escaping one test and\ncontaminating others, making debugging difficult. By using fixtures, each\ntest has a fresh set of variables that's different (but with the same\nnames). Thus, tests are kept independent of each other."}),"\n",(0,o.jsx)(t.li,{children:"Global variables pollute the global namespace."}),"\n",(0,o.jsx)(t.li,{children:"Test fixtures can be reused via subclassing, which cannot be done easily\nwith global variables. This is useful if many test suites have something in\ncommon."}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"what-can-the-statement-argument-in-assert_death-be",children:"What can the statement argument in ASSERT_DEATH() be?"}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"ASSERT_DEATH(statement, matcher)"})," (or any death assertion macro) can be used\nwherever ",(0,o.jsx)(t.em,{children:(0,o.jsx)(t.code,{children:"statement"})})," is valid. So basically ",(0,o.jsx)(t.em,{children:(0,o.jsx)(t.code,{children:"statement"})})," can be any C++\nstatement that makes sense in the current context. In particular, it can\nreference global and/or local variables, and can be:"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"a simple function call (often the case),"}),"\n",(0,o.jsx)(t.li,{children:"a complex expression, or"}),"\n",(0,o.jsx)(t.li,{children:"a compound statement."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Some examples are shown here:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-c++",children:'// A death test can be a simple function call.\nTEST(MyDeathTest, FunctionCall) {\n  ASSERT_DEATH(Xyz(5), "Xyz failed");\n}\n\n// Or a complex expression that references variables and functions.\nTEST(MyDeathTest, ComplexExpression) {\n  const bool c = Condition();\n  ASSERT_DEATH((c ? Func1(0) : object2.Method("test")),\n               "(Func1|Method) failed");\n}\n\n// Death assertions can be used anywhere in a function.  In\n// particular, they can be inside a loop.\nTEST(MyDeathTest, InsideLoop) {\n  // Verifies that Foo(0), Foo(1), ..., and Foo(4) all die.\n  for (int i = 0; i < 5; i++) {\n    EXPECT_DEATH_M(Foo(i), "Foo has \\\\d+ errors",\n                   ::testing::Message() << "where i is " << i);\n  }\n}\n\n// A death assertion can contain a compound statement.\nTEST(MyDeathTest, CompoundStatement) {\n  // Verifies that at lease one of Bar(0), Bar(1), ..., and\n  // Bar(4) dies.\n  ASSERT_DEATH({\n    for (int i = 0; i < 5; i++) {\n      Bar(i);\n    }\n  },\n  "Bar has \\\\d+ errors");\n}\n'})}),"\n",(0,o.jsxs)(t.h2,{id:"i-have-a-fixture-class-footest-but-test_ffootest-bar-gives-me-error-no-matching-function-for-call-to-footestfootest-why",children:["I have a fixture class ",(0,o.jsx)(t.code,{children:"FooTest"}),", but ",(0,o.jsx)(t.code,{children:"TEST_F(FooTest, Bar)"})," gives me error ",(0,o.jsx)(t.code,{children:'"no matching function for call to `FooTest::FooTest()\'"'}),". Why?"]}),"\n",(0,o.jsx)(t.p,{children:"GoogleTest needs to be able to create objects of your test fixture class, so it\nmust have a default constructor. Normally the compiler will define one for you.\nHowever, there are cases where you have to define your own:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["If you explicitly declare a non-default constructor for class ",(0,o.jsx)(t.code,{children:"FooTest"}),"\n(",(0,o.jsx)(t.code,{children:"DISALLOW_EVIL_CONSTRUCTORS()"})," does this), then you need to define a\ndefault constructor, even if it would be empty."]}),"\n",(0,o.jsxs)(t.li,{children:["If ",(0,o.jsx)(t.code,{children:"FooTest"})," has a const non-static data member, then you have to define the\ndefault constructor ",(0,o.jsx)(t.em,{children:"and"})," initialize the const member in the initializer\nlist of the constructor. (Early versions of ",(0,o.jsx)(t.code,{children:"gcc"})," doesn't force you to\ninitialize the const member. It's a bug that has been fixed in ",(0,o.jsx)(t.code,{children:"gcc 4"}),".)"]}),"\n"]}),"\n",(0,o.jsxs)(t.h2,{id:"why-does-googletest-require-the-entire-test-suite-instead-of-individual-tests-to-be-named-deathtest-when-it-uses-assert_death",children:["Why does GoogleTest require the entire test suite, instead of individual tests, to be named ",(0,o.jsx)(t.code,{children:"*DeathTest"})," when it uses ",(0,o.jsx)(t.code,{children:"ASSERT_DEATH"}),"?"]}),"\n",(0,o.jsx)(t.p,{children:"GoogleTest does not interleave tests from different test suites. That is, it\nruns all tests in one test suite first, and then runs all tests in the next test\nsuite, and so on. GoogleTest does this because it needs to set up a test suite\nbefore the first test in it is run, and tear it down afterwards. Splitting up\nthe test case would require multiple set-up and tear-down processes, which is\ninefficient and makes the semantics unclean."}),"\n",(0,o.jsx)(t.p,{children:"If we were to determine the order of tests based on test name instead of test\ncase name, then we would have a problem with the following situation:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-c++",children:"TEST_F(FooTest, AbcDeathTest) { ... }\nTEST_F(FooTest, Uvw) { ... }\n\nTEST_F(BarTest, DefDeathTest) { ... }\nTEST_F(BarTest, Xyz) { ... }\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Since ",(0,o.jsx)(t.code,{children:"FooTest.AbcDeathTest"})," needs to run before ",(0,o.jsx)(t.code,{children:"BarTest.Xyz"}),", and we don't\ninterleave tests from different test suites, we need to run all tests in the\n",(0,o.jsx)(t.code,{children:"FooTest"})," case before running any test in the ",(0,o.jsx)(t.code,{children:"BarTest"})," case. This contradicts\nwith the requirement to run ",(0,o.jsx)(t.code,{children:"BarTest.DefDeathTest"})," before ",(0,o.jsx)(t.code,{children:"FooTest.Uvw"}),"."]}),"\n",(0,o.jsxs)(t.h2,{id:"but-i-dont-like-calling-my-entire-test-suite-deathtest-when-it-contains-both-death-tests-and-non-death-tests-what-do-i-do",children:["But I don't like calling my entire test suite ",(0,o.jsx)(t.code,{children:"*DeathTest"})," when it contains both death tests and non-death tests. What do I do?"]}),"\n",(0,o.jsxs)(t.p,{children:["You don't have to, but if you like, you may split up the test suite into\n",(0,o.jsx)(t.code,{children:"FooTest"})," and ",(0,o.jsx)(t.code,{children:"FooDeathTest"}),", where the names make it clear that they are\nrelated:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-c++",children:"class FooTest : public ::testing::Test { ... };\n\nTEST_F(FooTest, Abc) { ... }\nTEST_F(FooTest, Def) { ... }\n\nusing FooDeathTest = FooTest;\n\nTEST_F(FooDeathTest, Uvw) { ... EXPECT_DEATH(...) ... }\nTEST_F(FooDeathTest, Xyz) { ... ASSERT_DEATH(...) ... }\n"})}),"\n",(0,o.jsx)(t.h2,{id:"googletest-prints-the-log-messages-in-a-death-tests-child-process-only-when-the-test-fails-how-can-i-see-the-log-messages-when-the-death-test-succeeds",children:"GoogleTest prints the LOG messages in a death test's child process only when the test fails. How can I see the LOG messages when the death test succeeds?"}),"\n",(0,o.jsxs)(t.p,{children:["Printing the LOG messages generated by the statement inside ",(0,o.jsx)(t.code,{children:"EXPECT_DEATH()"}),"\nmakes it harder to search for real problems in the parent's log. Therefore,\nGoogleTest only prints them when the death test has failed."]}),"\n",(0,o.jsx)(t.p,{children:"If you really need to see such LOG messages, a workaround is to temporarily\nbreak the death test (e.g. by changing the regex pattern it is expected to\nmatch). Admittedly, this is a hack. We'll consider a more permanent solution\nafter the fork-and-exec-style death tests are implemented."}),"\n",(0,o.jsxs)(t.h2,{id:"the-compiler-complains-about-no-match-for-operator-when-i-use-an-assertion-what-gives",children:["The compiler complains about ",(0,o.jsx)(t.code,{children:"no match for 'operator<<'"})," when I use an assertion. What gives?"]}),"\n",(0,o.jsxs)(t.p,{children:["If you use a user-defined type ",(0,o.jsx)(t.code,{children:"FooType"})," in an assertion, you must make sure\nthere is an ",(0,o.jsx)(t.code,{children:"std::ostream& operator<<(std::ostream&, const FooType&)"})," function\ndefined such that we can print a value of ",(0,o.jsx)(t.code,{children:"FooType"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["In addition, if ",(0,o.jsx)(t.code,{children:"FooType"})," is declared in a name space, the ",(0,o.jsx)(t.code,{children:"<<"})," operator also\nneeds to be defined in the ",(0,o.jsx)(t.em,{children:"same"})," name space. See\n",(0,o.jsx)(t.a,{href:"https://abseil.io/tips/49",children:"Tip of the Week #49"})," for details."]}),"\n",(0,o.jsx)(t.h2,{id:"how-do-i-suppress-the-memory-leak-messages-on-windows",children:"How do I suppress the memory leak messages on Windows?"}),"\n",(0,o.jsxs)(t.p,{children:["Since the statically initialized GoogleTest singleton requires allocations on\nthe heap, the Visual C++ memory leak detector will report memory leaks at the\nend of the program run. The easiest way to avoid this is to use the\n",(0,o.jsx)(t.code,{children:"_CrtMemCheckpoint"})," and ",(0,o.jsx)(t.code,{children:"_CrtMemDumpAllObjectsSince"})," calls to not report any\nstatically initialized heap objects. See MSDN for more details and additional\nheap check/debug routines."]}),"\n",(0,o.jsx)(t.h2,{id:"how-can-my-code-detect-if-it-is-running-in-a-test",children:"How can my code detect if it is running in a test?"}),"\n",(0,o.jsxs)(t.p,{children:["If you write code that sniffs whether it's running in a test and does different\nthings accordingly, you are leaking test-only logic into production code and\nthere is no easy way to ensure that the test-only code paths aren't run by\nmistake in production. Such cleverness also leads to\n",(0,o.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Heisenbug",children:"Heisenbugs"}),". Therefore we strongly\nadvise against the practice, and GoogleTest doesn't provide a way to do it."]}),"\n",(0,o.jsxs)(t.p,{children:["In general, the recommended way to cause the code to behave differently under\ntest is ",(0,o.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Dependency_injection",children:"Dependency Injection"}),". You can inject\ndifferent functionality from the test and from the production code. Since your\nproduction code doesn't link in the for-test logic at all (the\n",(0,o.jsx)(t.a,{href:"https://docs.bazel.build/versions/master/be/common-definitions.html#common.testonly",children:(0,o.jsx)(t.code,{children:"testonly"})})," attribute for BUILD targets helps to ensure\nthat), there is no danger in accidentally running it."]}),"\n",(0,o.jsxs)(t.p,{children:["However, if you ",(0,o.jsx)(t.em,{children:"really"}),", ",(0,o.jsx)(t.em,{children:"really"}),", ",(0,o.jsx)(t.em,{children:"really"})," have no choice, and if you follow\nthe rule of ending your test program names with ",(0,o.jsx)(t.code,{children:"_test"}),", you can use the\n",(0,o.jsx)(t.em,{children:"horrible"})," hack of sniffing your executable name (",(0,o.jsx)(t.code,{children:"argv[0]"})," in ",(0,o.jsx)(t.code,{children:"main()"}),") to know\nwhether the code is under test."]}),"\n",(0,o.jsx)(t.h2,{id:"how-do-i-temporarily-disable-a-test",children:"How do I temporarily disable a test?"}),"\n",(0,o.jsxs)(t.p,{children:["If you have a broken test that you cannot fix right away, you can add the\n",(0,o.jsx)(t.code,{children:"DISABLED_"})," prefix to its name. This will exclude it from execution. This is\nbetter than commenting out the code or using ",(0,o.jsx)(t.code,{children:"#if 0"}),", as disabled tests are\nstill compiled (and thus won't rot)."]}),"\n",(0,o.jsxs)(t.p,{children:["To include disabled tests in test execution, just invoke the test program with\nthe ",(0,o.jsx)(t.code,{children:"--gtest_also_run_disabled_tests"})," flag."]}),"\n",(0,o.jsxs)(t.h2,{id:"is-it-ok-if-i-have-two-separate-testfoo-bar-test-methods-defined-in-different-namespaces",children:["Is it OK if I have two separate ",(0,o.jsx)(t.code,{children:"TEST(Foo, Bar)"})," test methods defined in different namespaces?"]}),"\n",(0,o.jsx)(t.p,{children:"Yes."}),"\n",(0,o.jsxs)(t.p,{children:["The rule is ",(0,o.jsx)(t.strong,{children:"all test methods in the same test suite must use the same fixture\nclass"}),". This means that the following is ",(0,o.jsx)(t.strong,{children:"allowed"})," because both tests use the\nsame fixture class (",(0,o.jsx)(t.code,{children:"::testing::Test"}),")."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-c++",children:"namespace foo {\nTEST(CoolTest, DoSomething) {\n  SUCCEED();\n}\n}  // namespace foo\n\nnamespace bar {\nTEST(CoolTest, DoSomething) {\n  SUCCEED();\n}\n}  // namespace bar\n"})}),"\n",(0,o.jsxs)(t.p,{children:["However, the following code is ",(0,o.jsx)(t.strong,{children:"not allowed"})," and will produce a runtime error\nfrom GoogleTest because the test methods are using different test fixture\nclasses with the same test suite name."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-c++",children:"namespace foo {\nclass CoolTest : public ::testing::Test {};  // Fixture foo::CoolTest\nTEST_F(CoolTest, DoSomething) {\n  SUCCEED();\n}\n}  // namespace foo\n\nnamespace bar {\nclass CoolTest : public ::testing::Test {};  // Fixture: bar::CoolTest\nTEST_F(CoolTest, DoSomething) {\n  SUCCEED();\n}\n}  // namespace bar\n"})})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>a,x:()=>r});var n=s(6540);const o={},i=n.createContext(o);function a(e){const t=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);