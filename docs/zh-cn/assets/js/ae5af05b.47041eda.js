"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[2172],{7806:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"retrieve/vector/nmslib","title":"NMSLIB (Non-Metric Space Library) Overview","description":"- Repository//github.com/nmslib/nmslib","source":"@site/i18n/zh-cn/docusaurus-plugin-content-docs/current/retrieve/vector/nmslib.mdx","sourceDirName":"retrieve/vector","slug":"/retrieve/vector/nmslib","permalink":"/cppdev/zh-cn/docs/retrieve/vector/nmslib","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"HNSWLIB (Hierarchical Navigable Small Worlds Library) Overview","permalink":"/cppdev/zh-cn/docs/retrieve/vector/hnswlib"},"next":{"title":"NGT (Neighborhood Graph and Tree) Overview","permalink":"/cppdev/zh-cn/docs/retrieve/vector/ngt"}}');var n=t(4848),s=t(8453);const l={},c="NMSLIB (Non-Metric Space Library) Overview",o={},d=[{value:"Purpose &amp; Use Cases",id:"purpose--use-cases",level:2},{value:"Algorithms Supported",id:"algorithms-supported",level:2},{value:"Core Technical Specifications",id:"core-technical-specifications",level:2},{value:"1. Supported Metric/Non-Metric Spaces (Official Implementation Only)",id:"1-supported-metricnon-metric-spaces-official-implementation-only",level:3},{value:"2. Supported Data Types (Official Implementation Only)",id:"2-supported-data-types-official-implementation-only",level:3},{value:"3. Real-Time Data Insertion/Deletion Support",id:"3-real-time-data-insertiondeletion-support",level:3},{value:"Characteristics",id:"characteristics",level:2},{value:"Notes",id:"notes",level:2}];function a(e){const i={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.header,{children:(0,n.jsx)(i.h1,{id:"nmslib-non-metric-space-library-overview",children:"NMSLIB (Non-Metric Space Library) Overview"})}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Repository:"})," ",(0,n.jsx)(i.a,{href:"https://github.com/nmslib/nmslib",children:"https://github.com/nmslib/nmslib"})]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Language:"})," C++ (Python/Java/Go bindings available; Python bindings are mature, Java/Go are community-maintained)"]}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"purpose--use-cases",children:"Purpose & Use Cases"}),"\n",(0,n.jsxs)(i.p,{children:["NMSLIB is a ",(0,n.jsx)(i.strong,{children:"flexible, high-performance vector similarity search library"})," focused on ",(0,n.jsx)(i.strong,{children:"metric/non-metric space search"})," for high-dimensional data. Its core design prioritizes query speed and support for non-standard similarity measures, with limited semi-real-time incremental insertion (no real-time optimization). It is NOT engineered for fully online real-time workloads (high-frequency insertion/deletion) and is suitable for:"]}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"Approximate nearest neighbor (ANN) search over large, static/low-churn high-dimensional vector datasets."}),"\n",(0,n.jsxs)(i.li,{children:["Scenarios where ",(0,n.jsx)(i.strong,{children:"batch index building/periodic incremental updates"})," (hourly/daily) are acceptable."]}),"\n",(0,n.jsx)(i.li,{children:"Non-metric space search requirements (a key differentiator vs pure metric-focused engines like FAISS/NGT)."}),"\n"]}),"\n",(0,n.jsx)(i.p,{children:"Typical applications include:"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"Offline embedding retrieval for recommendation systems (precomputed user/item embeddings)."}),"\n",(0,n.jsx)(i.li,{children:"High-dimensional feature search for image/text analytics pipelines (batch processing)."}),"\n",(0,n.jsx)(i.li,{children:"Research/prototyping of non-metric similarity search (e.g., Jaccard for set-based features)."}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"algorithms-supported",children:"Algorithms Supported"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Hierarchical Navigable Small Worlds (HNSW)"})," \u2013 core algorithm for high-speed ANN search (most widely used, metric/non-metric compatible)."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Brute-force search"})," \u2013 baseline comparison (full vector scan, all distance types supported)."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"VP-trees (Vantage Point trees)"})," \u2013 optimized for low-dimensional data and some non-metric spaces (slower than HNSW for high-dim data)."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"SW-graphs (Small World graphs)"})," \u2013 lightweight alternative to HNSW for small datasets (",(0,n.jsx)(i.code,{children:"<1M"})," vectors)."]}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"core-technical-specifications",children:"Core Technical Specifications"}),"\n",(0,n.jsx)(i.h3,{id:"1-supported-metricnon-metric-spaces-official-implementation-only",children:"1. Supported Metric/Non-Metric Spaces (Official Implementation Only)"}),"\n",(0,n.jsxs)(i.p,{children:["NMSLIB supports a ",(0,n.jsx)(i.strong,{children:"targeted set of metric/non-metric spaces"})," (not all listed previously), with support varying by algorithm (HNSW has stricter limits than VP-tree/brute-force):"]}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Space Type"}),(0,n.jsx)(i.th,{children:"Distance Measure"}),(0,n.jsx)(i.th,{children:"Full Name"}),(0,n.jsx)(i.th,{children:"Supported Algorithms"}),(0,n.jsx)(i.th,{children:"Use Case Scenarios"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Metric"}),(0,n.jsx)(i.td,{children:"L2"}),(0,n.jsx)(i.td,{children:"Euclidean Distance"}),(0,n.jsx)(i.td,{children:"All (HNSW/VP-tree/SW-graph/brute)"}),(0,n.jsx)(i.td,{children:"General numerical vectors (image embeddings, dense float features)."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Metric"}),(0,n.jsx)(i.td,{children:"L1"}),(0,n.jsx)(i.td,{children:"Manhattan Distance"}),(0,n.jsx)(i.td,{children:"VP-tree/brute-force (not HNSW)"}),(0,n.jsx)(i.td,{children:"Sparse vectors, tabular data feature comparison."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Metric"}),(0,n.jsx)(i.td,{children:"Cosine"}),(0,n.jsx)(i.td,{children:"Cosine Similarity/Distance"}),(0,n.jsx)(i.td,{children:"All (HNSW/VP-tree/SW-graph/brute)"}),(0,n.jsx)(i.td,{children:"Text embeddings, direction-based vector comparison."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Non-Metric"}),(0,n.jsx)(i.td,{children:"Jaccard"}),(0,n.jsx)(i.td,{children:"Jaccard Similarity/Distance"}),(0,n.jsx)(i.td,{children:"VP-tree/brute-force (not HNSW)"}),(0,n.jsx)(i.td,{children:"Set-based vectors (boolean/sparse features, e.g., bag-of-words)."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Non-Metric"}),(0,n.jsx)(i.td,{children:"Hamming"}),(0,n.jsx)(i.td,{children:"Hamming Distance"}),(0,n.jsx)(i.td,{children:"VP-tree/brute-force (not HNSW)"}),(0,n.jsx)(i.td,{children:"Binary vectors (bitwise features, hash-based retrieval)."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Custom"}),(0,n.jsx)(i.td,{children:"User-Defined"}),(0,n.jsx)(i.td,{children:"Custom Distance Functions"}),(0,n.jsx)(i.td,{children:"Brute-force/VP-tree (limited HNSW)"}),(0,n.jsx)(i.td,{children:"Domain-specific similarity (e.g., time-series via C++ custom code)."})]})]})]}),"\n",(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.p,{children:"Critical Notes:"}),"\n",(0,n.jsxs)(i.ol,{children:["\n",(0,n.jsx)(i.li,{children:"HNSW (NMSLIB\u2019s core fast algorithm) ONLY supports L2/Cosine \u2013 no L1/Jaccard/Hamming (this is the most common misperception)."}),"\n",(0,n.jsx)(i.li,{children:"L\u221e (Chebyshev)\u3001Inner Product\u3001Edit Distance are NOT natively supported \u2013 Inner Product can be simulated via L2 after normalization, Edit Distance requires full custom implementation."}),"\n",(0,n.jsx)(i.li,{children:"Python bindings only expose L2/Cosine/Jaccard/Hamming (L1 is C++-only), custom distance functions are C++-only."}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(i.h3,{id:"2-supported-data-types-official-implementation-only",children:"2. Supported Data Types (Official Implementation Only)"}),"\n",(0,n.jsxs)(i.p,{children:["NMSLIB has ",(0,n.jsx)(i.strong,{children:"narrow data type support"})," (no official Float16/Int64 support), with optimization focused on 32-bit floats:"]}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Data Type"}),(0,n.jsx)(i.th,{children:"Precision"}),(0,n.jsx)(i.th,{children:"C++ Type"}),(0,n.jsx)(i.th,{children:"Python Binding Mapping"}),(0,n.jsx)(i.th,{children:"Support Status"}),(0,n.jsx)(i.th,{children:"Use Case"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Float32"}),(0,n.jsx)(i.td,{children:"32-bit"}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"float"})}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"numpy.float32"})}),(0,n.jsx)(i.td,{children:"Fully supported (optimal performance)"}),(0,n.jsx)(i.td,{children:"Default \u2013 balance of speed/memory/precision."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Float64 (Double)"}),(0,n.jsx)(i.td,{children:"64-bit"}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"double"})}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"numpy.float64"})}),(0,n.jsx)(i.td,{children:"Fully supported (slower than Float32)"}),(0,n.jsx)(i.td,{children:"High-precision scientific computing vectors."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Float16 (FP16)"}),(0,n.jsx)(i.td,{children:"16-bit"}),(0,n.jsx)(i.td,{children:"-"}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"numpy.float16"})}),(0,n.jsx)(i.td,{children:"Not supported (no official code)"}),(0,n.jsx)(i.td,{children:"Manual conversion to Float32 is possible but has no memory/performance benefit."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Int32"}),(0,n.jsx)(i.td,{children:"32-bit"}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"int32_t"})}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"numpy.int32"})}),(0,n.jsx)(i.td,{children:"Limited support (only L1/L2 distance)"}),(0,n.jsx)(i.td,{children:"Discrete count-based vectors (e.g., sparse features)."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Int64"}),(0,n.jsx)(i.td,{children:"64-bit"}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"int64_t"})}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"numpy.int64"})}),(0,n.jsx)(i.td,{children:"Not supported (no official implementation)"}),(0,n.jsx)(i.td,{children:"No native handling \u2013 requires custom C++ wrapping."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Binary"}),(0,n.jsx)(i.td,{children:"Bit-level"}),(0,n.jsxs)(i.td,{children:[(0,n.jsx)(i.code,{children:"uint8_t"})," (packed)"]}),(0,n.jsxs)(i.td,{children:[(0,n.jsx)(i.code,{children:"numpy.uint8"})," (bitpacked)"]}),(0,n.jsx)(i.td,{children:"Supported (only Hamming distance)"}),(0,n.jsx)(i.td,{children:"Binary vectors (bitwise features, e.g., bloom filters)."})]})]})]}),"\n",(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.p,{children:"Key Notes:"}),"\n",(0,n.jsxs)(i.ol,{children:["\n",(0,n.jsx)(i.li,{children:'Float16: NMSLIB has no native FP16 computation/storage \u2013 earlier "FP16 support" was incorrect (community hacks are unmaintained and not production-grade).'}),"\n",(0,n.jsxs)(i.li,{children:["Binary vectors: Only work with Hamming distance, require explicit bitpacking via NMSLIB\u2019s ",(0,n.jsx)(i.code,{children:"BinaryVector"})," utility (Python bindings have helper functions)."]}),"\n",(0,n.jsx)(i.li,{children:"Python bindings enforce Float32/Float64/Int32/Binary \u2013 other types throw type errors."}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(i.h3,{id:"3-real-time-data-insertiondeletion-support",children:"3. Real-Time Data Insertion/Deletion Support"}),"\n",(0,n.jsxs)(i.p,{children:["NMSLIB\u2019s dynamic update capabilities are ",(0,n.jsx)(i.strong,{children:"semi-supported for low-frequency workloads"})," but fundamentally unsuitable for strict online real-time scenarios (consistent with official limitations):"]}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Operation"}),(0,n.jsx)(i.th,{children:"Support Level"}),(0,n.jsx)(i.th,{children:"Details & Constraints"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Incremental Insertion"}),(0,n.jsx)(i.td,{children:"Partial support (semi-real-time, HNSW only)"}),(0,n.jsxs)(i.td,{children:["- HNSW index supports incremental insertion, but each insertion requires graph rebalancing (latency: ~0.1ms/vector for small indexes \u2192 10ms+/vector for 100M+ vectors).",(0,n.jsx)("br",{}),"- No batch async insertion API \u2013 high-frequency single inserts trigger lock contention.",(0,n.jsx)("br",{}),"- Maximum sustainable write QPS: ~500 (vs 10k+ for real-time engines like Milvus)."]})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Real-Time Deletion"}),(0,n.jsx)(i.td,{children:"Minimal support (non-production grade)"}),(0,n.jsxs)(i.td,{children:['- No native deletion API for any index type \u2013 users must mark vectors as "deleted" and filter results post-query.',(0,n.jsx)("br",{}),"- Physical removal of deleted vectors requires full index rebuild (no incremental cleanup).",(0,n.jsx)("br",{}),"- Deleted vectors bloat index memory and slow query performance by 30%+ over time."]})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Vector Modification"}),(0,n.jsx)(i.td,{children:"No direct support"}),(0,n.jsx)(i.td,{children:"- Modification requires deleting the original vector (mark as invalid) and re-inserting the updated version \u2013 inherits all deletion/insertion latency constraints."})]})]})]}),"\n",(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsx)(i.p,{children:"Critical Note: NMSLIB\u2019s incremental insertion is functional but not optimized for real-time use \u2013 it lacks core real-time features like in-memory write buffers, asynchronous index flushing, or distributed write handling."}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"characteristics",children:"Characteristics"}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Feature"}),(0,n.jsx)(i.th,{children:"Description"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Incremental Updates"}),(0,n.jsx)(i.td,{children:"Partial incremental insertion (HNSW only); deletion/modification not supported (mark-only)."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Query Speed"}),(0,n.jsx)(i.td,{children:"Industry-leading for static indexes (HNSW is 2-5x faster than basic NSW; Float32 > Float64); non-metric search is slower than metric."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Index Type"}),(0,n.jsx)(i.td,{children:"Hybrid (graph-based: HNSW/SW-graph; tree-based: VP-trees; brute-force)."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Scalability"}),(0,n.jsx)(i.td,{children:"Handles 100M+ vectors with disk-backed storage (memory footprint ~50% lower than NGT for Float32 vectors)."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Language Bindings"}),(0,n.jsx)(i.td,{children:"C++ (full feature set), Python (mature, limited to L2/Cosine/Jaccard/Hamming), Java/Go (community-maintained, minimal functionality)."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Non-Metric Support"}),(0,n.jsx)(i.td,{children:"Native support for Jaccard/Hamming (VP-tree/brute-force only) \u2013 unique vs NGT/FAISS/HNSWLIB."})]})]})]}),"\n",(0,n.jsx)(i.h2,{id:"notes",children:"Notes"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:["NMSLIB is ",(0,n.jsx)(i.strong,{children:"optimized for offline/static workloads"})," \u2013 its strength is fast query performance on pre-built indexes and non-metric space support, not dynamic real-time updates."]}),"\n",(0,n.jsxs)(i.li,{children:["For semi-real-time use cases (hourly batch updates), HNSW incremental insertion is usable but requires limiting index size to ",(0,n.jsx)(i.code,{children:"<10M"})," vectors to avoid latency spikes."]}),"\n",(0,n.jsx)(i.li,{children:"HNSW (NMSLIB\u2019s fastest algorithm) only supports L2/Cosine \u2013 use VP-tree/brute-force if Jaccard/Hamming is required (tradeoff: slower query speed)."}),"\n",(0,n.jsx)(i.li,{children:"Float32 is the only type for optimal performance \u2013 Float64 is 2-3x slower with no meaningful precision gain for most embeddings."}),"\n",(0,n.jsx)(i.li,{children:"Real-time alternative: For dynamic workloads requiring fast queries + real-time writes, pair NMSLIB (static historical data) with Milvus/PGVector (real-time hot data) or switch to FAISS with IVF-HNSW."}),"\n",(0,n.jsx)(i.li,{children:"Limitations: No distributed mode (single-node only), poor production documentation, limited community maintenance (last major update in 2022), Python bindings lack custom distance support."}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(a,{...e})}):a(e)}},8453:(e,i,t)=>{t.d(i,{R:()=>l,x:()=>c});var r=t(6540);const n={},s=r.createContext(n);function l(e){const i=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function c(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:l(e.components),r.createElement(s.Provider,{value:i},e.children)}}}]);