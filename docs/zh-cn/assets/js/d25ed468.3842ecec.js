"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[2185],{8453:(t,e,n)=>{n.d(e,{R:()=>a,x:()=>s});var i=n(6540);const r={},o=i.createContext(r);function a(t){const e=i.useContext(o);return i.useMemo(function(){return"function"==typeof t?t(e):{...e,...t}},[e,t])}function s(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(r):t.components||r:a(t.components),i.createElement(o.Provider,{value:e},t.children)}},9588:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"foundamentals/format/index","title":"Format & Output (String Formatting and Output)","description":"String formatting and output are high-frequency basic capabilities in the project, mainly used in scenarios such as log printing, console information output, data visualization, and business string concatenation. This module focuses on high-performance and extensible formatting solutions, which have significant performance advantages over the standard library std::printf, and also support extended capabilities such as color/stylized output and customized encapsulation for log scenarios.","source":"@site/docs/foundamentals/format/index.mdx","sourceDirName":"foundamentals/format","slug":"/foundamentals/format/","permalink":"/cppdev/zh-cn/docs/foundamentals/format/","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/foundamentals/format/index.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Base64","permalink":"/cppdev/zh-cn/docs/foundamentals/codec/base64"},"next":{"title":"High-Performance Map Container Selection Guide","permalink":"/cppdev/zh-cn/docs/foundamentals/map/"}}');var r=n(4848),o=n(8453);const a={},s="Format & Output (String Formatting and Output)",c={},d=[{value:"Core Capabilities &amp; Selection Recommendations",id:"core-capabilities--selection-recommendations",level:2},{value:"Key Supplementary Notes",id:"key-supplementary-notes",level:2},{value:"Integration Guide",id:"integration-guide",level:2}];function l(t){const e={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...t.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"format--output-string-formatting-and-output",children:"Format & Output (String Formatting and Output)"})}),"\n",(0,r.jsxs)(e.p,{children:["String formatting and output are high-frequency basic capabilities in the project, mainly used in scenarios such as log printing, console information output, data visualization, and business string concatenation. This module focuses on high-performance and extensible formatting solutions, which have significant performance advantages over the standard library ",(0,r.jsx)(e.code,{children:"std::stringstream/std::printf"}),", and also support extended capabilities such as color/stylized output and customized encapsulation for log scenarios."]}),"\n",(0,r.jsx)(e.h2,{id:"core-capabilities--selection-recommendations",children:"Core Capabilities & Selection Recommendations"}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Capability/Library"}),(0,r.jsx)(e.th,{children:"Core Description"}),(0,r.jsx)(e.th,{children:"Selection Advice"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"turbo/strings/str_format"}),(0,r.jsxs)(e.td,{children:["C-like formatting interface with syntax close to ",(0,r.jsx)(e.code,{children:"printf"}),", aligned with the project's core tech stack, no additional dependencies"]}),(0,r.jsxs)(e.td,{children:[(0,r.jsx)(e.strong,{children:"First Choice (General Formatting Scenarios)"}),"\uff1aUse for all regular string formatting needs; the interface is simple and performs better than std/abseil"]})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"turbo/strings/string_builder"}),(0,r.jsxs)(e.td,{children:["Stream-based string builder, comparable to ",(0,r.jsx)(e.code,{children:"std::stringstream"}),", with about 50% performance improvement and no redundant memory allocation"]}),(0,r.jsxs)(e.td,{children:[(0,r.jsx)(e.strong,{children:"First Choice (High-Frequency Concatenation/Large String Construction)"}),"\uff1aUse for log concatenation, batch data formatting, etc., to replace std::stringstream"]})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"abseil/strings/format"}),(0,r.jsx)(e.td,{children:"Basic formatting capabilities, indirectly introduced in the project only due to protobuf dependencies, no active integration or usage requirements"}),(0,r.jsx)(e.td,{children:"Not recommended for active use: Only compatible with legacy code; use turbo solutions for all new scenarios"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"fmtlib/fmt"}),(0,r.jsx)(e.td,{children:"Full-featured third-party formatting library with rich syntax extensions"}),(0,r.jsx)(e.td,{children:"Second Choice: Use only when turbo interfaces cannot meet special formatting needs (e.g., complex custom type formatting)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"ftxui"}),(0,r.jsx)(e.td,{children:"Independent terminal UI library that supports stylized output capabilities such as terminal text color, layout, and interactive interfaces; can be combined with fmt to achieve integrated formatting + style output"}),(0,r.jsx)(e.td,{children:"Scenario-based Recommendation: Use ftxui for console visualization and interactive output scenarios, and match with fmt for formatting logic"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"xlog"}),(0,r.jsx)(e.td,{children:"Terminal log formatting output encapsulated with fmt, adapted to the project's log system"}),(0,r.jsx)(e.td,{children:"Exclusive Scenario: Must use xlog for log output instead of directly calling fmt/turbo formatting"})]})]})]}),"\n",(0,r.jsx)(e.h2,{id:"key-supplementary-notes",children:"Key Supplementary Notes"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["Performance Priority: ",(0,r.jsx)(e.code,{children:"turbo::string_builder"})," > ",(0,r.jsx)(e.code,{children:"turbo::str_format"})," > ",(0,r.jsx)(e.code,{children:"fmtlib/fmt"})," > ",(0,r.jsx)(e.code,{children:"abseil::format"})," > ",(0,r.jsx)(e.code,{children:"std"})," standard library;"]}),"\n",(0,r.jsx)(e.li,{children:'Stylized Output: For terminal color/layout requirements, prioritize using the independent library ftxui, and match with fmt to achieve integrated "content formatting + style rendering" instead of implementing ANSI escape characters yourself to reduce compatibility issues;'}),"\n",(0,r.jsx)(e.li,{children:"Mandatory Log Scenario Specification: All log output must use xlog encapsulated interfaces; direct calls to formatting libraries for output are prohibited to ensure unified log formats."}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"integration-guide",children:"Integration Guide"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["Integrate turbo library: Refer to ",(0,r.jsx)(e.a,{href:"/cppdev/zh-cn/docs/integration/turbo",children:"integration/turbo"})]}),"\n",(0,r.jsxs)(e.li,{children:["Integrate fmtlib library: Refer to ",(0,r.jsx)(e.a,{href:"/cppdev/zh-cn/docs/integration/fmt",children:"integration/fmt"})]}),"\n",(0,r.jsxs)(e.li,{children:["Integrate ftxui library: Refer to ",(0,r.jsx)(e.a,{href:"/cppdev/zh-cn/docs/integration/ftxui",children:"integration/ftxui"})]}),"\n",(0,r.jsxs)(e.li,{children:["Integrate xlog library: Refer to ",(0,r.jsx)(e.a,{href:"/cppdev/zh-cn/docs/integration/xlog",children:"integration/xlog"})]}),"\n"]})]})}function u(t={}){const{wrapper:e}={...(0,o.R)(),...t.components};return e?(0,r.jsx)(e,{...t,children:(0,r.jsx)(l,{...t})}):l(t)}}}]);