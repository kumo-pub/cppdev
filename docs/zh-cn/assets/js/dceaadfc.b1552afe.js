"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[6456],{2938:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>a,contentTitle:()=>c,default:()=>l,frontMatter:()=>o,metadata:()=>n,toc:()=>h});const n=JSON.parse('{"id":"foundamentals/testing/doct/faq","title":"FAQ","description":"- How is doctest different from Catch?","source":"@site/docs/foundamentals/testing/doct/faq.mdx","sourceDirName":"foundamentals/testing/doct","slug":"/foundamentals/testing/doct/faq","permalink":"/cppdev/zh-cn/docs/foundamentals/testing/doct/faq","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/foundamentals/testing/doct/faq.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Extensions","permalink":"/cppdev/zh-cn/docs/foundamentals/testing/doct/extensions"},"next":{"title":"Integration and Building","permalink":"/cppdev/zh-cn/docs/foundamentals/testing/doct/build-systems"}}');var i=s(4848),r=s(8453);const o={},c="FAQ",a={},h=[{value:"<strong>How is doctest different from Catch?</strong>",id:"how-is-doctest-different-from-catch",level:3},{value:"<strong>How is doctest different from Google Test?</strong>",id:"how-is-doctest-different-from-google-test",level:3},{value:"<strong>How to get the best compile-time performance with the framework?</strong>",id:"how-to-get-the-best-compile-time-performance-with-the-framework",level:3},{value:"<strong>Is doctest thread-aware?</strong>",id:"is-doctest-thread-aware",level:3},{value:"<strong>Is mocking supported?</strong>",id:"is-mocking-supported",level:3},{value:"<strong>Why are my tests in a static library not getting registered?</strong>",id:"why-are-my-tests-in-a-static-library-not-getting-registered",level:3},{value:"<strong>Why is comparing C strings (<code>char*</code>) actually comparing pointers?</strong>",id:"why-is-comparing-c-strings-char-actually-comparing-pointers",level:3},{value:"<strong>How to write tests in header-only libraries?</strong>",id:"how-to-write-tests-in-header-only-libraries",level:3},{value:"<strong>Does the framework use exceptions?</strong>",id:"does-the-framework-use-exceptions",level:3},{value:"<strong>Why do I get compiler errors in STL headers when including the doctest header?</strong>",id:"why-do-i-get-compiler-errors-in-stl-headers-when-including-the-doctest-header",level:3},{value:"<strong>Can different versions of the framework be used within the same binary (executable/dll)?</strong>",id:"can-different-versions-of-the-framework-be-used-within-the-same-binary-executabledll",level:3},{value:"<strong>Why is doctest using macros?</strong>",id:"why-is-doctest-using-macros",level:3},{value:"<strong>How to use with multiple files?</strong>",id:"how-to-use-with-multiple-files",level:3}];function d(e){const t={a:"a",code:"code",h1:"h1",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"faq",children:"FAQ"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#how-is-doctest-different-from-catch",children:(0,i.jsx)(t.strong,{children:"How is doctest different from Catch?"})})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#how-is-doctest-different-from-google-test",children:(0,i.jsx)(t.strong,{children:"How is doctest different from Google Test?"})})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#how-to-get-the-best-compile-time-performance-with-the-framework",children:(0,i.jsx)(t.strong,{children:"How to get the best compile-time performance with the framework?"})})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#is-doctest-thread-aware",children:(0,i.jsx)(t.strong,{children:"Is doctest thread-aware?"})})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#is-mocking-supported",children:(0,i.jsx)(t.strong,{children:"Is mocking supported?"})})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#why-are-my-tests-in-a-static-library-not-getting-registered",children:(0,i.jsx)(t.strong,{children:"Why are my tests in a static library not getting registered?"})})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#why-is-comparing-c-strings-char-actually-comparing-pointers",children:(0,i.jsxs)(t.strong,{children:["Why is comparing C strings (",(0,i.jsx)(t.code,{children:"char*"}),") actually comparing pointers?"]})})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#how-to-write-tests-in-header-only-libraries",children:(0,i.jsx)(t.strong,{children:"How to write tests in header-only libraries?"})})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#does-the-framework-use-exceptions",children:(0,i.jsx)(t.strong,{children:"Does the framework use exceptions?"})})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#why-do-i-get-compiler-errors-in-stl-headers-when-including-the-doctest-header",children:(0,i.jsx)(t.strong,{children:"Why do I get compiler errors in STL headers when including the doctest header?"})})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#can-different-versions-of-the-framework-be-used-within-the-same-binary-executabledll",children:(0,i.jsx)(t.strong,{children:"Can different versions of the framework be used within the same binary (executable/dll)?"})})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#why-is-doctest-using-macros",children:(0,i.jsx)(t.strong,{children:"Why is doctest using macros?"})})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#how-to-use-with-multiple-files",children:(0,i.jsx)(t.strong,{children:"How to use with multiple files?"})})}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"how-is-doctest-different-from-catch",children:(0,i.jsx)(t.strong,{children:"How is doctest different from Catch?"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Advantages of doctest"}),":"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"doctest"})," is ",(0,i.jsx)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/doct/faq#is-doctest-thread-aware",children:(0,i.jsx)(t.strong,{children:"thread-safe"})})]}),"\n",(0,i.jsxs)(t.li,{children:["Assertions can be used ",(0,i.jsx)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/doct/assertions#using-asserts-out-of-a-testing-context",children:(0,i.jsx)(t.strong,{children:"outside of a testing context"})})]}),"\n",(0,i.jsxs)(t.li,{children:["Using the ",(0,i.jsx)(t.strong,{children:"doctest"})," header results in ",(0,i.jsx)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/doct/benchmarks#cost-of-including-the-header",children:(0,i.jsx)(t.strong,{children:"20x faster compile times"})})," compared to ",(0,i.jsx)(t.a,{href:"https://github.com/catchorg/Catch2",children:(0,i.jsx)(t.strong,{children:"Catch"})})]}),"\n",(0,i.jsxs)(t.li,{children:["Assertions in ",(0,i.jsx)(t.strong,{children:"doctest"})," compile faster than those in ",(0,i.jsx)(t.a,{href:"https://github.com/catchorg/Catch2",children:(0,i.jsx)(t.strong,{children:"Catch"})})]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"doctest"})," executes tests ",(0,i.jsx)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/doct/benchmarks#runtime-benchmarks",children:(0,i.jsx)(t.strong,{children:"many times faster"})})," than ",(0,i.jsx)(t.a,{href:"https://github.com/catchorg/Catch2",children:(0,i.jsx)(t.strong,{children:"Catch"})})]}),"\n",(0,i.jsxs)(t.li,{children:["All test-related content can be removed from the binary by defining the ",(0,i.jsx)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/doct/configuration#doctest_config_disable",children:(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"DOCTEST_CONFIG_DISABLE"})})})," identifier"]}),"\n",(0,i.jsx)(t.li,{children:"Does not pull in any headers when included (except in the translation unit that implements the library)"}),"\n",(0,i.jsxs)(t.li,{children:["Zero warnings even at ",(0,i.jsx)(t.a,{href:"https://github.com/doctest/doctest/blob/master/scripts/cmake/common.cmake#L84",children:(0,i.jsx)(t.strong,{children:"the most aggressive"})})," warning levels for MSVC/GCC/Clang"]}),"\n",(0,i.jsxs)(t.li,{children:["Tested with over 180 builds on ",(0,i.jsx)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/doct/features#extremely-portable",children:(0,i.jsx)(t.strong,{children:"more compilers"})})," for every commit - and validated with valgrind/sanitizers/analyzers"]}),"\n",(0,i.jsx)(t.li,{children:"Test cases can be written in headers - the framework still registers tests only once - no duplicates"}),"\n",(0,i.jsxs)(t.li,{children:["A binary (exe/dll) can use the test runner of another binary - so tests end up in a single registry - ",(0,i.jsx)(t.a,{href:"https://github.com/doctest/doctest/blob/master/examples/executable_dll_and_plugin/",children:(0,i.jsx)(t.strong,{children:"example"})})]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["In addition to everything mentioned so far, doctest has some ",(0,i.jsx)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/doct/features#other-features",children:(0,i.jsx)(t.strong,{children:"features"})})," (such as ",(0,i.jsx)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/doct/testcases#test-suites",children:(0,i.jsx)(t.strong,{children:"test suites"})})," and ",(0,i.jsx)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/doct/testcases#decorators",children:(0,i.jsx)(t.strong,{children:"decorators"})}),") that ",(0,i.jsx)(t.a,{href:"https://github.com/catchorg/Catch2",children:(0,i.jsx)(t.strong,{children:"Catch"})})," does not have."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Missing features"}),":"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Matchers and generators"}),"\n",(0,i.jsxs)(t.li,{children:["Microbenchmarking support - nonius for ",(0,i.jsx)(t.a,{href:"https://github.com/catchorg/Catch2",children:(0,i.jsx)(t.strong,{children:"Catch"})})]}),"\n",(0,i.jsx)(t.li,{children:"Other small things like tags - which can be easily emulated/migrated - see below"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["But these things (and more!) are planned in the ",(0,i.jsx)(t.a,{href:"https://github.com/doctest/doctest/issues/600",children:(0,i.jsx)(t.strong,{children:"roadmap"})}),"!"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"doctest"})," can be considered a very refined, lightweight, stable, and clean subset (or reimplementation) of ",(0,i.jsx)(t.a,{href:"https://github.com/catchorg/Catch2",children:(0,i.jsx)(t.strong,{children:"Catch"})}),", but this may change in the future as more features are added."]}),"\n",(0,i.jsxs)(t.p,{children:["Also check out ",(0,i.jsx)(t.a,{href:"https://github.com/martinmoene/catch-lest-other-comparison",children:"this table"})," which compares ",(0,i.jsx)(t.strong,{children:"doctest"})," / ",(0,i.jsx)(t.a,{href:"https://github.com/catchorg/Catch2",children:(0,i.jsx)(t.strong,{children:"Catch"})})," / ",(0,i.jsx)(t.a,{href:"https://github.com/martinmoene/lest",children:(0,i.jsx)(t.strong,{children:"lest"})}),"."]}),"\n",(0,i.jsx)(t.p,{children:'A quick and easy way to migrate most Catch tests to doctest is to change the "TEST_CASE" (if tags are used) and "SECTION" macros as follows:'}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c++",children:'#include "path/to/doctest.h"\n\n#define SECTION(name) DOCTEST_SUBCASE(name)\n\n// only if tags are used: will concatenate them to the test name string literal\n#undef TEST_CASE\n#define TEST_CASE(name, tags) DOCTEST_TEST_CASE(tags " " name)\n\n// catch exposes this by default outside of its namespace\nusing doctest::Approx;\n'})}),"\n",(0,i.jsx)(t.h3,{id:"how-is-doctest-different-from-google-test",children:(0,i.jsx)(t.strong,{children:"How is doctest different from Google Test?"})}),"\n",(0,i.jsx)(t.p,{children:"Here are some differences:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"The main point is that doctest is the only C++ framework that can be used alongside production code (compile speed, ability to remove tests from binaries, ability to execute tests/code/both, ability to have tests in multiple shared objects and still have a single registry for all of them)"}),"\n",(0,i.jsx)(t.li,{children:"doctest is header-only - Google Test must be built as a separate static library and linked against"}),"\n",(0,i.jsxs)(t.li,{children:["doctest has the concept of ",(0,i.jsx)(t.a,{href:"https://github.com/doctest/doctest/blob/master/doc/markdown/tutorial.mdx#test-cases-and-subcases",children:(0,i.jsx)(t.strong,{children:"Subcases"})}),", which is a much cleaner way to share setup and teardown code between tests compared to fixtures and class inheritance - Google Test is very verbose!"]}),"\n",(0,i.jsx)(t.li,{children:"doctest compiles faster and likely runs faster (though runtime only becomes an issue when you have millions of assertions)"}),"\n",(0,i.jsx)(t.li,{children:"doctest assertions are thread-safe even on Windows (Google Test uses pthreads, so thread-safe assertions are only available on UNIX)"}),"\n",(0,i.jsx)(t.li,{children:"doctest has a simpler API overall"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"But doctest also has some shortcomings:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Value-parameterized tests"}),"\n",(0,i.jsx)(t.li,{children:"Death tests (checking if calling a certain function does not simply throw an exception but causes the process to crash)"}),"\n",(0,i.jsx)(t.li,{children:"doctest has some integration with mocking libraries, but Google Test works perfectly with Google Mock (though doctest should theoretically work with it as well)"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Areas where doctest is lacking are planned for improvement in the future. There are many other smaller differences - covering all of them is impractical."}),"\n",(0,i.jsx)(t.h3,{id:"how-to-get-the-best-compile-time-performance-with-the-framework",children:(0,i.jsx)(t.strong,{children:"How to get the best compile-time performance with the framework?"})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/doct/configuration#doctest_config_super_fast_asserts",children:(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"DOCTEST_CONFIG_SUPER_FAST_ASSERTS"})})})," configuration option yields the ",(0,i.jsx)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/doct/benchmarks#cost-of-an-assertion-macro",children:(0,i.jsx)(t.strong,{children:"fastest possible"})})," compile times (up to 31-91% faster). Additionally, the expression decomposition template mechanism can be skipped by using ",(0,i.jsx)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/doct/assertions#binary-and-unary-asserts",children:(0,i.jsx)(t.strong,{children:"binary"})})," assertions."]}),"\n",(0,i.jsx)(t.p,{children:"There are only two minor drawbacks to using this configuration option:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["No ",(0,i.jsx)(t.code,{children:"try/catch"})," blocks within each assertion, so if an expression throws, the entire test case ends (but is still caught and reported)."]}),"\n",(0,i.jsx)(t.li,{children:"When an assertion fails and a debugger is attached - the framework will break inside a doctest function, so the user has to go one level up in the call stack to see where the actual assertion is in the source code."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"These two things can be considered negligible and completely worth it if you are mainly dealing with expressions that are unlikely to throw exceptions and all tests usually pass (you don't need to navigate to failed assertions with a debugger attached often)."}),"\n",(0,i.jsx)(t.h3,{id:"is-doctest-thread-aware",children:(0,i.jsx)(t.strong,{children:"Is doctest thread-aware?"})}),"\n",(0,i.jsxs)(t.p,{children:["Most macros/features can be used safely in a multithreaded context: ",(0,i.jsx)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/doct/assertions",children:(0,i.jsx)(t.strong,{children:"assertion"})})," and ",(0,i.jsx)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/doct/logging",children:(0,i.jsx)(t.strong,{children:"logging"})})," macros can be used safely from multiple threads spawned by a single test case. However, this does not mean multiple test cases can run in parallel - test cases still run serially. ",(0,i.jsx)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/doct/tutorial#test-cases-and-subcases",children:(0,i.jsx)(t.strong,{children:"Subcases"})})," should also only be used in the test-running thread, and all threads spawned within a subcase should be joined before that subcase ends, and no new threads should enter a subcase while other threads containing doctest assertions are still running - not following these instructions will result in crashes (",(0,i.jsx)(t.a,{href:"https://gitee.com/kumo-hub/doctest/tree/examples/master/examples/all_features/concurrency.cpp",children:(0,i.jsx)(t.strong,{children:"example here"})}),"). Also note that context logged in one thread will not be used/printed when an assertion fails in another thread - logged context is thread-local."]}),"\n",(0,i.jsxs)(t.p,{children:["There is also an option to run ",(0,i.jsx)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/doct/commandline",children:(0,i.jsx)(t.strong,{children:"range"})})," tests from the executable - so tests can be run in parallel by invoking the process multiple times with different ranges - see ",(0,i.jsx)(t.a,{href:"https://github.com/doctest/doctest/blob/master/examples/range_based_execution.py",children:(0,i.jsx)(t.strong,{children:"example python script"})}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"is-mocking-supported",children:(0,i.jsx)(t.strong,{children:"Is mocking supported?"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"doctest"})," does not support mocking natively, but should integrate easily with third-party libraries such as:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"https://github.com/rollbear/trompeloeil",children:"trompeloeil"})," - integration shown ",(0,i.jsx)(t.a,{href:"https://github.com/rollbear/trompeloeil/blob/master/docs/CookBook.mdx#adapt_doctest",children:"here"})]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"https://github.com/eranpeer/FakeIt",children:"FakeIt"})," - integration is likely similar to ",(0,i.jsx)(t.a,{href:"https://github.com/eranpeer/FakeIt/tree/master/config/catch",children:"catch"}),", but this has not been investigated yet"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["By using ",(0,i.jsx)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/doct/logging#messages-which-can-optionally-fail-test-cases",children:(0,i.jsx)(t.strong,{children:"logging"})})," macros such as ",(0,i.jsx)(t.code,{children:"ADD_FAIL_AT(file, line, message)"})]}),"\n",(0,i.jsx)(t.h3,{id:"why-are-my-tests-in-a-static-library-not-getting-registered",children:(0,i.jsx)(t.strong,{children:"Why are my tests in a static library not getting registered?"})}),"\n",(0,i.jsxs)(t.p,{children:["This is a ",(0,i.jsx)(t.a,{href:"https://groups.google.com/forum/#!msg/catch-forum/FV0Qo62DvgY/jxEO6c9_q3kJ",children:(0,i.jsx)(t.strong,{children:"common problem in libraries with self-registering code"})})," that affects all modern compilers on all platforms."]}),"\n",(0,i.jsx)(t.p,{children:"The issue is that when a static library is linked into a binary (executable or dll), only the object files in the static library that define symbols needed by the binary are pulled in (this is linker/dependency optimization)."}),"\n",(0,i.jsx)(t.p,{children:"One way to solve this in CMake is to use an object library instead of a static library - like this:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cmake",children:"add_library(with_tests OBJECT src_1.cpp src_2.cpp src_3.cpp ...)\n\nadd_library(dll SHARED $<TARGET_OBJECTS:with_tests> dll_src_1.cpp ...)\nadd_executable(exe $<TARGET_OBJECTS:with_tests> exe_src_1.cpp ...)\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Thanks to ",(0,i.jsx)(t.a,{href:"https://github.com/pthom",children:"pthom"})," for the suggestion."]}),"\n",(0,i.jsxs)(t.p,{children:["As an alternative, I created a CMake function that forces every object file in a static library to be linked into a binary target - it's called ",(0,i.jsx)(t.a,{href:"https://github.com/doctest/doctest/blob/master/examples/exe_with_static_libs/doctest_force_link_static_lib_in_target.cmake",children:(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"doctest_force_link_static_lib_in_target()"})})}),". It is non-intrusive - no source files are changed - everything is done via compiler flags for each source file. An example project using it can be found ",(0,i.jsx)(t.a,{href:"https://github.com/doctest/doctest/blob/master/examples/exe_with_static_libs",children:(0,i.jsx)(t.strong,{children:"here"})})," - check the commented sections of the CMakeLists.txt file."]}),"\n",(0,i.jsx)(t.p,{children:"It does not work in two cases:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["The target or library uses precompiled headers - see ",(0,i.jsx)(t.a,{href:"https://github.com/doctest/doctest/issues/21#issuecomment-247001423",children:(0,i.jsx)(t.strong,{children:"this"})})," issue for details"]}),"\n",(0,i.jsx)(t.li,{children:"The target or library is an imported target (prebuilt) and not built in the current cmake tree"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["You can also check out this repository for a different solution: ",(0,i.jsx)(t.a,{href:"https://github.com/pthom/doctest_registerlibrary",children:(0,i.jsx)(t.strong,{children:"pthom/doctest_registerlibrary"})}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["A compiler-specific solution for MSVC is to use the ",(0,i.jsx)(t.a,{href:"https://msdn.microsoft.com/en-us/library/bxwfs976.aspx",children:(0,i.jsx)(t.code,{children:"/OPT:NOREF"})})," linker flag (thanks to ",(0,i.jsx)(t.a,{href:"https://github.com/Lectem",children:"lectem"})," for ",(0,i.jsx)(t.a,{href:"https://github.com/doctest/doctest/issues/106",children:"reporting"})," it!). Another option is to look at ",(0,i.jsx)(t.a,{href:"https://docs.microsoft.com/en-us/cpp/build/reference/wholearchive-include-all-library-object-files?vie=vs-2019",children:(0,i.jsx)(t.code,{children:"/wholearchive"})})," for MSVC."]}),"\n",(0,i.jsx)(t.h3,{id:"why-is-comparing-c-strings-char-actually-comparing-pointers",children:(0,i.jsxs)(t.strong,{children:["Why is comparing C strings (",(0,i.jsx)(t.code,{children:"char*"}),") actually comparing pointers?"]})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"doctest"})," treats ",(0,i.jsx)(t.code,{children:"char*"})," as ordinary pointers by default. Using ",(0,i.jsx)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/doct/configuration#doctest_config_treat_char_star_as_string",children:(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING"})})})," changes this behavior."]}),"\n",(0,i.jsx)(t.h3,{id:"how-to-write-tests-in-header-only-libraries",children:(0,i.jsx)(t.strong,{children:"How to write tests in header-only libraries?"})}),"\n",(0,i.jsx)(t.p,{children:"There are 2 options:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Simply include the doctest header in your header and write tests - the doctest header should be shipped with your header, and users must implement the doctest runner in one of their source files."}),"\n",(0,i.jsxs)(t.li,{children:["Do not include the doctest header, and guard your test cases with ",(0,i.jsx)(t.code,{children:"#ifdef DOCTEST_LIBRARY_INCLUDED"})," and ",(0,i.jsx)(t.code,{children:"#endif"})," - this way, if the user has included the doctest header before your header, your tests will be compiled and registered (they also have to implement the test runner somewhere)."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Also note that it's a good idea to add a tag to your test case names (like this: ",(0,i.jsx)(t.code,{children:'TEST_CASE("[the_lib]testing foo")'}),"), so users can easily filter them out with ",(0,i.jsx)(t.code,{children:"--test-case-exclude=*the_lib*"})," if they wish."]}),"\n",(0,i.jsx)(t.h3,{id:"does-the-framework-use-exceptions",children:(0,i.jsx)(t.strong,{children:"Does the framework use exceptions?"})}),"\n",(0,i.jsxs)(t.p,{children:["Yes - but they can be disabled - see the ",(0,i.jsx)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/doct/configuration#doctest_config_no_exceptions",children:(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"DOCTEST_CONFIG_NO_EXCEPTIONS"})})})," configuration identifier."]}),"\n",(0,i.jsx)(t.h3,{id:"why-do-i-get-compiler-errors-in-stl-headers-when-including-the-doctest-header",children:(0,i.jsx)(t.strong,{children:"Why do I get compiler errors in STL headers when including the doctest header?"})}),"\n",(0,i.jsxs)(t.p,{children:["Try using the ",(0,i.jsx)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/doct/configuration#doctest_config_use_std_headers",children:(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"DOCTEST_CONFIG_USE_STD_HEADERS"})})})," configuration identifier."]}),"\n",(0,i.jsx)(t.h3,{id:"can-different-versions-of-the-framework-be-used-within-the-same-binary-executabledll",children:(0,i.jsx)(t.strong,{children:"Can different versions of the framework be used within the same binary (executable/dll)?"})}),"\n",(0,i.jsxs)(t.p,{children:["Not currently. Single-header libraries like ",(0,i.jsx)(t.a,{href:"https://github.com/nothings/stb",children:(0,i.jsx)(t.strong,{children:"stb"})})," offer this as an option (everything is declared static - giving it internal linkage), but this doesn't make much logical sense for ",(0,i.jsx)(t.strong,{children:"doctest"})," - the point is to write tests in any source file of the project and implement the test runner in only one source file."]}),"\n",(0,i.jsx)(t.h3,{id:"why-is-doctest-using-macros",children:(0,i.jsx)(t.strong,{children:"Why is doctest using macros?"})}),"\n",(0,i.jsxs)(t.p,{children:["Aren't they evil and not \"modern\"? - Check out Phil Nash's answer to this question ",(0,i.jsx)(t.a,{href:"http://accu.org/index.php/journals/2064",children:(0,i.jsx)(t.strong,{children:"here"})})," (creator of ",(0,i.jsx)(t.a,{href:"https://github.com/catchorg/Catch2",children:(0,i.jsx)(t.strong,{children:"Catch"})}),")."]}),"\n",(0,i.jsx)(t.h3,{id:"how-to-use-with-multiple-files",children:(0,i.jsx)(t.strong,{children:"How to use with multiple files?"})}),"\n",(0,i.jsxs)(t.p,{children:["All you need to do is define ",(0,i.jsx)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/doct/configuration#doctest_config_implement_with_main",children:(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN"})})})," or ",(0,i.jsx)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/doct/configuration#doctest_config_implement",children:(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"DOCTEST_CONFIG_IMPLEMENT"})})})," in only one of your source files before including the doctest header - in all other source files, you just include the header and use the framework. The difference between the two is that one provides a ",(0,i.jsx)(t.code,{children:"main()"})," entry point - see ",(0,i.jsx)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/doct/main",children:(0,i.jsx)(t.code,{children:"main() entry point"})})," for more information."]})]})}function l(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>o,x:()=>c});var n=s(6540);const i={},r=n.createContext(i);function o(e){const t=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);