"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[1773],{4932:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>u,frontMatter:()=>o,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"testing/doct/tutorial","title":"Quick Start","description":"To get started with doctest, install doctest using kmpkg:","source":"@site/docs/testing/doct/tutorial.mdx","sourceDirName":"testing/doct","slug":"/testing/doct/tutorial","permalink":"/cppdev/zh-cn/docs/testing/doct/tutorial","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/testing/doct/tutorial.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Overview","permalink":"/cppdev/zh-cn/docs/testing/doct/overview"},"next":{"title":"Assertions","permalink":"/cppdev/zh-cn/docs/testing/doct/assertions"}}');var i=s(4848),a=s(8453);const r=s.p+"assets/images/doctest_code_line-6adf8ddfbc9ecba029e74d4471088678.png",o={},c="Quick Start",d={},l=[{value:"A Simple Example",id:"a-simple-example",level:2},{value:"What Did We Do Here?",id:"what-did-we-do-here",level:2},{value:"Test Cases and Subcases",id:"test-cases-and-subcases",level:2},{value:"Scaling Up",id:"scaling-up",level:2},{value:"Next Steps",id:"next-steps",level:2}];function h(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"quick-start",children:"Quick Start"})}),"\n",(0,i.jsxs)(t.p,{children:["To get started with ",(0,i.jsx)(t.strong,{children:"doctest"}),", install ",(0,i.jsx)(t.code,{children:"doctest"})," using ",(0,i.jsx)(t.code,{children:"kmpkg"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-shell",children:"kmpkg install doctest\n"})}),"\n",(0,i.jsxs)(t.p,{children:["You can also download the ",(0,i.jsx)(t.a,{href:"https://raw.githubusercontent.com/doctest/doctest/master/doctest/doctest.h",children:(0,i.jsx)(t.strong,{children:"latest version"})})," (it\u2019s just a single header file) and include it in your source files (or add this repository as a git submodule)."]}),"\n",(0,i.jsxs)(t.p,{children:["This tutorial assumes you can use the header directly: ",(0,i.jsx)(t.code,{children:'#include "doctest.h"'})," \u2013 so it is either in the same folder as your test source files, or you have correctly set up its include path in your build system."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Test-driven_development",children:"TDD"})," is not discussed in this tutorial."]}),"\n",(0,i.jsx)(t.h2,{id:"a-simple-example",children:"A Simple Example"}),"\n",(0,i.jsxs)(t.p,{children:["Suppose we have a ",(0,i.jsx)(t.code,{children:"factorial()"})," function to test:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c++",children:"int factorial(int number) {\n    return number <= 1 ? number : factorial(number - 1) * number;\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"A complete compilable example with self-registering tests looks like this:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c++",children:'#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN\n#include "doctest.h"\n\nint factorial(int number) { return number <= 1 ? number : factorial(number - 1) * number; }\n\nTEST_CASE("testing the factorial function") {\n    CHECK(factorial(1) == 1);\n    CHECK(factorial(2) == 2);\n    CHECK(factorial(3) == 6);\n    CHECK(factorial(10) == 3628800);\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["This compiles into a full executable that responds to command-line arguments. If you run it without any arguments, it will execute all test cases (in this case \u2013 only one), report any failures, output a summary of the number of passed and failed tests, and return 0 on success, 1 if failed (useful if you just want a yes/no answer: ",(0,i.jsx)(t.code,{children:"does it work"}),")."]}),"\n",(0,i.jsxs)(t.p,{children:["If you run it as written, it will pass. All good. Right? Well, there\u2019s still a bug here. We missed checking if ",(0,i.jsx)(t.code,{children:"factorial(0) == 1"}),", so let\u2019s add that check too:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c++",children:'TEST_CASE("testing the factorial function") {\n    CHECK(factorial(0) == 1);\n    CHECK(factorial(1) == 1);\n    CHECK(factorial(2) == 2);\n    CHECK(factorial(3) == 6);\n    CHECK(factorial(10) == 3628800);\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:"Now we get a failure \u2013 something like:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"test.cpp(7) FAILED!\n  CHECK( factorial(0) == 1 )\nwith expansion:\n  CHECK( 0 == 1 )\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Note that we get the actual return value (0) of ",(0,i.jsx)(t.code,{children:"factorial(0)"})," printed for us \u2013 even though we used a natural expression with the ",(0,i.jsx)(t.code,{children:"=="})," operator. This lets us see the problem immediately."]}),"\n",(0,i.jsx)(t.p,{children:"Let\u2019s change the factorial function to:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c++",children:"int factorial(int number) { return number > 1 ? factorial(number - 1) * number : 1; }\n"})}),"\n",(0,i.jsx)(t.p,{children:"Now all tests pass."}),"\n",(0,i.jsxs)(t.p,{children:["Of course, there are more issues to handle. For example, we\u2019ll run into problems when the return value starts to exceed the range of ",(0,i.jsx)(t.code,{children:"int"}),". For factorial, this can happen quite quickly. You may want to add tests for such cases and decide how to handle them. We won\u2019t do that here."]}),"\n",(0,i.jsx)(t.h2,{id:"what-did-we-do-here",children:"What Did We Do Here?"}),"\n",(0,i.jsxs)(t.p,{children:["Although this is a simple test, it\u2019s enough to demonstrate a few key points about using ",(0,i.jsx)(t.strong,{children:"doctest"}),"."]}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["All we did was ",(0,i.jsx)(t.code,{children:"#define"})," an identifier and ",(0,i.jsx)(t.code,{children:"#include"})," a header, and we got everything \u2013 even a ",(0,i.jsx)(t.code,{children:"main()"})," implementation that responds to command-line arguments. For (hopefully) obvious reasons, you can only use this ",(0,i.jsx)(t.code,{children:"#define"})," in one source file. Once you have multiple files containing unit tests, you just ",(0,i.jsx)(t.code,{children:'#include "doctest.h"'}),". Typically, it\u2019s best to have a dedicated implementation file containing nothing but ",(0,i.jsx)(t.code,{children:"#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN"})," and ",(0,i.jsx)(t.code,{children:'#include "doctest.h"'}),". You can also provide your own ",(0,i.jsx)(t.code,{children:"main"})," function and drive the ",(0,i.jsx)(t.strong,{children:"doctest"})," implementation yourself \u2013 see ",(0,i.jsx)(t.a,{href:"/cppdev/zh-cn/docs/testing/doct/main",children:(0,i.jsxs)(t.strong,{children:["Providing your own ",(0,i.jsx)(t.code,{children:"main()"})]})}),"."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["We introduced a test case with the ",(0,i.jsx)(t.code,{children:"TEST_CASE"})," macro. It takes one parameter \u2013 a free-form test name (see ",(0,i.jsx)(t.a,{href:"/cppdev/zh-cn/docs/testing/doct/testcases",children:(0,i.jsx)(t.strong,{children:"Test Cases and Subcases"})})," for more details). Test names do not have to be unique. You can run a set of tests by specifying wildcard test names or tag expressions. See the ",(0,i.jsx)(t.a,{href:"/cppdev/zh-cn/docs/testing/doct/commandline",children:(0,i.jsx)(t.strong,{children:"Command Line"})})," documentation for more information on running tests."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"The name is just a string. We didn\u2019t have to declare a function or method \u2013 or explicitly register the test case anywhere. Behind the scenes, the system defines a function with a generated name for you and automatically registers it using a static registry class. By abstracting away the function name, we can name our tests without being limited by identifier naming rules."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["We wrote individual test assertions using the ",(0,i.jsx)(t.code,{children:"CHECK()"})," macro. We expressed the condition naturally using standard C++ syntax, rather than using separate macros for each type of condition (equals, less than, greater than, etc.). Behind the scenes, a simple expression template captures the left and right sides of the expression, allowing us to display their values in the test report. Other ",(0,i.jsx)(t.a,{href:"/cppdev/zh-cn/docs/testing/doct/assertions",children:(0,i.jsx)(t.strong,{children:"Assertion Macros"})})," are not covered in this tutorial \u2013 but their number is greatly reduced thanks to this technique."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"test-cases-and-subcases",children:"Test Cases and Subcases"}),"\n",(0,i.jsxs)(t.p,{children:["Most test frameworks have class-based fixture mechanisms \u2013 test cases map to methods on a class, and setup/teardown logic can be placed in ",(0,i.jsx)(t.code,{children:"setup()"})," and ",(0,i.jsx)(t.code,{children:"teardown()"})," methods (or constructors/destructors in languages like C++ that support deterministic destruction)."]}),"\n",(0,i.jsxs)(t.p,{children:["While ",(0,i.jsx)(t.strong,{children:"doctest"})," fully supports this approach, it has some drawbacks. In particular, the way code must be split and its inflexible granularity can cause issues. You only get one setup/teardown pair for a set of methods, but sometimes you want slightly different setup for each method, or you may even need multiple levels of setup (we\u2019ll clarify this concept later in the tutorial). It was ",(0,i.jsx)(t.a,{href:"http://jamesnewkirk.typepad.com/posts/2007/09/why-you-should-.html",children:(0,i.jsx)(t.strong,{children:"problems like this"})})," that led James Newkirk (who led the team that built NUnit) to start building ",(0,i.jsx)(t.a,{href:"http://jamesnewkirk.typepad.com/posts/2007/09/announcing-xuni.html",children:(0,i.jsx)(t.strong,{children:"xUnit"})})," from scratch."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"doctest"})," takes a different approach (compared to both NUnit and xUnit) that fits more naturally with C++ and the C family of languages."]}),"\n",(0,i.jsx)(t.p,{children:"This is best explained with an example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c++",children:'TEST_CASE("vectors can be sized and resized") {\n    std::vector<int> v(5);\n\n    REQUIRE(v.size() == 5);\n    REQUIRE(v.capacity() >= 5);\n\n    SUBCASE("adding to the vector increases its size") {\n        v.push_back(1);\n\n        CHECK(v.size() == 6);\n        CHECK(v.capacity() >= 6);\n    }\n    SUBCASE("reserving increases just the capacity") {\n        v.reserve(6);\n\n        CHECK(v.size() == 5);\n        CHECK(v.capacity() >= 6);\n    }\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["For each ",(0,i.jsx)(t.code,{children:"SUBCASE()"}),", the ",(0,i.jsx)(t.code,{children:"TEST_CASE()"})," is executed from the start \u2013 so when we enter each subcase, we know the size is 5 and the capacity is at least 5. We enforce these requirements at the top level with the ",(0,i.jsx)(t.code,{children:"REQUIRE()"})," macro, so we can be confident in them. If a ",(0,i.jsx)(t.code,{children:"CHECK()"})," fails \u2013 the test is marked as failed but execution continues \u2013 but if a ",(0,i.jsx)(t.code,{children:"REQUIRE()"})," fails \u2013 test execution stops immediately."]}),"\n",(0,i.jsxs)(t.p,{children:["This works because the ",(0,i.jsx)(t.code,{children:"SUBCASE()"})," macro contains an ",(0,i.jsx)(t.code,{children:"if"})," statement that calls back into ",(0,i.jsx)(t.strong,{children:"doctest"})," to check if the subcase should be executed. One leaf case is executed each time the ",(0,i.jsx)(t.code,{children:"TEST_CASE()"})," runs. Other subcases are skipped. On the next run, the next subcase is executed, and so on until no new subcases are left."]}),"\n",(0,i.jsx)(t.p,{children:"So far so good \u2013 this is already an improvement over setup/teardown methods because our setup code is now inline and uses the stack. The real power of subcases becomes evident when we start nesting them, as in the following example:"}),"\n","\n",(0,i.jsx)("img",{src:r}),"\n",(0,i.jsx)(t.p,{children:"Subcases can be nested to any depth (limited only by stack size). Each leaf case (a subcase with no nested subcases) is executed exactly once on a unique execution path (so no leaf case interferes with another). A fatal failure in a parent subcase will prevent nested subcases from running \u2013 but that\u2019s intentional."}),"\n",(0,i.jsxs)(t.p,{children:["Remember that even though ",(0,i.jsx)(t.strong,{children:"doctest"})," is ",(0,i.jsx)(t.a,{href:"/cppdev/zh-cn/docs/testing/doct/faq#is-doctest-thread-aware",children:(0,i.jsx)(t.strong,{children:"thread-safe"})})," \u2013 subcases can only be used in the main test runner thread. Threads spawned in any subcase should be joined before the subcase ends, and new subcases should not be entered while other threads containing doctest assertions are still running."]}),"\n",(0,i.jsx)(t.h2,{id:"scaling-up",children:"Scaling Up"}),"\n",(0,i.jsxs)(t.p,{children:["To keep the tutorial simple, we put all the code in one file. This is fine for getting started \u2013 and makes it quicker and easier to start using ",(0,i.jsx)(t.strong,{children:"doctest"}),". However, this isn\u2019t the best approach when you start writing more realistic tests."]}),"\n",(0,i.jsxs)(t.p,{children:["The requirement is that the following code block (",(0,i.jsx)(t.a,{href:"/cppdev/zh-cn/docs/testing/doct/main",children:(0,i.jsx)(t.strong,{children:"or equivalent"})}),"):"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c++",children:'#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN\n#include "doctest.h"\n'})}),"\n",(0,i.jsxs)(t.p,{children:["appears ",(0,i.jsx)(t.em,{children:"exactly"})," once in one translation unit (source file). You can use as many additional source files as needed for your tests \u2013 partition them in a way that makes the most sense for your workflow. Each additional file only needs to ",(0,i.jsx)(t.code,{children:'#include "doctest.h"'})," \u2013 do ",(0,i.jsx)(t.strong,{children:"not"})," repeat the ",(0,i.jsx)(t.code,{children:"#define"}),"! In fact, it\u2019s often a good idea to put the block with the ",(0,i.jsx)(t.code,{children:"#define"})," into its own dedicated source file."]}),"\n",(0,i.jsx)(t.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsx)(t.p,{children:"This has been a brief introduction to get you up and running with doctest, and to highlight some key differences between doctest and other frameworks you may be familiar with. This will take you a long way already \u2013 now you can dive in and start writing tests."}),"\n",(0,i.jsxs)(t.p,{children:["Of course, there\u2019s much more to learn \u2013 see the growing ",(0,i.jsx)(t.a,{href:"/cppdev/zh-cn/docs/testing/doct/overview#reference",children:(0,i.jsx)(t.strong,{children:"Reference"})})," section to explore all available features."]})]})}function u(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>r,x:()=>o});var n=s(6540);const i={},a=n.createContext(i);function r(e){const t=n.useContext(a);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);