"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[1405],{6545:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"foundamentals/testing/gt/primer","title":"GoogleTest Primer","description":"Introduction: Why GoogleTest?","source":"@site/i18n/zh-cn/docusaurus-plugin-content-docs/current/foundamentals/testing/gt/primer.md","sourceDirName":"foundamentals/testing/gt","slug":"/foundamentals/testing/gt/primer","permalink":"/cppdev/zh-cn/docs/foundamentals/testing/gt/primer","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Quickstart: Building with CMake","permalink":"/cppdev/zh-cn/docs/foundamentals/testing/gt/quickstart-cmake"},"next":{"title":"Advanced GoogleTest Topics","permalink":"/cppdev/zh-cn/docs/foundamentals/testing/gt/advanced"}}');var i=n(4848),o=n(8453);const r={},a="GoogleTest Primer",l={},c=[{value:"Introduction: Why GoogleTest?",id:"introduction-why-googletest",level:2},{value:"Beware of the Nomenclature",id:"beware-of-the-nomenclature",level:2},{value:"Basic Concepts",id:"basic-concepts",level:2},{value:"Assertions",id:"assertions",level:2},{value:"Simple Tests",id:"simple-tests",level:2},{value:"Test Fixtures: Using the Same Data Configuration for Multiple Tests",id:"same-data-multiple-tests",level:2},{value:"Invoking the Tests",id:"invoking-the-tests",level:2},{value:"Writing the main() Function",id:"writing-the-main-function",level:2},{value:"Known Limitations",id:"known-limitations",level:2}];function d(e){const t={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"googletest-primer",children:"GoogleTest Primer"})}),"\n",(0,i.jsx)(t.h2,{id:"introduction-why-googletest",children:"Introduction: Why GoogleTest?"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.em,{children:"GoogleTest"})," helps you write better C++ tests."]}),"\n",(0,i.jsxs)(t.p,{children:["GoogleTest is a testing framework developed by the Testing Technology team with\nGoogle's specific requirements and constraints in mind. Whether you work on\nLinux, Windows, or a Mac, if you write C++ code, GoogleTest can help you. And it\nsupports ",(0,i.jsx)(t.em,{children:"any"})," kind of tests, not just unit tests."]}),"\n",(0,i.jsx)(t.p,{children:"So what makes a good test, and how does GoogleTest fit in? We believe:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["Tests should be ",(0,i.jsx)(t.em,{children:"independent"})," and ",(0,i.jsx)(t.em,{children:"repeatable"}),". It's a pain to debug a test\nthat succeeds or fails as a result of other tests. GoogleTest isolates the\ntests by running each of them on a different object. When a test fails,\nGoogleTest allows you to run it in isolation for quick debugging."]}),"\n",(0,i.jsxs)(t.li,{children:["Tests should be well ",(0,i.jsx)(t.em,{children:"organized"})," and reflect the structure of the tested\ncode. GoogleTest groups related tests into test suites that can share data\nand subroutines. This common pattern is easy to recognize and makes tests\neasy to maintain. Such consistency is especially helpful when people switch\nprojects and start to work on a new code base."]}),"\n",(0,i.jsxs)(t.li,{children:["Tests should be ",(0,i.jsx)(t.em,{children:"portable"})," and ",(0,i.jsx)(t.em,{children:"reusable"}),". Google has a lot of code that is\nplatform-neutral; its tests should also be platform-neutral. GoogleTest\nworks on different OSes, with different compilers, with or without\nexceptions, so GoogleTest tests can work with a variety of configurations."]}),"\n",(0,i.jsxs)(t.li,{children:["When tests fail, they should provide as much ",(0,i.jsx)(t.em,{children:"information"})," about the problem\nas possible. GoogleTest doesn't stop at the first test failure. Instead, it\nonly stops the current test and continues with the next. You can also set up\ntests that report non-fatal failures after which the current test continues.\nThus, you can detect and fix multiple bugs in a single run-edit-compile\ncycle."]}),"\n",(0,i.jsxs)(t.li,{children:["The testing framework should liberate test writers from housekeeping chores\nand let them focus on the test ",(0,i.jsx)(t.em,{children:"content"}),". GoogleTest automatically keeps\ntrack of all tests defined, and doesn't require the user to enumerate them\nin order to run them."]}),"\n",(0,i.jsxs)(t.li,{children:["Tests should be ",(0,i.jsx)(t.em,{children:"fast"}),". With GoogleTest, you can reuse shared resources\nacross tests and pay for the set-up/tear-down only once, without making\ntests depend on each other."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Since GoogleTest is based on the popular xUnit architecture, you'll feel right\nat home if you've used JUnit or PyUnit before. If not, it will take you about 10\nminutes to learn the basics and get started. So let's go!"}),"\n",(0,i.jsx)(t.h2,{id:"beware-of-the-nomenclature",children:"Beware of the Nomenclature"}),"\n",(0,i.jsx)(t.admonition,{type:"info",children:(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.em,{children:"Note:"})," There might be some confusion arising from different definitions of the\nterms ",(0,i.jsx)(t.em,{children:"Test"}),", ",(0,i.jsx)(t.em,{children:"Test Case"})," and ",(0,i.jsx)(t.em,{children:"Test Suite"}),", so beware of misunderstanding these."]})}),"\n",(0,i.jsxs)(t.p,{children:["Historically, GoogleTest started to use the term ",(0,i.jsx)(t.em,{children:"Test Case"})," for grouping\nrelated tests, whereas current publications, including International Software\nTesting Qualifications Board (",(0,i.jsx)(t.a,{href:"https://www.istqb.org/",children:"ISTQB"}),") materials and\nvarious textbooks on software quality, use the term\n",(0,i.jsx)(t.em,{children:(0,i.jsx)(t.a,{href:"https://glossary.istqb.org/en_US/term/test-suite",children:"Test Suite"})})," for this."]}),"\n",(0,i.jsxs)(t.p,{children:["The related term ",(0,i.jsx)(t.em,{children:"Test"}),", as it is used in GoogleTest, corresponds to the term\n",(0,i.jsx)(t.em,{children:(0,i.jsx)(t.a,{href:"https://glossary.istqb.org/en_US/term/test-case",children:"Test Case"})})," of ISTQB and others."]}),"\n",(0,i.jsxs)(t.p,{children:["The term ",(0,i.jsx)(t.em,{children:"Test"})," is commonly of broad enough sense, including ISTQB's definition\nof ",(0,i.jsx)(t.em,{children:"Test Case"}),", so it's not much of a problem here. But the term ",(0,i.jsx)(t.em,{children:"Test Case"})," as\nwas used in Google Test is of contradictory sense and thus confusing."]}),"\n",(0,i.jsxs)(t.p,{children:["GoogleTest recently started replacing the term ",(0,i.jsx)(t.em,{children:"Test Case"})," with ",(0,i.jsx)(t.em,{children:"Test Suite"}),".\nThe preferred API is ",(0,i.jsx)(t.em,{children:"TestSuite"}),". The older TestCase API is being slowly\ndeprecated and refactored away."]}),"\n",(0,i.jsx)(t.p,{children:"So please be aware of the different definitions of the terms:"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Meaning"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"GoogleTest Term"}),(0,i.jsxs)(t.th,{style:{textAlign:"left"},children:[(0,i.jsx)(t.a,{href:"https://www.istqb.org/",children:"ISTQB"})," Term"]})]})}),(0,i.jsx)(t.tbody,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Exercise a particular program path with specific input values and verify the results"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.a,{href:"#simple-tests",children:"TEST()"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.a,{href:"https://glossary.istqb.org/en_US/term/test-case",children:"Test Case"})})]})})]}),"\n",(0,i.jsx)(t.h2,{id:"basic-concepts",children:"Basic Concepts"}),"\n",(0,i.jsxs)(t.p,{children:["When using GoogleTest, you start by writing ",(0,i.jsx)(t.em,{children:"assertions"}),", which are statements\nthat check whether a condition is true. An assertion's result can be ",(0,i.jsx)(t.em,{children:"success"}),",\n",(0,i.jsx)(t.em,{children:"nonfatal failure"}),", or ",(0,i.jsx)(t.em,{children:"fatal failure"}),". If a fatal failure occurs, it aborts the\ncurrent function; otherwise the program continues normally."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.em,{children:"Tests"})," use assertions to verify the tested code's behavior. If a test crashes\nor has a failed assertion, then it ",(0,i.jsx)(t.em,{children:"fails"}),"; otherwise it ",(0,i.jsx)(t.em,{children:"succeeds"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["A ",(0,i.jsx)(t.em,{children:"test suite"})," contains one or many tests. You should group your tests into test\nsuites that reflect the structure of the tested code. When multiple tests in a\ntest suite need to share common objects and subroutines, you can put them into a\n",(0,i.jsx)(t.em,{children:"test fixture"})," class."]}),"\n",(0,i.jsxs)(t.p,{children:["A ",(0,i.jsx)(t.em,{children:"test program"})," can contain multiple test suites."]}),"\n",(0,i.jsx)(t.p,{children:"We'll now explain how to write a test program, starting at the individual\nassertion level and building up to tests and test suites."}),"\n",(0,i.jsx)(t.h2,{id:"assertions",children:"Assertions"}),"\n",(0,i.jsx)(t.p,{children:"GoogleTest assertions are macros that resemble function calls. You test a class\nor function by making assertions about its behavior. When an assertion fails,\nGoogleTest prints the assertion's source file and line number location, along\nwith a failure message. You may also supply a custom failure message which will\nbe appended to GoogleTest's message."}),"\n",(0,i.jsxs)(t.p,{children:["The assertions come in pairs that test the same thing but have different effects\non the current function. ",(0,i.jsx)(t.code,{children:"ASSERT_*"})," versions generate fatal failures when they\nfail, and ",(0,i.jsx)(t.strong,{children:"abort the current function"}),". ",(0,i.jsx)(t.code,{children:"EXPECT_*"})," versions generate nonfatal\nfailures, which don't abort the current function. Usually ",(0,i.jsx)(t.code,{children:"EXPECT_*"})," are\npreferred, as they allow more than one failure to be reported in a test.\nHowever, you should use ",(0,i.jsx)(t.code,{children:"ASSERT_*"})," if it doesn't make sense to continue when the\nassertion in question fails."]}),"\n",(0,i.jsxs)(t.p,{children:["Since a failed ",(0,i.jsx)(t.code,{children:"ASSERT_*"})," returns from the current function immediately,\npossibly skipping clean-up code that comes after it, it may cause a space leak.\nDepending on the nature of the leak, it may or may not be worth fixing - so keep\nthis in mind if you get a heap checker error in addition to assertion errors."]}),"\n",(0,i.jsxs)(t.p,{children:["To provide a custom failure message, simply stream it into the macro using the\n",(0,i.jsx)(t.code,{children:"<<"})," operator or a sequence of such operators. See the following example, using\nthe ",(0,i.jsxs)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/gt/reference/assertions#EXPECT_EQ",children:[(0,i.jsx)(t.code,{children:"ASSERT_EQ"})," and ",(0,i.jsx)(t.code,{children:"EXPECT_EQ"})]})," macros to\nverify value equality:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c++",children:'ASSERT_EQ(x.size(), y.size()) << "Vectors x and y are of unequal length";\n\nfor (int i = 0; i < x.size(); ++i) {\n  EXPECT_EQ(x[i], y[i]) << "Vectors x and y differ at index " << i;\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Anything that can be streamed to an ",(0,i.jsx)(t.code,{children:"ostream"})," can be streamed to an assertion\nmacro--in particular, C strings and ",(0,i.jsx)(t.code,{children:"string"})," objects. If a wide string\n(",(0,i.jsx)(t.code,{children:"wchar_t*"}),", ",(0,i.jsx)(t.code,{children:"TCHAR*"})," in ",(0,i.jsx)(t.code,{children:"UNICODE"})," mode on Windows, or ",(0,i.jsx)(t.code,{children:"std::wstring"}),") is\nstreamed to an assertion, it will be translated to UTF-8 when printed."]}),"\n",(0,i.jsxs)(t.p,{children:["GoogleTest provides a collection of assertions for verifying the behavior of\nyour code in various ways. You can check Boolean conditions, compare values\nbased on relational operators, verify string values, floating-point values, and\nmuch more. There are even assertions that enable you to verify more complex\nstates by providing custom predicates. For the complete list of assertions\nprovided by GoogleTest, see the ",(0,i.jsx)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/gt/reference/assertions",children:"Assertions Reference"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"simple-tests",children:"Simple Tests"}),"\n",(0,i.jsx)(t.p,{children:"To create a test:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["Use the ",(0,i.jsx)(t.code,{children:"TEST()"})," macro to define and name a test function. These are\nordinary C++ functions that don't return a value."]}),"\n",(0,i.jsx)(t.li,{children:"In this function, along with any valid C++ statements you want to include,\nuse the various GoogleTest assertions to check values."}),"\n",(0,i.jsx)(t.li,{children:"The test's result is determined by the assertions; if any assertion in the\ntest fails (either fatally or non-fatally), or if the test crashes, the\nentire test fails. Otherwise, it succeeds."}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c++",children:"TEST(TestSuiteName, TestName) {\n  ... test body ...\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"TEST()"})," arguments go from general to specific. The ",(0,i.jsx)(t.em,{children:"first"})," argument is the name\nof the test suite, and the ",(0,i.jsx)(t.em,{children:"second"})," argument is the test's name within the test\nsuite. Both names must be valid C++ identifiers, and they should not contain any\nunderscores (",(0,i.jsx)(t.code,{children:"_"}),"). A test's ",(0,i.jsx)(t.em,{children:"full name"})," consists of its containing test suite\nand its individual name. Tests from different test suites can have the same\nindividual name."]}),"\n",(0,i.jsx)(t.p,{children:"For example, let's take a simple integer function:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c++",children:"int Factorial(int n);  // Returns the factorial of n\n"})}),"\n",(0,i.jsx)(t.p,{children:"A test suite for this function might look like:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c++",children:"// Tests factorial of 0.\nTEST(FactorialTest, HandlesZeroInput) {\n  EXPECT_EQ(Factorial(0), 1);\n}\n\n// Tests factorial of positive numbers.\nTEST(FactorialTest, HandlesPositiveInput) {\n  EXPECT_EQ(Factorial(1), 1);\n  EXPECT_EQ(Factorial(2), 2);\n  EXPECT_EQ(Factorial(3), 6);\n  EXPECT_EQ(Factorial(8), 40320);\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["GoogleTest groups the test results by test suites, so logically related tests\nshould be in the same test suite; in other words, the first argument to their\n",(0,i.jsx)(t.code,{children:"TEST()"})," should be the same. In the above example, we have two tests,\n",(0,i.jsx)(t.code,{children:"HandlesZeroInput"})," and ",(0,i.jsx)(t.code,{children:"HandlesPositiveInput"}),", that belong to the same test\nsuite ",(0,i.jsx)(t.code,{children:"FactorialTest"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["When naming your test suites and tests, you should follow the same convention as\nfor\n",(0,i.jsx)(t.a,{href:"https://google.github.io/styleguide/cppguide.html#Function_Names",children:"naming functions and classes"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Availability"}),": Linux, Windows, Mac."]}),"\n",(0,i.jsx)(t.h2,{id:"same-data-multiple-tests",children:"Test Fixtures: Using the Same Data Configuration for Multiple Tests"}),"\n",(0,i.jsxs)(t.p,{children:["If you find yourself writing two or more tests that operate on similar data, you\ncan use a ",(0,i.jsx)(t.em,{children:"test fixture"}),". This allows you to reuse the same configuration of\nobjects for several different tests."]}),"\n",(0,i.jsx)(t.p,{children:"To create a fixture:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["Derive a class from ",(0,i.jsx)(t.code,{children:"testing::Test"})," . Start its body with ",(0,i.jsx)(t.code,{children:"protected:"}),", as\nwe'll want to access fixture members from sub-classes."]}),"\n",(0,i.jsx)(t.li,{children:"Inside the class, declare any objects you plan to use."}),"\n",(0,i.jsxs)(t.li,{children:["If necessary, write a default constructor or ",(0,i.jsx)(t.code,{children:"SetUp()"})," function to prepare\nthe objects for each test. A common mistake is to spell ",(0,i.jsx)(t.code,{children:"SetUp()"})," as\n",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"Setup()"})})," with a small ",(0,i.jsx)(t.code,{children:"u"})," - Use ",(0,i.jsx)(t.code,{children:"override"})," in C++11 to make sure you\nspelled it correctly."]}),"\n",(0,i.jsxs)(t.li,{children:["If necessary, write a destructor or ",(0,i.jsx)(t.code,{children:"TearDown()"})," function to release any\nresources you allocated in ",(0,i.jsx)(t.code,{children:"SetUp()"})," . To learn when you should use the\nconstructor/destructor and when you should use ",(0,i.jsx)(t.code,{children:"SetUp()/TearDown()"}),", read\nthe ",(0,i.jsx)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/gt/faq#CtorVsSetUp",children:"FAQ"}),"."]}),"\n",(0,i.jsx)(t.li,{children:"If needed, define subroutines for your tests to share."}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["When using a fixture, use ",(0,i.jsx)(t.code,{children:"TEST_F()"})," instead of ",(0,i.jsx)(t.code,{children:"TEST()"})," as it allows you to\naccess objects and subroutines in the test fixture:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c++",children:"TEST_F(TestFixtureClassName, TestName) {\n  ... test body ...\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Unlike ",(0,i.jsx)(t.code,{children:"TEST()"}),", in ",(0,i.jsx)(t.code,{children:"TEST_F()"})," the first argument must be the name of the test\nfixture class. (",(0,i.jsx)(t.code,{children:"_F"}),' stands for "Fixture"). No test suite name is specified for\nthis macro.']}),"\n",(0,i.jsx)(t.p,{children:"Unfortunately, the C++ macro system does not allow us to create a single macro\nthat can handle both types of tests. Using the wrong macro causes a compiler\nerror."}),"\n",(0,i.jsxs)(t.p,{children:["Also, you must first define a test fixture class before using it in a\n",(0,i.jsx)(t.code,{children:"TEST_F()"}),", or you'll get the compiler error \"",(0,i.jsx)(t.code,{children:"virtual outside class declaration"}),'".']}),"\n",(0,i.jsxs)(t.p,{children:["For each test defined with ",(0,i.jsx)(t.code,{children:"TEST_F()"}),", GoogleTest will create a ",(0,i.jsx)(t.em,{children:"fresh"})," test\nfixture at runtime, immediately initialize it via ",(0,i.jsx)(t.code,{children:"SetUp()"}),", run the test, clean\nup by calling ",(0,i.jsx)(t.code,{children:"TearDown()"}),", and then delete the test fixture. Note that\ndifferent tests in the same test suite have different test fixture objects, and\nGoogleTest always deletes a test fixture before it creates the next one.\nGoogleTest does ",(0,i.jsx)(t.strong,{children:"not"})," reuse the same test fixture for multiple tests. Any\nchanges one test makes to the fixture do not affect other tests."]}),"\n",(0,i.jsxs)(t.p,{children:["As an example, let's write tests for a FIFO queue class named ",(0,i.jsx)(t.code,{children:"Queue"}),", which has\nthe following interface:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c++",children:"template <typename E>  // E is the element type.\nclass Queue {\n public:\n  Queue();\n  void Enqueue(const E& element);\n  E* Dequeue();  // Returns NULL if the queue is empty.\n  size_t size() const;\n  ...\n};\n"})}),"\n",(0,i.jsxs)(t.p,{children:["First, define a fixture class. By convention, you should give it the name\n",(0,i.jsx)(t.code,{children:"FooTest"})," where ",(0,i.jsx)(t.code,{children:"Foo"})," is the class being tested."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c++",children:"class QueueTest : public testing::Test {\n protected:\n  QueueTest() {\n     // q0_ remains empty\n     q1_.Enqueue(1);\n     q2_.Enqueue(2);\n     q2_.Enqueue(3);\n  }\n\n  // ~QueueTest() override = default;\n\n  Queue<int> q0_;\n  Queue<int> q1_;\n  Queue<int> q2_;\n};\n"})}),"\n",(0,i.jsxs)(t.p,{children:["In this case, we don't need to define a destructor or a ",(0,i.jsx)(t.code,{children:"TearDown()"})," method,\nbecause the implicit destructor generated by the compiler will perform all of\nthe necessary cleanup."]}),"\n",(0,i.jsxs)(t.p,{children:["Now we'll write tests using ",(0,i.jsx)(t.code,{children:"TEST_F()"})," and this fixture."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c++",children:"TEST_F(QueueTest, IsEmptyInitially) {\n  EXPECT_EQ(q0_.size(), 0);\n}\n\nTEST_F(QueueTest, DequeueWorks) {\n  int* n = q0_.Dequeue();\n  EXPECT_EQ(n, nullptr);\n\n  n = q1_.Dequeue();\n  ASSERT_NE(n, nullptr);\n  EXPECT_EQ(*n, 1);\n  EXPECT_EQ(q1_.size(), 0);\n  delete n;\n\n  n = q2_.Dequeue();\n  ASSERT_NE(n, nullptr);\n  EXPECT_EQ(*n, 2);\n  EXPECT_EQ(q2_.size(), 1);\n  delete n;\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The above uses both ",(0,i.jsx)(t.code,{children:"ASSERT_*"})," and ",(0,i.jsx)(t.code,{children:"EXPECT_*"})," assertions. The rule of thumb is\nto use ",(0,i.jsx)(t.code,{children:"EXPECT_*"})," when you want the test to continue to reveal more errors after\nthe assertion failure, and use ",(0,i.jsx)(t.code,{children:"ASSERT_*"})," when continuing after failure doesn't\nmake sense. For example, the second assertion in the ",(0,i.jsx)(t.code,{children:"Dequeue"})," test is\n",(0,i.jsx)(t.code,{children:"ASSERT_NE(n, nullptr)"}),", as we need to dereference the pointer ",(0,i.jsx)(t.code,{children:"n"})," later, which\nwould lead to a segfault when ",(0,i.jsx)(t.code,{children:"n"})," is ",(0,i.jsx)(t.code,{children:"NULL"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"When these tests run, the following happens:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["GoogleTest constructs a ",(0,i.jsx)(t.code,{children:"QueueTest"})," object (let's call it ",(0,i.jsx)(t.code,{children:"t1"}),")."]}),"\n",(0,i.jsxs)(t.li,{children:["The first test (",(0,i.jsx)(t.code,{children:"IsEmptyInitially"}),") runs on ",(0,i.jsx)(t.code,{children:"t1"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"t1"})," is destructed."]}),"\n",(0,i.jsxs)(t.li,{children:["The above steps are repeated on another ",(0,i.jsx)(t.code,{children:"QueueTest"})," object, this time\nrunning the ",(0,i.jsx)(t.code,{children:"DequeueWorks"})," test."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Availability"}),": Linux, Windows, Mac."]}),"\n",(0,i.jsx)(t.h2,{id:"invoking-the-tests",children:"Invoking the Tests"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"TEST()"})," and ",(0,i.jsx)(t.code,{children:"TEST_F()"})," implicitly register their tests with GoogleTest. So,\nunlike with many other C++ testing frameworks, you don't have to re-list all\nyour defined tests in order to run them."]}),"\n",(0,i.jsxs)(t.p,{children:["After defining your tests, you can run them with ",(0,i.jsx)(t.code,{children:"RUN_ALL_TESTS()"}),", which\nreturns ",(0,i.jsx)(t.code,{children:"0"})," if all the tests are successful, or ",(0,i.jsx)(t.code,{children:"1"})," otherwise. Note that\n",(0,i.jsx)(t.code,{children:"RUN_ALL_TESTS()"})," runs ",(0,i.jsx)(t.em,{children:"all tests"})," in your link unit--they can be from different\ntest suites, or even different source files."]}),"\n",(0,i.jsxs)(t.p,{children:["When invoked, the ",(0,i.jsx)(t.code,{children:"RUN_ALL_TESTS()"})," macro:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Saves the state of all GoogleTest flags."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Creates a test fixture object for the first test."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Initializes it via ",(0,i.jsx)(t.code,{children:"SetUp()"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Runs the test on the fixture object."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Cleans up the fixture via ",(0,i.jsx)(t.code,{children:"TearDown()"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Deletes the fixture."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Restores the state of all GoogleTest flags."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Repeats the above steps for the next test, until all tests have run."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"If a fatal failure happens the subsequent steps will be skipped."}),"\n",(0,i.jsx)(t.admonition,{type:"warning",children:(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:["IMPORTANT: You must ",(0,i.jsx)(t.strong,{children:"not"})," ignore the return value of ",(0,i.jsx)(t.code,{children:"RUN_ALL_TESTS()"}),", or\nyou will get a compiler error. The rationale for this design is that the\nautomated testing service determines whether a test has passed based on its\nexit code, not on its stdout/stderr output; thus your ",(0,i.jsx)(t.code,{children:"main()"})," function must\nreturn the value of ",(0,i.jsx)(t.code,{children:"RUN_ALL_TESTS()"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Also, you should call ",(0,i.jsx)(t.code,{children:"RUN_ALL_TESTS()"})," only ",(0,i.jsx)(t.strong,{children:"once"}),". Calling it more than\nonce conflicts with some advanced GoogleTest features (e.g., thread-safe\n",(0,i.jsx)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/gt/advanced#death-tests",children:"death tests"}),") and thus is not supported."]}),"\n"]})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Availability"}),": Linux, Windows, Mac."]}),"\n",(0,i.jsx)(t.h2,{id:"writing-the-main-function",children:"Writing the main() Function"}),"\n",(0,i.jsxs)(t.p,{children:["Most users should ",(0,i.jsx)(t.em,{children:"not"})," need to write their own ",(0,i.jsx)(t.code,{children:"main"})," function and instead link\nwith ",(0,i.jsx)(t.code,{children:"gtest_main"})," (as opposed to with ",(0,i.jsx)(t.code,{children:"gtest"}),"), which defines a suitable entry\npoint. See the end of this section for details. The remainder of this section\nshould only apply when you need to do something custom before the tests run that\ncannot be expressed within the framework of fixtures and test suites."]}),"\n",(0,i.jsxs)(t.p,{children:["If you write your own ",(0,i.jsx)(t.code,{children:"main"})," function, it should return the value of\n",(0,i.jsx)(t.code,{children:"RUN_ALL_TESTS()"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"You can start from this boilerplate:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c++",children:'#include "this/package/foo.h"\n\n#include <gtest/gtest.h>\n\nnamespace my {\nnamespace project {\nnamespace {\n\n// The fixture for testing class Foo.\nclass FooTest : public testing::Test {\n protected:\n  // You can remove any or all of the following functions if their bodies would\n  // be empty.\n\n  FooTest() {\n     // You can do set-up work for each test here.\n  }\n\n  ~FooTest() override {\n     // You can do clean-up work that doesn\'t throw exceptions here.\n  }\n\n  // If the constructor and destructor are not enough for setting up\n  // and cleaning up each test, you can define the following methods:\n\n  void SetUp() override {\n     // Code here will be called immediately after the constructor (right\n     // before each test).\n  }\n\n  void TearDown() override {\n     // Code here will be called immediately after each test (right\n     // before the destructor).\n  }\n\n  // Class members declared here can be used by all tests in the test suite\n  // for Foo.\n};\n\n// Tests that the Foo::Bar() method does Abc.\nTEST_F(FooTest, MethodBarDoesAbc) {\n  const std::string input_filepath = "this/package/testdata/myinputfile.dat";\n  const std::string output_filepath = "this/package/testdata/myoutputfile.dat";\n  Foo f;\n  EXPECT_EQ(f.Bar(input_filepath, output_filepath), 0);\n}\n\n// Tests that Foo does Xyz.\nTEST_F(FooTest, DoesXyz) {\n  // Exercises the Xyz feature of Foo.\n}\n\n}  // namespace\n}  // namespace project\n}  // namespace my\n\nint main(int argc, char **argv) {\n  testing::InitGoogleTest(&argc, argv);\n  return RUN_ALL_TESTS();\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"testing::InitGoogleTest()"})," function parses the command line for GoogleTest\nflags, and removes all recognized flags. This allows the user to control a test\nprogram's behavior via various flags, which we'll cover in the\n",(0,i.jsx)(t.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/gt/advanced",children:"AdvancedGuide"}),". You ",(0,i.jsx)(t.strong,{children:"must"})," call this function before calling\n",(0,i.jsx)(t.code,{children:"RUN_ALL_TESTS()"}),", or the flags won't be properly initialized."]}),"\n",(0,i.jsxs)(t.p,{children:["On Windows, ",(0,i.jsx)(t.code,{children:"InitGoogleTest()"})," also works with wide strings, so it can be used\nin programs compiled in ",(0,i.jsx)(t.code,{children:"UNICODE"})," mode as well."]}),"\n",(0,i.jsxs)(t.p,{children:["But maybe you think that writing all those ",(0,i.jsx)(t.code,{children:"main"})," functions is too much work? We\nagree with you completely, and that's why Google Test provides a basic\nimplementation of main(). If it fits your needs, then just link your test with\nthe ",(0,i.jsx)(t.code,{children:"gtest_main"})," library and you are good to go."]}),"\n",(0,i.jsx)(t.admonition,{type:"info",children:(0,i.jsxs)(t.p,{children:["NOTE: ",(0,i.jsx)(t.code,{children:"ParseGUnitFlags()"})," is deprecated in favor of ",(0,i.jsx)(t.code,{children:"InitGoogleTest()"}),"."]})}),"\n",(0,i.jsx)(t.h2,{id:"known-limitations",children:"Known Limitations"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Google Test is designed to be thread-safe. The implementation is thread-safe\non systems where the ",(0,i.jsx)(t.code,{children:"pthreads"})," library is available. It is currently\n",(0,i.jsx)(t.em,{children:"unsafe"})," to use Google Test assertions from two threads concurrently on\nother systems (e.g. Windows). In most tests this is not an issue as usually\nthe assertions are done in the main thread. If you want to help, you can\nvolunteer to implement the necessary synchronization primitives in\n",(0,i.jsx)(t.code,{children:"gtest-port.h"})," for your platform."]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var s=n(6540);const i={},o=s.createContext(i);function r(e){const t=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);