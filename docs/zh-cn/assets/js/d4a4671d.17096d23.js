"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[4966],{7946:(t,e,s)=>{s.r(e),s.d(e,{assets:()=>o,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"strings/split","title":"String Splitting","description":"turbo::str_split() - Splitting Strings","source":"@site/docs/strings/split.mdx","sourceDirName":"strings","slug":"/strings/split","permalink":"/cppdev/zh-cn/docs/strings/split","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/strings/split.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Formatted Output","permalink":"/cppdev/zh-cn/docs/strings/fmt"},"next":{"title":"String Concatenation","permalink":"/cppdev/zh-cn/docs/strings/strcat"}}');var i=s(4848),r=s(8453);const l={},a="String Splitting",o={},c=[{value:"<code>turbo::str_split()</code> - Splitting Strings",id:"turbostr_split---splitting-strings",level:2},{value:"Adapting Return Types",id:"adapting-return-types",level:3},{value:"Delimiters",id:"delimiters",level:3},{value:"Filtering Conditions (Predicates)",id:"filtering-conditions-predicates",level:3}];function d(t){const e={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...t.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"string-splitting",children:"String Splitting"})}),"\n",(0,i.jsxs)(e.h2,{id:"turbostr_split---splitting-strings",children:[(0,i.jsx)(e.code,{children:"turbo::str_split()"})," - Splitting Strings"]}),"\n",(0,i.jsxs)(e.p,{children:["The ",(0,i.jsx)(e.code,{children:"turbo::str_split()"})," function provides a simple way to split a string into substrings.\n",(0,i.jsx)(e.code,{children:"str_split()"})," accepts an input string to split, a delimiter (e.g., comma ",(0,i.jsx)(e.code,{children:","}),") for splitting the string,\nand (optionally) a predicate that acts as a filter to determine whether split elements are included in the result set. ",(0,i.jsx)(e.code,{children:"str_split()"})," also adapts the returned collection to the type specified by the caller."]}),"\n",(0,i.jsx)(e.p,{children:"Examples:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'// Splits the given string on commas. Returns the results in a\n// vector of strings. (Data is copied once.)\nstd::vector<std::string> v = turbo::str_split("a,b,c", \',\');  // Can also use ","\n// v[0] == "a", v[1] == "b", v[2] == "c"\n\n// Splits the string as in the previous example, except that the results\n// are returned as `std::string_view` objects, avoiding copies. Note that\n// because we are storing the results within `std::string_view` objects, we\n// have to ensure that the input string outlives any results.\nstd::vector<std::string_view> v = turbo::str_split("a,b,c", \',\');\n// v[0] == "a", v[1] == "b", v[2] == "c"\n'})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"str_split()"})," splits the string using the passed ",(0,i.jsx)(e.em,{children:"Delimiter"})," object. (See ",(0,i.jsx)(e.a,{href:"#delimiters",children:"Delimiters"})," below.) However, in many cases,\nyou can simply pass a string literal as the delimiter (it will be implicitly converted to a ",(0,i.jsx)(e.code,{children:"turbo::ByString"})," delimiter)."]}),"\n",(0,i.jsx)(e.p,{children:"Examples:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'// By default, empty strings are *included* in the output. See the\n// `turbo::SkipEmpty()` predicate below to omit them{#stringSplitting}.\nstd::vector<std::string> v = turbo::str_split("a,b,,c", \',\');\n// v[0] == "a", v[1] == "b", v[2] == "", v[3] = "c"\n\n// You can also split an empty string\nv = turbo::str_split("", \',\');\n// v[0] = ""\n\n// The delimiter need not be a single character\nstd::vector<std::string> v = turbo::str_split("aCOMMAbCOMMAc", "COMMA");\n// v[0] == "a", v[1] == "b", v[2] == "c"\n\n// You can also use the empty string as the delimiter, which will split\n// a string into its constituent characters.\nstd::vector<std::string> v = turbo::str_split("abcd", "");\n// v[0] == "a", v[1] == "b", v[2] == "c", v[3] = "d"\n'})}),"\n",(0,i.jsx)(e.h3,{id:"adapting-return-types",children:"Adapting Return Types"}),"\n",(0,i.jsxs)(e.p,{children:["One of the more useful features of the ",(0,i.jsx)(e.code,{children:"str_split()"})," API is its ability to adapt its result set to the desired return type. The collection returned by ",(0,i.jsx)(e.code,{children:"str_split()"}),"\nmay contain ",(0,i.jsx)(e.code,{children:"std::string"}),", ",(0,i.jsx)(e.code,{children:"std::string_view"}),", or any object that can be explicitly created from ",(0,i.jsx)(e.code,{children:"std::string_view"}),".\nThis pattern works with all standard STL containers, including ",(0,i.jsx)(e.code,{children:"std::vector"}),", ",(0,i.jsx)(e.code,{children:"std::list"}),", ",(0,i.jsx)(e.code,{children:"std::deque"}),", ",(0,i.jsx)(e.code,{children:"std::set"}),", ",(0,i.jsx)(e.code,{children:"std::multiset"}),",\n",(0,i.jsx)(e.code,{children:"std::map"}),", and ",(0,i.jsx)(e.code,{children:"std::multimap"}),"\u2014even ",(0,i.jsx)(e.code,{children:"std::pair"}),", which is not actually a container."]}),"\n",(0,i.jsx)(e.p,{children:"Examples:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'// Stores results in a std::set<std::string>, which also performs de-duplication\n// and orders the elements in ascending order.\nstd::set<std::string> s = turbo::str_split("b,a,c,a,b", \',\');\n// s[0] == "a", s[1] == "b", s[2] == "c"\n\n// Stores results in a map. The map implementation assumes that the input\n// is provided as a series of key/value pairs. For example, the 0th element\n// resulting from the split will be stored as a key to the 1st element. If\n// an odd number of elements are resolved, the last element is paired with\n// a default-constructed value (e.g., empty string).\nstd::map<std::string, std::string> m = turbo::str_split("a,b,c", \',\');\n// m["a"] == "b", m["c"] == "" // last component value equals ""\n\n// Stores first two split strings as the members in a std::pair. Any split\n// strings beyond the first two are omitted because std::pair can hold only two\n// elements.\nstd::pair<std::string, std::string> p = turbo::str_split("a,b,c", \',\');\n// p.first = "a", p.second = "b" ; "c" is omitted\n'})}),"\n",(0,i.jsx)(e.h3,{id:"delimiters",children:"Delimiters"}),"\n",(0,i.jsxs)(e.p,{children:["The ",(0,i.jsx)(e.code,{children:"str_split()"}),' API provides a number of "delimiters" to provide special delimiter behaviors. A Delimiter implementation contains a ',(0,i.jsx)(e.code,{children:"Find()"})," function\nthat knows how to find the first occurrence of itself within a given ",(0,i.jsx)(e.code,{children:"std::string_view"}),". Models of the Delimiter concept represent specific types of delimiters,\nsuch as single characters, substrings, or even regular expressions."]}),"\n",(0,i.jsxs)(e.p,{children:["The following delimiter abstractions are provided as part of the ",(0,i.jsx)(e.code,{children:"str_split()"})," API:"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"turbo::ByString()"})," (default for ",(0,i.jsx)(e.code,{children:"std::string"})," arguments)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"turbo::ByChar()"})," (default for a ",(0,i.jsx)(e.code,{children:"char"})," argument)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"turbo::ByAnyChar()"})," (for mixing delimiters)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"turbo::ByLength()"})," (for applying a delimiter a set number of times)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"turbo::MaxSplits()"})," (for splitting a specific number of times)"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"Examples:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'// Because a `string` literal is converted to an `turbo::ByString`, the following\n// two splits are equivalent.\nstd::vector<std::string> v = turbo::str_split("a,b,c", ",");\nstd::vector<std::string> v = turbo::str_split("a,b,c", turbo::ByString(","));\n// v[0] == "a", v[1] == "b", v[2] == "c"\n\n// Because a `char` literal is converted to an `turbo::ByChar`, the following two\n// splits are equivalent.\nstd::vector<std::string> v = turbo::str_split("a,b,c", \',\');\n// v[0] == "a", v[1] == "b", v[2] == "c"\n\nstd::vector<std::string> v = turbo::str_split("a,b,c", turbo::ByChar(\',\'));\n// v[0] == "a", v[1] == "b", v[2] == "c"\n\n// Splits on any of the given characters ("," or ";")\nvector<std::string> v = turbo::str_split("a,b;c", turbo::ByAnyChar(",;"));\n// v[0] == "a", v[1] == "b", v[2] == "c"\n\n// Uses the `turbo::MaxSplits` delimiter to limit the number of matches a\n// delimiter can have. In this case, the delimiter of a literal comma is limited\n// to matching at most one time. The last element in the returned collection\n// will contain all unsplit pieces, which may contain instances of the\n// delimiter.\nstd::vector<std::string> v = turbo::str_split("a,b,c", turbo::MaxSplits(\',\', 1));\n// v[0] == "a", v[1] == "b,c"\n\n// Splits into equal-length substrings.\nstd::vector<std::string> v = turbo::str_split("12345", turbo::ByLength(2));\n// v[0] == "12", v[1] == "34", v[2] == "5"\n'})}),"\n",(0,i.jsx)(e.h3,{id:"filtering-conditions-predicates",children:"Filtering Conditions (Predicates)"}),"\n",(0,i.jsxs)(e.p,{children:["A predicate can filter the results of a ",(0,i.jsx)(e.code,{children:"str_split()"})," operation by determining whether a result element is included in the result set. A filtering predicate can be passed as an ",(0,i.jsx)(e.em,{children:"optional"})," third argument to the ",(0,i.jsx)(e.code,{children:"str_split()"})," function."]}),"\n",(0,i.jsxs)(e.p,{children:["The predicate must be a unary function (or function object, such as a ",(0,i.jsx)(e.a,{href:"https://en.cppreference.com/w/cpp/language/lambda",children:"lambda"}),") that takes a single ",(0,i.jsx)(e.code,{children:"std::string_view"})," parameter and returns a bool indicating whether the parameter should be included (",(0,i.jsx)(e.code,{children:"true"}),") or excluded (",(0,i.jsx)(e.code,{children:"false"}),")."]}),"\n",(0,i.jsxs)(e.p,{children:["One example where using a predicate is useful is filtering out empty substrings. By default, ",(0,i.jsx)(e.code,{children:"str_split()"})," may return empty substrings as separate elements in the result set, which is similar to how split functions work in other programming languages."]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'// Empty strings *are* included in the returned collection.\nstd::vector<std::string> v = turbo::str_split(",a,,b,", \',\');\n// v[0] == "", v[1] == "a", v[2] == "", v[3] = "b", v[4] = ""\n'})}),"\n",(0,i.jsxs)(e.p,{children:["These empty strings can be filtered out of the result set simply by passing the provided ",(0,i.jsx)(e.code,{children:"SkipEmpty()"})," predicate as the third argument to the ",(0,i.jsx)(e.code,{children:"str_split()"})," function. ",(0,i.jsx)(e.code,{children:"SkipEmpty()"})," does ",(0,i.jsx)(e.strong,{children:"not"})," treat strings containing all whitespace as empty. For that behavior, use the ",(0,i.jsx)(e.code,{children:"SkipWhitespace()"})," predicate."]}),"\n",(0,i.jsx)(e.p,{children:"Examples:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'// Uses turbo::SkipEmpty() to omit empty strings. Strings containing whitespace\n// are not empty and are therefore not skipped.\nstd::vector<std::string> v = turbo::str_split(",a, ,b,", \',\', turbo::SkipEmpty());\n// v[0] == "a", v[1] == " ", v[2] == "b"\n\n// Uses turbo::SkipWhitespace() to skip all strings that are either empty or\n// contain only whitespace.\nstd::vector<std::string> v = turbo::str_split(",a, ,b,", \',\',\n                                            turbo::SkipWhitespace());\n// v[0] == "a", v[1] == "b"\n\n// Passes a lambda as the predicate to keep only the lines that don\'t start\n// with a `#`.\nstd::vector<std::string> non_comment_lines = turbo::str_split(\n    file_content, \'\\n\',\n    [](std::string_view line) { return !turbo::StartsWith(line, "#"); });\n'})})]})}function p(t={}){const{wrapper:e}={...(0,r.R)(),...t.components};return e?(0,i.jsx)(e,{...t,children:(0,i.jsx)(d,{...t})}):d(t)}},8453:(t,e,s)=>{s.d(e,{R:()=>l,x:()=>a});var n=s(6540);const i={},r=n.createContext(i);function l(t){const e=n.useContext(r);return n.useMemo(function(){return"function"==typeof t?t(e):{...e,...t}},[e,t])}function a(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(i):t.components||i:l(t.components),n.createElement(r.Provider,{value:e},t.children)}}}]);