"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[9414],{7316:(e,i,r)=>{r.r(i),r.d(i,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>d,metadata:()=>n,toc:()=>o});const n=JSON.parse('{"id":"retrieve/vector/ngt","title":"NGT (Neighborhood Graph and Tree) Overview","description":"- Repository//github.com/yahoojapan/NGT","source":"@site/i18n/zh-cn/docusaurus-plugin-content-docs/current/retrieve/vector/ngt.mdx","sourceDirName":"retrieve/vector","slug":"/retrieve/vector/ngt","permalink":"/cppdev/zh-cn/docs/retrieve/vector/ngt","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"NMSLIB (Non-Metric Space Library) Overview","permalink":"/cppdev/zh-cn/docs/retrieve/vector/nmslib"},"next":{"title":"DiskANN (Disk-based Approximate Nearest Neighbor) Overview","permalink":"/cppdev/zh-cn/docs/retrieve/vector/diskann"}}');var s=r(4848),t=r(8453);const d={},c="NGT (Neighborhood Graph and Tree) Overview",l={},o=[{value:"Purpose &amp; Use Cases",id:"purpose--use-cases",level:2},{value:"Algorithms Supported",id:"algorithms-supported",level:2},{value:"Core Technical Specifications",id:"core-technical-specifications",level:2},{value:"1. Supported Metric Spaces",id:"1-supported-metric-spaces",level:3},{value:"2. Supported Data Types",id:"2-supported-data-types",level:3},{value:"3. Real-Time Data Insertion/Deletion Support",id:"3-real-time-data-insertiondeletion-support",level:3},{value:"Characteristics",id:"characteristics",level:2},{value:"Notes",id:"notes",level:2}];function a(e){const i={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"ngt-neighborhood-graph-and-tree-overview",children:"NGT (Neighborhood Graph and Tree) Overview"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Repository:"})," ",(0,s.jsx)(i.a,{href:"https://github.com/yahoojapan/NGT",children:"https://github.com/yahoojapan/NGT"})]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Language:"})," C++ (Python bindings available)"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"purpose--use-cases",children:"Purpose & Use Cases"}),"\n",(0,s.jsxs)(i.p,{children:["NGT is a ",(0,s.jsx)(i.strong,{children:"vector similarity search engine"})," designed for ",(0,s.jsx)(i.strong,{children:"high-dimensional data"}),". It is suitable for:"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Approximate nearest neighbor (ANN) search over large datasets."}),"\n",(0,s.jsxs)(i.li,{children:["Scenarios where ",(0,s.jsx)(i.strong,{children:"batch index building"})," is acceptable."]}),"\n",(0,s.jsxs)(i.li,{children:["Systems where ",(0,s.jsx)(i.strong,{children:"insertion is occasional"}),", rather than fully real-time dynamic updates."]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"Typical applications include:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Recommendation systems with offline embedding indexing."}),"\n",(0,s.jsx)(i.li,{children:"Image or text feature retrieval for search or ranking pipelines."}),"\n",(0,s.jsx)(i.li,{children:"Large-scale analytics where high-dimensional vectors need similarity queries."}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"algorithms-supported",children:"Algorithms Supported"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"NSW (Navigable Small World graph)"})," for fast approximate nearest neighbor search."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"NGT-tree"})," (combines graph and tree structures for indexing)."]}),"\n",(0,s.jsxs)(i.li,{children:["Supports ",(0,s.jsx)(i.strong,{children:"metric spaces"})," (detailed below) such as L2 (Euclidean) and cosine similarity."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"core-technical-specifications",children:"Core Technical Specifications"}),"\n",(0,s.jsx)(i.h3,{id:"1-supported-metric-spaces",children:"1. Supported Metric Spaces"}),"\n",(0,s.jsx)(i.p,{children:"NGT supports a comprehensive set of metric and non-metric similarity measures, covering most common use cases for high-dimensional vector comparison:"}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Metric Type"}),(0,s.jsx)(i.th,{children:"Full Name"}),(0,s.jsx)(i.th,{children:"Use Case Scenarios"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"L2"}),(0,s.jsx)(i.td,{children:"Euclidean Distance"}),(0,s.jsx)(i.td,{children:"General numerical vector similarity (e.g., image feature vectors, dense embeddings)."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Cosine"}),(0,s.jsx)(i.td,{children:"Cosine Similarity/Distance"}),(0,s.jsx)(i.td,{children:"Text embedding similarity (e.g., BERT embeddings), direction-based vector comparison."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"L1"}),(0,s.jsx)(i.td,{children:"Manhattan Distance (City Block)"}),(0,s.jsx)(i.td,{children:"Sparse vector scenarios, feature difference aggregation (e.g., tabular data vectors)."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"L\u221e (Chebyshev)"}),(0,s.jsx)(i.td,{children:"Chebyshev Distance"}),(0,s.jsx)(i.td,{children:"Maximizing feature difference (e.g., outlier detection in high-dimensional data)."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Angle"}),(0,s.jsx)(i.td,{children:"Angular Distance"}),(0,s.jsx)(i.td,{children:"Pure direction similarity (ignores vector magnitude, alternative to cosine)."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Hamming"}),(0,s.jsx)(i.td,{children:"Hamming Distance"}),(0,s.jsx)(i.td,{children:"Binary vector comparison (e.g., bitwise feature vectors, hash-based retrieval)."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Jaccard"}),(0,s.jsx)(i.td,{children:"Jaccard Similarity/Distance"}),(0,s.jsx)(i.td,{children:"Set-based vector similarity (e.g., sparse boolean feature vectors)."})]})]})]}),"\n",(0,s.jsxs)(i.blockquote,{children:["\n",(0,s.jsx)(i.p,{children:"Note: For non-metric spaces (e.g., Jaccard), NGT maintains approximate nearest neighbor search performance but does not guarantee strict metric axioms."}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"2-supported-data-types",children:"2. Supported Data Types"}),"\n",(0,s.jsx)(i.p,{children:"NGT optimizes for numerical vector data, with explicit support for the following scalar types (consistent across C++ and Python bindings, including FP16/float16 support):"}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Data Type"}),(0,s.jsx)(i.th,{children:"Precision"}),(0,s.jsx)(i.th,{children:"C++ Type"}),(0,s.jsx)(i.th,{children:"Python Binding Mapping"}),(0,s.jsx)(i.th,{children:"Use Case"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Float16 (FP16)"}),(0,s.jsx)(i.td,{children:"16-bit"}),(0,s.jsxs)(i.td,{children:[(0,s.jsx)(i.code,{children:"float16_t"}),"/",(0,s.jsx)(i.code,{children:"half"})]}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"numpy.float16"})}),(0,s.jsx)(i.td,{children:"Memory-efficient high-dimensional vectors (e.g., large-scale embedding datasets, GPU-generated embeddings)."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Float32"}),(0,s.jsx)(i.td,{children:"32-bit"}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"float"})}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"numpy.float32"})}),(0,s.jsx)(i.td,{children:"Default (balance of precision/speed/memory)."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Float64 (Double)"}),(0,s.jsx)(i.td,{children:"64-bit"}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"double"})}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"numpy.float64"})}),(0,s.jsx)(i.td,{children:"High-precision scenarios (e.g., scientific computing)."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Int32"}),(0,s.jsx)(i.td,{children:"32-bit"}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"int32_t"})}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"numpy.int32"})}),(0,s.jsx)(i.td,{children:"Discrete feature vectors (e.g., count-based embeddings)."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Int64"}),(0,s.jsx)(i.td,{children:"64-bit"}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"int64_t"})}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"numpy.int64"})}),(0,s.jsx)(i.td,{children:"Large discrete value vectors."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Binary"}),(0,s.jsx)(i.td,{children:"Bit-level"}),(0,s.jsxs)(i.td,{children:[(0,s.jsx)(i.code,{children:"uint8_t"})," (packed)"]}),(0,s.jsxs)(i.td,{children:[(0,s.jsx)(i.code,{children:"numpy.uint8"})," (bitpacked)"]}),(0,s.jsx)(i.td,{children:"Hamming distance scenarios (space-efficient binary vectors)."})]})]})]}),"\n",(0,s.jsxs)(i.blockquote,{children:["\n",(0,s.jsx)(i.p,{children:"Key Notes:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"Float16 support: NGT natively supports 16-bit floating-point vectors (FP16/half-precision) in both C++ core and Python bindings. This is particularly valuable for reducing memory footprint in large-scale embedding systems (e.g., millions/billions of high-dim vectors) and aligning with GPU-generated embeddings (common in deep learning workflows)."}),"\n",(0,s.jsxs)(i.li,{children:["Python bindings: ",(0,s.jsx)(i.code,{children:"numpy.float16"})," arrays are directly compatible with NGT\u2019s ",(0,s.jsx)(i.code,{children:"insert"}),"/",(0,s.jsx)(i.code,{children:"build_index"})," APIs; no manual type conversion is required (NGT handles FP16 internally for indexing/querying)."]}),"\n",(0,s.jsx)(i.li,{children:"Precision tradeoff: Float16 reduces memory usage by 50% vs Float32, with minimal precision loss for most embedding similarity search scenarios (recommended for production when precision requirements allow)."}),"\n",(0,s.jsxs)(i.li,{children:["Binary vectors: Require explicit bitpacking via ",(0,s.jsx)(i.code,{children:"ngtpy"})," utilities for optimal performance with Hamming distance."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"3-real-time-data-insertiondeletion-support",children:"3. Real-Time Data Insertion/Deletion Support"}),"\n",(0,s.jsxs)(i.p,{children:["NGT\u2019s support for dynamic data updates (insertion/deletion) is ",(0,s.jsx)(i.strong,{children:"partial and non-real-time optimized"}),", with clear limitations for high-frequency dynamic workloads:"]}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Operation"}),(0,s.jsx)(i.th,{children:"Support Level"}),(0,s.jsx)(i.th,{children:"Details & Constraints"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Incremental Insertion"}),(0,s.jsx)(i.td,{children:"Partial support (semi-real-time)"}),(0,s.jsxs)(i.td,{children:["- Small-batch incremental insertion is allowed (e.g., hundreds/thousands of vectors at a time).",(0,s.jsx)("br",{}),"- Inserted vectors require a ",(0,s.jsx)(i.code,{children:"build_index"}),"/",(0,s.jsx)(i.code,{children:"optimize"})," call to be fully integrated into the search graph (otherwise query performance degrades).",(0,s.jsx)("br",{}),"- Not designed for high-frequency single-vector insertions (e.g., >1000 inserts/sec) \u2013 high latency and index fragmentation will occur."]})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Real-Time Deletion"}),(0,s.jsx)(i.td,{children:"Limited support (non-real-time)"}),(0,s.jsxs)(i.td,{children:["- Deletion of vectors is possible via ",(0,s.jsx)(i.code,{children:"remove"})," API, but requires a full index rebuild/optimization to clean up deleted entries from the graph structure.",(0,s.jsx)("br",{}),'- Deleted vectors are marked as "invalid" in the index (not immediately purged), leading to gradual memory bloat.',(0,s.jsx)("br",{}),"- No native support for low-latency (sub-second) deletion of vectors in production indexes."]})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Vector Modification"}),(0,s.jsx)(i.td,{children:"No direct support"}),(0,s.jsx)(i.td,{children:"- To modify a vector, users must delete the original entry and re-insert the updated vector (inherits all deletion/insertion constraints above)."})]})]})]}),"\n",(0,s.jsxs)(i.blockquote,{children:["\n",(0,s.jsxs)(i.p,{children:["Critical Note: NGT is ",(0,s.jsx)(i.strong,{children:"not optimized for real-time dynamic workloads"})," (e.g., user-generated content embeddings requiring immediate indexing, or high-turnover datasets). For use cases needing sub-second insertion/deletion with consistent query performance, consider complementary tools (e.g., combining NGT for batch indexing with a lightweight in-memory ANN for real-time vectors) or alternative engines (e.g., FAISS with IVF indexes, or Milvus for fully dynamic workloads)."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"characteristics",children:"Characteristics"}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Feature"}),(0,s.jsx)(i.th,{children:"Description"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Incremental Updates"}),(0,s.jsx)(i.td,{children:"Partial incremental insertion supported; real-time deletion/modification not fully supported."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Query Speed"}),(0,s.jsx)(i.td,{children:"High, especially on pre-built indexes; optimized for ANN search (FP16 queries are as fast as FP32 with lower memory overhead)."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Index Type"}),(0,s.jsx)(i.td,{children:"Graph-based and tree hybrid."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Scalability"}),(0,s.jsx)(i.td,{children:"Handles millions/billions of vectors efficiently with disk-backed storage (FP16 enables larger datasets on the same hardware)."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Language Bindings"}),(0,s.jsx)(i.td,{children:"C++ and Python."})]})]})]}),"\n",(0,s.jsx)(i.h2,{id:"notes",children:"Notes"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["NGT is ",(0,s.jsx)(i.strong,{children:"more suitable for offline or semi-online workloads"}),", where indexes can be built or updated in batches."]}),"\n",(0,s.jsx)(i.li,{children:"Not designed for high-frequency real-time insertion/deletion scenarios."}),"\n",(0,s.jsx)(i.li,{children:"For binary vectors (Hamming distance), NGT uses optimized bitwise operations to reduce memory overhead and accelerate queries."}),"\n",(0,s.jsxs)(i.li,{children:["When using non-L2 metrics (e.g., cosine), NGT normalizes vectors during index building by default (configurable via ",(0,s.jsx)(i.code,{children:"normalize"})," parameter); normalization is compatible with all float types (FP16/FP32/FP64)."]}),"\n",(0,s.jsx)(i.li,{children:"Float16 is recommended for large-scale embedding deployments (e.g., >10M vectors with dim \u2265 128) to balance memory, speed, and precision."}),"\n",(0,s.jsx)(i.li,{children:'For dynamic workloads: If real-time updates are required, NGT is best used in a "hybrid" architecture (batch-indexed NGT for historical data + in-memory ANN for real-time vectors) or with scheduled batch reindexing (e.g., hourly/daily) to mitigate deletion/insertion limitations.'}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},8453:(e,i,r)=>{r.d(i,{R:()=>d,x:()=>c});var n=r(6540);const s={},t=n.createContext(s);function d(e){const i=n.useContext(t);return n.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function c(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),n.createElement(t.Provider,{value:i},e.children)}}}]);