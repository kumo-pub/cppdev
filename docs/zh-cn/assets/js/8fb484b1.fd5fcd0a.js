"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[8560],{2814:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>c,metadata:()=>n,toc:()=>a});const n=JSON.parse('{"id":"foundamentals/testing/doct/testcases","title":"Test Cases","description":"Test Cases","source":"@site/i18n/zh-cn/docusaurus-plugin-content-docs/current/foundamentals/testing/doct/testcases.mdx","sourceDirName":"foundamentals/testing/doct","slug":"/foundamentals/testing/doct/testcases","permalink":"/cppdev/zh-cn/docs/foundamentals/testing/doct/testcases","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Assertions","permalink":"/cppdev/zh-cn/docs/foundamentals/testing/doct/assertions"},"next":{"title":"Parameterized Tests","permalink":"/cppdev/zh-cn/docs/foundamentals/testing/doct/parameterized-tests"}}');var i=t(4848),r=t(8453);const c={},o="Test Cases",d={},a=[{value:"Test Cases",id:"test-cases",level:2},{value:"BDD-style Test Cases",id:"bdd-style-test-cases",level:2},{value:"Test Fixtures",id:"test-fixtures",level:2},{value:"Test Suites",id:"test-suites",level:2},{value:"Decorators",id:"decorators",level:2}];function l(e){const s={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"test-cases",children:"Test Cases"})}),"\n",(0,i.jsx)(s.h2,{id:"test-cases",children:"Test Cases"}),"\n",(0,i.jsxs)(s.p,{children:["While ",(0,i.jsx)(s.strong,{children:"doctest"})," fully supports the traditional xUnit style based on classes containing test case methods,\nthis is not the preferred style. Instead, ",(0,i.jsx)(s.strong,{children:"doctest"})," provides a powerful mechanism for nesting subcases within test cases. For a more detailed discussion and examples, see ",(0,i.jsx)(s.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/doct/tutorial#test-cases-and-subcases",children:(0,i.jsx)(s.strong,{children:"tutorial"})}),"."]}),"\n",(0,i.jsx)(s.p,{children:"Test cases and subcases are very easy to use in practice:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"TEST_CASE("})," ",(0,i.jsx)(s.code,{children:"test name"})," ",(0,i.jsx)(s.strong,{children:")"})]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"SUBCASE("})," ",(0,i.jsx)(s.code,{children:"subcase name"})," ",(0,i.jsx)(s.strong,{children:")"})]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"test name"})," and ",(0,i.jsx)(s.code,{children:"subcase name"})," are free-form, quoted strings. Test names do not have to be unique within a ",(0,i.jsx)(s.strong,{children:"doctest"})," executable. They should also be string literals."]}),"\n",(0,i.jsxs)(s.p,{children:["Test cases can be written inside class bodies in C++17 with the help of ",(0,i.jsx)(s.code,{children:"TEST_CASE_CLASS()"})," - used just like ",(0,i.jsx)(s.code,{children:"TEST_CASE()"})," - making it easier to access private parts of test classes."]}),"\n",(0,i.jsxs)(s.p,{children:["Remember that even though ",(0,i.jsx)(s.strong,{children:"doctest"})," is ",(0,i.jsx)(s.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/doct/faq#is-doctest-thread-aware",children:(0,i.jsx)(s.strong,{children:"thread-safe"})})," - the use of subcases can only be done in the main test runner thread."]}),"\n",(0,i.jsxs)(s.p,{children:["Test cases can also be parameterized - see the ",(0,i.jsx)(s.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/doct/parameterized-tests",children:(0,i.jsx)(s.strong,{children:"documentation"})}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["Test cases and subcases can be filtered by using the ",(0,i.jsx)(s.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/doct/commandline",children:(0,i.jsx)(s.strong,{children:"command line"})}),"."]}),"\n",(0,i.jsx)(s.h2,{id:"bdd-style-test-cases",children:"BDD-style Test Cases"}),"\n",(0,i.jsxs)(s.p,{children:["In addition to the classic test case style adopted by ",(0,i.jsx)(s.strong,{children:"doctest"}),", ",(0,i.jsx)(s.strong,{children:"doctest"}),' also supports an alternative syntax that allows tests to be written as "executable specifications" (one of the early goals of ',(0,i.jsx)(s.a,{href:"http://dannorth.net/introducing-bdd/",children:"Behavior-Driven Development"}),"). This set of macros maps to ",(0,i.jsx)(s.code,{children:"TEST_CASE"})," and ",(0,i.jsx)(s.code,{children:"SUBCASE"}),", with some internal support to make them easier to use."]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"SCENARIO("})," ",(0,i.jsx)(s.code,{children:"scenario name"})," ",(0,i.jsx)(s.strong,{children:")"})]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["This macro maps to ",(0,i.jsx)(s.code,{children:"TEST_CASE"})," and works in the same way, except that the test case name will be prefixed with ",(0,i.jsx)(s.code,{children:"Scenario: "}),"."]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"SCENARIO_TEMPLATE("})," ",(0,i.jsx)(s.code,{children:"scenario name"}),", ",(0,i.jsx)(s.em,{children:"type"}),", ",(0,i.jsx)(s.code,{children:"list of types"})," ",(0,i.jsx)(s.strong,{children:")"})]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["This macro maps to ``TEST_CASE_TEMPLATE``` and works in the same way, except that the test case name will be prefixed with ",(0,i.jsx)(s.code,{children:"Scenario: "}),"."]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"SCENARIO_TEMPLATE_DEFINE("})," ",(0,i.jsx)(s.code,{children:"scenario name"}),", ",(0,i.jsx)(s.em,{children:"type"}),", ",(0,i.jsx)(s.em,{children:"id"})," ",(0,i.jsx)(s.strong,{children:")"})]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["This macro maps to ``TEST_CASE_TEMPLATE_DEFINE``` and works in the same way, except that the test case name will be prefixed with ",(0,i.jsx)(s.code,{children:"Scenario: "}),"."]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"GIVEN("})," ",(0,i.jsx)(s.em,{children:"something"})," ",(0,i.jsx)(s.strong,{children:")"})]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"WHEN("})," ",(0,i.jsx)(s.em,{children:"something"})," ",(0,i.jsx)(s.strong,{children:")"})]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"THEN("})," ",(0,i.jsx)(s.em,{children:"something"})," ",(0,i.jsx)(s.strong,{children:")"})]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["These macros map to ",(0,i.jsx)(s.code,{children:"SUBCASE"}),", except that the subcase name is ",(0,i.jsx)(s.em,{children:"something"})," prefixed with ",(0,i.jsx)(s.code,{children:"given: "}),", ",(0,i.jsx)(s.code,{children:"when: "}),", or ",(0,i.jsx)(s.code,{children:"then: "})," respectively."]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"AND_WHEN("})," ",(0,i.jsx)(s.em,{children:"something"})," ",(0,i.jsx)(s.strong,{children:")"})]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"AND_THEN("})," ",(0,i.jsx)(s.em,{children:"something"})," ",(0,i.jsx)(s.strong,{children:")"})]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["Similar to ",(0,i.jsx)(s.code,{children:"WHEN"})," and ",(0,i.jsx)(s.code,{children:"THEN"}),", except the prefix starts with ",(0,i.jsx)(s.code,{children:"and "}),". They are used to chain WHENs and THENs together."]}),"\n",(0,i.jsx)(s.p,{children:"When any of these macros are used, the console reporter recognizes them and formats the test case headings to align the Givens, Whens, and Thens to aid readability."}),"\n",(0,i.jsxs)(s.p,{children:["Beyond the additional prefixes and formatting in the console reporter, these macros behave exactly like ",(0,i.jsx)(s.code,{children:"TEST_CASE"})," and ",(0,i.jsx)(s.code,{children:"SUBCASE"}),". Therefore, there is nothing to enforce the correct ordering of these macros - that is up to the programmer!"]}),"\n",(0,i.jsxs)(s.p,{children:["Note that when using the ",(0,i.jsx)(s.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/doct/commandline",children:(0,i.jsx)(s.code,{children:"--test-case=<filters>"})})," command line option (or ",(0,i.jsx)(s.code,{children:"--subcase=<filters>"}),") you must also pass the prefix ",(0,i.jsx)(s.code,{children:"Scenario: "}),"."]}),"\n",(0,i.jsx)(s.h2,{id:"test-fixtures",children:"Test Fixtures"}),"\n",(0,i.jsxs)(s.p,{children:["Although ",(0,i.jsx)(s.strong,{children:"doctest"})," allows you to group tests together as subcases within test cases, it is sometimes still convenient to group them using more traditional test fixtures. ",(0,i.jsx)(s.strong,{children:"doctest"})," fully supports this as well. You define a test fixture as a simple struct:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-c++",children:'class UniqueTestsFixture {\nprivate:\n    static int uniqueID;\nprotected:\n    DBConnection conn;\npublic:\n    UniqueTestsFixture() : conn(DBConnection::createConnection("myDB")) {}\nprotected:\n    int getID() {\n        return ++uniqueID;\n    }\n};\n\nint UniqueTestsFixture::uniqueID = 0;\n\nTEST_CASE_FIXTURE(UniqueTestsFixture, "Create Employee/No Name") {\n    REQUIRE_THROWS(conn.executeSQL("INSERT INTO employee (id, name) VALUES (?, ?)", getID(), ""));\n}\nTEST_CASE_FIXTURE(UniqueTestsFixture, "Create Employee/Normal") {\n    REQUIRE(conn.executeSQL("INSERT INTO employee (id, name) VALUES (?, ?)", getID(), "Joe Bloggs"));\n}\n'})}),"\n",(0,i.jsxs)(s.p,{children:["The two test cases here will create uniquely named derived classes of UniqueTestsFixture, and thus have access to the ",(0,i.jsx)(s.code,{children:"getID()"})," protected method and the ",(0,i.jsx)(s.code,{children:"conn"})," member variable. This ensures that both test cases are able to create a DBConnection using the same method (DRY principle), and any IDs created are unique, so the order of test execution does not matter."]}),"\n",(0,i.jsx)(s.h2,{id:"test-suites",children:"Test Suites"}),"\n",(0,i.jsxs)(s.p,{children:["Test cases can be grouped into test suites. This is done with ",(0,i.jsx)(s.code,{children:"TEST_SUITE()"})," or ",(0,i.jsx)(s.code,{children:"TEST_SUITE_BEGIN()"}),"/",(0,i.jsx)(s.code,{children:"TEST_SUITE_END()"}),"."]}),"\n",(0,i.jsx)(s.p,{children:"For example:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-c++",children:'TEST_CASE("") {} // not part of any test suite\n\nTEST_SUITE("math") {\n    TEST_CASE("") {} // part of the math test suite\n    TEST_CASE("") {} // part of the math test suite\n}\n\nTEST_SUITE_BEGIN("utils");\n\nTEST_CASE("") {} // part of the utils test suite\n\nTEST_SUITE_END();\n\nTEST_CASE("") {} // not part of any test suite\n'})}),"\n",(0,i.jsxs)(s.p,{children:["Test cases in specific test suites can then be executed with the help of filters - see ",(0,i.jsx)(s.a,{href:"/cppdev/zh-cn/docs/foundamentals/testing/doct/commandline",children:(0,i.jsx)(s.strong,{children:"command line"})}),"."]}),"\n",(0,i.jsx)(s.h2,{id:"decorators",children:"Decorators"}),"\n",(0,i.jsxs)(s.p,{children:["Test cases can be ",(0,i.jsx)(s.code,{children:"decorated"})," with additional attributes like this:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-c++",children:'TEST_CASE("name"\n          * doctest::description("shouldn\'t take more than 500ms")\n          * doctest::timeout(0.5)) {\n    // asserts\n}\n'})}),"\n",(0,i.jsx)(s.p,{children:"Multiple decorators can be used at the same time. These are the currently supported decorators:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"skip(bool = true)"})})," - Marks the test case to be skipped from execution - unless the ",(0,i.jsx)(s.code,{children:"--no-skip"})," option is used"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"no_breaks(bool = true)"})})," - Assertions in the test case do not break into the debugger - useful in combination with ",(0,i.jsx)(s.code,{children:"may_fail"}),"/",(0,i.jsx)(s.code,{children:"should_fail"}),"/",(0,i.jsx)(s.code,{children:"expected_failures"})]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"no_output(bool = true)"})})," - Assertions in the test case have no output - useful in combination with ",(0,i.jsx)(s.code,{children:"may_fail"}),"/",(0,i.jsx)(s.code,{children:"should_fail"}),"/",(0,i.jsx)(s.code,{children:"expected_failures"})]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"may_fail(bool = true)"})})," - The test does not fail if any given assertion fails (but still reports it) - this is useful for marking work in progress, or known issues that you do not want to fix immediately but still want to track in tests"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"should_fail(bool = true)"})})," - Like ",(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"may_fail()"})})," but the test fails if it passes - this can be useful if you want to be notified of accidental or third-party fixes"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"expected_failures(int)"})})," - Defines the number of assertions expected to fail in the test case - reported as a failure when the number of failed assertions differs from the declared expected failures"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"timeout(double)"})})," - The test case fails if its execution exceeds this limit (in seconds) - but does not terminate it - this requires subprocess support"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:'test_suite("name")'})})," - Can be used on test cases to override (or just set) the test suite they are in"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:'description("text")'})})," - A description for the test case"]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["The values taken by decorators are evaluated when the test case is registered (during global initialization) - before entering ",(0,i.jsx)(s.code,{children:"main()"}),", not before running them."]}),"\n",(0,i.jsx)(s.p,{children:"Decorators can also be applied to test suite blocks, and all test cases within the block inherit them:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-c++",children:'TEST_SUITE("some TS" * doctest::description("all tests will have this")) {\n    TEST_CASE("has a description from the surrounding test suite") {\n        // asserts\n    }\n}\nTEST_SUITE("some TS") {\n    TEST_CASE("no description even though in the same test suite as the one above") {\n        // asserts\n    }\n}\n'})}),"\n",(0,i.jsx)(s.p,{children:"Test cases can override decorators they inherit from the surrounding test suite:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-c++",children:'TEST_SUITE("not longer than 500ms" * doctest::timeout(0.5)) {\n    TEST_CASE("500ms limit") {\n        // asserts\n    }\n    TEST_CASE("200ms limit" * doctest::timeout(0.2)) {\n        // asserts\n    }\n}\n'})}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Check out the ",(0,i.jsx)(s.a,{href:"https://github.com/doctest/doctest/blob/master/examples/all_features/subcases.cpp",children:(0,i.jsx)(s.strong,{children:"subcases and BDD example"})})]}),"\n",(0,i.jsxs)(s.li,{children:["Check out the ",(0,i.jsx)(s.a,{href:"https://github.com/doctest/doctest/blob/master/examples/all_features/assertion_macros.cpp",children:(0,i.jsx)(s.strong,{children:"assertion macros example"})})," to see how test suites are used"]}),"\n",(0,i.jsx)(s.li,{children:"Tests are registered from top to bottom of each processed cpp after preprocessing and including the header, but there is no order between cpp files."}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,s,t)=>{t.d(s,{R:()=>c,x:()=>o});var n=t(6540);const i={},r=n.createContext(i);function c(e){const s=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),n.createElement(r.Provider,{value:s},e.children)}}}]);