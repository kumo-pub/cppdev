"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[3107],{1032:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"foundamentals/log/logging","title":"Logging","description":"The turbo Logging library provides tools for writing short text messages about program state to stderr, disk files, or other receivers (via the extension API).","source":"@site/docs/foundamentals/log/logging.mdx","sourceDirName":"foundamentals/log","slug":"/foundamentals/log/logging","permalink":"/cppdev/zh-cn/docs/foundamentals/log/logging","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/foundamentals/log/logging.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Log Tutorial","permalink":"/cppdev/zh-cn/docs/category/log-tutorial"},"next":{"title":"Custom Log Sinks","permalink":"/cppdev/zh-cn/docs/foundamentals/log/sinks"}}');var r=n(4848),o=n(8453);const t={},l="Logging",d={},a=[{value:"API Overview",id:"API",level:2},{value:"<code>KLOG()</code> Macro",id:"KLOG",level:3},{value:"<code>kCHECK()</code> Macro",id:"kCHECK",level:3},{value:"Log Levels",id:"severity",level:3},{value:"Four Proper Log Levels",id:"four-proper-log-levels",level:4},{value:"<code>INFO</code>",id:"severity-info",level:5},{value:"<code>WARNING</code>",id:"severity-warning",level:5},{value:"<code>ERROR</code>",id:"severity-error",level:5},{value:"<code>FATAL</code>",id:"severity-fatal",level:5},{value:"Two Pseudo-Levels",id:"two-pseudo-levels",level:4},{value:"<code>DFATAL</code>",id:"severity-dfatal",level:5},{value:"<code>QFATAL</code>",id:"severity-qfatal",level:5},{value:"Dynamic Log Levels",id:"dynamic-log-levels",level:3},{value:"<code>VKLOG()</code> Macro",id:"VKLOG",level:3},{value:"Other Macro Variants",id:"mutators",level:3},{value:"Mutator Methods",id:"mutator-methods",level:3},{value:"Log Message Output",id:"output",level:2},{value:"Log Prefix",id:"prefix",level:3},{value:"<code>stderr</code> Output",id:"stderr",level:3}];function c(e){const s={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"logging",children:"Logging"})}),"\n",(0,r.jsxs)(s.p,{children:["The turbo Logging library provides tools for writing short text messages about program state to ",(0,r.jsx)(s.code,{children:"stderr"}),", ",(0,r.jsx)(s.code,{children:"disk files"}),", or ",(0,r.jsx)(s.code,{children:"other receivers"})," (via the extension API)."]}),"\n",(0,r.jsx)(s.h2,{id:"API",children:"API Overview"}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"KLOG()"})," and ",(0,r.jsx)(s.code,{children:"kCHECK()"})," macro families are the core of the API. Each forms the start of a statement into which additional data can be streamed, much like ",(0,r.jsx)(s.code,{children:"std::cout"}),"."]}),"\n",(0,r.jsxs)(s.p,{children:["All data streamed into a single macro will be concatenated and written to the log file as one message, with a ",(0,r.jsx)(s.a,{href:"#prefix",children:"prefix"})," formed from metadata (time, file/line, etc.). Notably, unlike ",(0,r.jsx)(s.code,{children:"std::cout"}),", the library supplies a newline at the end of each message, so you should generally not end log statements with ",(0,r.jsx)(s.code,{children:"\\n"})," or ",(0,r.jsx)(s.code,{children:"std::endl"}),". Any newlines ",(0,r.jsx)(s.em,{children:"that are"})," streamed in will appear in the log file."]}),"\n",(0,r.jsx)(s.p,{children:"For more detailed information, refer to the header files."}),"\n",(0,r.jsxs)(s.h3,{id:"KLOG",children:[(0,r.jsx)(s.code,{children:"KLOG()"})," Macro"]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"KLOG()"})," takes a severity level as an argument, which defines the granularity and type of logging information to be recorded. The four basic severity levels are ",(0,r.jsx)(s.code,{children:"INFO"}),", ",(0,r.jsx)(s.code,{children:"WARNING"}),", ",(0,r.jsx)(s.code,{children:"ERROR"}),", and ",(0,r.jsx)(s.code,{children:"FATAL"}),". ",(0,r.jsx)(s.code,{children:"FATAL"})," is not named arbitrarily; it causes the logging library to terminate the process after recording the streamed message.\nSee below for more information on ",(0,r.jsx)(s.a,{href:"#severity",children:"log levels"}),", including best practices for choosing one."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-c++",children:'KLOG(INFO) << "Hello Kumo!";\n'})}),"\n",(0,r.jsx)(s.p,{children:"This will generate a message in the log like the following:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-text",children:"I0926 09:00:00.000000 12345 foo.cc:10] Hello Kumo!\n"})}),"\n",(0,r.jsxs)(s.p,{children:["The format of the metadata is documented ",(0,r.jsx)(s.a,{href:"#prefix",children:"below"}),"."]}),"\n",(0,r.jsxs)(s.h3,{id:"kCHECK",children:[(0,r.jsx)(s.code,{children:"kCHECK()"})," Macro"]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"kCHECK()"})," is an assertion. Its severity is always ",(0,r.jsx)(s.code,{children:"FATAL"}),", so its only argument is a condition that ",(0,r.jsx)(s.code,{children:"should"})," be true. If not, ",(0,r.jsx)(s.code,{children:"kCHECK()"})," writes to the log and terminates the process. It is active in ",(0,r.jsx)(s.strong,{children:"all build modes"})," (unlike the C ",(0,r.jsx)(s.code,{children:"assert()"})," macro) and logs failures to the application log in a manner similar to ",(0,r.jsx)(s.code,{children:"KLOG()"}),", but includes additional information about the reason for the failure and where it occurred."]}),"\n",(0,r.jsxs)(s.p,{children:["Like ",(0,r.jsx)(s.code,{children:"FATAL"}),", ",(0,r.jsx)(s.code,{children:"CHECK()"})," assertions should be used sparingly (especially in server code) and only in cases where it is better to actually terminate the process rather than attempt recovery: for example, unrecoverable errors, or memory corruption that could corrupt user data. Note that you should also be aware of where your code may be running; a ",(0,r.jsx)(s.code,{children:"kCHECK()"})," in a command-line utility or batch processing job requires less caution than a ",(0,r.jsx)(s.code,{children:"CHECK()"})," in a user-facing service. If you are unsure where the code will run (e.g., if you are writing a utility library), err on the side of caution and assume it will be used in production-facing services, and avoid ",(0,r.jsx)(s.code,{children:"kCHECK()"})," whenever possible."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-c++",children:'kCHECK(!filenames_sorted.empty()) << "no files matched";\nProcessFile(filenames_sorted.front());\n'})}),"\n",(0,r.jsx)(s.p,{children:"This will generate a message in the log like the following:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{children:"F0926 09:00:01.000000   12345 foo.cc:100] Check failed: !filenames_sorted.empty() no files matched\nE0926 09:00:01.150000   12345 process_state.cc:1133] *** SIGABRT received by PID 12345 (TID 12345) on cpu 0 from PID 12345; stack trace: ***\nE0926 09:00:01.250000   12345 process_state.cc:1136] PC: @     0xdeadbeef  (unknown)  raise\n    @     0xdeadbeef       1920  FailureSignalHandler()\n    @     0xdeadc0w5    2377680  (unknown)\n(more stack frames follow)\n"})}),"\n",(0,r.jsxs)(s.p,{children:["Note that this log entry uses the prefix ",(0,r.jsx)(s.code,{children:"F"})," for the ",(0,r.jsx)(s.code,{children:"FATAL"})," log level. The text of the condition itself is recorded before the streamed operands.\nAdditionally, the stack trace is logged at severity ",(0,r.jsx)(s.code,{children:"ERROR"})," (on lines prefixed with ",(0,r.jsx)(s.code,{children:"E"})," for ",(0,r.jsx)(s.code,{children:"ERROR"}),") after the ",(0,r.jsx)(s.code,{children:"FATAL"})," message but before process termination."]}),"\n",(0,r.jsxs)(s.p,{children:["A special two-argument form is spelled ",(0,r.jsx)(s.code,{children:"CHECK_EQ()"}),", ",(0,r.jsx)(s.code,{children:"CHECK_GT()"}),", ",(0,r.jsx)(s.code,{children:"CHECK_STREQ()"})," (for ",(0,r.jsx)(s.code,{children:"char*"})," strings), etc., which can be used to assert comparisons between streamable, comparable types. In addition to the text of the arguments, these forms record the actual values of the arguments."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-c++",children:'int x = 3, y = 5;\nCHECK_EQ(2 * x, y) << "oops!";\n'})}),"\n",(0,r.jsx)(s.p,{children:"This will generate a message in the log like the following:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{children:"F0926 09:00:02.000000   12345 foo.cc:20] Check failed: 2 * x == y (6 vs. 5) oops!\n"})}),"\n",(0,r.jsx)(s.h3,{id:"severity",children:"Log Levels"}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"turbo::LogSeverity"})," type represents severity levels. The argument to ",(0,r.jsx)(s.code,{children:"KLOG()"})," is not actually of this type, or ",(0,r.jsx)(s.em,{children:"any"})," type. Some macro trickery is used to make ",(0,r.jsx)(s.code,{children:"KLOG(ERROR)"})," work without using a macro or global symbol named ",(0,r.jsx)(s.code,{children:"ERROR"}),". This is necessary because ",(0,r.jsx)(s.code,{children:"ERROR"})," is defined by some popular third-party packages (e.g., Microsoft Windows) and cannot be redefined."]}),"\n",(0,r.jsx)(s.h4,{id:"four-proper-log-levels",children:"Four Proper Log Levels"}),"\n",(0,r.jsx)(s.h5,{id:"severity-info",children:(0,r.jsx)(s.code,{children:"INFO"})}),"\n",(0,r.jsxs)(s.p,{children:["Corresponds to ",(0,r.jsx)(s.code,{children:"turbo::LogSeverity::kInfo"}),". It describes ",(0,r.jsx)(s.em,{children:"expected"})," events that are important for understanding the state of the ",(0,r.jsx)(s.em,{children:"program"})," but do not indicate a problem. Libraries, especially low-level public libraries, should use this level sparingly to avoid spamming the logs of every program that uses them."]}),"\n",(0,r.jsx)(s.h5,{id:"severity-warning",children:(0,r.jsx)(s.code,{children:"WARNING"})}),"\n",(0,r.jsxs)(s.p,{children:["Corresponds to ",(0,r.jsx)(s.code,{children:"turbo::LogSeverity::kWarning"}),". It describes unexpected events that ",(0,r.jsx)(s.em,{children:"may"})," indicate a problem but from which the program can recover."]}),"\n",(0,r.jsx)(s.h5,{id:"severity-error",children:(0,r.jsx)(s.code,{children:"ERROR"})}),"\n",(0,r.jsxs)(s.p,{children:["Corresponds to ",(0,r.jsx)(s.code,{children:"turbo::LogSeverity::kError"}),". It describes unexpected problematic events from which the program was able to recover. ",(0,r.jsx)(s.code,{children:"ERROR"})," messages should be actionable, meaning they should describe an actual problem with the software or its configuration (rather than, for example, user input) and the combination of message, filename and line number, and surrounding messages should be at least sufficient to understand the reported event."]}),"\n",(0,r.jsx)(s.h5,{id:"severity-fatal",children:(0,r.jsx)(s.code,{children:"FATAL"})}),"\n",(0,r.jsxs)(s.p,{children:["Corresponds to ",(0,r.jsx)(s.code,{children:"turbo::LogSeverity::kFatal"})," and is the implicit severity level for ",(0,r.jsx)(s.code,{children:"kCHECK"})," failures. It describes an unrecoverable problem. Logging at this level terminates the process. The ",(0,r.jsx)(s.code,{children:"FATAL"})," logging level should be used cautiously, especially for services\u2014particularly user-facing services\u2014and for library code that may be included in such services. Every fatal log is a potential outage if a large portion of service workers experience it simultaneously.",(0,r.jsx)("br",{}),"\nFatal logging is generally more appropriate for developer tools, certain batch jobs, and failures at job startup. That said, process termination and outages are always better than undefined behavior (which may include user data corruption and/or security or privacy incidents), so ",(0,r.jsx)(s.code,{children:"FATAL"})," is sometimes appropriate even in server and library code as a last resort response to unexpected behavior that cannot be handled in any other way."]}),"\n",(0,r.jsx)(s.h4,{id:"two-pseudo-levels",children:"Two Pseudo-Levels"}),"\n",(0,r.jsx)(s.h5,{id:"severity-dfatal",children:(0,r.jsx)(s.code,{children:"DFATAL"})}),"\n",(0,r.jsxs)(s.p,{children:['("debug fatal") corresponds to ',(0,r.jsx)(s.code,{children:"turbo::kLogDebugFatal"}),". In optimized builds, its value is ",(0,r.jsx)(s.code,{children:"ERROR"})," (e.g., in production) and ",(0,r.jsx)(s.code,{children:"FATAL"})," in other builds (e.g., tests). It can be used to ensure that unexpected events cause test failures (by terminating the process) but do not harm production. Since production workers will continue after a ",(0,r.jsx)(s.code,{children:"DFATAL"})," failure, ensure recovery is graceful."]}),"\n",(0,r.jsx)(s.h5,{id:"severity-qfatal",children:(0,r.jsx)(s.code,{children:"QFATAL"})}),"\n",(0,r.jsxs)(s.p,{children:['("quiet fatal") has no corresponding ',(0,r.jsx)(s.code,{children:"turbo::LogSeverity"})," value. It behaves like ",(0,r.jsx)(s.code,{children:"FATAL"}),", except that no stack trace is logged and ",(0,r.jsx)(s.code,{children:"atexit()"})," handlers are not run. This is usually the best choice for errors that occur at startup (e.g., flag validation), where control flow is uninteresting and diagnostics are unnecessary."]}),"\n",(0,r.jsx)(s.h3,{id:"dynamic-log-levels",children:"Dynamic Log Levels"}),"\n",(0,r.jsx)(s.p,{children:"If you want to specify the severity level using a C++ expression\u2014for example, so that the level used varies at runtime\u2014you can do so as well:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-c++",children:'KLOG(LEVEL(MoonPhase() == kFullMoon ? turbo::LogSeverity::kFatal\n                                   : turbo::LogSeverity::kError))\n      << "Spooky error!";\n'})}),"\n",(0,r.jsxs)(s.h3,{id:"VKLOG",children:[(0,r.jsx)(s.code,{children:"VKLOG()"})," Macro"]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"VKLOG()"}),' ("verbose log") is used for runtime-configurable debug logging. This macro takes a non-negative integer verbosity level as an argument\u2014',(0,r.jsx)(s.code,{children:"INFO"})," is implied as the severity. Verbosity level values are arbitrary, but lower values correspond to more visible messages. Non-zero verbosity levels are disabled by default, and the performance cost of disabled ",(0,r.jsx)(s.code,{children:"VKLOG()"})," is very small, so it is acceptable to use ",(0,r.jsx)(s.code,{children:"VLOG()"})," liberally in most parts of Kumo without risk of significant performance degradation."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-c++",children:'Foo::Foo(int num_bars) {\n  VKLOG(4) << "Constructing a new Foo with " << num_bars << " Bars";\n  for (int i = 0; i < num_bars; i++) bars_.push_back(MakeBar(this));\n}\n'})}),"\n",(0,r.jsxs)(s.p,{children:["Setting the ",(0,r.jsx)(s.code,{children:"--verbosity"})," flag will turn on all ",(0,r.jsx)(s.code,{children:"VKLOG()"})," messages at or below the specified level. This can make your logs hard to read and/or fill your disk. The ",(0,r.jsx)(s.code,{children:"--vmodule"})," flag allows setting different levels for different source files; it takes a comma-separated list of ",(0,r.jsx)(s.code,{children:"key=value"})," pairs where each key is a glob that matches filenames and each value is the verbosity level that should apply to matching files. Verbosity logging levels can also be changed at runtime using ",(0,r.jsx)(s.code,{children:"turbo::set_vlog_level"})," and ",(0,r.jsx)(s.code,{children:"turbo::set_global_vlog_level"}),":"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-c++",children:'class FooTest : public testing::Test {\n protected:\n  FooTest() {\n    // Crank up the `VKLOG()` level for `Foo` since it does not log much otherwise:\n    turbo::set_vlog_level("foo_impl", 4);\n  }\n};\n'})}),"\n",(0,r.jsx)(s.h3,{id:"mutators",children:"Other Macro Variants"}),"\n",(0,r.jsx)(s.p,{children:"The logging API includes numerous additional macros for special cases."}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"QCHECK()"})," works like ",(0,r.jsx)(s.code,{children:"kCHECK()"})," but has the same variant relationship to ",(0,r.jsx)(s.code,{children:"QFATAL"})," as ",(0,r.jsx)(s.code,{children:"kCHECK()"})," does to ",(0,r.jsx)(s.code,{children:"FATAL"}),": it does not log a stack trace or run ",(0,r.jsx)(s.code,{children:"atexit()"})," handlers on failure."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-c++",children:' int main (int argc, char**argv) {\n   turbo::ParseCommandLine(argc, argv);\n   QCHECK(!turbo::get_flag(FLAGS_path).empty()) << "--path is required";\n   ...\n'})}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"PKLOG()"})," and ",(0,r.jsx)(s.code,{children:"PKCHECK()"})," automatically append a string describing ",(0,r.jsx)(s.code,{children:"errno"})," to the logged message. They are useful for system library calls that set ",(0,r.jsx)(s.code,{children:"errno"})," on failure to indicate the nature of the failure. Their names are intended to align with the ",(0,r.jsx)(s.code,{children:"perror"})," library function."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-c++",children:'   const int fd = open(path.c_str(), O_RDONLY);\n   PKCHECK(fd != -1) << "Failed to open " << path;\n\n   const ssize_t bytes_read = read(fd, buf, sizeof(buf));\n   PKCHECK(bytes_read != -1) << "Failed to read from " << path;\n\n   const int close_ret = close(fd);\n   if (close_ret == -1) PKLOG(WARNING) << "Failed to close " << path;\n'})}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"DKLOG()"}),' ("debug log") and ',(0,r.jsx)(s.code,{children:"DKCHECK()"})," disappear entirely from binaries in optimized builds. Note that ",(0,r.jsx)(s.code,{children:"DKLOG(FATAL)"})," and ",(0,r.jsx)(s.code,{children:"DKCHECK()"})," have very different semantics from ",(0,r.jsx)(s.code,{children:"KLOG(DFATAL)"}),".",(0,r.jsx)("br",{}),"\nDebug logging is useful for providing information that is helpful when debugging tests but costly to collect in production (e.g., acquiring contended locks):"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-c++",children:"DKLOG(INFO) << server.State();\n"})}),"\n",(0,r.jsxs)(s.p,{children:["Use ",(0,r.jsx)(s.code,{children:"DKCHECK()"})," carefully; if it's worth checking in tests it may be worth checking in production too:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-c++",children:"DKCHECK(ptr != nullptr);\nptr->Method();\n"})}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"DKCHECK"})," is sometimes useful for checking invariants in very hot code paths where the check in tests must be relied upon to validate behavior in production.",(0,r.jsx)("br",{}),"\nLike ",(0,r.jsx)(s.code,{children:"assert()"}),", ensure you do not rely on the evaluation of side effects in ",(0,r.jsx)(s.code,{children:"DKCHECK"})," and ",(0,r.jsx)(s.code,{children:"DKLOG"})," statements:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-c++",metastring:"{.bad}",children:"DKCHECK(server.Start());\n// In an optimized build, no attempt will have been made to start the\n// server!\n"})}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"LOG_IF()"})," adds a conditional argument, equivalent to an ",(0,r.jsx)(s.code,{children:"if"})," statement. Like ",(0,r.jsx)(s.code,{children:"if"})," and the ternary operator, the condition will be converted to ",(0,r.jsx)(s.code,{children:"bool"})," based on context. Variants like ",(0,r.jsx)(s.code,{children:"PLOG_IF()"})," and ",(0,r.jsx)(s.code,{children:"DLOG_IF()"})," also exist."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-c++",children:'LOG_IF(INFO, turbo::get_flag(FLAGS_dry_run))\n    << "--dry_run set; no changes will be made";\n'})}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"LOG_EVERY_N()"}),", ",(0,r.jsx)(s.code,{children:"LOG_FIRST_N()"}),", ",(0,r.jsx)(s.code,{children:"LOG_EVERY_N_SEC()"}),", and ",(0,r.jsx)(s.code,{children:"LOG_EVERY_POW_2()"})," add more complex conditions that are not easily replicated with a simple ",(0,r.jsx)(s.code,{children:"if"})," statement. Each of these maintains a static state object per statement in storage, used to determine when it is time to log again. They are thread-safe.",(0,r.jsx)("br",{}),"\nThe token ",(0,r.jsx)(s.code,{children:"COUNTER"})," can be streamed into these; it will be replaced with a monotonically increasing count of the number of times this statement has been executed, including times when logging occurred and times when it did not. Macro variants with additional conditions (e.g., ",(0,r.jsx)(s.code,{children:"LOG_IF_EVERY_N()"}),") also exist, as do many combinations with ",(0,r.jsx)(s.code,{children:"VKLOG()"}),", ",(0,r.jsx)(s.code,{children:"PKLOG()"}),", and ",(0,r.jsx)(s.code,{children:"DLOG()"}),"."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-c++",children:'LOG_EVERY_N(WARNING, 1000) << "Got a packet with a bad CRC (" << COUNTER\n                          << " total)";\n'})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"mutator-methods",children:"Mutator Methods"}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"KLOG()"})," and ",(0,r.jsx)(s.code,{children:"kCHECK()"})," macros support a number of chainable methods that alter their behavior."]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:".AtLocation(std::string_view file, int line)"}),(0,r.jsx)("br",{}),"\nOverrides the location inferred from the call site. The string pointed to by ",(0,r.jsx)(s.code,{children:"file"})," must be valid until the end of the statement."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:".NoPrefix()"}),(0,r.jsx)("br",{}),"\nOmits the ",(0,r.jsx)(s.a,{href:"#prefix",children:"prefix"})," in this line. The prefix contains metadata about the logged data, such as source code location and timestamp."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:".WithVerbosity(int verbose_level)"}),(0,r.jsx)("br",{}),"\nSets the verbosity field of the logged message as if it were emitted by ",(0,r.jsx)(s.code,{children:"VLOG(verbose_level)"}),". Unlike ",(0,r.jsx)(s.code,{children:"VLOG()"}),", this method does not affect whether the statement is evaluated when the specified ",(0,r.jsx)(s.code,{children:"verbose_level"})," is disabled. The only effect is on ",(0,r.jsx)(s.code,{children:"turbo::LogSink"})," implementations that use the ",(0,r.jsx)(s.code,{children:"turbo::LogSink::verbosity()"})," value. The value ",(0,r.jsx)(s.code,{children:"turbo::LogEntry::kNoVerbosityLevel"})," can be specified to mark the message as having no verbosity level."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:".WithTimestamp(turbo::Time timestamp)"}),(0,r.jsx)("br",{}),"\nUses the specified timestamp instead of the one collected at the time of execution."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:".WithThreadID(turbo::LogEntry::tid_t tid)"}),(0,r.jsx)("br",{}),"\nUses the specified thread ID instead of the one collected at the time of execution."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:".WithMetadataFrom(const turbo::LogEntry &entry)"}),(0,r.jsx)("br",{}),"\nCopies all metadata (but not data) from the specified ",(0,r.jsx)(s.code,{children:"turbo::LogEntry"}),".",(0,r.jsx)("br",{}),"\nThis can be used to change the severity of a message, but it has some limitations:"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"TURBO_MIN_LOG_LEVEL"})," is evaluated based on the severity passed to ",(0,r.jsx)(s.code,{children:"KLOG"})," (or the implicit ",(0,r.jsx)(s.code,{children:"FATAL"})," level for ",(0,r.jsx)(s.code,{children:"CHECK"}),")."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"KLOG(FATAL)"})," and ",(0,r.jsx)(s.code,{children:"kCHECK"})," unconditionally terminate the process even if the severity is changed later."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:".WithPerror()"}),(0,r.jsx)("br",{}),"\nAppends a colon, a space, the textual description of the current value of ",(0,r.jsx)(s.code,{children:"errno"})," (as per ",(0,r.jsx)(s.code,{children:"strerror(3)"}),"), and the numeric value of ",(0,r.jsx)(s.code,{children:"errno"})," to the logged message. The result is equivalent to ",(0,r.jsx)(s.code,{children:"PKLOG()"})," and ",(0,r.jsx)(s.code,{children:"PKCHECK()"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:".ToSinkAlso(turbo::LogSink* sink)"}),(0,r.jsx)("br",{}),"\nSends this message to ",(0,r.jsx)(s.code,{children:"*sink"})," in addition to any other sinks it would have been sent to otherwise. ",(0,r.jsx)(s.code,{children:"sink"})," must not be null."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:".ToSinkOnly(turbo::LogSink* sink)"}),(0,r.jsx)("br",{}),"\nSends this message to ",(0,r.jsx)(s.code,{children:"*sink"})," and no others. ",(0,r.jsx)(s.code,{children:"sink"})," must not be null."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"output",children:"Log Message Output"}),"\n",(0,r.jsx)(s.h3,{id:"prefix",children:"Log Prefix"}),"\n",(0,r.jsx)(s.p,{children:"Each message is logged with metadata in the following form:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{children:"I0926 09:00:00.000000   12345 foo.cc:10] Hello world!\n"})}),"\n",(0,r.jsxs)(s.p,{children:["The prefix starts with ",(0,r.jsx)(s.code,{children:"I"}),", representing the ",(0,r.jsx)(s.code,{children:"INFO"})," log level, combined with the date ",(0,r.jsx)(s.code,{children:"0926"}),". The time is in microseconds, in the machine's local time zone. ",(0,r.jsx)(s.code,{children:"12345"})," is the thread ID number. ",(0,r.jsx)(s.code,{children:"foo.cc:10"})," is the location in the source code where the ",(0,r.jsx)(s.code,{children:"KLOG()"})," statement appears, and the bracket and space are a fixed separator before the message itself."]}),"\n",(0,r.jsxs)(s.p,{children:["Prefixes can be suppressed globally using the ",(0,r.jsx)(s.code,{children:"FLAGS_log_with_prefix"})," flag, or for individual messages using the ",(0,r.jsx)(s.code,{children:".NoPrefix()"})," ",(0,r.jsx)(s.a,{href:"#mutators",children:"mutator method"}),"."]}),"\n",(0,r.jsxs)(s.h3,{id:"stderr",children:[(0,r.jsx)(s.code,{children:"stderr"})," Output"]}),"\n",(0,r.jsxs)(s.p,{children:["By default, a ",(0,r.jsx)(s.code,{children:"LogSink"})," that writes to ",(0,r.jsx)(s.code,{children:"stderr"})," is included and registered."]})]})}function h(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>t,x:()=>l});var i=n(6540);const r={},o=i.createContext(r);function t(e){const s=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(o.Provider,{value:s},e.children)}}}]);