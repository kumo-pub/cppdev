"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[5089],{8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var r=s(6540);const i={},t=r.createContext(i);function a(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(t.Provider,{value:n},e.children)}},9621:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"foundamentals/json/faq","title":"Frequently Asked Questions","description":"[TOC]","source":"@site/docs/foundamentals/json/faq.mdx","sourceDirName":"foundamentals/json","slug":"/foundamentals/json/faq","permalink":"/cppdev/zh-cn/docs/foundamentals/json/faq","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/foundamentals/json/faq.mdx","tags":[],"version":"current","frontMatter":{}}');var i=s(4848),t=s(8453);const a={},o="Frequently Asked Questions",l={},d=[{value:"General Questions",id:"general-questions",level:2},{value:"JSON",id:"json",level:2},{value:"DOM &amp; SAX",id:"dom--sax",level:2},{value:"Document/Value (DOM)",id:"documentvalue-dom",level:2},{value:"Reader/Writer (SAX)",id:"readerwriter-sax",level:2},{value:"Unicode",id:"unicode",level:2},{value:"Streams",id:"streams",level:2},{value:"Performance",id:"performance",level:2},{value:"Trivia",id:"trivia",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"frequently-asked-questions",children:"Frequently Asked Questions"})}),"\n",(0,i.jsx)(n.p,{children:"[TOC]"}),"\n",(0,i.jsx)(n.h2,{id:"general-questions",children:"General Questions"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["What is Merak?\nMerak is a C++ library for parsing and generating JSON. You can refer to its full list of ",(0,i.jsx)(n.a,{href:"/cppdev/zh-cn/docs/foundamentals/json/features",children:"features"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Why is it called Merak?\nIt draws inspiration from ",(0,i.jsx)(n.a,{href:"http://rapidxml.sourceforge.net/",children:"RapidXML"}),", a high-performance XML DOM parser."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Is Merak similar to RapidXML?\nMerak borrows some design concepts from RapidXML, including in situ parsing and being a header-only library. However, their APIs are completely different. Additionally, Merak offers many features not available in RapidXML."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Is Merak free?\nYes, it is free under the MIT License and can be used in commercial software. For details, see ",(0,i.jsx)(n.a,{href:"https://github.com/kumose/merak/blob/master/license.txt",children:"license.txt"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Is Merak small? What are its dependencies?\nYes. On Windows, an executable that parses JSON and prints statistics is less than 30KB.\nMerak only depends on the C++ Standard Library."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["How to install Merak?\nSee the ",(0,i.jsx)(n.a,{href:"/cppdev/zh-cn/docs/foundamentals/json/overview#installation",children:"Installation section"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Can Merak run on my platform?\nThe community has tested Merak on various combinations of operating systems/compilers/CPU architectures. However, we cannot guarantee it will run on your specific platform\u2014simply build and run the unit tests to find out."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Does Merak support C++03? What about C++11?\nMerak was initially implemented for C++03 and later added optional support for C++11 features (e.g., move constructors, ",(0,i.jsx)(n.code,{children:"noexcept"}),"). Merak should be compatible with all compilers conforming to C++03 or C++11."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Is Merak actually used in real-world applications?\nYes. It is deployed in production front-end and back-end applications. One community member reported that Merak parses 50 million JSON documents daily in their system."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["How is Merak tested?\nMerak includes a suite of unit tests for automated testing. ",(0,i.jsx)(n.a,{href:"https://travis-ci.org/Tencent/merak/json/",children:"Travis"})," (for Linux) and ",(0,i.jsx)(n.a,{href:"https://ci.appveyor.com/project/Tencent/merak/json/",children:"AppVeyor"})," (for Windows) compile and run unit tests for all changes. Valgrind is also used on Linux to detect memory leaks."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Does Merak have complete documentation?\nMerak provides a user manual and API documentation."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Are there alternative libraries?\nThere are many alternatives. For example, ",(0,i.jsx)(n.a,{href:"https://github.com/miloyip/nativejson-benchmark",children:"nativejson-benchmark"})," lists several open-source C/C++ JSON libraries, and ",(0,i.jsx)(n.a,{href:"http://www.json.org/",children:"json.org"})," also has a comprehensive list."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"json",children:"JSON"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["What is JSON?\nJSON (JavaScript Object Notation) is a lightweight data interchange format using a human-readable text format. For more details on JSON, refer to ",(0,i.jsx)(n.a,{href:"http://www.ietf.org/rfc/rfc7159.txt",children:"RFC7159"})," and ",(0,i.jsx)(n.a,{href:"http://www.ecma-international.org/publications/standards/Ecma-404.htm",children:"ECMA-404"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"What are common use cases for JSON?\nJSON is widely used in web applications to transmit structured data and as a file format for data persistence."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Is Merak compliant with JSON standards?\nYes. Merak fully complies with ",(0,i.jsx)(n.a,{href:"http://www.ietf.org/rfc/rfc7159.txt",children:"RFC7159"})," and ",(0,i.jsx)(n.a,{href:"http://www.ecma-international.org/publications/standards/Ecma-404.htm",children:"ECMA-404"}),". It handles edge cases such as null characters and surrogate pairs in JSON strings."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Does Merak support relaxed syntax?\nNot currently. Merak only supports strict standard-compliant syntax. Relaxed syntax is discussed in this ",(0,i.jsx)(n.a,{href:"https://github.com/kumose/merak/issues/36",children:"issue"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"dom--sax",children:"DOM & SAX"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"What is a DOM-style API?\nThe Document Object Model (DOM) is an in-memory representation of JSON for querying and modifying JSON data."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"What is a SAX-style API?\nSAX is an event-driven API for parsing and generating JSON."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Should I use DOM or SAX?\nDOM is easy to query and modify. SAX is extremely fast and memory-efficient but generally more difficult to use."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["What is in situ parsing?\nIn situ parsing decodes JSON strings directly into the input JSON buffer. This optimization reduces memory usage and improves performance but modifies the original input JSON. For more details, see ",(0,i.jsx)(n.a,{href:"/cppdev/zh-cn/docs/foundamentals/json/dom",children:"In Situ Parsing"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["When do parsing errors occur?\nParsing errors occur if the input JSON contains invalid syntax, cannot represent a value (e.g., a Number is too large), or the parser\u2019s handler aborts the parsing process. See ",(0,i.jsx)(n.a,{href:"/cppdev/zh-cn/docs/foundamentals/json/dom",children:"Parse Errors"})," for details."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["What error information is available?\nError information is stored in ",(0,i.jsx)(n.code,{children:"ParseResult"}),", which contains an error code and an offset (the number of characters from the start of the JSON to the error location). Error codes can be translated into human-readable messages."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Why not just use ",(0,i.jsx)(n.code,{children:"double"})," to represent JSON numbers?\nSome applications require 64-bit signed/unsigned integers, which cannot be converted to ",(0,i.jsx)(n.code,{children:"double"})," without loss of precision. The parser therefore checks if a JSON number can be converted to various integer types and ",(0,i.jsx)(n.code,{children:"double"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["How to clear and minimize the capacity of a ",(0,i.jsx)(n.code,{children:"document"})," or ",(0,i.jsx)(n.code,{children:"value"}),"?\nCall the ",(0,i.jsx)(n.code,{children:"SetXXX()"})," methods\u2014these invoke the destructor and rebuild an empty Object or Array:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"Document d;\n...\nd.SetObject();  // clear and minimize\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Alternatively, refer to the equivalent approach in the ",(0,i.jsx)(n.a,{href:"https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Clear-and-minimize",children:"C++ swap with temporary idiom"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"Value(kObjectType).Swap(d);\n"})}),"\n",(0,i.jsx)(n.p,{children:"Or use this slightly longer code to achieve the same result:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"d.Swap(Value(kObjectType).Move()); \n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["How to insert a ",(0,i.jsx)(n.code,{children:"document"})," node into another ",(0,i.jsx)(n.code,{children:"document"}),"?\nFor example, consider two documents (DOMs):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'Document person;\nperson.Parse("{\\"person\\":{\\"name\\":{\\"first\\":\\"Adam\\",\\"last\\":\\"Thomas\\"}}}");\n\nDocument address;\naddress.Parse("{\\"address\\":{\\"city\\":\\"Moscow\\",\\"street\\":\\"Quiet\\"}}");\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Suppose we want to insert the entire ",(0,i.jsx)(n.code,{children:"address"})," as a child node of ",(0,i.jsx)(n.code,{children:"person"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'{ "person": {\n   "name": { "first": "Adam", "last": "Thomas" },\n   "address": { "city": "Moscow", "street": "Quiet" }\n   }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["When inserting nodes, pay attention to the lifetime of ",(0,i.jsx)(n.code,{children:"document"})," and ",(0,i.jsx)(n.code,{children:"value"}),", and correctly use the allocator for memory management."]}),"\n",(0,i.jsxs)(n.p,{children:["A simple and effective method is to initialize the ",(0,i.jsx)(n.code,{children:"address"})," variable with ",(0,i.jsx)(n.code,{children:"person"}),"'s allocator, then add it to the root node:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'Document address(&person.GetAllocator());\n...\nperson["person"].AddMember("address", address["address"], person.GetAllocator());\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Alternatively, if you do not want to explicitly specify the ",(0,i.jsx)(n.code,{children:"address"})," key to retrieve its value, use an iterator:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'auto addressRoot = address.MemberBegin();\nperson["person"].AddMember(addressRoot->name, addressRoot->value, person.GetAllocator());\n'})}),"\n",(0,i.jsx)(n.p,{children:"Additionally, you can implement this by deep-copying the address document:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'Value addressValue = Value(address["address"], person.GetAllocator());\nperson["person"].AddMember("address", addressValue, person.GetAllocator());\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"documentvalue-dom",children:"Document/Value (DOM)"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["What is move semantics? Why use it?\n",(0,i.jsx)(n.code,{children:"Value"})," uses move semantics instead of copy semantics. This means when assigning a source value to a target value, ownership of the source value is transferred to the target.\nSince moving is faster than copying, this design forces users to be aware of the cost of copying."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["How to copy a value?\nTwo APIs are available: the constructor with an allocator, and ",(0,i.jsx)(n.code,{children:"CopyFrom()"}),". See examples in ",(0,i.jsx)(n.a,{href:"/cppdev/zh-cn/docs/foundamentals/json/tutorial",children:"Deep Copy a Value"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Why do I need to provide the length of a string?\nC-style strings are null-terminated, so ",(0,i.jsx)(n.code,{children:"strlen()"})," is required to calculate their length\u2014a linear complexity operation. If the user already knows the string length, this incurs unnecessary overhead for many operations.\nAdditionally, Merak can handle strings containing ",(0,i.jsx)(n.code,{children:"\\u0000"})," (null characters). If a string contains null characters, ",(0,i.jsx)(n.code,{children:"strlen()"})," cannot return the true length, so the user must explicitly provide the length."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Why is an allocator required as a parameter in many DOM operation APIs?\nSince these APIs are member functions of ",(0,i.jsx)(n.code,{children:"Value"}),", we avoid storing an allocator pointer in each ",(0,i.jsx)(n.code,{children:"Value"})," to save memory."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Does it convert between different numeric types?\nConversions may occur when using APIs like ",(0,i.jsx)(n.code,{children:"GetInt()"}),", ",(0,i.jsx)(n.code,{children:"GetUint()"}),", etc. For integer-to-integer conversions, conversion only occurs if it is safe (otherwise, an assertion failure is triggered). However, converting a 64-bit signed/unsigned integer to ",(0,i.jsx)(n.code,{children:"double"})," may result in precision loss. Numbers with fractional parts or integers larger than 64 bits can only be retrieved using ",(0,i.jsx)(n.code,{children:"GetDouble()"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"readerwriter-sax",children:"Reader/Writer (SAX)"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Why not just use ",(0,i.jsx)(n.code,{children:"printf"})," to output JSON? Why is ",(0,i.jsx)(n.code,{children:"Writer"})," needed?\nMost importantly, ",(0,i.jsx)(n.code,{children:"Writer"})," ensures the output JSON is syntactically correct. Invalid SAX event calls (e.g., mismatched ",(0,i.jsx)(n.code,{children:"StartObject()"})," and ",(0,i.jsx)(n.code,{children:"EndArray()"}),") trigger assertion failures. Additionally, ",(0,i.jsx)(n.code,{children:"Writer"})," escapes strings (e.g., ",(0,i.jsx)(n.code,{children:"\\n"}),"). Finally, numeric output from ",(0,i.jsx)(n.code,{children:"printf()"})," may not be a valid JSON number\u2014especially in locales with digit separators. Moreover, ",(0,i.jsx)(n.code,{children:"Writer"})," uses highly optimized algorithms for numeric-to-string conversion, outperforming ",(0,i.jsx)(n.code,{children:"printf()"})," and ",(0,i.jsx)(n.code,{children:"iostream"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Can I pause parsing and resume it later?\nFor performance reasons, direct support for this feature is not available in the current version. However, if the execution environment supports multithreading, users can parse JSON in a separate thread and pause by blocking the input stream."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"unicode",children:"Unicode"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Does it support UTF-8, UTF-16, and other formats?\nYes. It fully supports UTF-8, UTF-16 (big-endian/little-endian), UTF-32 (big-endian/little-endian), and ASCII."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Can it validate encoding validity?\nYes. Simply pass ",(0,i.jsx)(n.code,{children:"kParseValidateEncodingFlag"})," to ",(0,i.jsx)(n.code,{children:"Parse()"}),". If invalid encoding is detected in the input stream, it triggers a ",(0,i.jsx)(n.code,{children:"kParseErrorStringInvalidEncoding"})," error."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["What are surrogate pairs? Does Merak support them?\nJSON uses UTF-16 encoding to escape Unicode characters (e.g., ",(0,i.jsx)(n.code,{children:"\\u5927"}),' represents the Chinese character "\u5927"). To handle characters outside the Basic Multilingual Plane (BMP), UTF-16 encodes them as two 16-bit values, known as UTF-16 surrogate pairs. For example, the emoji character U+1F602 can be encoded in JSON as ',(0,i.jsx)(n.code,{children:"\\uD83D\\uDE02"}),".\nMerak fully supports parsing and generating UTF-16 surrogate pairs."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Can it handle ",(0,i.jsx)(n.code,{children:"\\u0000"})," (null characters) in JSON strings?\nYes. Merak fully supports null characters in JSON strings. However, users must be aware of this and use ",(0,i.jsx)(n.code,{children:"GetStringLength()"})," and related APIs to retrieve the true string length."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Can all non-ASCII characters be output as ",(0,i.jsx)(n.code,{children:"\\uxxxx"}),"?\nYes. Using ",(0,i.jsx)(n.code,{children:"ASCII<>"})," as the output encoding parameter in ",(0,i.jsx)(n.code,{children:"Writer"})," forces escaping of these characters."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"streams",children:"Streams"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["I have a large JSON file. Should I load it entirely into memory?\nUsers can use ",(0,i.jsx)(n.code,{children:"FileReadStream"})," to read the file in chunks. However, in situ parsing requires loading the entire file into memory."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Can I parse JSON streamed over a network?\nYes. Users can implement a custom stream based on the ",(0,i.jsx)(n.code,{children:"FileReadStream"})," implementation."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["I don\u2019t know the encoding of some JSON data. How to handle it?\nYou can use ",(0,i.jsx)(n.code,{children:"AutoUTFInputStream"}),", which automatically detects the input stream\u2019s encoding\u2014though this incurs some performance overhead."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["What is a BOM? How does Merak handle it?\nA ",(0,i.jsx)(n.a,{href:"http://en.wikipedia.org/wiki/Byte_order_mark",children:"Byte Order Mark (BOM)"})," sometimes appears at the start of a file/stream to indicate its UTF encoding type.\nMerak\u2019s ",(0,i.jsx)(n.code,{children:"EncodedInputStream"})," can detect/skip BOMs, and ",(0,i.jsx)(n.code,{children:"EncodedOutputStream"})," can optionally write a BOM. See examples in ",(0,i.jsx)(n.a,{href:"/cppdev/zh-cn/docs/foundamentals/json/stream",children:"Encoded Streams"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Why is big-endian/little-endian relevant?\nEndianness is a concern for UTF-16 and UTF-32 streams but not for UTF-8."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"performance",children:"Performance"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Is Merak really fast?\nYes. It is likely the fastest open-source JSON library. A ",(0,i.jsx)(n.a,{href:"https://github.com/miloyip/nativejson-benchmark",children:"benchmark"})," evaluates the performance of C/C++ JSON libraries."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Why is it fast?\nMany design decisions in Merak prioritize time/space performance (even if this affects API usability). Additionally, it uses low-level optimizations (intrinsics/SIMD) and specialized algorithms (custom double-to-string and string-to-double conversion)."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["What is SIMD? How is it used in Merak?\n",(0,i.jsx)(n.a,{href:"http://en.wikipedia.org/wiki/SIMD",children:"SIMD"})," instructions enable parallel computation on modern CPUs. Merak supports Intel SSE2/SSE4.2 and ARM Neon to accelerate filtering of whitespace, tabs, carriage returns, and newlines\u2014improving performance when parsing indented JSON. This feature can be enabled by defining the macros ",(0,i.jsx)(n.code,{children:"RAPIDJSON_SSE2"}),", ",(0,i.jsx)(n.code,{children:"RAPIDJSON_SSE42"}),", or ",(0,i.jsx)(n.code,{children:"RAPIDJSON_NEON"}),". However, executing the resulting binaries on machines without these instruction sets will cause crashes."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Does it consume a lot of memory?\nMerak is designed to minimize memory usage.\nFor the SAX API, ",(0,i.jsx)(n.code,{children:"Reader"})," consumes memory proportional to the depth of the JSON tree plus the longest JSON string.\nFor the DOM API, each ",(0,i.jsx)(n.code,{children:"Value"})," consumes 16/24 bytes on 32/64-bit architectures, respectively. Merak also uses a specialized memory allocator to reduce allocation overhead."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"What is the significance of high performance?\nSome applications process extremely large JSON files, while backend applications handle massive volumes of JSON data. High performance improves both latency and throughput\u2014and more broadly, reduces energy consumption."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"trivia",children:"Trivia"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Who are the developers of Merak?\nMilo Yip (",(0,i.jsx)(n.a,{href:"https://github.com/miloyip",children:"miloyip"}),") is the original author of Merak. Many contributors worldwide continue to improve it. Philipp A. Hartmann (",(0,i.jsx)(n.a,{href:"https://github.com/pah",children:"pah"}),") implemented numerous enhancements, set up automated testing, and participated in extensive community discussions. Don Ding (",(0,i.jsx)(n.a,{href:"https://github.com/thebusytypist",children:"thebusytypist"}),") implemented the iterative parser. Andrii Senkovych (",(0,i.jsx)(n.a,{href:"https://github.com/jollyroger",children:"jollyroger"}),") completed the migration to CMake. Kosta (",(0,i.jsx)(n.a,{href:"https://github.com/Kosta-Github",children:"Kosta-Github"}),") contributed an elegant short string optimization. Thanks are also due to other contributors and community members."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Why was Merak developed?\nThe project began in 2011 as a hobby. Milo Yip, a game programmer at the time, discovered JSON and wanted to use it in future projects. Since JSON seemed simple, he aimed to create a fast, header-only library."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Why was there a long hiatus in development?\nMainly personal reasons (e.g., welcoming a new family member). Additionally, Milo Yip spent much of his spare time translating Jason Gregory\u2019s ",(0,i.jsx)(n.em,{children:"Game Engine Architecture"})," into Chinese (",(0,i.jsx)(n.em,{children:"\u6e38\u620f\u5f15\u64ce\u67b6\u6784"}),")."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Why was the project moved from Google Code to GitHub?\nThis aligned with industry trends, and GitHub is more powerful and user-friendly."}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);