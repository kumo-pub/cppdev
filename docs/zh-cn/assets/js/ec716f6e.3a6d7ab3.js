"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[968],{3152:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"foundamentals/json/sax","title":"SAX","description":"The term \\"SAX\\" originates from Simple API for XML. We borrow this term and apply it to the parsing and generation of JSON.","source":"@site/docs/foundamentals/json/sax.mdx","sourceDirName":"foundamentals/json","slug":"/foundamentals/json/sax","permalink":"/cppdev/zh-cn/docs/foundamentals/json/sax","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/foundamentals/json/sax.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"DOM","permalink":"/cppdev/zh-cn/docs/foundamentals/json/dom"},"next":{"title":"Schema\uff08\u6a21\u5f0f\uff09","permalink":"/cppdev/zh-cn/docs/foundamentals/json/schema"}}');var s=r(4848),i=r(8453);const o={},a="SAX",l={},c=[{value:"Handler",id:"Handler",level:2},{value:"GenericReader",id:"GenericReader",level:2},{value:"Parsing",id:"SaxParsing",level:2},{value:"Template",id:"WriterTemplate",level:2},{value:"PrettyWriter",id:"PrettyWriter",level:2},{value:"Completeness and Reset",id:"CompletenessReset",level:2},{value:"Parsing JSON to Custom Data Structures",id:"CustomDataStructure",level:2},{value:"Filtering JSON",id:"Filtering",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"sax",children:"SAX"})}),"\n",(0,s.jsxs)(n.p,{children:['The term "SAX" originates from ',(0,s.jsx)(n.a,{href:"http://en.wikipedia.org/wiki/Simple_API_for_XML",children:"Simple API for XML"}),". We borrow this term and apply it to the parsing and generation of JSON."]}),"\n",(0,s.jsxs)(n.p,{children:["In Merak, ",(0,s.jsx)(n.code,{children:"Reader"})," (a typedef of ",(0,s.jsx)(n.code,{children:"GenericReader<...>"}),") is a SAX-style parser for JSON, while ",(0,s.jsx)(n.code,{children:"Writer"})," (a typedef of ",(0,s.jsx)(n.code,{children:"GenericWriter<...>"}),") is a SAX-style generator for JSON."]}),"\n",(0,s.jsx)(n.p,{children:"[TOC]"}),"\n",(0,s.jsx)(n.h1,{id:"Reader",children:"Reader"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Reader"})," parses a JSON from an input stream. As it reads characters from the stream, it analyzes them based on JSON syntax and sends events to a handler."]}),"\n",(0,s.jsx)(n.p,{children:"For example, consider the following JSON:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'{\n    "hello": "world",\n    "t": true ,\n    "f": false,\n    "n": null,\n    "i": 123,\n    "pi": 3.1416,\n    "a": [1, 2, 3, 4]\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["When a ",(0,s.jsx)(n.code,{children:"Reader"})," parses this JSON, it sequentially sends the following events to the handler:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'StartObject()\nKey("hello", 5, true)\nString("world", 5, true)\nKey("t", 1, true)\nBool(true)\nKey("f", 1, true)\nBool(false)\nKey("n", 1, true)\nNull()\nKey("i")\nUint(123)\nKey("pi")\nDouble(3.1416)\nKey("a")\nStartArray()\nUint(1)\nUint(2)\nUint(3)\nUint(4)\nEndArray(4)\nEndObject(7)\n'})}),"\n",(0,s.jsxs)(n.p,{children:["These events can be easily mapped to the JSON structure, except for some event parameters that require further explanation. You can refer to the ",(0,s.jsx)(n.code,{children:"simplereader"})," example, which produces exactly the same output as above:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include "merak/json/reader.h"\n#include <iostream>\n\nusing namespace merak::json;\nusing namespace std;\n\nstruct MyHandler : public BaseReaderHandler<UTF8<>, MyHandler> {\n    bool Null() { cout << "Null()" << endl; return true; }\n    bool Bool(bool b) { cout << "Bool(" << boolalpha << b << ")" << endl; return true; }\n    bool Int(int i) { cout << "Int(" << i << ")" << endl; return true; }\n    bool Uint(unsigned u) { cout << "Uint(" << u << ")" << endl; return true; }\n    bool Int64(int64_t i) { cout << "Int64(" << i << ")" << endl; return true; }\n    bool Uint64(uint64_t u) { cout << "Uint64(" << u << ")" << endl; return true; }\n    bool Double(double d) { cout << "Double(" << d << ")" << endl; return true; }\n    bool String(const char* str, SizeType length, bool copy) { \n        cout << "String(" << str << ", " << length << ", " << boolalpha << copy << ")" << endl;\n        return true;\n    }\n    bool StartObject() { cout << "StartObject()" << endl; return true; }\n    bool Key(const char* str, SizeType length, bool copy) { \n        cout << "Key(" << str << ", " << length << ", " << boolalpha << copy << ")" << endl;\n        return true;\n    }\n    bool EndObject(SizeType memberCount) { cout << "EndObject(" << memberCount << ")" << endl; return true; }\n    bool StartArray() { cout << "StartArray()" << endl; return true; }\n    bool EndArray(SizeType elementCount) { cout << "EndArray(" << elementCount << ")" << endl; return true; }\n};\n\nvoid main() {\n    const char json[] = " { \\"hello\\" : \\"world\\", \\"t\\" : true , \\"f\\" : false, \\"n\\": null, \\"i\\":123, \\"pi\\": 3.1416, \\"a\\":[1, 2, 3, 4] } ";\n\n    MyHandler handler;\n    Reader reader;\n    StringStream ss(json);\n    reader.Parse(ss, handler);\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Note that Merak uses templates to statically bind the ",(0,s.jsx)(n.code,{children:"Reader"})," type and the handler type, instead of using classes with virtual functions. This paradigm can improve performance by inlining functions."]}),"\n",(0,s.jsx)(n.h2,{id:"Handler",children:"Handler"}),"\n",(0,s.jsxs)(n.p,{children:["As shown in the previous example, the user needs to implement a handler to process events (function calls) from the ",(0,s.jsx)(n.code,{children:"Reader"}),". The handler must include the following member functions:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class Handler {\n    bool Null();\n    bool Bool(bool b);\n    bool Int(int i);\n    bool Uint(unsigned i);\n    bool Int64(int64_t i);\n    bool Uint64(uint64_t i);\n    bool Double(double d);\n    bool RawNumber(const Ch* str, SizeType length, bool copy);\n    bool String(const Ch* str, SizeType length, bool copy);\n    bool StartObject();\n    bool Key(const Ch* str, SizeType length, bool copy);\n    bool EndObject(SizeType memberCount);\n    bool StartArray();\n    bool EndArray(SizeType elementCount);\n};\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Null()"})," is called when the ",(0,s.jsx)(n.code,{children:"Reader"})," encounters a JSON null value."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Bool(bool)"})," is called when the ",(0,s.jsx)(n.code,{children:"Reader"})," encounters a JSON true or false value."]}),"\n",(0,s.jsxs)(n.li,{children:["When the ",(0,s.jsx)(n.code,{children:"Reader"})," encounters a JSON number, it selects an appropriate C++ type mapping and then calls ",(0,s.jsx)(n.strong,{children:"exactly one"})," of ",(0,s.jsx)(n.code,{children:"Int(int)"}),", ",(0,s.jsx)(n.code,{children:"Uint(unsigned)"}),", ",(0,s.jsx)(n.code,{children:"Int64(int64_t)"}),", ",(0,s.jsx)(n.code,{children:"Uint64(uint64_t)"}),", and ",(0,s.jsx)(n.code,{children:"Double(double)"}),". If the ",(0,s.jsx)(n.code,{children:"kParseNumbersAsStrings"})," option is enabled, the ",(0,s.jsx)(n.code,{children:"Reader"})," will call ",(0,s.jsx)(n.code,{children:"RawNumber()"})," instead."]}),"\n",(0,s.jsxs)(n.li,{children:["When the ",(0,s.jsx)(n.code,{children:"Reader"})," encounters a JSON string, it calls ",(0,s.jsx)(n.code,{children:"String(const char* str, SizeType length, bool copy)"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The first parameter is a pointer to the string."}),"\n",(0,s.jsxs)(n.li,{children:["The second parameter is the length of the string (excluding the null terminator). Note that Merak supports null characters ",(0,s.jsx)(n.code,{children:"\\0"})," in strings, in which case ",(0,s.jsx)(n.code,{children:"strlen(str) < length"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["The final ",(0,s.jsx)(n.code,{children:"copy"})," parameter indicates whether the handler needs to copy the string. In normal parsing, ",(0,s.jsx)(n.code,{children:"copy = true"}),"; ",(0,s.jsx)(n.code,{children:"copy = false"})," only when using in situ parsing. Additionally, note that the character type is related to the target encoding, which we will discuss later."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["When the ",(0,s.jsx)(n.code,{children:"Reader"})," encounters the start of a JSON object, it calls ",(0,s.jsx)(n.code,{children:"StartObject()"}),". A JSON object is a collection of key-value pairs (members). If the object contains members, it first calls ",(0,s.jsx)(n.code,{children:"Key()"})," for the member name, then calls the corresponding function according to the type of the value. It continues calling these key-value pairs until it finally calls ",(0,s.jsx)(n.code,{children:"EndObject(SizeType memberCount)"}),". Note that the ",(0,s.jsx)(n.code,{children:"memberCount"})," parameter is only for the handler's reference, and the user may not need it."]}),"\n",(0,s.jsxs)(n.li,{children:["JSON arrays are similar to objects but simpler. At the start of an array, the ",(0,s.jsx)(n.code,{children:"Reader"})," calls ",(0,s.jsx)(n.code,{children:"StartArray()"}),". If the array contains elements, it calls the corresponding function according to the element type. Similarly, it finally calls ",(0,s.jsx)(n.code,{children:"EndArray(SizeType elementCount)"}),", where the ",(0,s.jsx)(n.code,{children:"elementCount"})," parameter is only for the handler's reference."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Each handler function returns a ",(0,s.jsx)(n.code,{children:"bool"}),". Normally, they should return ",(0,s.jsx)(n.code,{children:"true"}),". If the handler encounters an error, it can return ",(0,s.jsx)(n.code,{children:"false"})," to notify the event sender to stop further processing."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, when parsing a JSON with the ",(0,s.jsx)(n.code,{children:"Reader"}),", if the handler detects that the JSON does not conform to the required schema, the handler can return ",(0,s.jsx)(n.code,{children:"false"})," to make the ",(0,s.jsx)(n.code,{children:"Reader"})," stop subsequent parsing. The ",(0,s.jsx)(n.code,{children:"Reader"})," will then enter an error state, marked with the ",(0,s.jsx)(n.code,{children:"kParseErrorTermination"})," error code."]}),"\n",(0,s.jsx)(n.h2,{id:"GenericReader",children:"GenericReader"}),"\n",(0,s.jsxs)(n.p,{children:["As mentioned earlier, ",(0,s.jsx)(n.code,{children:"Reader"})," is a typedef of the ",(0,s.jsx)(n.code,{children:"GenericReader"})," template class:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"namespace merak::json {\n\ntemplate <typename SourceEncoding, typename TargetEncoding, typename Allocator = MemoryPoolAllocator<> >\nclass GenericReader {\n    // ...\n};\n\ntypedef GenericReader<UTF8<>, UTF8<> > Reader;\n\n} // namespace merak::json\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Reader"})," uses UTF-8 as both the source and target encoding. The source encoding refers to the encoding of the JSON stream; the target encoding refers to the encoding used for the ",(0,s.jsx)(n.code,{children:"str"})," parameter of ",(0,s.jsx)(n.code,{children:"String()"}),". For example, to parse a UTF-8 stream and output to UTF-16 string events, you need to define a reader like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"GenericReader<UTF8<>, UTF16<> > reader;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Note that the default type of ",(0,s.jsx)(n.code,{children:"UTF16"})," is ",(0,s.jsx)(n.code,{children:"wchar_t"}),". Therefore, this ",(0,s.jsx)(n.code,{children:"reader"})," will call the handler's ",(0,s.jsx)(n.code,{children:"String(const wchar_t*, SizeType, bool)"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The third template parameter ",(0,s.jsx)(n.code,{children:"Allocator"})," is the type of allocator for internal data structures (actually a stack)."]}),"\n",(0,s.jsx)(n.h2,{id:"SaxParsing",children:"Parsing"}),"\n",(0,s.jsxs)(n.p,{children:["The only function of ",(0,s.jsx)(n.code,{children:"Reader"})," is to parse JSON."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"template <unsigned parseFlags, typename InputStream, typename Handler>\nbool Parse(InputStream& is, Handler& handler);\n\n// Uses parseFlags = kDefaultParseFlags\ntemplate <typename InputStream, typename Handler>\nbool Parse(InputStream& is, Handler& handler);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If an error occurs during parsing, it returns ",(0,s.jsx)(n.code,{children:"false"}),". The user can call ",(0,s.jsx)(n.code,{children:"bool HasParseError()"}),", ",(0,s.jsx)(n.code,{children:"ParseErrorCode GetParseErrorCode()"}),", and ",(0,s.jsx)(n.code,{children:"size_t GetErrorOffset()"})," to get the error state. In fact, ",(0,s.jsx)(n.code,{children:"Document"})," uses these ",(0,s.jsx)(n.code,{children:"Reader"})," functions to get parsing errors. Please refer to ",(0,s.jsx)(n.a,{href:"/cppdev/zh-cn/docs/foundamentals/json/dom",children:"DOM"})," for details about parsing errors."]}),"\n",(0,s.jsx)(n.h1,{id:"Writer",children:"Writer"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Reader"})," converts (parses) JSON into events; ",(0,s.jsx)(n.code,{children:"Writer"})," does the exact opposite. It converts events into JSON."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Writer"})," is very easy to use. If your application only needs to convert some data into JSON, it may be more convenient to use ",(0,s.jsx)(n.code,{children:"Writer"})," directly than to build a ",(0,s.jsx)(n.code,{children:"Document"})," and then convert it to JSON with ",(0,s.jsx)(n.code,{children:"Writer"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["In the ",(0,s.jsx)(n.code,{children:"simplewriter"})," example, we do the exact opposite of ",(0,s.jsx)(n.code,{children:"simplereader"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include "merak/json/writer.h"\n#include "merak/json/stringbuffer.h"\n#include <iostream>\n\nusing namespace merak::json;\nusing namespace std;\n\nvoid main() {\n    StringBuffer s;\n    Writer<StringBuffer> writer(s);\n    \n    writer.StartObject();\n    writer.Key("hello");\n    writer.String("world");\n    writer.Key("t");\n    writer.Bool(true);\n    writer.Key("f");\n    writer.Bool(false);\n    writer.Key("n");\n    writer.Null();\n    writer.Key("i");\n    writer.Uint(123);\n    writer.Key("pi");\n    writer.Double(3.1416);\n    writer.Key("a");\n    writer.StartArray();\n    for (unsigned i = 0; i < 4; i++)\n        writer.Uint(i);\n    writer.EndArray();\n    writer.EndObject();\n\n    cout << s.GetString() << endl;\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Output:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'{"hello":"world","t":true,"f":false,"n":null,"i":123,"pi":3.1416,"a":[0,1,2,3]}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"String()"})," and ",(0,s.jsx)(n.code,{children:"Key()"})," each have two overloads. One has 3 parameters, as per the handler concept, which can handle strings with null characters. The other is the simpler version used above."]}),"\n",(0,s.jsxs)(n.p,{children:["Note that ",(0,s.jsx)(n.code,{children:"EndArray()"})," and ",(0,s.jsx)(n.code,{children:"EndObject()"})," in the example code have no parameters. A ",(0,s.jsx)(n.code,{children:"SizeType"})," parameter can be passed, but it will be ignored by ",(0,s.jsx)(n.code,{children:"Writer"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["You may wonder why not use ",(0,s.jsx)(n.code,{children:"sprintf()"})," or ",(0,s.jsx)(n.code,{children:"std::stringstream"})," to build a JSON?"]}),"\n",(0,s.jsx)(n.p,{children:"There are several reasons:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Writer"})," will definitely output a well-formed JSON. If there is an incorrect event order (e.g., ",(0,s.jsx)(n.code,{children:"Int()"})," follows ",(0,s.jsx)(n.code,{children:"StartObject()"}),"), it will cause an assertion failure in debug mode."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Writer::String()"})," can handle string escaping (e.g., converting the code point ",(0,s.jsx)(n.code,{children:"U+000A"})," to ",(0,s.jsx)(n.code,{children:"\\n"}),") and perform Unicode transcoding."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Writer"})," handles number output consistently."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Writer"})," implements the event handler concept. It can be used to process events from ",(0,s.jsx)(n.code,{children:"Reader"}),", ",(0,s.jsx)(n.code,{children:"Document"}),", or other event generators."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Writer"})," is optimized for different platforms."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["In any case, using the ",(0,s.jsx)(n.code,{children:"Writer"})," API to generate JSON is even simpler than these ad-hoc methods."]}),"\n",(0,s.jsx)(n.h2,{id:"WriterTemplate",children:"Template"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Writer"})," has a slight design difference from ",(0,s.jsx)(n.code,{children:"Reader"}),". ",(0,s.jsx)(n.code,{children:"Writer"})," is a template class, not a typedef. There is no ",(0,s.jsx)(n.code,{children:"GenericWriter"}),". The declaration of ",(0,s.jsx)(n.code,{children:"Writer"})," is as follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"namespace merak::json {\n\ntemplate<typename OutputStream, typename SourceEncoding = UTF8<>, typename TargetEncoding = UTF8<>, typename Allocator = CrtAllocator<> >\nclass Writer {\npublic:\n    Writer(OutputStream& os, Allocator* allocator = 0, size_t levelDepth = kDefaultLevelDepth)\n// ...\n};\n\n} // namespace merak::json\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"OutputStream"})," template parameter is the type of the output stream. Its type cannot be inferred automatically and must be provided by the user."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"SourceEncoding"})," template parameter specifies the encoding of ",(0,s.jsx)(n.code,{children:"String(const Ch*, ...)"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"TargetEncoding"})," template parameter specifies the encoding of the output stream."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Allocator"})," is the type of allocator used to allocate internal data structures (a stack)."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"writeFlags"})," is a combination of the following bit flags:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Write Bit Flag"}),(0,s.jsx)(n.th,{children:"Meaning"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"kWriteNoFlags"})}),(0,s.jsx)(n.td,{children:"No flags."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"kWriteDefaultFlags"})}),(0,s.jsxs)(n.td,{children:["Default parsing options. Equivalent to the macro ",(0,s.jsx)(n.code,{children:"RAPIDJSON_WRITE_DEFAULT_FLAGS"}),", which is defined as ",(0,s.jsx)(n.code,{children:"kWriteNoFlags"}),"."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"kWriteValidateEncodingFlag"})}),(0,s.jsx)(n.td,{children:"Validate the encoding of JSON strings."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"kWriteNanAndInfFlag"})}),(0,s.jsxs)(n.td,{children:["Allow writing ",(0,s.jsx)(n.code,{children:"Infinity"}),", ",(0,s.jsx)(n.code,{children:"-Infinity"}),", and ",(0,s.jsx)(n.code,{children:"NaN"}),"."]})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["In addition, the constructor of ",(0,s.jsx)(n.code,{children:"Writer"})," has a ",(0,s.jsx)(n.code,{children:"levelDepth"})," parameter, which affects the initial memory allocation for storing level information."]}),"\n",(0,s.jsx)(n.h2,{id:"PrettyWriter",children:"PrettyWriter"}),"\n",(0,s.jsxs)(n.p,{children:["The output of ",(0,s.jsx)(n.code,{children:"Writer"})," is the most compact JSON without whitespace characters, suitable for network transmission or storage, but not for human reading."]}),"\n",(0,s.jsxs)(n.p,{children:["Therefore, Merak provides a ",(0,s.jsx)(n.code,{children:"PrettyWriter"})," that adds indentation and line breaks to the output."]}),"\n",(0,s.jsxs)(n.p,{children:["The usage of ",(0,s.jsx)(n.code,{children:"PrettyWriter"})," is almost the same as ",(0,s.jsx)(n.code,{children:"Writer"}),", except that ",(0,s.jsx)(n.code,{children:"PrettyWriter"})," provides a ",(0,s.jsx)(n.code,{children:"SetIndent(Ch indentChar, unsigned indentCharCount)"})," function. The default indentation is 4 spaces."]}),"\n",(0,s.jsx)(n.h2,{id:"CompletenessReset",children:"Completeness and Reset"}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.code,{children:"Writer"})," can only output a single JSON, whose root node can be of any JSON type. When a single root node event (such as ",(0,s.jsx)(n.code,{children:"String()"}),") is processed, or the matching final ",(0,s.jsx)(n.code,{children:"EndObject()"})," or ",(0,s.jsx)(n.code,{children:"EndArray()"})," event is processed, the output JSON is well-formed and complete. The user can call ",(0,s.jsx)(n.code,{children:"Writer::IsComplete()"})," to detect completeness."]}),"\n",(0,s.jsxs)(n.p,{children:["When the JSON is complete, the ",(0,s.jsx)(n.code,{children:"Writer"})," cannot accept new events; otherwise, its output will be invalid (e.g., having more than one root node). To reuse the ",(0,s.jsx)(n.code,{children:"Writer"})," object, the user can call ",(0,s.jsx)(n.code,{children:"Writer::Reset(OutputStream& os)"})," to reset all its internal states and set a new output stream."]}),"\n",(0,s.jsx)(n.h1,{id:"SaxTechniques",children:"Techniques"}),"\n",(0,s.jsx)(n.h2,{id:"CustomDataStructure",children:"Parsing JSON to Custom Data Structures"}),"\n",(0,s.jsxs)(n.p,{children:["The parsing function of ",(0,s.jsx)(n.code,{children:"Document"})," relies entirely on ",(0,s.jsx)(n.code,{children:"Reader"}),". In fact, ",(0,s.jsx)(n.code,{children:"Document"})," is a handler that receives events to build a DOM when parsing JSON."]}),"\n",(0,s.jsxs)(n.p,{children:["Users can use ",(0,s.jsx)(n.code,{children:"Reader"})," directly to build other data structures. This eliminates the step of building a DOM, thereby reducing memory overhead and improving performance."]}),"\n",(0,s.jsxs)(n.p,{children:["In the ",(0,s.jsx)(n.code,{children:"messagereader"})," example, ",(0,s.jsx)(n.code,{children:"ParseMessages()"})," parses a JSON that should be an object containing key-value pairs:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include "merak/json/reader.h"\n#include "merak/json/error/en.h"\n#include <iostream>\n#include <string>\n#include <map>\n\nusing namespace std;\nusing namespace merak::json;\n\ntypedef map<string, string> MessageMap;\n\nstruct MessageHandler\n    : public BaseReaderHandler<UTF8<>, MessageHandler> {\n    MessageHandler() : state_(kExpectObjectStart) {\n    }\n\n    bool StartObject() {\n        switch (state_) {\n        case kExpectObjectStart:\n            state_ = kExpectNameOrObjectEnd;\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    bool String(const char* str, SizeType length, bool) {\n        switch (state_) {\n        case kExpectNameOrObjectEnd:\n            name_ = string(str, length);\n            state_ = kExpectValue;\n            return true;\n        case kExpectValue:\n            messages_.insert(MessageMap::value_type(name_, string(str, length)));\n            state_ = kExpectNameOrObjectEnd;\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    bool EndObject(SizeType) { return state_ == kExpectNameOrObjectEnd; }\n\n    bool Default() { return false; } // All other events are invalid.\n\n    MessageMap messages_;\n    enum State {\n        kExpectObjectStart,\n        kExpectNameOrObjectEnd,\n        kExpectValue,\n    }state_;\n    std::string name_;\n};\n\nvoid ParseMessages(const char* json, MessageMap& messages) {\n    Reader reader;\n    MessageHandler handler;\n    StringStream ss(json);\n    if (reader.Parse(ss, handler))\n        messages.swap(handler.messages_);   // Only change it if success.\n    else {\n        ParseErrorCode e = reader.GetParseErrorCode();\n        size_t o = reader.GetErrorOffset();\n        cout << "Error: " << GetParseError_En(e) << endl;;\n        cout << " at offset " << o << " near \'" << string(json).substr(o, 10) << "...\'" << endl;\n    }\n}\n\nint main() {\n    MessageMap messages;\n\n    const char* json1 = "{ \\"greeting\\" : \\"Hello!\\", \\"farewell\\" : \\"bye-bye!\\" }";\n    cout << json1 << endl;\n    ParseMessages(json1, messages);\n\n    for (MessageMap::const_iterator itr = messages.begin(); itr != messages.end(); ++itr)\n        cout << itr->first << ": " << itr->second << endl;\n\n    cout << endl << "Parse a JSON with invalid schema." << endl;\n    const char* json2 = "{ \\"greeting\\" : \\"Hello!\\", \\"farewell\\" : \\"bye-bye!\\", \\"foo\\" : {} }";\n    cout << json2 << endl;\n    ParseMessages(json2, messages);\n\n    return 0;\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Output:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'{ "greeting" : "Hello!", "farewell" : "bye-bye!" }\nfarewell: bye-bye!\ngreeting: Hello!\n\nParse a JSON with invalid schema.\n{ "greeting" : "Hello!", "farewell" : "bye-bye!", "foo" : {} }\nError: Terminate parsing due to Handler error.\n at offset 59 near \'} }...\'\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The first JSON (",(0,s.jsx)(n.code,{children:"json1"}),") is successfully parsed into ",(0,s.jsx)(n.code,{children:"MessageMap"}),". Since ",(0,s.jsx)(n.code,{children:"MessageMap"})," is a ",(0,s.jsx)(n.code,{children:"std::map"}),", the printing order is sorted by key, which is different from the order in the JSON."]}),"\n",(0,s.jsxs)(n.p,{children:["In the second JSON (",(0,s.jsx)(n.code,{children:"json2"}),"), the value of ",(0,s.jsx)(n.code,{children:"foo"})," is an empty object. Since it is an object, ",(0,s.jsx)(n.code,{children:"MessageHandler::StartObject()"})," will be called. However, with ",(0,s.jsx)(n.code,{children:"state_ = kExpectValue"}),", this function will return ",(0,s.jsx)(n.code,{children:"false"}),", causing the parsing process to terminate. The error code is ",(0,s.jsx)(n.code,{children:"kParseErrorTermination"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"Filtering",children:"Filtering JSON"}),"\n",(0,s.jsxs)(n.p,{children:["As mentioned earlier, ",(0,s.jsx)(n.code,{children:"Writer"})," can process events emitted by ",(0,s.jsx)(n.code,{children:"Reader"}),". The ",(0,s.jsx)(n.code,{children:"example/condense/condense.cpp"})," example simply sets ",(0,s.jsx)(n.code,{children:"Writer"})," as the handler of a ",(0,s.jsx)(n.code,{children:"Reader"}),", thus removing all whitespace characters from the JSON. The ",(0,s.jsx)(n.code,{children:"example/pretty/pretty.cpp"})," example uses the same relationship, only replacing ",(0,s.jsx)(n.code,{children:"Writer"})," with ",(0,s.jsx)(n.code,{children:"PrettyWriter"}),". Therefore, ",(0,s.jsx)(n.code,{children:"pretty"})," can reformat the JSON by adding indentation and line breaks."]}),"\n",(0,s.jsxs)(n.p,{children:["In fact, we can use the SAX-style API to add (multiple) intermediate layers to filter the content of JSON. For example, the ",(0,s.jsx)(n.code,{children:"capitalize"})," example can convert all JSON strings to uppercase:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include "merak/json/reader.h"\n#include "merak/json/writer.h"\n#include "merak/json/filereadstream.h"\n#include "merak/json/filewritestream.h"\n#include "merak/json/error/en.h"\n#include <vector>\n#include <cctype>\n\nusing namespace merak::json;\n\ntemplate<typename OutputHandler>\nstruct CapitalizeFilter {\n    CapitalizeFilter(OutputHandler& out) : out_(out), buffer_() {\n    }\n\n    bool Null() { return out_.Null(); }\n    bool Bool(bool b) { return out_.Bool(b); }\n    bool Int(int i) { return out_.Int(i); }\n    bool Uint(unsigned u) { return out_.Uint(u); }\n    bool Int64(int64_t i) { return out_.Int64(i); }\n    bool Uint64(uint64_t u) { return out_.Uint64(u); }\n    bool Double(double d) { return out_.Double(d); }\n    bool RawNumber(const char* str, SizeType length, bool copy) { return out_.RawNumber(str, length, copy); }\n    bool String(const char* str, SizeType length, bool) { \n        buffer_.clear();\n        for (SizeType i = 0; i < length; i++)\n            buffer_.push_back(std::toupper(str[i]));\n        return out_.String(&buffer_.front(), length, true); // true = output handler need to copy the string\n    }\n    bool StartObject() { return out_.StartObject(); }\n    bool Key(const char* str, SizeType length, bool copy) { return String(str, length, copy); }\n    bool EndObject(SizeType memberCount) { return out_.EndObject(memberCount); }\n    bool StartArray() { return out_.StartArray(); }\n    bool EndArray(SizeType elementCount) { return out_.EndArray(elementCount); }\n\n    OutputHandler& out_;\n    std::vector<char> buffer_;\n};\n\nint main(int, char*[]) {\n    // Prepare JSON reader and input stream.\n    Reader reader;\n    char readBuffer[65536];\n    FileReadStream is(stdin, readBuffer, sizeof(readBuffer));\n\n    // Prepare JSON writer and output stream.\n    char writeBuffer[65536];\n    FileWriteStream os(stdout, writeBuffer, sizeof(writeBuffer));\n    Writer<FileWriteStream> writer(os);\n\n    // JSON reader parse from the input stream and let writer generate the output.\n    CapitalizeFilter<Writer<FileWriteStream> > filter(writer);\n    if (!reader.Parse(is, filter)) {\n        fprintf(stderr, "\\nError(%u): %s\\n", (unsigned)reader.GetErrorOffset(), GetParseError_En(reader.GetParseErrorCode()));\n        return 1;\n    }\n\n    return 0;\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Note that you cannot simply convert JSON to uppercase as a string. For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'["Hello\\nWorld"]\n'})}),"\n",(0,s.jsx)(n.p,{children:"Simply converting the entire JSON to uppercase will produce an incorrect escape character:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'["HELLO\\NWORLD"]\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Whereas ",(0,s.jsx)(n.code,{children:"capitalize"})," will produce the correct result:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'["HELLO\\nWORLD"]\n'})}),"\n",(0,s.jsx)(n.p,{children:"We can also develop more complex filters. However, since the SAX-style API only provides information about a\nsingle event at a time, the user needs to record some contextual information themselves (e.g., the path from the\nroot node, storing other related values). For handling certain cases, using DOM is easier to implement than SAX."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>a});var t=r(6540);const s={},i=t.createContext(s);function o(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);