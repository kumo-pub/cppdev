"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[7902],{3789:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>d,default:()=>u,frontMatter:()=>s,metadata:()=>a,toc:()=>o});const a=JSON.parse('{"id":"foundamentals/monitor/metrics","title":"Metrics","description":"This section introduces monitoring metrics collectible by Prometheus, including Counter, Gauge, and Histogram.","source":"@site/docs/foundamentals/monitor/metrics.mdx","sourceDirName":"foundamentals/monitor","slug":"/foundamentals/monitor/metrics","permalink":"/cppdev/zh-cn/docs/foundamentals/monitor/metrics","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/foundamentals/monitor/metrics.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Variables","permalink":"/cppdev/zh-cn/docs/foundamentals/monitor/var"},"next":{"title":"System Monitoring","permalink":"/cppdev/zh-cn/docs/foundamentals/monitor/sys"}}');var i=t(4848),l=t(8453);const s={},d="Metrics",r={},o=[{value:"tally::Counter",id:"tallycounter",level:2},{value:"tally::MaxerGauge",id:"tallymaxergauge",level:2},{value:"tally::MinerGauge",id:"tallyminergauge",level:2},{value:"tally::AverageGauge",id:"tallyaveragegauge",level:2},{value:"tally::LatencyRecorder",id:"tallylatencyrecorder",level:2},{value:"tally::Window",id:"tallywindow",level:2},{value:"How to use tally::Window",id:"how-to-use-tallywindow",level:3},{value:"tally::PerSecond",id:"tallypersecond",level:2},{value:"Difference with Window",id:"difference-with-window",level:3},{value:"tally::WindowEx",id:"tallywindowex",level:2},{value:"How to use tally::WindowEx",id:"how-to-use-tallywindowex",level:3},{value:"Difference between tally::WindowEx and tally::Window",id:"difference-between-tallywindowex-and-tallywindow",level:3},{value:"tally::PerSecondEx",id:"tallypersecondex",level:2},{value:"How to use tally::PerSecondEx",id:"how-to-use-tallypersecondex",level:3},{value:"Difference between tally::PerSecondEx and tally::WindowEx",id:"difference-between-tallypersecondex-and-tallywindowex",level:3},{value:"Difference between tally::PerSecondEx and tally::PerSecond",id:"difference-between-tallypersecondex-and-tallypersecond",level:3},{value:"tally::Status",id:"tallystatus",level:2},{value:"tally::FuncGauge",id:"tallyfuncgauge",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"metrics",children:"Metrics"})}),"\n",(0,i.jsxs)(n.p,{children:["This section introduces monitoring metrics collectible by Prometheus, including ",(0,i.jsx)(n.code,{children:"Counter"}),", ",(0,i.jsx)(n.code,{children:"Gauge"}),", and ",(0,i.jsx)(n.code,{children:"Histogram"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"tallycounter",children:"tally::Counter"}),"\n",(0,i.jsxs)(n.p,{children:["As the name implies, it is used for accumulation with the operator ",(0,i.jsx)(n.code,{children:"+"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c++",children:"tally::Counter<int> value;\nvalue << 1 << 2 << 3 << -4;\nCHECK_EQ(2, value.get_value());\n\ntally::Counter<double> fp_value;  // may generate a warning\nfp_value << 1.0 << 2.0 << 3.0 << -4.0;\nCHECK_DOUBLE_EQ(2.0, fp_value.get_value());\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Counter<>"})," can be used with non-primitive types, provided that the corresponding type has at least overloaded ",(0,i.jsx)(n.code,{children:"T operator+(T, T)"}),". An existing example is ",(0,i.jsx)(n.code,{children:"std::string"}),"; the code below concatenates strings:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c++",children:'// This is just proof-of-concept, don\'t use it for production code because it creates\n// numerous temporary strings which is inefficient. Use std::ostringstream instead.\ntally::Counter<std::string> concater;\nstd::string str1 = "world";\nconcater << "hello " << str1;\nCHECK_EQ("hello world", concater.get_value());\n'})}),"\n",(0,i.jsx)(n.h2,{id:"tallymaxergauge",children:"tally::MaxerGauge"}),"\n",(0,i.jsxs)(n.p,{children:["Used to retrieve the maximum value, with the operator being ",(0,i.jsx)(n.code,{children:"std::max"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c++",children:"tally::MaxerGauge<int> value;\nvalue << 1 << 2 << 3 << -4;\nCHECK_EQ(3, value.get_value());\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Since ",(0,i.jsx)(n.code,{children:"MaxerGauge<>"})," uses ",(0,i.jsx)(n.code,{children:"std::numeric_limits<T>::min()"})," as the identity value, it cannot be applied to generic types unless you specialize ",(0,i.jsx)(n.code,{children:"std::numeric_limits<>"})," (and overload ",(0,i.jsx)(n.code,{children:"operator<"}),"\u2014note, not ",(0,i.jsx)(n.code,{children:"operator>"}),")."]}),"\n",(0,i.jsx)(n.h2,{id:"tallyminergauge",children:"tally::MinerGauge"}),"\n",(0,i.jsxs)(n.p,{children:["Used to retrieve the minimum value, with the operator being ",(0,i.jsx)(n.code,{children:"std::min"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c++",children:"tally::MinerGauge<int> value;\nvalue << 1 << 2 << 3 << -4;\nCHECK_EQ(-4, value.get_value());\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Since ",(0,i.jsx)(n.code,{children:"MinerGauge<>"})," uses ",(0,i.jsx)(n.code,{children:"std::numeric_limits<T>::max()"})," as the identity value, it cannot be applied to generic types unless you specialize ",(0,i.jsx)(n.code,{children:"std::numeric_limits<>"})," (and overload ",(0,i.jsx)(n.code,{children:"operator<"}),")."]}),"\n",(0,i.jsx)(n.h2,{id:"tallyaveragegauge",children:"tally::AverageGauge"}),"\n",(0,i.jsx)(n.p,{children:"Used to calculate the average value."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c++",children:"// For calculating average of numbers.\n// Example:\n//   AverageGauge latency;\n//   latency << 1 << 3 << 5;\n//   CHECK_EQ(3, latency.average());\nclass AverageGauge : public Variable;\n"})}),"\n",(0,i.jsx)(n.h2,{id:"tallylatencyrecorder",children:"tally::LatencyRecorder"}),"\n",(0,i.jsxs)(n.p,{children:["A counter dedicated to calculating latency and QPS (Queries Per Second). Simply input latency data to obtain latency / max_latency / QPS / count. The statistical window is specified by the last parameter; if omitted, it defaults to ",(0,i.jsx)(n.code,{children:"tally_dump_interval"})," (not provided here)."]}),"\n",(0,i.jsxs)(n.p,{children:["Note: ",(0,i.jsx)(n.code,{children:"LatencyRecorder"})," does not inherit from ",(0,i.jsx)(n.code,{children:"Variable"})," but is a combination of multiple ",(0,i.jsx)(n.code,{children:"tally"})," components."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c++",children:'LatencyRecorder write_latency("table2_my_table_write");  // produces 4 variables:\n                                                         //   table2_my_table_write_latency\n                                                         //   table2_my_table_write_max_latency\n                                                         //   table2_my_table_write_qps\n                                                         //   table2_my_table_write_count\n// In your write function\nwrite_latency << the_latency_of_write;\n'})}),"\n",(0,i.jsx)(n.h2,{id:"tallywindow",children:"tally::Window"}),"\n",(0,i.jsxs)(n.p,{children:["Retrieves statistical values from a specified time window in the past. A ",(0,i.jsx)(n.code,{children:"Window"})," cannot exist independently and must depend on an existing counter. The ",(0,i.jsx)(n.code,{children:"Window"})," updates automatically and does not require explicit data input. For performance reasons, ",(0,i.jsx)(n.code,{children:"Window"})," data is sampled from the original counter once per second, resulting in a maximum latency of 1 second for returned values in the worst case."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c++",children:"// Get data within a time window.\n// The time unit is fixed at 1 second.\n// Window relies on another tally, which must be constructed before this window and destroyed after it.\n// R must:\n// - have get_sampler() (thread-safety not required)\n// - define value_type and sampler_type\ntemplate <typename R>\nclass Window : public Variable;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"how-to-use-tallywindow",children:"How to use tally::Window"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c++",children:"tally::Counter<int> sum;\ntally::MaxerGauge<int> max_value;\ntally::IntRecorder avg_value;\n\n// sum_minute.get_value() returns the accumulated value of sum over the past 60 seconds.\ntally::Window<tally::Counter<int> > sum_minute(&sum, 60);\n\n// max_value_minute.get_value() returns the maximum value of max_value over the past 60 seconds.\ntally::Window<tally::MaxerGauge<int> > max_value_minute(&max_value, 60);\n\n// avg_value_minute.get_value() returns the average value of avg_value over the past 60 seconds.\ntally::Window<IntRecorder> avg_value_minute(&avg_value, 60);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"tallypersecond",children:"tally::PerSecond"}),"\n",(0,i.jsxs)(n.p,{children:["Retrieves the average per-second statistical value over a specified time window in the past. It is essentially the same as ",(0,i.jsx)(n.code,{children:"Window"}),", except that the returned value is divided by the time window duration."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c++",children:"tally::Counter<int> sum;\n\n// sum_per_second.get_value() returns the average per-second accumulated value of sum over the past 60 seconds.\n// If the last time window parameter is omitted, it defaults to tally_dump_interval.\ntally::PerSecond<tally::Counter<int> > sum_per_second(&sum, 60);\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"PerSecond is not always meaningful"})}),"\n",(0,i.jsxs)(n.p,{children:["The code above does not include ",(0,i.jsx)(n.code,{children:"MaxerGauge"})," because dividing the maximum value over a time window by the window duration is meaningless."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c++",children:"tally::MaxerGauge<int> max_value;\n\n// Wrong! Dividing the maximum value by time is meaningless\ntally::PerSecond<tally::MaxerGauge<int> > max_value_per_second_wrong(&max_value);\n\n// Correct: Set the Window's time window to 1 second instead\ntally::Window<tally::MaxerGauge<int> > max_value_per_second(&max_value, 1);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"difference-with-window",children:"Difference with Window"}),"\n",(0,i.jsx)(n.p,{children:"For example, to count memory changes over the past minute:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Using ",(0,i.jsx)(n.code,{children:"Window<>"}),', the returned value means "memory increased by 18MB in the past minute".']}),"\n",(0,i.jsxs)(n.li,{children:["Using ",(0,i.jsx)(n.code,{children:"PerSecond<>"}),', the returned value means "memory increased by an average of 0.3MB per second in the past minute".']}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The advantage of ",(0,i.jsx)(n.code,{children:"Window"}),' is that it provides exact values, making it suitable for small quantities (e.g., "number of errors in the past minute"). Using ',(0,i.jsx)(n.code,{children:"PerSecond"}),' for this case would return "0.0167 errors per second in the past minute", which is clearly less intuitive than "1 error in the past minute". Additionally, ',(0,i.jsx)(n.code,{children:"Window"})," should be used for time-independent metrics. For example, to calculate CPU utilization over the past minute: use a ",(0,i.jsx)(n.code,{children:"Counter"})," to accumulate both CPU time and real time, then use ",(0,i.jsx)(n.code,{children:"Window"})," to get the CPU time and real time from the past minute, and divide the two to get the CPU utilization\u2014this is time-independent, and using ",(0,i.jsx)(n.code,{children:"PerSecond"})," would yield incorrect results."]}),"\n",(0,i.jsx)(n.h2,{id:"tallywindowex",children:"tally::WindowEx"}),"\n",(0,i.jsxs)(n.p,{children:["Retrieves statistical values from a specified time window in the past. ",(0,i.jsx)(n.code,{children:"WindowEx"})," is self-contained, does not depend on other counters, and requires explicit data input. For performance reasons, ",(0,i.jsx)(n.code,{children:"WindowEx"})," aggregates data once per second, resulting in a maximum latency of 1 second for returned values in the worst case."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c++",children:"// Get data within a time window.\n// The time unit is fixed at 1 second.\n// WindowEx does not rely on other tally components.\n\n// R must:\n// - window_size must be a constant\ntemplate <typename R, time_t window_size = 0>\nclass WindowEx : public adapter::WindowExAdapter<R, adapter::WindowExType<R> > {\npublic:\n    typedef adapter::WindowExAdapter<R, adapter::WindowExType<R> > Base;\n\n    WindowEx() : Base(window_size) {}\n\n    WindowEx(const base::StringPiece& name) : Base(window_size) {\n        this->expose(name);\n    }\n\n    WindowEx(const base::StringPiece& prefix,\n             const base::StringPiece& name)\n        : Base(window_size) {\n        this->expose_as(prefix, name);\n    }\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"how-to-use-tallywindowex",children:"How to use tally::WindowEx"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c++",children:'const int window_size = 60;\n\n// sum_minute.get_value() returns the accumulated value over 60 seconds.\n// If the last window_size parameter is omitted, it defaults to tally_dump_interval.\ntally::WindowEx<tally::Counter<int>, window_size> sum_minute("sum_minute");\nsum_minute << 1 << 2 << 3;\n\n// max_minute.get_value() returns the maximum value over 60 seconds.\n// If the last window_size parameter is omitted, it defaults to tally_dump_interval.\ntally::WindowEx<tally::MaxerGauge<int>, window_size> max_minute("max_minute");\nmax_minute << 1 << 2 << 3;\n\n// min_minute.get_value() returns the minimum value over 60 seconds.\n// If the last window_size parameter is omitted, it defaults to tally_dump_interval.\ntally::WindowEx<tally::MinerGauge<int>, window_size> min_minute("min_minute");\nmin_minute << 1 << 2 << 3;\n\n// avg_minute.get_value() returns the average value over 60 seconds (returns tally::Stat).\n// If the last window_size parameter is omitted, it defaults to tally_dump_interval.\ntally::WindowEx<tally::IntRecorder, window_size> avg_minute("avg_minute");\navg_minute << 1 << 2 << 3;\n// Get the 60-second average stat of avg_minute\ntally::Stat avg_stat = avg_minute.get_value();\n// Get the integer average\nint64_t avg_int = avg_stat.get_average_int();\n// Get the double-precision average\ndouble avg_double = avg_stat.get_average_double();\n'})}),"\n",(0,i.jsx)(n.h3,{id:"difference-between-tallywindowex-and-tallywindow",children:"Difference between tally::WindowEx and tally::Window"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"tally::Window"})," cannot exist independently and must depend on an existing counter. It updates automatically without explicit data input; ",(0,i.jsx)(n.code,{children:"window_size"})," is passed as a constructor parameter."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"tally::WindowEx"})," is self-contained, does not depend on other counters, and requires explicit data input (easier to use). ",(0,i.jsx)(n.code,{children:"window_size"})," is passed as a template parameter; if omitted, it defaults to ",(0,i.jsx)(n.code,{children:"tally_dump_interval"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"tallypersecondex",children:"tally::PerSecondEx"}),"\n",(0,i.jsxs)(n.p,{children:["Retrieves the average per-second statistical value over a specified time window in the past. It is essentially the same as ",(0,i.jsx)(n.code,{children:"WindowEx"}),", except that the returned value is divided by the time window duration."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c++",children:"// Get data per second within a time window.\n// The only difference between PerSecondEx and WindowEx is that PerSecondEx divides\n// the aggregated data by the time window duration.\n\n// R must:\n// - window_size must be a constant\ntemplate <typename R, time_t window_size = 0>\nclass PerSecondEx : public adapter::WindowExAdapter<R, adapter::PerSecondExType<R> > {\npublic:\n    typedef adapter::WindowExAdapter<R, adapter::PerSecondExType<R> > Base;\n\n    PerSecondEx() : Base(window_size) {}\n\n    PerSecondEx(const base::StringPiece& name) : Base(window_size) {\n        this->expose(name);\n    }\n\n    PerSecondEx(const base::StringPiece& prefix,\n                const base::StringPiece& name)\n        : Base(window_size) {\n        this->expose_as(prefix, name);\n    }\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"how-to-use-tallypersecondex",children:"How to use tally::PerSecondEx"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c++",children:'const int window_size = 60;\n\n// sum_per_second.get_value() returns the average per-second accumulated value over 60 seconds.\n// If the last window_size parameter is omitted, it defaults to tally_dump_interval.\ntally::PerSecondEx<tally::Counter<int>, window_size> sum_per_second("sum_per_second");\nsum_per_second << 1 << 2 << 3;\n'})}),"\n",(0,i.jsx)(n.h3,{id:"difference-between-tallypersecondex-and-tallywindowex",children:"Difference between tally::PerSecondEx and tally::WindowEx"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"tally::PerSecondEx"})," retrieves the average per-second statistical value over a specified time window in the past. It is essentially the same as ",(0,i.jsx)(n.code,{children:"WindowEx"}),", except that the returned value is divided by the time window duration."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"difference-between-tallypersecondex-and-tallypersecond",children:"Difference between tally::PerSecondEx and tally::PerSecond"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"tally::PerSecond"})," cannot exist independently and must depend on an existing counter. It updates automatically without explicit data input; ",(0,i.jsx)(n.code,{children:"window_size"})," is passed as a constructor parameter."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"tally::PerSecondEx"})," is self-contained, does not depend on other counters, and requires explicit data input (easier to use). ",(0,i.jsx)(n.code,{children:"window_size"})," is passed as a template parameter; if omitted, it defaults to ",(0,i.jsx)(n.code,{children:"tally_dump_interval"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"tallystatus",children:"tally::Status"}),"\n",(0,i.jsxs)(n.p,{children:["Records and displays a value, with an additional ",(0,i.jsx)(n.code,{children:"set_value"})," function."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c++",children:'// Display a rarely or periodically updated value.\n// Usage:\n//   tally::Status<int> foo_count1(17);\n//   foo_count1.expose("my_value");\n//\n//   tally::Status<int> foo_count2;\n//   foo_count2.set_value(17);\n//\n//   tally::Status<int> foo_count3("my_value", 17);\n//\n// Notice that Tp must be std::string or compatible with boost::atomic<Tp>.\ntemplate <typename Tp>\nclass Status : public Variable;\n'})}),"\n",(0,i.jsx)(n.h2,{id:"tallyfuncgauge",children:"tally::FuncGauge"}),"\n",(0,i.jsxs)(n.p,{children:["Displays values on demand. In some scenarios, we cannot call ",(0,i.jsx)(n.code,{children:"set_value"})," or are unsure of the frequency to call it\u2014instead, it is more appropriate to retrieve and display the value only when needed. Users implement this by passing a callback function for value retrieval."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c++",children:'// Display a value updated on demand. This is achieved by passing a user-defined callback\n// that is invoked to generate the value.\n// Example:\n//   int print_number(void* arg) {\n//      ...\n//      return 5;\n//   }\n//\n//   // number1 : 5\n//   tally::FuncGauge status1("number1", print_number, arg);\n//\n//   // foo_number2 : 5\n//   tally::FuncGauge status2(typeid(Foo), "number2", print_number, arg);\ntemplate <typename Tp>\nclass FuncGauge : public Variable;\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Despite its simplicity, ",(0,i.jsx)(n.code,{children:"FuncGauge"})," is one of the most useful ",(0,i.jsx)(n.code,{children:"tally"})," components. This is because many statistical values already exist\u2014we do not need to store them again, only retrieve them on demand. For example, the code below declares a ",(0,i.jsx)(n.code,{children:"tally"})," that displays the process username on Linux:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c++",children:'static void get_username(std::ostream& os, void*) {\n    char buf[32];\n    if (getlogin_r(buf, sizeof(buf)) == 0) {\n        buf[sizeof(buf)-1] = \'\\0\';\n        os << buf;\n    } else {\n        os << "unknown";\n    }\n}\nPassiveStatus<std::string> g_username("process_username", get_username, NULL);\n'})})]})}function u(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>d});var a=t(6540);const i={},l=a.createContext(i);function s(e){const n=a.useContext(l);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(l.Provider,{value:n},e.children)}}}]);