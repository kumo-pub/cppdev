"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[2837],{5740:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"testing/doct/parameterized-tests","title":"Parameterized Tests","description":"parameterized-test-cases}","source":"@site/docs/testing/doct/parameterized-tests.mdx","sourceDirName":"testing/doct","slug":"/testing/doct/parameterized-tests","permalink":"/cppdev/zh-cn/docs/testing/doct/parameterized-tests","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/testing/doct/parameterized-tests.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Test Cases","permalink":"/cppdev/zh-cn/docs/testing/doct/testcases"},"next":{"title":"logging","permalink":"/cppdev/zh-cn/docs/testing/doct/logging"}}');var a=n(4848),i=n(8453);const r={},o="Parameterized Tests {#parameterized-test-cases}",d={},c=[{value:"Value-Parameterized Test Cases",id:"value-parameterized-test-cases",level:2},{value:"Templated Test Cases - Parameterized by Type",id:"templated-test-cases-parameterized-by-type",level:2}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"parameterized-test-cases",children:"Parameterized Tests"})}),"\n",(0,a.jsx)(t.p,{children:"Test cases can be easily parameterized by type, and indirectly parameterized by value as well."}),"\n",(0,a.jsx)(t.h2,{id:"value-parameterized-test-cases",children:"Value-Parameterized Test Cases"}),"\n",(0,a.jsx)(t.p,{children:"Proper support for this will be added in the future. Currently, there are two ways to perform data-driven testing in doctest:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Extract assertions into a helper function and call it with a user-constructed array of data:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-c++",children:'void doChecks(int data) {\n    // do asserts with data\n}\n\nTEST_CASE("test name") {\n    std::vector<int> data {1, 2, 3, 4, 5, 6};\n\n    for(auto& i : data) {\n        CAPTURE(i); // log the current input data\n        doChecks(i);\n    }\n}\n'})}),"\n",(0,a.jsx)(t.p,{children:"This has several drawbacks:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:'If an exception is thrown (or a "REQUIRE" assertion fails), the entire test case ends, and no checks are performed on the remaining input data'}),"\n",(0,a.jsx)(t.li,{children:'The user must manually log the data by calling "CAPTURE()" (or "INFO()")'}),"\n",(0,a.jsx)(t.li,{children:"More boilerplate code - doctest should provide primitives for generating data, but currently does not - so the user has to write their own data generation"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Use subcases to initialize data in different ways:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-c++",children:'TEST_CASE("test name") {\n    int data;\n    SUBCASE("") { data = 1; }\n    SUBCASE("") { data = 2; }\n\n    CAPTURE(data);\n\n    // do asserts with data\n}\n'})}),"\n",(0,a.jsx)(t.p,{children:"Doing this has the following drawbacks:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Poor scalability - writing such code for multiple different inputs is highly impractical"}),"\n",(0,a.jsxs)(t.li,{children:["The user must manually log the data by calling ",(0,a.jsx)(t.code,{children:"CAPTURE()"})," (or ",(0,a.jsx)(t.code,{children:"INFO()"}),")"]}),"\n"]}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.p,{children:"However, there is a simple way to encapsulate this into a macro (written using C++14 for simplicity):"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-c++",children:'#include <algorithm>\n#include <string>\n\n#define DOCTEST_VALUE_PARAMETERIZED_DATA(data, data_container)                                  \\\n    static size_t _doctest_subcase_idx = 0;                                                     \\\n    std::for_each(data_container.begin(), data_container.end(), [&](const auto& in) {           \\\n        DOCTEST_SUBCASE((std::string(#data_container "[") +                                     \\\n                        std::to_string(_doctest_subcase_idx++) + "]").c_str()) { data = in; }  \\\n    });                                                                                         \\\n    _doctest_subcase_idx = 0\n'})}),"\n",(0,a.jsx)(t.p,{children:"It can now be used as follows:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-c++",children:'TEST_CASE("test name") {\n    int data;\n    std::list<int> data_container = {1, 2, 3, 4}; // must be iterable - std::vector<> would work as well\n\n    DOCTEST_VALUE_PARAMETERIZED_DATA(data, data_container);\n\n    printf("%d\\n", data);\n}\n'})}),"\n",(0,a.jsx)(t.p,{children:"And it will print 4 numbers by re-entering the test case 3 times (after the first entry) - just like subcases:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"1\n2\n3\n4\n"})}),"\n",(0,a.jsxs)(t.p,{children:["A major limitation of this approach is that the macro cannot be used with other subcases at the same indentation level of the same code block "," (it will behave strangely) - it can only be used inside a subcase."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Stay tuned for proper value parameterization in doctest!"}),"\n",(0,a.jsx)(t.h2,{id:"templated-test-cases-parameterized-by-type",children:"Templated Test Cases - Parameterized by Type"}),"\n",(0,a.jsx)(t.p,{children:'Suppose you have multiple implementations of the same interface and want to ensure all implementations meet some common requirements. Alternatively, you may have defined several types that should conform to the same "concept" and you want to verify this. In both cases, you want to repeat the same test logic for different types.'}),"\n",(0,a.jsxs)(t.p,{children:["While you could write a ",(0,a.jsx)(t.code,{children:"TEST_CASE"})," for each type you want to test (and you could even factor out the test logic into a function template called from the test cases), it is tedious and does not scale: if you want to run ",(0,a.jsx)(t.code,{children:"M"})," tests on ",(0,a.jsx)(t.code,{children:"N"})," types, you end up writing ",(0,a.jsx)(t.code,{children:"M * N"})," tests."]}),"\n",(0,a.jsx)(t.p,{children:"Templated tests allow you to repeat the same test logic for a range of types. You only need to write the test logic once."}),"\n",(0,a.jsx)(t.p,{children:"There are two ways to do this:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Pass the list of types directly to the templated test case"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-c++",children:'TEST_CASE_TEMPLATE("signed integers stuff", T, char, short, int, long long int) {\n    T var = T();\n    --var;\n    CHECK(var == -1);\n}\n'})}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Define a templated test case with a specific unique name (identifier) for later instantiation"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-c++",children:'TEST_CASE_TEMPLATE_DEFINE("signed integer stuff", T, test_id) {\n    T var = T();\n    --var;\n    CHECK(var == -1);\n}\n\nTEST_CASE_TEMPLATE_INVOKE(test_id, char, short, int, long long int);\n\nTEST_CASE_TEMPLATE_APPLY(test_id, std::tuple<float, double>);\n'})}),"\n",(0,a.jsx)(t.p,{children:"If you are designing an interface or concept, you can define a suite of type-parameterized tests that verify the properties any valid implementation of the interface/concept should have. Then, the author of each implementation only needs to instantiate the test suite with their type to verify compliance, without having to repeatedly write similar tests."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:'A test case named "signed integers stuff" instantiated for the type "int" will result in the following test case name:'}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"signed integers stuff<int>\n"})}),"\n",(0,a.jsxs)(t.p,{children:["By default, all fundamental types (basic - ",(0,a.jsx)(t.code,{children:"int"}),", ",(0,a.jsx)(t.code,{children:"bool```, "}),"float",(0,a.jsx)(t.code,{children:"...) have stringification provided by the library. For all other types, the user must use the ``TYPE_TO_STRING(type)"})," macro - like this:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-c++",children:"TYPE_TO_STRING(std::vector<int>);\n"})}),"\n",(0,a.jsx)(t.p,{children:"The ``TYPE_TO_STRING``` macro is only valid within the current source file, so if the same type is used in a separate source file for a templated test case, it needs to be placed in some header."}),"\n",(0,a.jsxs)(t.p,{children:["Other test frameworks use the header ",(0,a.jsx)(t.code,{children:"<typeinfo>"})," in addition to demangling to automatically get the type string, but doctest cannot include any headers in the forward declaration section (public part) of the header - so the user has to teach the framework about each type. This is done to achieve ",(0,a.jsx)(t.a,{href:"/cppdev/zh-cn/docs/testing/doct/benchmarks",children:"maximum compile-time performance"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"Some notes:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Uniqueness of types is not filtered - the same templated test case can be instantiated multiple times for the same type - it is up to the user to prevent this"}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["You do not need to provide stringification for each type, as it only affects the test case name - the default is ",(0,a.jsx)(t.code,{children:"<>"})," - the tests are still valid and distinct"]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"If you need to parameterize over more than 1 type, you can pack multiple types into one type like this:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-c++",children:'template <typename first, typename second>\nstruct TypePair\n{\n    typedef first  A;\n    typedef second B;\n};\n\n#define pairs \\\n    TypePair<int, char>, \\\n    TypePair<char, int>\n\nTEST_CASE_TEMPLATE("multiple types", T, pairs) {\n    typedef typename T::A T1;\n    typedef typename T::B T2;\n    // use T1 and T2 types\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["Check out the ",(0,a.jsx)(t.a,{href:"https://github.com/doctest/doctest/blob/master/examples/all_features/templated_test_cases.cpp",children:(0,a.jsx)(t.strong,{children:"example"})})," which shows how to use all of these."]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var s=n(6540);const a={},i=s.createContext(a);function r(e){const t=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);