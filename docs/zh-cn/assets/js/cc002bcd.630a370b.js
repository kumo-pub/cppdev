"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[6780],{5254:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"foundamentals/map/benchmark","title":"C++ Hashmap Benchmark","description":"The latest hashmap performance comparison results have been released, courtesy of Martin Leitner-Ankerl, the developer of ankerl::map.","source":"@site/docs/foundamentals/map/benchmark.mdx","sourceDirName":"foundamentals/map","slug":"/foundamentals/map/benchmark","permalink":"/cppdev/zh-cn/docs/foundamentals/map/benchmark","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/foundamentals/map/benchmark.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Introduction to parallel-hashmap: High-Performance, Thread-Safe, Memory-Efficient Hash Tables and B-Trees","permalink":"/cppdev/zh-cn/docs/foundamentals/map/pmap"},"next":{"title":"Comprehensive Guide to Compression Technologies","permalink":"/cppdev/zh-cn/docs/foundamentals/compress/"}}');var i=r(4848),a=r(8453);const t={},o="C++ Hashmap Benchmark",l={},d=[{value:"I. Hashmap Performance Comparison",id:"i-hashmap-performance-comparison",level:2},{value:"Test Dimensions",id:"test-dimensions",level:3},{value:"Core Test Results",id:"core-test-results",level:3},{value:"II. Hash Function Comparison",id:"ii-hash-function-comparison",level:2},{value:"III. In-depth Analysis of Top-Performing Containers",id:"iii-in-depth-analysis-of-top-performing-containers",level:2},{value:"(I) Ankerl::unordered_dense::map",id:"i-ankerlunordered_densemap",level:3},{value:"1. Design Architecture",id:"1-design-architecture",level:4},{value:"2. Core Operation Implementations",id:"2-core-operation-implementations",level:4},{value:"(II) emhash8::HashMap",id:"ii-emhash8hashmap",level:3},{value:"1. Design Architecture",id:"1-design-architecture-1",level:4},{value:"2. Key Design Details",id:"2-key-design-details",level:4}];function c(e){const n={a:"a",blockquote:"blockquote",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"c-hashmap-benchmark",children:"C++ Hashmap Benchmark"})}),"\n",(0,i.jsxs)(n.p,{children:["The latest hashmap performance comparison results have been released, courtesy of Martin Leitner-Ankerl, the developer of ",(0,i.jsx)(n.code,{children:"ankerl::unordered_dense::map"}),".\nA previous round of testing was conducted in 2019, and this update provides comprehensive test data, serving as a valuable reference for selecting high-performance hashmaps."]}),"\n",(0,i.jsx)(n.h2,{id:"i-hashmap-performance-comparison",children:"I. Hashmap Performance Comparison"}),"\n",(0,i.jsx)(n.h3,{id:"test-dimensions",children:"Test Dimensions"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Data Types: Divided into two categories: Numbers (numeric types) and Strings (string types)."}),"\n",(0,i.jsx)(n.li,{children:"Test Operations: Covers common operations such as Insert, Random Insert, Iterate, Find, and Copy."}),"\n",(0,i.jsx)(n.li,{children:"Specialized Find Tests: Evaluates performance under different selection rates and insert-find frequency ratios."}),"\n",(0,i.jsx)(n.li,{children:"Additional Comparison: Includes memory usage analysis, with overall results calculated using arithmetic mean."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"core-test-results",children:"Core Test Results"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"ankerl::unordered_dense::map"}),": Delivers the best overall performance (top arithmetic mean across all operations). It boasts unrivaled performance in Copy and Iterate operations, with excellent Find performance. It adapts well to different hash functions with minimal performance variance. Inherited from robin_hood (by the same author), it outperforms the robin_hood series."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"gtl::flat_hash_map / gtl::parallel_flat_hash_map"}),": Commonly known in the open-source community as ",(0,i.jsx)(n.code,{children:"phmap::flat_hash_map"})," and ",(0,i.jsx)(n.code,{children:"phmap::parallel_flat_hash_map"})," (for detailed introduction to phmap, refer to: ",(0,i.jsx)(n.a,{href:"https://byronhe.com/post/2020/11/10/parallel-hashmap-btree-fast-multi-thread-intro/",children:"https://byronhe.com/post/2020/11/10/parallel-hashmap-btree-fast-multi-thread-intro/"}),"). ",(0,i.jsx)(n.code,{children:"gtl::parallel_flat_hash_map"})," is the parallel variant, derived from Google Abseil\u2019s ",(0,i.jsx)(n.code,{children:"absl::flat_hash_map"}),", offering excellent performance. The repository includes both btree and hash container implementations, provided as header-only for easy integration. ",(0,i.jsx)(n.code,{children:"gtl::flat_hash_map"}),' achieved the best performance in the "Find 1 \u2013 500k uint64_t" test set.']}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"emhash8::HashMap / emhash7::HashMap"}),": Rank second only to the ankerl series, demonstrating outstanding performance."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"folly::F14NodeMap / folly::F14ValueMap"}),": Delivers excellent performance but comes with heavy dependencies on the folly library. Recommended if folly is already integrated into the project."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"absl::flat_hash_map"}),": Implemented by Google Abseil, it belongs to the top performance tier. It excels in handling large maps and string lookup scenarios but performs relatively slower in Copy and Iterate operations."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"boost::unordered_map"}),": Offers lookup performance twice as fast as ",(0,i.jsx)(n.code,{children:"std::unordered_map"}),", making it a direct replacement for the standard library version. However, it has higher memory usage and average insert performance."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"std::unordered_map"}),": Ranks the lowest in performance, serving only as a baseline reference."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"ii-hash-function-comparison",children:"II. Hash Function Comparison"}),"\n",(0,i.jsx)(n.p,{children:"Hash function tests cover two scenarios: Integral types and String types, with core conclusions as follows:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Integral Types Scenario"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"std::hash"})," and ",(0,i.jsx)(n.code,{children:"boost::hash"})," directly use the original value as the hash result, leading to highly variable performance dependent on input data\u2014",(0,i.jsx)(n.strong,{children:"not recommended"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ankerl::unordered_dense::hash"}),": Similar in logic to ",(0,i.jsx)(n.code,{children:"absl::hash"})," (both use wyhash), but differs in integral type processing (applies XOR to input), delivering excellent performance."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"robin_hood::hash"}),": Based on murmurhash3, offering solid performance."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"mumx"}),": Adopts the same integral type processing as ",(0,i.jsx)(n.code,{children:"ankerl::unordered_dense::hash"}),", ensuring stable performance."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"String Types Scenario"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"std::hash"}),": Delivers good performance\u2014",(0,i.jsx)(n.strong,{children:"recommended"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"boost::hash"}),": Performs poorly\u2014",(0,i.jsx)(n.strong,{children:"not recommended"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ankerl::unordered_dense::hash"}),"/",(0,i.jsx)(n.code,{children:"absl::hash"}),": Both based on wyhash, achieving excellent performance."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"robin_hood::hash"}),": Based on MurmurHash2, with good performance."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"mumx"}),": Uses the same string processing as ",(0,i.jsx)(n.code,{children:"std::hash"}),", ensuring strong compatibility."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["All conclusions above are referenced from: ",(0,i.jsx)(n.a,{href:"https://martin.ankerl.com/2022/08/27/hashmap-bench-01/#ankerl__unordered_dense__map",children:"https://martin.ankerl.com/2022/08/27/hashmap-bench-01/#ankerl__unordered_dense__map"})]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"iii-in-depth-analysis-of-top-performing-containers",children:"III. In-depth Analysis of Top-Performing Containers"}),"\n",(0,i.jsx)(n.p,{children:"Both containers below are provided as header-only, enabling direct integration as third-party headers with strong adaptability."}),"\n",(0,i.jsx)(n.h3,{id:"i-ankerlunordered_densemap",children:"(I) Ankerl::unordered_dense::map"}),"\n",(0,i.jsxs)(n.p,{children:["GitHub Repository: ",(0,i.jsx)(n.a,{href:"https://github.com/martinus/unordered_dense",children:"https://github.com/martinus/unordered_dense"}),(0,i.jsx)(n.br,{}),"\n","Core Implementation: Based on Robin hood probing."]}),"\n",(0,i.jsx)(n.h4,{id:"1-design-architecture",children:"1. Design Architecture"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Hash Function: Uses ",(0,i.jsx)(n.code,{children:"ankerl::unordered_dense::hash"}),"; string types default to wyhash for high execution efficiency."]}),"\n",(0,i.jsxs)(n.li,{children:["Core Structures: Consists of two key arrays\u2014","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Vector Array: Stores ",(0,i.jsx)(n.code,{children:"pair{key, value}"})," key-value pairs."]}),"\n",(0,i.jsxs)(n.li,{children:["Bucket Array: A collision resolution solution tailored for Robin hood hashing, with the following structure:","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"struct Bucket {\n    uint32_t dist_and_fingerprint; // Top 3 bytes store distance, bottom 1 byte stores fingerprint\n    uint32_t value_idx; // Stores the index of data in the vector array\n};\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"Key Optimization: The Bucket array is partially sorted (in descending order) and features a contiguous memory layout, ensuring excellent cache-locality."}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"2-core-operation-implementations",children:"2. Core Operation Implementations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Insert"}),":"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Compute the hash value of the key and shift to get the bucket_index."}),"\n",(0,i.jsx)(n.li,{children:"Insert directly if the target bucket is empty."}),"\n",(0,i.jsxs)(n.li,{children:["If a collision occurs, compare ",(0,i.jsx)(n.code,{children:"dist_and_fingerprint"})," and place the element with the larger distance first."]}),"\n",(0,i.jsxs)(n.li,{children:["Move bucket_index backward sequentially and update ",(0,i.jsx)(n.code,{children:"dist_and_fingerprint"})," ( ",(0,i.jsx)(n.code,{children:"dist_and_fingerprint + 1UL<<8"})," )."]}),"\n",(0,i.jsxs)(n.li,{children:["Insert data into the vector array first, then update ",(0,i.jsx)(n.code,{children:"value_idx"})," in the Bucket array (Bucket indices are relative positions)."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Find"}),":"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Compute the hash value of the key and shift according to the Bucket array length to get the bucket_index."}),"\n",(0,i.jsxs)(n.li,{children:["Compare ",(0,i.jsx)(n.code,{children:"dist_and_fingerprint"})," of the target bucket; if matched, retrieve the key from the vector via ",(0,i.jsx)(n.code,{children:"value_idx"})," and compare."]}),"\n",(0,i.jsxs)(n.li,{children:["Return the corresponding value if keys match; otherwise, move backward to continue searching until ",(0,i.jsx)(n.code,{children:"dist_and_fingerprint > bucket.dist_and_fingerprint"}),"."]}),"\n",(0,i.jsx)(n.li,{children:"Core Advantage: Find operations only require a limited sequential search of the Bucket array, fully leveraging cache locality for excellent performance."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Iterate"}),": Simply traverse the vector array\u2014logically simple with exceptional performance."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"ii-emhash8hashmap",children:"(II) emhash8::HashMap"}),"\n",(0,i.jsxs)(n.p,{children:["GitHub Repository: ",(0,i.jsx)(n.a,{href:"https://github.com/ktprime/emhash",children:"https://github.com/ktprime/emhash"}),(0,i.jsx)(n.br,{}),"\n",'Core Positioning: The "masterpiece" of linear probing.']}),"\n",(0,i.jsx)(n.h4,{id:"1-design-architecture-1",children:"1. Design Architecture"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Hash Function: Uses murmurhash3mixer for integral types and wyhash for string types."}),"\n",(0,i.jsx)(n.li,{children:'Key Optimization: Traditional open addressing is prone to Primary Clustering and Secondary Clustering. emhash8 resolves this via "3-way combined probing" technology, maintaining high performance even with a load factor > 0.9.'}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"2-key-design-details",children:"2. Key Design Details"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Core Data Structures"}),":","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"struct Index\n{\n    size_type bucket; // Stores collision position\n    size_type slot;   // Stores actual data position\n};\ntypedef std::pair<KeyT, ValueT> value_type; // Key-value pair storage structure\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"3-way Combined Probing"}),":","\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Within 2-3 CPU cache lines: Use linear probing."}),"\n",(0,i.jsx)(n.li,{children:"Beyond cache lines: Use limited quadratic probing."}),"\n",(0,i.jsxs)(n.li,{children:["Record the last empty position ",(0,i.jsx)(n.code,{children:"_last"}),", and calculate the empty slot via the formula ",(0,i.jsx)(n.code,{children:"(_mask / 2 + _last++) & _mask"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Smart Collision Resolution"}),":\nCollision nodes are linked via the ",(0,i.jsx)(n.code,{children:"bucket"})," field in Index ( ",(0,i.jsx)(n.code,{children:"bucket"})," stores the index of the next collision node), fundamentally avoiding performance degradation caused by clustering."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>o});var s=r(6540);const i={},a=s.createContext(i);function t(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);